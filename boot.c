/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_1000(unsigned __int8 a1);
char sub_1153();
signed __int64 __fastcall sub_1202(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
_BYTE *sub_15A8();
signed __int64 __fastcall sub_1617(_QWORD *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_1713(_QWORD *a1, __int64 *a2);
signed __int64 __fastcall sub_176C(_QWORD *a1, unsigned __int64 *a2, signed __int64 *a3);
signed __int64 __fastcall sub_1810(_QWORD *a1, __int64 a2);
signed __int64 __fastcall sub_18D2(_QWORD *a1, _QWORD *a2, signed __int64 *a3);
signed __int64 __fastcall sub_1995(_QWORD *a1, __int64 a2, _QWORD *a3, _BYTE *a4);
__int64 __fastcall sub_1A0A(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_1A3E(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_1A54(__int64 a1);
signed __int64 __fastcall sub_1A72(_QWORD *a1);
signed __int64 __fastcall sub_1B0F(_QWORD *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_1B5A(_QWORD *a1);
__int64 sub_1C7E();
signed __int64 __fastcall sub_1CCF(_QWORD *a1);
__int64 __fastcall sub_1D2C(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_1DA0(_QWORD *a1);
signed __int64 __fastcall sub_1E67(__int64 a1);
signed __int64 __fastcall sub_1F58(__int64 a1, __int64 a2);
void __fastcall sub_20D7(__int64 a1, _QWORD *a2);
void __fastcall sub_22EC(__int64 a1, __int64 a2);
__int64 __fastcall sub_23D4(__int64 a1);
__int64 __fastcall sub_2470(__int64 a1, __int64 a2);
void __fastcall sub_24B1(__int64 a1);
__int64 __fastcall sub_255B(__int64 a1);
__int64 __fastcall sub_2624(__int64 a1, char *a2, unsigned int a3, __int64 a4);
_BYTE *sub_2642();
void sub_26DC();
_BYTE *__fastcall sub_2724(char a1, __int64 a2, int a3);
__int64 sub_2801();
signed __int64 __fastcall sub_28A7(char *a1);
_BYTE *sub_2939();
__int64 sub_2A19();
_DWORD *__fastcall sub_30C0(__int64 a1);
_DWORD *__fastcall sub_30F0(__int64 a1, signed __int64 a2);
signed __int64 __fastcall sub_3144(__int64 a1);
signed __int64 __fastcall sub_3160(__int64 a1, __int64 a2);
signed __int64 sub_31B4();
signed __int64 sub_341F();
signed __int64 __fastcall sub_368A(_DWORD *a1, int *a2, __int64 a3);
signed __int64 __fastcall sub_38CC(_DWORD *a1, int *a2, __int64 a3);
// __m128 __usercall sub_3B0E@<xmm0>(signed int a1@<edx>, unsigned int *a2@<rcx>, __int64 a3@<r8>, __m128 *__struct_ptr result@<xmm0>);
// __int64 __usercall sub_402A@<rax>(unsigned int a1@<eax>);
// __m128 __usercall sub_4067@<xmm0>(signed int a1@<edx>, unsigned int *a2@<rcx>, _DWORD *a3@<r8>, __m128i *__struct_ptr a4@<xmm7>);
__m128 __fastcall sub_40E1(unsigned int *a1, __int64 a2);
signed __int64 __fastcall sub_4C13(char *a1, __int64 **a2);
signed __int64 __fastcall sub_4C69(__int64 a1, __int64 *a2, _QWORD *a3, _QWORD *a4);
signed __int64 __fastcall sub_4E0C(char *a1, __int64 *a2, _QWORD *a3, _QWORD *a4);
signed __int64 __fastcall sub_4E7F(unsigned __int8 *a1, unsigned __int64 a2);
void sub_5180();
__int64 __fastcall sub_5202(__int64 a1);
__int64 __fastcall sub_52BA(unsigned int a1, unsigned int a2);
signed __int64 __fastcall sub_5310(__int64 a1, __int64 *a2);
__int64 sub_5505();
__int64 sub_59F5();
_BYTE *__fastcall sub_5ABA(char a1);
__int64 sub_5D11();
_BYTE *__fastcall sub_5DCF(int a1);
EFI_STATUS __cdecl ModuleEntryPoint(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable);
char __fastcall sub_7035(signed __int64 a1, int a2, _BYTE *a3, int a4, int a5);
void __fastcall sub_7102(unsigned __int8 *a1, __int64 a2, _WORD *a3, signed __int64 *a4, __int64 a5);
_BYTE *__fastcall sub_71CF(_WORD *a1);
_WORD *__fastcall sub_7226(unsigned __int8 *a1, int a2);
__int64 __fastcall sub_7294(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_74E9(_BYTE *a1);
signed __int64 sub_7623();
const char *__fastcall sub_77C2(char *a1, unsigned __int8 a2);
__int64 sub_7809();
__int64 __fastcall sub_7AC8(unsigned int *a1, unsigned __int64 a2);
bool __fastcall sub_7B52(int a1);
__int64 __fastcall sub_7B82(unsigned int *a1);
__int64 __fastcall sub_7C43(__int64 a1, char *a2);
__int64 sub_81D5();
__int64 __fastcall sub_82E2(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
char *sub_98E2();
__int64 sub_99EE();
__int64 *sub_9ADC();
signed __int64 __fastcall sub_9B19(char *a1, unsigned int a2, unsigned int a3);
__int64 __fastcall sub_9B9D(char *a1, unsigned int a2, __int64 a3, _BYTE *a4);
__int64 sub_9CD8();
__int64 sub_9CE0(__int64 a1, ...);
__int64 sub_9D57();
char sub_9DAB();
signed __int64 sub_9DBE();
signed __int64 sub_9E7F();
signed __int64 __fastcall sub_9E8B(int a1);
signed __int64 __fastcall sub_9EC7(signed __int64 *a1, _BYTE *a2, unsigned __int64 a3, char *a4, char a5);
__int64 __fastcall sub_A012(__int64 *a1, _BYTE *a2);
signed __int64 *__fastcall sub_A04C(__int64 a1, _BYTE *a2);
signed __int64 *sub_A13F();
__int64 sub_A192();
__int64 __fastcall sub_A211(_QWORD *a1, _QWORD *a2);
_DWORD *__fastcall sub_A296(_QWORD *a1, _DWORD *a2);
const char *__fastcall sub_A34D(__int64 *a1);
__int64 sub_A398();
__int64 __fastcall sub_A485(__int64 a1, unsigned __int64 a2, __int64 a3);
__int64 sub_A4F1(__int64 *a1, signed __int16 *a2, ...);
__int64 __fastcall sub_A5DE(_BYTE *a1);
__int64 __fastcall sub_A6D3(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A6F7(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A716(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A741(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A75F(__int64 *a1, _BYTE *a2);
__int64 __fastcall sub_A7A3(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A7E1(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A827(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A84B(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A86F(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A891(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A8B3(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A8D6(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A8FA(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A938(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A956(__int64 *a1, __int64 a2);
__int64 __fastcall sub_A9C7(__int64 *a1, __int64 a2);
__int64 __fastcall sub_AA05(__int64 *a1);
__int64 __fastcall sub_AA1F(__int64 *a1);
__int64 __fastcall sub_AA39(__int64 *a1, __int64 a2);
__int64 __fastcall sub_AAEA(__int64 *a1, __int64 a2);
__int64 __fastcall sub_AB48(__int64 *a1, __int64 a2);
__int64 __fastcall sub_AB66(__int64 *a1, __int64 a2);
__int64 __fastcall sub_AB84(__int64 *a1, __int64 a2);
__int64 __fastcall sub_ABA2(__int64 *a1, __int64 a2);
__int64 __fastcall sub_ABC0(__int64 *a1, __int64 a2);
__int64 __fastcall sub_ABFE(__int64 *a1);
__int64 __fastcall sub_AC18(__int64 *a1, __int64 a2);
__int64 __fastcall sub_AC3A(__int64 *a1, __int64 a2);
__int64 __fastcall sub_ACAE(_BYTE *a1);
__int64 __fastcall sub_ADC4(__int64 a1, _WORD *a2);
_WORD *__fastcall sub_AE6A(_BYTE *a1, signed int a2, void (__fastcall *a3)(signed __int64, __int64), __int64 a4);
signed __int64 __fastcall sub_AEE6(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_AF60(__int64 a1, __int64 a2, _BYTE *a3);
signed __int64 __fastcall sub_B0E9(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_B1BA(__int64 a1);
signed __int64 __fastcall sub_B226(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 *a5);
signed __int64 __fastcall sub_B252(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 *a7);
signed __int64 __fastcall sub_B3AB(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_B3CF(char a1);
signed __int64 __fastcall sub_B59D(__int64 a1, __int64 a2, _QWORD *a3, __int64 *a4);
__int64 sub_B814();
__int64 __fastcall sub_B830(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 sub_B88A();
__int64 sub_B8E5();
__int64 sub_B95F();
__int64 __fastcall sub_BA8B(unsigned int a1);
signed __int64 __fastcall sub_BAD6(_DWORD *a1);
signed __int64 sub_BB0D();
signed __int64 sub_BCFC();
void __fastcall sub_BD15(__int64 a1, __int64 *a2, _QWORD *a3, _QWORD *a4);
__int64 __fastcall sub_C267(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_C2C4(char a1, char a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_C4E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 *a7);
signed __int64 __fastcall sub_CAE6(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_CCF2(unsigned __int64 a1, __int64 a2, __int64 a3, char a4);
__int64 __fastcall sub_CDB1(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_CFB6(__int64 a1);
__int64 sub_D1B2();
__int64 sub_D212();
signed __int64 sub_D24B();
void __fastcall sub_D31B(__int64 a1, __int64 a2);
char sub_D39E();
signed __int64 sub_D463();
__int64 sub_D5CB();
_QWORD *__fastcall sub_D642(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_D693(__int64 a1, __int64 *a2);
signed __int64 __fastcall sub_D739(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5, __int64 *a6);
__int64 __fastcall sub_D97B(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_DAB5(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_DBA9(_QWORD *a1, unsigned __int64 *a2, char *a3);
__int64 __fastcall sub_DE03(_QWORD *a1);
__int64 __fastcall sub_DE57(__int64 a1, __int64 a2, __int64 *a3);
signed __int64 __fastcall sub_E217(__int64 a1, __int64 a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_E3FD(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_E523(_QWORD *a1, __int64 *a2, unsigned __int64 *a3);
signed __int64 sub_E83F();
signed __int64 __fastcall sub_E89C(_QWORD *a1, __int64 *a2);
signed __int64 __fastcall sub_F11F(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_F180(char *a1, int a2, unsigned __int64 a3);
__int64 __fastcall sub_F1B0(_QWORD, _QWORD); // weak
// unsigned __int64 __usercall sub_F1B3@<rax>(unsigned __int64 result@<rax>, unsigned __int64 a2@<rdx>, char *a3@<rcx>);
signed __int64 __fastcall sub_F1CC(char *a1, _BYTE *a2, __int64 *a3, char **a4);
signed __int64 __fastcall sub_F364(char *a1, _BYTE *a2, __int64 *a3, char **a4);
signed __int64 __fastcall sub_F3C2(__int64 a1, _BYTE *a2, _QWORD *a3);
unsigned __int8 *__fastcall sub_F403(__int64 a1, __int64 a2, unsigned __int8 *a3, __int64 a4);
unsigned __int8 *__fastcall sub_F798(int a1, unsigned __int8 *a2, unsigned __int8 *a3, __int64 a4, unsigned __int64 a5, __int64 a6);
__int64 __fastcall sub_F981(__int64 a1, __int16 *a2, char a3);
char *__fastcall sub_FB02(__int64 a1, char a2);
__int64 __fastcall sub_FC87(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char sub_FE80();
__int64 sub_FF72();
__int64 __fastcall sub_10310(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 *a5);
signed __int64 __fastcall sub_1040A(__int64 a1, _BYTE *a2);
signed __int64 __fastcall sub_106AA(__int64 a1, __int64 a2, _WORD *a3, char **a4);
char __fastcall sub_10E81(__int64 a1);
__int64 __fastcall sub_10EBB(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_10F72(unsigned __int8 a1);
__int64 __fastcall sub_11012(_BYTE *a1);
__int64 __fastcall sub_1103F(_BYTE *a1);
bool __fastcall sub_11070(char *a1, _BYTE *a2);
__int64 __fastcall sub_111CF(char *a1, _BYTE *a2);
__int64 sub_1125C();
__int64 __fastcall sub_112D5(char a1);
signed int __fastcall sub_11351(__int64 a1, unsigned __int64 a2, _BYTE **a3);
__int64 sub_113A9();
unsigned __int64 sub_11577();
_BYTE *__fastcall sub_116D9(_BYTE *a1, char *a2, __int64 a3);
bool sub_117B5();
__int64 sub_11805();
// __int64 __usercall sub_11882@<rax>(unsigned int a1@<esi>);
signed __int64 __fastcall sub_118F1(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_1195E(_QWORD *a1);
char *__fastcall sub_11987(int *a1, char *a2, unsigned int a3);
__int64 __fastcall sub_11A4F(int *a1, __int64 a2);
char *__fastcall sub_123E7(int *a1);
__int64 __fastcall sub_1245A(__int64 a1, int *a2);
__int64 __fastcall sub_124B2(__int64 a1, _BYTE *a2);
signed __int64 __fastcall sub_12512(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_125A2(__int64 a1, __int64 *a2);
void __fastcall sub_12C84(__int64 a1);
__int64 __fastcall sub_12D6F(__int64 a1);
__int64 __fastcall sub_12D9A(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_12DC6(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_12E56(__int64 a1, __int64 *a2, int a3, __int64 a4);
__int64 __fastcall sub_12F48(char **a1);
char *__fastcall sub_12F82(char **a1, char **a2, unsigned __int64 *a3, __int64 *a4, signed int a5);
__int64 sub_13260();
signed __int64 __fastcall sub_132DD(__int64 a1, _BYTE *a2);
char __fastcall sub_1335D(char *a1);
signed __int64 __fastcall sub_1349D(char *a1);
char *__fastcall sub_13536(char **a1, unsigned __int64 *a2, __int64 *a3, char *a4, char a5);
__int64 __fastcall sub_1364F(__int64 a1);
_QWORD *__fastcall sub_1368E(__int64 a1);
__int64 __fastcall sub_136C5(__int64 a1);
__int64 __fastcall sub_13759(__int64 a1, __int64 a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_137B1(__int64 a1, __int64 a2);
__int64 sub_1384F();
signed __int64 sub_138C6();
// __int64 __usercall sub_13980@<rax>(char a1@<cf>, _QWORD *a2@<rcx>);
__int64 __fastcall sub_1399B(_DWORD *a1, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5, int a6, unsigned int a7, char a8, char a9, __int64 a10);
__int64 sub_13F31();
signed __int64 __fastcall sub_14446(__int64 *a1, signed __int64 *a2, _BYTE *a3, char *a4);
char sub_1487D();
// __int64 __usercall sub_1498C@<rax>(_BYTE *a1@<rcx>, __int64 a2@<r9>, __m128 *a3@<xmm0>, __m128i *a4@<xmm1>, __m128i *a5@<xmm2>, __m128i *a6@<xmm6>, __m128i *a7@<xmm7>);
// signed __int64 __usercall sub_152FD@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, unsigned __int64 a4@<r9>, __m128 *__struct_ptr a5@<xmm0>, __m128i *a6@<xmm1>, __m128i *a7@<xmm2>, __m128i *a8@<xmm6>, __m128i *a9@<xmm7>, unsigned int *a10, __int64 a11, unsigned __int8 a12);
signed __int64 __fastcall sub_16FB7(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// __int64 __usercall sub_17139@<rax>(unsigned __int64 a1@<rdx>, unsigned int *a2@<rcx>, __m128 *a3@<xmm0>, __m128i *a4@<xmm1>, __m128i *a5@<xmm2>, __m128i *a6@<xmm6>, __m128i *a7@<xmm7>);
__int64 sub_17276();
__int64 __fastcall sub_1738E(unsigned __int64 *a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_174C9(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, _QWORD *a5, _QWORD *a6);
unsigned __int64 __fastcall sub_17500(__int64 *a1, unsigned __int64 *a2);
__int64 __fastcall sub_17602(int a1);
__int64 __fastcall sub_17610(char a1, unsigned __int64 a2, __int64 a3);
__int64 __fastcall sub_176C6(unsigned __int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_17741(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_1775B(_QWORD *a1, unsigned __int64 *a2, __int64 a3);
char *__fastcall sub_177A5(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3);
signed __int64 __fastcall sub_178DE(unsigned __int64 a1, char *a2, char **a3, unsigned __int64 a4, __int64 a5, unsigned __int64 a6, unsigned __int64 a7, __int64 a8);
__int64 __fastcall sub_17CD4(int a1, __int64 a2, int a3);
void __fastcall sub_17D0C(int a1, __int64 a2);
void __fastcall sub_17D26(int a1, __int64 a2, __int64 a3, unsigned int *a4);
unsigned __int16 __fastcall sub_17D61(unsigned __int16 a1, __int64 a2, int a3);
void __fastcall sub_17D9C(__int64 a1, void (__fastcall *a2)(signed __int64, __int64), __int64 a3, unsigned __int64 **a4);
__int64 __fastcall sub_18630(unsigned __int64 a1, int a2, __int64 a3, int a4, signed int a5, void (__fastcall *a6)(signed __int64, __int64), __int64 a7);
__int64 __fastcall sub_18734(char *a1, char a2, int a3, int a4, void (__fastcall *a5)(signed __int64, __int64), __int64 a6);
__int64 sub_18905(unsigned __int64 a1, __int64 a2, ...);
_BYTE *__fastcall sub_18968(char a1, __int64 a2);
__int64 __fastcall sub_1898E(_BYTE *a1, int a2, __int64 a3, unsigned __int64 **a4);
__int64 __fastcall sub_189D2(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_189FE(_BYTE *a1);
__int64 __fastcall sub_18A1A(char *a1, _BYTE *a2);
__int64 __fastcall sub_18A43(__int64 a1, __int64 a2, int a3);
char *__fastcall sub_18A75(char *a1, const char *a2);
__int64 __fastcall sub_18A90(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_18AB5(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_18AE1(char *a1);
signed __int64 __fastcall sub_18B20(signed __int64 a1, signed __int64 *a2, __int64 a3);
_BYTE *__fastcall sub_18C7A(_BYTE *a1, __int64 a2, __int64 a3);
_BYTE *__fastcall sub_18CC7(_BYTE *a1, char *a2);
__int64 __fastcall sub_18D2F(__int64 a1, __int64 a2, int a3);
unsigned __int64 sub_18D72();
char *__fastcall sub_18D87(char *a1, unsigned __int64 a2);
__int64 sub_19006();
_BYTE *sub_1905F(__int64 a1, ...);
_BYTE *__fastcall sub_190B4(int a1, __int64 a2, unsigned __int64 **a3);
__int64 sub_192A2();
_BYTE *sub_1936A();
// __int64 __usercall sub_194E0@<rax>(__m128i *__struct_ptr a1@<xmm0>, __m128i *__struct_ptr a2@<xmm1>, __m128i *__struct_ptr a3@<xmm2>, __m128i *__struct_ptr a4@<xmm6>, __m128i *__struct_ptr a5@<xmm7>);
// signed __int64 __usercall sub_1959F@<rax>(__int64 a1@<rdx>, unsigned int *a2@<rcx>, __int64 a3@<r8>, char *a4@<r9>, __m128i *a5@<xmm1>, __m128i *a6@<xmm2>, __m128i *a7@<xmm6>, __m128i *a8@<xmm7>, unsigned __int64 a9, __int64 a10, unsigned __int64 *a11);
signed __int64 __fastcall sub_1980F(__int64 a1);
__int64 __fastcall sub_19819(char *a1, unsigned __int8 a2, unsigned __int8 a3);
void sub_198A7();
void sub_1995F();
__int64 __fastcall sub_199A0(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3);
void sub_19B1A();
__int64 __fastcall sub_19B32(unsigned int *a1, int a2, __int64 *a3, unsigned __int64 a4);
__int64 __fastcall sub_19CB6(void (__fastcall **a1)(signed __int64), __int64 a2);
__int64 __fastcall sub_19D1B(int a1, __int64 *a2, unsigned __int64 a3, __int64 a4, unsigned int a5, __int64 a6);
__int64 __fastcall sub_19D9D(int a1, __int64 *a2, unsigned __int64 a3, __int64 a4, unsigned int a5, __int64 a6);
signed __int64 __fastcall sub_19DBC(int a1, __int64 *a2, unsigned __int64 a3, char *a4, unsigned __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned __int64 a9);
// signed __int64 __usercall sub_1A042@<rax>(__int64 a1@<rdx>, unsigned int *a2@<r9>, __m128i *a3@<xmm1>, __m128i *a4@<xmm2>, __m128i *a5@<xmm6>, __m128i *a6@<xmm7>, __int64 a7, char *a8, unsigned __int64 a9, __int64 a10, unsigned __int64 *a11);
signed __int64 __fastcall sub_1A0A1(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_1A0B0(__int64 a1, int a2);
void sub_1A11E();
void sub_1A127(__int64 a1, __int64 a2, ...);
_BYTE *__fastcall sub_1A171(_QWORD *a1);
_BYTE *__fastcall sub_1A1D3(int a1, _QWORD *a2);
_BYTE *__fastcall sub_1A2B6(char a1, __int64 a2, __int64 a3, __int64 a4);
_BYTE *__fastcall sub_1A301(__int64 a1, unsigned __int64 **a2);
_BYTE *sub_1A36C(__int64 a1, ...);
__int64 __fastcall sub_1A3A7(int a1);
signed __int64 __fastcall sub_1A3C0(__int64 a1, unsigned __int8 a2);
__int64 __fastcall sub_1A3CA(int a1);
void __fastcall sub_1A3FB(__int64 a1, __int64 a2);
__int64 sub_1A53A();
__int64 __fastcall sub_1A542(unsigned __int8 *a1);
__int64 __fastcall sub_1A5AB(int a1);
__int64 sub_1A609();
_BYTE *__fastcall sub_1A648(unsigned int a1);
signed __int64 __fastcall sub_1A6EF(unsigned int a1);
signed __int64 *__fastcall sub_1A9C4(__int64 a1);
signed __int64 __fastcall sub_1AAAE(_DWORD *a1, char *a2, unsigned int a3);
__int64 __fastcall sub_1AB55(__int64 a1);
__int64 __fastcall sub_1B757(__int64 a1, int *a2, unsigned int a3);
signed __int64 __fastcall sub_1B84F(__int64 a1);
signed __int64 __fastcall sub_1B87F(__int64 a1, int *a2);
__int64 __fastcall sub_1B89D(char *a1, unsigned int a2, __int64 a3);
char *__fastcall sub_1B930(char *a1, char *a2, unsigned __int64 a3);
char *__fastcall sub_1B950(char *a1, char *a2, unsigned __int64 a3);
__int64 sub_1B98C();
__int64 sub_1BA2E();
_BYTE *__fastcall sub_1BAD2(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// char *__usercall sub_1BBA2@<rax>(unsigned int a1@<edx>, __int64 *a2@<rcx>, char *a3@<r8>, char *a4@<r9>, __m128i *a5@<xmm1>, __m128i *a6@<xmm2>, __m128i *a7@<xmm6>, __m128i *a8@<xmm7>);
signed __int64 __fastcall sub_1BCB1(__int64 a1, char *a2);
// __int64 __usercall sub_1BDDD@<rax>(__int64 a1@<rdx>, unsigned int *a2@<rcx>, __int64 a3@<r8>, __m128i *a4@<xmm1>, __m128i *a5@<xmm2>, __m128i *a6@<xmm6>, __m128i *a7@<xmm7>);
bool sub_1BE84();
signed __int64 __fastcall sub_1BEDE(unsigned __int16 a1, _WORD *a2, __int64 a3, unsigned int a4, __int64 a5);
// __int64 __usercall sub_1C099@<rax>(__m128 *a1@<xmm0>, __m128i *a2@<xmm7>);
// signed __int64 __usercall sub_1C727@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, unsigned int *a3@<r8>, __m128 *a4@<xmm0>, __m128i *a5@<xmm7>);
// signed __int64 __usercall sub_1C881@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __m128 *a5@<xmm0>, __m128i *a6@<xmm7>);
_BYTE *__fastcall sub_1D3D6(__int64 a1, __int64 a2, unsigned int a3);
signed __int64 sub_1D49C();
signed __int64 __fastcall sub_1D4EF(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, _QWORD *a5);
// __int64 __usercall sub_1D658@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __m128i *a5@<xmm1>, __m128i *a6@<xmm2>, __m128i *a7@<xmm6>, __m128i *a8@<xmm7>);
// __int64 __usercall sub_1DE44@<rax>(__m128i *a1@<xmm1>, __m128i *a2@<xmm2>, __m128i *a3@<xmm6>, __m128i *a4@<xmm7>);
bool __fastcall sub_1DFC6(__int64 a1, char **a2, _WORD *a3, char **a4);
__int64 __fastcall sub_1DFE7(__int64 a1, char **a2, _WORD *a3, char **a4, _DWORD *a5);
// __int64 __usercall sub_1E09C@<rax>(_QWORD *a1@<rdx>, unsigned int a2@<esi>, _WORD *a3@<r8>, __int64 a4@<r9>, __m128i *a5@<xmm1>, __m128i *a6@<xmm2>, __m128i *a7@<xmm6>, __m128i *a8@<xmm7>);
_BYTE *__fastcall sub_1E195(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_1E202(char **a1, __int64 *a2);
__int64 sub_1E2B5();
signed __int64 __fastcall sub_1E360(unsigned __int64 *a1, unsigned __int64 *a2);
__int64 sub_1E5B1();
unsigned int *__fastcall sub_1E6AD(_QWORD *a1, __int64 a2, unsigned int *a3);
__int64 __fastcall sub_1E8F2(__int64 a1);
// __int64 __usercall sub_1E928@<rax>(__int64 a1@<rcx>, unsigned int a2@<esi>);
signed __int64 __fastcall sub_1E9D0(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall sub_1EA00(__int64 a1, unsigned __int64 a2, char *a3);
// signed __int64 __usercall sub_1EA39@<rax>(int a1@<ecx>, unsigned int *a2@<r8>, unsigned int a3@<r9d>, __m128 *a4@<xmm0>, __m128i *a5@<xmm7>, unsigned int *a6, int a7, int a8, __int64 a9, _DWORD *a10);
// signed __int64 __usercall sub_1EAA3@<rax>(unsigned int a1@<edx>, unsigned int *a2@<rcx>, _DWORD *a3@<r8>, __m128 *a4@<xmm0>, __m128i *a5@<xmm7>);
signed __int64 __fastcall sub_1EB0D(__m128i *a1, unsigned __int64 a2, __m128i *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_1EC69(char *a1);
signed __int64 __fastcall sub_1ECA5(__int64 a1);
__int64 __fastcall sub_1ECEF(__int64 a1, int a2);
signed __int64 __fastcall sub_1EF8A(__int64 a1, _QWORD *a2, __int64 *a3);
signed __int64 __fastcall sub_1F3B0(__m128i *a1, _OWORD *a2, __int64 _R8);
signed __int64 __fastcall sub_1F770(__m128i *a1, _OWORD *a2, __int64 _R8);
signed __int64 __fastcall sub_1FEC0(__m128i *a1, __m128i *a2, signed int a3, __m128i *a4);
void __fastcall sub_20782(__int64 a1, unsigned int a2);
__int64 __fastcall sub_207EC(__int64 a1, unsigned int a2);
__int64 __fastcall sub_20858(__int64 a1, unsigned int a2);
__int64 __fastcall sub_209A2(__int64 a1, unsigned int a2);
void __fastcall sub_20A40(__m128i *a1);
signed __int64 __fastcall sub_21220(__m128i *a1, __m128i *a2, __m128i *a3);
char __fastcall sub_212D0(__m128i *a1, __m128i *a2, __m128i *a3, __int64 a4);
signed __int64 __fastcall sub_21984(unsigned int a1);
signed __int64 __fastcall sub_219D7(__int64 a1, unsigned __int8 a2);
signed __int64 sub_21A08();
// __int64 __usercall sub_21A60@<rax>(char a1@<cf>, _QWORD *a2@<rcx>);
// __int64 __usercall sub_21A79@<rax>(int a1@<r12d>);
_BYTE *__fastcall sub_226B1(unsigned int a1, unsigned int a2);
__int64 __fastcall sub_228E7(unsigned __int16 *a1);
__int64 __fastcall sub_22976(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_22AE1(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_22C00(__int64 a1, unsigned __int64 a2, _QWORD *a3, __int64 a4);
__int64 sub_22ED4(__int64 a1, __int64 a2, __int64 a3, ...);
signed __int64 __fastcall sub_22EF5(__int64 a1, unsigned __int64 a2, signed __int16 *a3, unsigned __int64 **a4);
__int64 __fastcall sub_23590(unsigned int *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_2362C(__int64 a1, __int64 a2, __int64 a3);
bool __fastcall sub_23695(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_236BB(_QWORD *a1, _QWORD *a2, __int64 a3);
void __fastcall sub_2370D(_WORD *a1, __int16 *a2);
__int64 __fastcall sub_23741(_WORD *a1);
signed __int64 __fastcall sub_23764(_WORD *a1);
unsigned __int64 __fastcall sub_2378A(unsigned __int16 *a1, _WORD *a2);
signed __int64 __fastcall sub_237BC(_WORD *a1, __int16 *a2);
__int64 __fastcall sub_23811(_BYTE *a1);
signed __int64 __fastcall sub_2382D(_BYTE *a1, char *a2);
void __fastcall sub_23853(signed __int64 a1, char *a2, signed __int64 a3);
signed __int64 __fastcall sub_23894(_BYTE *a1);
unsigned __int64 __fastcall sub_238B5(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 a3);
_WORD *__fastcall sub_238F1(_WORD *a1, _WORD *a2);
_WORD *__fastcall sub_2394B(unsigned __int8 *a1, _WORD *a2);
unsigned __int64 __fastcall sub_23982(_WORD *a1, unsigned __int64 a2, unsigned __int64 a3, char a4, unsigned __int64 a5);
signed __int64 __fastcall sub_23A4C(_WORD *a1, unsigned __int64 a2, signed __int64 a3, __int64 a4, unsigned __int64 a5);
void __fastcall sub_23BC8(_QWORD *a1);
bool __fastcall sub_23BD5(_QWORD *a1);
__int64 __fastcall sub_23BE1(__int64 *a1);
_QWORD *__fastcall sub_23BF5(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_23C0D(__int64 a1);
void __fastcall sub_23C16(signed __int64 a1, signed __int64 a2);
__int64 __fastcall sub_23C84(__int64 a1, char a2);
__int64 __fastcall sub_23C92(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_23C9F(unsigned __int64 a1, char a2);
unsigned __int64 __fastcall sub_23CAD(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3);
char __fastcall sub_23CCE(unsigned __int64 a1);
__int64 __fastcall sub_23CF5(__int64 a1);
signed __int64 __fastcall sub_23D3E(__int64 a1);
__int64 __fastcall sub_23D7F(__int64 a1);
__int64 __fastcall sub_23DB4(__int64 a1, __int64 a2);
__int64 __fastcall sub_23E90(__int64 a1, __int64 a2);
__int64 __fastcall sub_23EFD(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_23FC3(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_24047(__int64 a1);
__int64 __fastcall sub_24098(_QWORD *a1, __int64 a2);
signed __int64 __fastcall sub_240AB(_QWORD *a1);
__int64 __fastcall sub_240E8(__int64 a1);
__int64 __fastcall sub_24103(__int64 a1);
__int64 __fastcall sub_24136(__int64 a1);
__int64 __fastcall sub_2418C(__int64 a1, __int64 a2);
void __fastcall sub_241E9(__int64 a1);
signed __int64 sub_241F6();
__int64 sub_243DB();
__int64 __fastcall sub_243E3(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
signed __int64 __fastcall sub_2445C(int a1, __int64 a2, unsigned int *a3, unsigned int *a4);
signed __int64 __fastcall sub_244D1(__int64 a1, __int64 a2, int *a3, __int64 a4, int *a5, int *a6, char a7, __int64 a8);
__int64 __fastcall sub_24A17(__int64 a1);
char __fastcall sub_24A5F(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3);
signed __int64 __fastcall sub_24B90(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 *a7, char a8, _QWORD *a9);
signed __int64 __fastcall sub_257CF(__int64 a1, char **a2);
signed __int64 __fastcall sub_2580F(__int64 a1);
void __fastcall sub_25949(__int64 a1, signed int a2);
// __int64 __usercall sub_25B09@<rax>(__int64 a1@<rdx>, _QWORD *a2@<rcx>, unsigned int a3@<r8d>, __int64 a4@<r13>);
// __int64 __usercall sub_25FE0@<rax>(__int64 a1@<rax>, __int64 a2@<rdx>, __int64 a3@<rcx>, __int16 *a4@<r8>, __int64 a5@<r9>);
__int64 __fastcall sub_26191(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_261EC(__int64 a1);
signed __int64 __fastcall sub_2625A(__int64 a1, __int16 *a2, _QWORD *a3);
void __fastcall sub_262D1(__int64 a1, unsigned __int64 *a2, char *a3, _QWORD *a4, unsigned __int64 *a5);
signed __int64 __fastcall sub_263BE(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_2653B(__int64 a1, unsigned __int64 a2, __int64 a3);
signed __int64 __fastcall sub_2665A(__int64 a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_267C8(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5, unsigned __int8 a6);
signed __int64 __fastcall sub_26A90(int a1);
bool __fastcall sub_26AB0(int *a1, int *a2);
void __fastcall sub_26AE1(_DWORD *a1, int a2, int a3);
void __fastcall sub_26AF2(_DWORD *a1, int a2, int a3);
__int64 __fastcall sub_26B03(_DWORD *a1, int a2, int a3, int a4, unsigned int a5);
__int64 __fastcall sub_26B1E(__int64 a1, _DWORD *a2, _DWORD *a3);
signed __int64 __fastcall sub_26BB1(_DWORD *a1, int *a2, int *a3);
__int64 __fastcall sub_26C52(__int64 a1, int *a2, int *a3);
signed __int64 __fastcall sub_26D37(__int64 a1, __int64 a2, unsigned int a3);
char __fastcall sub_26E30(_BYTE *a1, char a2, char a3, char a4, char a5);
signed __int64 __fastcall sub_26E4B(__int64 *a1, __int64 a2);
signed __int64 __fastcall sub_26F86(__int64 a1, int *a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_26FF5(__int64 a1, int a2);
signed __int64 __fastcall sub_27054(__int64 a1);
signed __int64 __fastcall sub_27168(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_271F9(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_27219(__int64 a1, _DWORD *a2);
signed __int64 __fastcall sub_27251(__int64 a1, _DWORD *a2);
signed __int64 __fastcall sub_272F9(__int64 a1);
signed __int64 __fastcall sub_27402(_DWORD *a1, _DWORD *a2);
signed __int64 __fastcall sub_274AA(__int64 a1);
signed __int64 __fastcall sub_274E1(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_27500(__int64 a1, unsigned __int8 a2);
signed __int64 __fastcall sub_27533(__int64 a1, unsigned int a2);
__int64 __fastcall sub_275C4(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_27643(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_2768D(__int64 a1, int a2);
signed __int64 __fastcall sub_276AC(__int64 a1, _DWORD *a2);
signed __int64 __fastcall sub_276D0(__int64 a1, int a2, __int64 a3, int a4, __int64 a5);
signed __int64 __fastcall sub_2780F(_QWORD *a1, __int64 a2);
signed __int64 __fastcall sub_278C3(__int64 a1, __int64 a2);
__int64 __fastcall sub_27987(int a1, __int64 a2, __int64 *a3, __int64 a4);
signed __int64 __fastcall sub_27A48(__int64 a1);
signed __int64 __fastcall sub_27AC9(_DWORD *a1);
signed __int64 __fastcall sub_27AD3(__int64 a1, char *a2);
__int64 __fastcall sub_27B30(__int64 a1);
__int64 sub_27BDC();
__int64 sub_27C1B();
char sub_27CB1();
__int64 __fastcall sub_27CFB(__int64 **a1);
__int64 __fastcall sub_27D1B(__int64 a1);
__int64 sub_27DE2();
void **sub_27E47();
__int64 sub_27E75();
void sub_27ECA();
__int64 sub_27FD3();
void __fastcall sub_28017(__int64 a1);
__int64 sub_2809A();
void sub_280CE();
__int64 __fastcall sub_280E5(__int64 a1, int a2, __int64 a3, int a4);
__int64 __fastcall sub_2816D(__int64 a1, __int64 a2);
signed __int64 sub_28202();
void sub_282BE();
void sub_284F7();
signed __int64 __fastcall sub_2851C(_DWORD *a1);
__int64 sub_2857A();
char __fastcall sub_28665(__int64 a1, __int64 a2, int a3);
unsigned __int64 __fastcall sub_2885A(unsigned __int64 a1);
__int64 sub_288AD();
signed __int64 __fastcall sub_288EC(__int64 a1, _QWORD *a2, __int64 *a3);
signed __int64 __fastcall sub_289D6(__int64 *a1, _DWORD *a2);
signed __int64 __fastcall sub_28AC9(__int64 *a1, __int64 a2, _DWORD *a3);
signed __int64 sub_28B4E();
signed __int64 __fastcall sub_28BD7(__int64 a1, int a2, int a3);
__int64 sub_28C1E();
void sub_28C86();
unsigned __int64 __fastcall sub_28CAB(__int16 a1, _DWORD *a2, char a3);
__int64 sub_28CE6();
signed __int64 __fastcall sub_28D3B(_BYTE *a1);
signed __int64 __fastcall sub_28D5C(int a1, unsigned __int64 *a2, _WORD *a3, _DWORD *a4);
__int64 __fastcall sub_290EF(__int64 *a1, unsigned __int64 *a2, __int64 a3);
void __fastcall sub_2923D(__int64 a1);
void __fastcall sub_29277(__int64 a1);
char sub_292C5();
__int64 __fastcall sub_29350(__int64 a1);
__int64 __fastcall sub_29405(unsigned __int64 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int8 a4, __int64 a5, __int16 a6, int *a7, __int64 a8, unsigned __int16 *a9, __int64 a10);
signed __int64 __fastcall sub_29A0D(__int64 a1, __int64 a2, __int16 a3, unsigned __int16 a4, _WORD *a5, __int64 a6);
signed __int64 __fastcall sub_29A6F(__int64 a1, __int64 a2, unsigned __int16 a3, unsigned __int16 a4, _WORD *a5, __int64 a6);
signed __int64 __fastcall sub_29B58(__int64 a1, __int64 a2, unsigned __int16 a3, unsigned __int16 a4, _WORD *a5, __int64 a6);
__int64 sub_29BA0();
__int64 sub_29BAF();
void __fastcall sub_29BBF(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_29C71(unsigned __int64 a1, unsigned __int16 a2, unsigned __int8 a3, int a4, char *a5, unsigned __int64 a6, unsigned __int16 *a7);
char __fastcall sub_29D3C(unsigned __int16 a1);
// void __usercall sub_29D63(__int64 a1@<rax>, unsigned __int64 a2@<rdx>, __int64 a3@<rcx>, unsigned __int16 a4@<r8w>, unsigned __int8 a5@<r9b>, int a6);
__int64 __fastcall sub_2A128(__int16 *a1);
__int64 __fastcall sub_2A137(__int64 a1);
__int64 __fastcall sub_2A140(__int16 *a1, unsigned int a2);
__int64 __fastcall sub_2A1AF(__int64 a1);
__int64 __fastcall sub_2A1BF(char *a1);
__int64 __fastcall sub_2A1D1(_BYTE *a1, _BYTE *a2, __int16 a3);
__int64 __fastcall sub_2A205(_BYTE *a1, __int16 a2, __int64 a3, __int16 a4);
signed __int64 __fastcall sub_2A281(_QWORD *a1, __int64 *a2, const void *a3, __int64 a4, char a5);
__int64 __fastcall sub_2A45E(__int64 a1);
void __fastcall sub_2A4D4(_QWORD *a1, char a2);
void __fastcall sub_2AB36(_QWORD *a1);
__int64 __fastcall sub_2AB71(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_2AB8E(__int64 a1, __int16 a2, char a3);
signed __int64 __fastcall sub_2AE83(__int64 a1);
void __fastcall sub_2AF13(__int64 a1, __int16 *a2, unsigned __int64 a3, unsigned __int16 a4, unsigned __int16 a5, unsigned __int8 a6, unsigned int a7);
__int64 __fastcall sub_2B19E(__int64 a1, __int64 a2);
void __fastcall sub_2B20C(__int64 a1);
__int64 __fastcall sub_2B269(__int64 a1, char a2);
__int64 __fastcall sub_2B27C(__int64 a1, char a2);
__int64 __fastcall sub_2B28F(__int64 a1, char a2);
__int64 __fastcall sub_2B2A2(__int64 a1, char a2, char a3);
__int64 __fastcall sub_2B3C8(__int64 a1, char a2);
char __fastcall sub_2B3E0(__int64 a1);
__int64 __fastcall sub_2B3F3(_QWORD *a1, char a2);
__int64 __fastcall sub_2B417(__int64 a1);
__int64 __fastcall sub_2B42C(__int64 a1);
__int64 __fastcall sub_2B441(__int64 a1);
bool __fastcall sub_2B456(__int64 a1);
char __fastcall sub_2B497(__int64 a1);
signed __int64 __fastcall sub_2B4AA(__int64 a1, __int64 a2);
__int64 __fastcall sub_2B4F7(__int64 a1, unsigned int a2, char a3);
void __fastcall sub_2B63E(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_2B665(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 *a4, _QWORD *a5);
signed __int64 __fastcall sub_2B8B8(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_2B927(__int64 a1, unsigned int a2);
signed __int64 __fastcall sub_2B9C3(unsigned int a1, __int64 a2, unsigned __int8 a3);
__int64 __fastcall sub_2BA6A(unsigned __int64 *a1, char *a2);
signed __int64 __fastcall sub_2BB74(unsigned __int64 *a1, char *a2, _QWORD *a3, unsigned __int64 *a4, _QWORD *a5);
signed __int64 __fastcall sub_2BCF0(unsigned __int64 *a1, char *a2, _QWORD *a3, unsigned __int64 *a4, _QWORD *a5, char a6);
signed __int64 __fastcall sub_2BDBE(unsigned __int64 *a1, __int64 a2, char *a3);
signed __int64 __fastcall sub_2BE2F(unsigned __int64 *a1, char *a2, _QWORD *a3, unsigned __int64 *a4, _QWORD *a5, char a6);
__int64 __fastcall sub_2BEB3(unsigned __int64 *a1, char *a2, char *a3, char *a4, __int64 a5, __int64 a6);
char __fastcall sub_2C02D(__int64 a1, __int64 a2, int a3);
char __fastcall sub_2C0AB(__int64 a1, __int64 a2, __int64 a3);
signed __int64 sub_2C122();
void __fastcall sub_2C12E(signed int a1);
void sub_2C16A();
signed __int64 __fastcall sub_2C1A0(__int64 a1, __int16 *a2, _QWORD *a3);
signed __int64 __fastcall sub_2C1B7(__int64 a1, __int16 *a2, _QWORD *a3, _BYTE *a4);
signed __int64 __fastcall sub_2C317(unsigned __int64 *a1, char *a2, _QWORD *a3, unsigned __int64 *a4, _QWORD *a5, char a6);
__int64 __fastcall sub_2C321(__int64 a1, __int64 a2, _QWORD *a3);
signed __int64 __fastcall sub_2C3B2(__int64 a1, __int64 a2, _QWORD *a3);
signed __int64 __fastcall sub_2C45B(__int64 a1, __int64 a2, _QWORD *a3);
signed __int64 __fastcall sub_2C52E(__int64 a1, __int64 a2, _QWORD *a3);
signed __int64 __fastcall sub_2C62D(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_2C719(unsigned __int64 *a1, char *a2, char a3, char **a4, unsigned __int64 *a5, char a6);
__int64 __fastcall sub_2C860(int a1);
__int64 __fastcall sub_2C86B(unsigned int a1);
__int64 __fastcall sub_2C88C(unsigned int a1, int a2);
__int64 __fastcall sub_2C899(unsigned int a1, unsigned int a2);
__int64 __fastcall sub_2C8F8(unsigned int a1, int a2);
__int64 __fastcall sub_2C905(unsigned int a1, unsigned int a2);
__int64 __fastcall sub_2C972(int a1, int a2);
void __fastcall sub_2C982(__int64 a1, int a2);
void __fastcall sub_2CBDA(__int64 a1);
__int64 __fastcall sub_2CDAA(__int64 a1, __int64 a2);
char __fastcall sub_2CEC9(__int64 a1, char a2);
__int64 __fastcall sub_2D085(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_2D39E(__int64 a1);
__int64 __fastcall sub_2D438(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_2D46E(__int64 *a1);
__int64 __fastcall sub_2D4C8(__int64 a1, __int64 a2);
__int64 __fastcall sub_2D508(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_2D570(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_2DBD3(__int64 a1);
__int64 __fastcall sub_2DC3D(__int64 *a1);
void __fastcall sub_2DD3B(__int64 a1);
signed __int64 __fastcall sub_2E005(__int64 *a1);
void __fastcall sub_2E0D9(__int64 a1, __int64 a2);
char sub_2E144();
void __fastcall sub_2E14C(__int64 a1, char a2);
__int64 __fastcall sub_2E379(__int64 a1);
__int64 __fastcall sub_2E3C8(__int64 a1, unsigned int a2);
void __fastcall sub_2E405(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_2E413(__int64 a1, int a2, __int64 a3);
signed __int64 __fastcall sub_2E45B(__int64 a1, __int64 a2);
__int64 __fastcall sub_2EEC1(__int64 a1);
_QWORD *__fastcall sub_2EECA(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_2EF20(__int64 a1, __int64 a2);
void __fastcall sub_2EF5F(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_2F139(__int64 a1, bool *a2, bool *a3);
__int64 __fastcall sub_2F190(__int64 a1, __int64 a2);
void __fastcall sub_2F273(__int64 a1, __int64 a2);
__int64 __fastcall sub_2F2DC(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_2F3F7(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4);
signed __int64 __fastcall sub_2F563(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_2F778(__int64 a1);
signed __int64 __fastcall sub_2F868(_BYTE *a1);
signed __int64 __fastcall sub_2F8BC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void sub_2F98D();
signed __int64 __fastcall sub_2F99D(_QWORD *a1, __int64 a2);
signed __int64 __fastcall sub_2FA0E(__int64 a1, __int64 a2);
signed __int64 sub_2FA45();
signed __int64 sub_2FA77();
signed __int64 __fastcall sub_2FACD(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_2FB24(__int64 a1);
signed __int64 __fastcall sub_2FB5E(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_2FB9B(__int64 a1);
signed __int64 __fastcall sub_2FBD8(__int64 a1);
_DWORD *__fastcall sub_2FC6B(_DWORD *a1, __int64 a2);
signed __int64 __fastcall sub_2FCF6(_QWORD *a1, _DWORD *a2, __int64 *a3);
signed __int64 __fastcall sub_2FE89(__int64 a1);
void __fastcall sub_2FED5(__int64 a1, unsigned int a2, int a3, int a4);
signed __int64 __fastcall sub_304D0(__int64 a1);
void __fastcall sub_3054D(__int64 a1, int a2);
signed __int64 __fastcall sub_30638(__int64 a1);
bool __fastcall sub_306BD(__int64 a1);
signed __int64 __fastcall sub_306FE(__int64 a1);
// __int64 __usercall sub_30799@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, char *a3@<rdi>);
signed __int64 __fastcall sub_30C41(__int64 a1);
__int64 __fastcall sub_30CAB(__int64 a1);
signed __int64 __fastcall sub_30D10(__int64 a1, unsigned __int8 a2);
__int64 __fastcall sub_30ECA(__int64 a1, int a2, char a3);
__int64 __fastcall sub_30F3C(__int64 a1);
signed __int64 __fastcall sub_30F4F(__int64 a1, signed int a2);
__int64 __fastcall sub_30FE7(__int64 a1);
signed __int64 __fastcall sub_310A2(__int64 a1);
signed __int64 __fastcall sub_3110D(__int64 a1);
__int64 __fastcall sub_31187(__int64 a1);
__int64 __fastcall sub_311B0(__int64 a1);
void __fastcall sub_311C5(__int64 a1, int a2, unsigned int a3, int *a4, int a5, int a6);
_DWORD *__fastcall sub_3146C(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_31513(int a1, int a2, int a3);
void __fastcall sub_31598(__int64 a1, __int64 a2, int *a3, int *a4, char a5);
_DWORD *__fastcall sub_31687(_DWORD *a1, __int64 a2);
_DWORD *__fastcall sub_31718(_DWORD *a1, __int64 a2);
void __fastcall sub_317A8(__int64 a1, int a2, char a3);
signed __int64 __fastcall sub_31814(__int64 a1, int *a2);
__int64 __fastcall sub_318AE(__int64 a1, __int64 a2);
__int64 __fastcall sub_31933(__int64 a1, __int64 a2);
__int64 __fastcall sub_3196B(__int64 a1, __int64 a2);
__int64 __fastcall sub_319A4(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_319E8(_QWORD *a1, __int64 a2, int a3, __int64 a4, __int64 a5, int *a6);
signed __int64 __fastcall sub_31BFA(__int64 a1);
__int64 (__fastcall *__fastcall sub_31C46(__int64 a1))(__int64, _QWORD);
signed __int64 __fastcall sub_31F31(__int64 a1);
signed __int64 __fastcall sub_31F4D(__int64 a1, int a2);
signed __int64 __fastcall sub_31FAA(__int64 a1);
_DWORD *__fastcall sub_31FE6(_DWORD *a1, __int64 a2);
__int64 __fastcall sub_3201C(__int64 a1);
signed __int64 __fastcall sub_3205B(__int64 a1, int a2);
__int64 __fastcall sub_320A3(__int64 a1, signed int a2);
signed __int64 __fastcall sub_3213A(__int64 a1, __int64 *a2);
__int64 __fastcall sub_3217A(__int64 a1, __int64 a2, _QWORD *a3);
_DWORD *__fastcall sub_32195(_DWORD *a1, __int64 a2, int a3);
__int64 __fastcall sub_321E1(__int64 a1, __int64 a2, __int64 a3);
__int64 (__fastcall *__fastcall sub_321F6(__int64 a1, __int64 a2, __int64 a3))(__int64, _QWORD);
__int64 (__fastcall *__fastcall sub_32215(__int64 a1, __int64 a2, __int64 a3))(__int64, _QWORD);
__int64 __fastcall sub_32235(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_32250(_QWORD *a1, int *a2);
signed __int64 __fastcall sub_323D1(__int64 a1);
__int64 __fastcall sub_32436(__int64 a1);
signed __int64 __fastcall sub_3264C(__int64 a1);
__int64 __fastcall sub_326E7(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_32952(__int64 a1);
signed __int64 __fastcall sub_3299E(__int64 a1);
__int64 __fastcall sub_329D9(__int64 a1, __int64 a2);
__int64 __fastcall sub_32A4A(unsigned int a1);
__int64 __fastcall sub_32B0C(int a1);
__int64 __fastcall sub_32B42(unsigned int a1, int a2);
__int64 __fastcall sub_32BA9(signed int a1);
signed __int64 __fastcall sub_32BCB(__int64 a1, _DWORD *a2);
signed __int64 __fastcall sub_32D82(__int64 a1, unsigned __int8 a2);
signed __int64 __fastcall sub_32E34(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_32E65(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_32F35(__int64 a1, _BYTE *a2);
signed __int64 __fastcall sub_3340E(__int64 a1, unsigned __int8 a2, int a3, int a4);
char __fastcall sub_334E0(__int64 a1, int a2, int a3);
bool __fastcall sub_336BB(__int64 a1, int a2, int a3);
__int64 __fastcall sub_337EF(_QWORD *a1, __int64 a2);
void __fastcall sub_33BD0(__int64 a1, _WORD *a2);
signed __int64 __fastcall sub_340E9(__int64 *a1, __int64 a2);
signed __int64 __fastcall sub_3413D(__int64 a1);
signed __int64 __fastcall sub_341CC(__int64 a1);
__int64 __fastcall sub_34247(__int64 a1);
signed __int64 __fastcall sub_34253(char *a1);
__int64 __fastcall sub_342D0(__int64 a1);
void sub_34302();
void __fastcall sub_34327(__int64 a1, __int64 a2);
__int64 sub_34446();
__int64 __fastcall sub_34497(__int64 a1, __int64 a2);
__int64 __fastcall sub_344BE(__int64 a1, __int64 a2);
__int64 __fastcall sub_3450F(__int64 a1, __int64 a2);
__int64 __fastcall sub_3453F(__int64 a1, int a2);
__int64 __fastcall sub_345BE(_QWORD *a1, __int64 a2);
signed __int64 __fastcall sub_3469F(_QWORD *a1, __int64 **a2);
int **__fastcall sub_34774(__int64 a1);
__int64 __fastcall sub_34829(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3484A(_QWORD *a1, __int64 a2);
unsigned __int64 *__fastcall sub_348ED(unsigned __int64 **a1);
char __fastcall sub_34936(unsigned __int64 **a1);
__int64 __fastcall sub_3495B(unsigned __int64 **a1, char *a2);
char __fastcall sub_349C6(unsigned __int64 **a1);
__int64 __fastcall sub_349EB(unsigned __int64 **a1);
char __fastcall sub_34A08(unsigned __int64 **a1);
signed __int64 __fastcall sub_34A2F(__int64 a1);
signed __int64 __fastcall sub_34D13(__int64 a1);
void __fastcall sub_34D38(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_34E27(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall sub_34EC2(__int64 a1, __int64 a2);
void __fastcall sub_34F2B(__int64 a1);
__int64 __fastcall sub_35006(__int64 a1);
signed __int64 __fastcall sub_35036(unsigned int a1, _BYTE *a2);
__int64 __fastcall sub_350AF(unsigned int a1, unsigned int a2, __int64 a3);
signed __int64 sub_3511E();
char sub_3518C();
__int64 sub_351CC();
signed __int64 sub_35204();
__int64 __fastcall sub_353A0(__int64 a1, unsigned __int64 a2, char a3);
signed __int64 sub_3560A();
__int64 sub_357DF();
__int64 sub_35852();
__int64 __fastcall sub_35907(unsigned __int16 *a1, __int64 a2);
__int64 __fastcall sub_359AF(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4);
__int64 __fastcall sub_359CB(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4, __int64 a5);
__int64 __fastcall sub_35A58(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4);
void __fastcall sub_35A74(__int64 a1);
signed __int64 __fastcall sub_35AB4(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, signed int *a5, __int64 *a6);
signed __int64 __fastcall sub_35C57(__int64 a1, char a2);
signed __int64 __fastcall sub_35C95(__int64 a1, int *a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_35DED(__int64 a1);
signed __int64 __fastcall sub_35E2C(__int64 a1);
signed __int64 __fastcall sub_35E9F(_QWORD *a1);
signed __int64 __fastcall sub_35F37(__int64 a1, __int64 a2, __int64 a3, __int64 a4, signed int *a5);
signed __int64 __fastcall sub_35F95(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, signed int *a5);
__int64 __fastcall sub_36107(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_36544(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_36576(__int64 a1);
signed __int64 __fastcall sub_365CA(__int64 a1, int a2);
signed __int64 __fastcall sub_3661D(__int64 a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_3664E(__int64 a1, char a2);
void __fastcall sub_3667A(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_366DA(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_3670F(__int64 a1, __int64 a2);
void __fastcall sub_36774(__int64 a1);
void __fastcall sub_367A3(__int64 a1);
__int64 __fastcall sub_367EF(__int64 a1);
signed __int64 __fastcall sub_3681B(__int64 a1, __int64 a2, __int64 a3, int a4, _QWORD *a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, char a10, char a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15);
signed __int64 __fastcall sub_36CB8(_QWORD *a1);
bool __fastcall sub_36F59(__int64 a1);
void sub_36FB5();
void sub_37005();
signed __int64 __fastcall sub_37012(__int64 a1, char **a2, __int64 a3);
void __fastcall sub_38464(__int64 a1);
void __fastcall sub_38714(__int64 a1, char a2, char a3);
void __fastcall sub_38799(__int64 a1, char a2);
__int64 __fastcall sub_38B4D(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_38BF4(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_38C1B(__int64 a1);
__int64 __fastcall sub_38C5A(__int64 a1, __int64 a2);
__int64 __fastcall sub_38CA4(__int64 a1, __int64 a2);
__int64 __fastcall sub_38CEE(__int64 a1, __int64 a2);
__int64 __fastcall sub_38D3C(__int64 a1, __int64 a2);
__int64 __fastcall sub_38D86(__int64 a1, __int64 a2);
__int64 __fastcall sub_38DD0(__int64 a1, __int64 a2, char *a3, int a4, char a5);
__int64 __fastcall sub_38F3A(__int64 a1, __int64 *a2);
signed __int64 __fastcall sub_39014(__int64 a1, __int64 a2);
__int64 __fastcall sub_3904B(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_39090(__int64 a1);
__int64 __fastcall sub_390CA(__int64 a1, __int64 a2, __int64 (__fastcall *a3)(__int64));
signed __int64 __fastcall sub_390D5(__int64 a1);
__int64 __fastcall sub_3910F(_QWORD *a1);
void __fastcall sub_39194(__int64 a1, char a2);
void __fastcall sub_392BD(_QWORD *a1, int a2);
signed __int64 __fastcall sub_39381(__int64 a1);
bool __fastcall sub_3941B(_QWORD *a1);
__int64 __fastcall sub_3947A(__int64 a1, int a2);
signed __int64 __fastcall sub_39C9F(__int64 a1);
__int64 __fastcall sub_39D2F(__int64 a1, __int64 a2);
__int64 __fastcall sub_39D59(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_39D83(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_39DEA(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int128 *__struct_ptr a7, __int64 a8, __int64 *a9, __int64 a10, __int64 a11, __int64 a12, __int64 *a13, __int64 a14, __int64 a15, __int64 a16, __int64 *a17, __int64 a18);
signed __int64 __fastcall sub_3A2B4(__int64 a1);
__int64 __fastcall sub_3A409(_QWORD *a1);
void __fastcall sub_3A4BF(__int64 a1, _DWORD *a2, int a3);
void __fastcall sub_3AFB2(__int64 a1, int a2);
void __fastcall sub_3B080(_QWORD *a1, unsigned int a2);
signed __int64 __fastcall sub_3B15D(__int64 a1, _DWORD *a2, _DWORD *a3, __int64 a4, _DWORD *a5);
signed __int64 __fastcall sub_3B2A4(__int64 a1, char a2);
signed __int64 __fastcall sub_3B312(__int64 a1);
__int64 __fastcall sub_3B51B(__int64 a1);
__int64 __fastcall sub_3B583(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4);
void __fastcall sub_3B93D(__int64 a1, int a2);
signed __int64 __fastcall sub_3BADA(__int64 a1);
void __fastcall sub_3BB78(__int64 a1);
char __fastcall sub_3BBC7(__int64 a1, char *a2, unsigned int a3);
void __fastcall sub_3BF44(__int64 a1, __int64 a2);
__int64 __fastcall sub_3BFBC(__int64 a1, __int64 a2, __int64 a3);
__int64 *__fastcall sub_3C045(__int64 a1, __int64 a2);
__int64 __fastcall sub_3C0C2(__int64 a1);
__int64 __fastcall sub_3C11E(__int64 a1);
__int64 __fastcall sub_3C17A(__int64 a1, __int64 a2);
__int64 __fastcall sub_3C279(__int64 a1, __int64 a2, unsigned int a3);
signed __int64 __fastcall sub_3C3B8(__int64 a1, __int64 a2);
__int64 __fastcall sub_3C432(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3C5E0(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3C6DF(__int64 a1);
void __fastcall sub_3C7E5(__int64 a1, char a2, char a3);
__int64 __fastcall sub_3CCE2(__int64 a1);
__int64 __fastcall sub_3CD52(__int64 a1);
__int64 __fastcall sub_3CDB1(__int64 *a1);
__int64 __fastcall sub_3CE33(__int64 a1);
signed __int64 __fastcall sub_3CED1(__int64 a1, __int64 a2);
__int64 __fastcall sub_3CF59(__int64 a1);
__int64 __fastcall sub_3CF9A(__int64 a1);
__int64 __fastcall sub_3D007(__int64 a1);
__int64 __fastcall sub_3D038(__int64 a1);
__int64 __fastcall sub_3D069(__int64 a1);
__int64 __fastcall sub_3D09A(__int64 a1);
__int64 __fastcall sub_3D0D2(__int64 a1);
signed __int64 __fastcall sub_3D10A(__int64 a1);
__int64 __fastcall sub_3D133(__int64 a1);
signed __int64 __fastcall sub_3D1A5(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3D1FC(__int64 a1, __int64 *a2);
signed __int64 __fastcall sub_3D325(__int64 a1);
signed __int64 __fastcall sub_3D402(__int64 a1);
signed __int64 __fastcall sub_3D482(_QWORD *a1, _QWORD *a2, char a3);
__int64 __fastcall sub_3D64E(int a1, __int64 a2, __int64 a3, unsigned __int8 (__fastcall *a4)(_BYTE *, char *, signed __int64));
__int64 __fastcall sub_3D7CB(__int64 a1);
__int64 __fastcall sub_3D871(__int64 a1);
signed __int64 __fastcall sub_3D892(__int64 a1);
signed __int64 __fastcall sub_3D8B3(__int64 a1);
__int64 __fastcall sub_3D8D4(__int64 a1, __int16 *a2);
__int64 __fastcall sub_3DAD5(__int64 a1, __int64 a2);
void __fastcall sub_3DB6E(__int64 a1, __int64 a2);
void __fastcall sub_3DD75(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3DE3B(_QWORD *a1, __int64 a2, _DWORD *a3);
void __fastcall sub_3E084(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3E0E5(__int64 a1);
__int64 __fastcall sub_3E12C(__int64 a1);
__int64 __fastcall sub_3E188(unsigned int a1);
__int64 __fastcall sub_3E19E(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall sub_3E1FE(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
signed __int64 __fastcall sub_3E230(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
signed __int64 __fastcall sub_3E262(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
signed __int64 __fastcall sub_3E367(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, __int64 a5, unsigned int a6);
signed __int64 __fastcall sub_3E777(int a1);
signed __int64 __fastcall sub_3E794(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_3E7C6(int a1);
signed __int64 __fastcall sub_3E7E0(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_3E834(signed int a1);
signed __int64 __fastcall sub_3E8BA(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_3E8EC(signed int a1);
__int64 __fastcall sub_3E972(signed int a1);
signed __int64 __fastcall sub_3EA33(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_3EA65(signed int a1);
__int64 __fastcall sub_3EB5D(signed int *a1);
signed __int64 __fastcall sub_3EBD5(int a1, int a2, __int64 a3, _QWORD *a4);
signed __int64 __fastcall sub_3EED1(__int64 a1, _QWORD *a2);
signed __int64 __fastcall sub_3EF0E(__int64 *a1, int a2);
signed __int64 __fastcall sub_3F069(_QWORD *a1);
signed __int64 __fastcall sub_3F181(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3F18E(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3F1DC(__int64 a1, __int64 *a2);
__int64 __fastcall sub_3F278(__int64 a1);
void __fastcall sub_3F2DA(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3F340(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3F3B4(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_3F58B(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3F613(__int64 a1, __int64 a2, char a3);
signed __int64 __fastcall sub_3F6AA(_QWORD *a1);
void __fastcall sub_3F9D3(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_3FAAF(_QWORD *a1, __int64 a2);
signed __int64 __fastcall sub_3FB13(__int64 a1);
signed __int64 __fastcall sub_3FB3E(__int64 a1);
signed __int64 __fastcall sub_3FBB3(__int64 a1);
char sub_3FBF3();
void __fastcall sub_3FBFF(char a1);
signed __int64 __fastcall sub_3FC0B(__int64 a1, signed int *a2, __int64 *a3, __int64 a4);
signed __int64 __fastcall sub_3FD8F(__int64 a1, __int64 a2, __int64 a3, __int64 *a4);
signed __int64 __fastcall sub_3FED1(__int64 a1, __int64 *a2, _QWORD *a3);
__int64 __fastcall sub_3FFD2(int a1);
void __fastcall sub_40008(_DWORD *a1, __int64 a2, char *a3);
__int64 __fastcall sub_400E3(char *a1);
__int64 __fastcall sub_401FA(__int64 a1, char *a2);
void __noreturn sub_402B7();
__int64 __fastcall __far sub_926C0(); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_4118; // weak
_UNKNOWN loc_4345; // weak
char byte_51B7 = '\x0F'; // weak
int dword_51DA = 0; // weak
char byte_51E0[2] = { '\x18', '\0' }; // weak
__int64 qword_51E2 = 0i64; // weak
__int16 word_51EA[3] = { 0, 0, 0 }; // weak
_UNKNOWN loc_FFFF; // weak
void *__ptr32 off_18588[42] =
{
  (void *__ptr32 )0xFFFFF94Ci64,
  (void *__ptr32 )0xFFFFF956i64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF968i64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF9ABi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF9DDi64,
  (void *__ptr32 )0xFFFFFA48i64,
  (void *__ptr32 )0xFFFFFA5Di64,
  (void *__ptr32 )0xFFFFF946i64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFFA67i64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF8F3i64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF94Ci64,
  (void *__ptr32 )0xFFFFF95Ai64,
  (void *__ptr32 )0xFFFFF918i64,
  (void *__ptr32 )0xFFFFFC8Fi64,
  (void *__ptr32 )0xFFFFF96Ci64,
  (void *__ptr32 )0xFFFFFCE3i64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF83Bi64,
  (void *__ptr32 )0xFFFFF9AFi64
}; // weak
_UNKNOWN loc_186A0; // weak
void *__ptr32 off_1DE30[5] =
{
  (void *__ptr32 )0xFFFFFE0Ai64,
  (void *__ptr32 )0xFFFFFEC4i64,
  (void *__ptr32 )0xFFFFFF0Bi64,
  (void *__ptr32 )0xFFFFFF4Di64,
  (void *__ptr32 )0xFFFFFF72i64
}; // weak
_UNKNOWN loc_1FFFD; // weak
_UNKNOWN loc_32CDF; // weak
_UNKNOWN loc_38000; // weak
_UNKNOWN loc_40000; // weak
__int16 word_40ADE = 47; // weak
__int16 word_40AE2[2] = { 92, 0 }; // weak
__int16 word_40AE6 = 92; // weak
__int16 word_4109E = 0; // weak
char byte_42BDF = '\0'; // weak
char aDictKeyIoprovi[172] = "<dict><key>IOProviderClass</key><string>IONetworkInterface</string><key>IOParentMatch</key><dict><key>IOPropertyMatch</key><dict><key>IOMACAddress</key><data format=\"hex\">"; // weak
char aDataDictDictDi[29] = "</data></dict></dict></dict>"; // weak
char aChunklistNoRev[23] = "-chunklist-no-rev2-dev"; // weak
char a0123456789abcd[33] = "0123456789abcdef0123456789ABCDEF"; // weak
char aOk0[6] = "Ok(0)"; // weak
char aErr[4] = "Err"; // weak
char aWarn[5] = "Warn"; // weak
char a0x[4] = "(0x"; // weak
int dword_46AB4 = 10911970; // weak
__int64 qword_4E380 = 4620710844295151872i64; // weak
int dword_4F38C[] = { 2774754246 }; // weak
char byte_4FF7F = ''; // weak
__int64 qword_50000[113] =
{
  -1975265551194807132i64,
  8485546647132815552i64,
  4444652145607507453i64,
  7807612510838335014i64,
  -791797942116597953i64,
  7519942877947874508i64,
  -3371817447908399707i64,
  -2120226265238015503i64,
  7085060728183576792i64,
  579842867959108885i64,
  5072499191038789575i64,
  3470050006887482307i64,
  724803584996251286i64,
  1011347318767983258i64,
  1989324948265898514i64,
  -3663981848524102942i64,
  9209213291931969319i64,
  1304646455249565045i64,
  6373767940623205251i64,
  3903806255653591578i64,
  -5409286756129149330i64,
  -6559965293534535520i64,
  -5232665075431687365i64,
  5943389391426597811i64,
  6805272394555384803i64,
  -6416130477843315580i64,
  3110654417i64,
  4638742941243600365i64,
  8775459251509263612i64,
  -3116936885525718181i64,
  7483221981476080587i64,
  -7719651027660883655i64,
  -5699208190892946356i64,
  -4941626572100939825i64,
  5757195349092134895i64,
  -8735501943195632645i64,
  7373856261623205197i64,
  -8444454613346384507i64,
  289921437535369721i64,
  -6849886724433019009i64,
  2718660832337869884i64,
  -6704926010617124696i64,
  -9169258196127276125i64,
  4588484751216250767i64,
  8090778544306429341i64,
  7196678249244849653i64,
  -5803491912950106442i64,
  2319371470115119393i64,
  -211963903593480193i64,
  -9129696061023202606i64,
  2753127719936199692i64,
  -4692364471842116372i64,
  -8589415329554065513i64,
  -7829573080292190441i64,
  -251499548106381401i64,
  -3986701187418735299i64,
  3615010724195556701i64,
  -4566544052852001933i64,
  -7002728744433974911i64,
  4928664374370884828i64,
  4299689218822515242i64,
  -8301745696449263480i64,
  7769756885899144942i64,
  -6378822351454465004i64,
  1593441988200521310i64,
  -2649276700189860901i64,
  8380699979048956466i64,
  -7864611746053486070i64,
  5218585805454968326i64,
  -6963195307263501220i64,
  4895321177887527891i64,
  4154730711504806498i64,
  -3226858939251124843i64,
  -3084147811402679943i64,
  7951447328798525640i64,
  111619731176779117i64,
  -7146563558792964651i64,
  -2831519053357471319i64,
  -934509065944803754i64,
  -3841740469182272790i64,
  5181864912716987002i64,
  8058552416546064392i64,
  5363546526101043320i64,
  4045389273421196846i64,
  8342835521389700774i64,
  -3808944774156532026i64,
  -1685344116269064739i64,
  -7575816211630317793i64,
  974619800130862525i64,
  -2265186985968301430i64,
  8197877012799569470i64,
  -8009572459769862554i64,
  -647965334841261309i64,
  -4421583339437027826i64,
  -5838539408950741707i64,
  1698286446354414009i64,
  4190349991255523777i64,
  -2794235211633025378i64,
  3149028347008514296i64,
  -3261897604833537775i64,
  543121973454100953i64,
  3293991268356953236i64,
  1554453836295446046i64,
  -8698193817756440087i64,
  5798428675372176725i64,
  256578239483011039i64,
  684698366373306785i64,
  7339389370251021581i64,
  -8879336760468707610i64,
  -9024297477389916056i64,
  6518728657638300057i64,
  8920417757402566415i64,
  7914719809818612820i64
}; // weak
int dword_5038C[] = { 1353184337 }; // weak
int dword_5138C[] = { 99 }; // weak
int dword_5238C[] = { 82 }; // weak
__int64 qword_53020[120] =
{
  2522015794582257664i64,
  -1297036691659292672i64,
  -7710162560783220736i64,
  4755801206687793152i64,
  -4395513232119300096i64,
  576460753612046336i64,
  -6845471432831401984i64,
  2882303763228393472i64,
  2594073389006061568i64,
  8502796099461840896i64,
  -6773413838038499328i64,
  7854277751358881792i64,
  -3386706917450579968i64,
  8214565720944541696i64,
  -720575936218529792i64,
  -8791026470949486592i64,
  -7493989778199674880i64,
  -3170534137299730432i64,
  6629298654240833536i64,
  6701356248949850112i64,
  -5332261957112168448i64,
  7782220158545690624i64,
  5188146772609859584i64,
  -216172780771606528i64,
  -5116089172716683264i64,
  6773413843222659072i64,
  5044031583007277056i64,
  -6413125867915968512i64,
  -7133701807389278208i64,
  -8070450530033336320i64,
  -6124895489599995904i64,
  -8358680908399640576i64,
  -3242591728552640512i64,
  -648518346173579264i64,
  6341068279162863616i64,
  -5188146770646925312i64,
  4971973991620149248i64,
  -3458764513719877632i64,
  2161727821876035584i64,
  -3891110075648966656i64,
  1080863911625883648i64,
  -4539628424355905536i64,
  -4827858797605158912i64,
  72057594088259584i64,
  -8502796096156729344i64,
  4179340455994982400i64,
  1224979101077471232i64,
  5692549930086825984i64,
  -2594073383637352448i64,
  -7566047370056564736i64,
  -3530822103798382592i64,
  -1152921501150740480i64,
  -1873497441966227456i64,
  -7638104966090981376i64,
  8358680911285321728i64,
  -1801439850377773056i64,
  3819052486912638976i64,
  -2161727818906468352i64,
  3963167676263563264i64,
  2017612636954296320i64,
  -2377900601288687616i64,
  5116089178538377216i64,
  1873497449029435392i64,
  2089670228995735552i64,
  -4251398047549882368i64,
  7998392940508479488i64,
  7061644218787168256i64,
  -6196953087026921472i64,
  -4755801206100590592i64,
  -288230375698726912i64,
  4467570831794372608i64,
  -4179340452941529088i64,
  8718968882112495616i64,
  -7349874591331778560i64,
  -4611686014753177600i64,
  8646911288812765184i64,
  6485183466852843520i64,
  2233785419269406720i64,
  -6341068271629893632i64,
  -8646911283695714304i64,
  -4107282860044451840i64,
  -5692549928174223360i64,
  1152921504908836864i64,
  2810246168972361728i64,
  -1441151878611075072i64,
  6917529029234917376i64,
  9151314444175802368i64,
  1801439853783547904i64,
  5332261961843343360i64,
  3242591731924860928i64,
  8791026476469190656i64,
  -7854277747466567680i64,
  -7205759400420573184i64,
  -6917529023631327232i64,
  4251398051995844608i64,
  -5908722709818245120i64,
  -792633533712564224i64,
  -4035225263171174400i64,
  -4971973984674381824i64,
  -9007199253734359040i64,
  -7421932184514068480i64,
  1657324664499732480i64,
  288230376873132032i64,
  -5044031580541026304i64,
  -3026418947596484608i64,
  -2233785414538231808i64,
  1441151882520166400i64,
  6124895494884818944i64,
  864691129008783360i64,
  2097152000i64,
  -1080880403511770776i64,
  -1080880403494997761i64,
  -1080880403494997761i64,
  -1080880403494997761i64,
  -1080880403494997761i64,
  -1080880403494997761i64,
  -1080880403494997761i64,
  6600849092863i64,
  0i64,
  0i64
}; // weak
__int64 qword_7A120[512] =
{
  3103769712614436864i64,
  -4500952091004921i64,
  87857688982656752i64,
  -3967584263067439632i64,
  -1150907619105308360i64,
  -1080881501393727879i64,
  -7025914455174099437i64,
  9182575692992217127i64,
  5399817293698961685i64,
  932526529610765167i64,
  87856408269995119i64,
  5410275779620300790i64,
  -1553970638455423150i64,
  8964708563460051758i64,
  -4011553977342562263i64,
  1760683085330853889i64,
  3670435039758274349i64,
  2517513532513854890i64,
  -1150868033716080226i64,
  -1080881266259693775i64,
  -6182896900094453754i64,
  -7048150346603684999i64,
  114848323142161442i64,
  -792609765213599915i64,
  128407497048826735i64,
  -7060253333776222686i64,
  -648457193742399700i64,
  2388431944397816478i64,
  3863791611876030709i64,
  2609911036707583751i64,
  4320922496361039344i64,
  -7052347181009669904i64,
  -7037879201559476468i64,
  -7478337101961887230i64,
  -215829631674151886i64,
  4551151371346487111i64,
  499939381758404394i64,
  114903359778804304i64,
  4282764915970672430i64,
  4119993622901834530i64,
  3556189310563263879i64,
  -1129106911662177992i64,
  -1127244605536782315i64,
  7998692029836536095i64,
  3351811774818171203i64,
  -1136533309379762024i64,
  1660352786413467659i64,
  932316817003327063i64,
  -56352062456191944i64,
  263913291749431i64,
  -1152578417383991184i64,
  671740307050108936i64,
  4610561458807990358i64,
  67555334808425627i64,
  1661529200587725625i64,
  7422222778077490384i64,
  -6772305526609465698i64,
  860251541039275635i64,
  -6401214690093760200i64,
  -3739940492067422068i64,
  263913218113840i64,
  -3733181793135059344i64,
  -1129106910214511697i64,
  3480182153952704533i64,
  -5616178873009728249i64,
  74578840037060396i64,
  4007111952235456311i64,
  6012058350645624074i64,
  1168536971499289112i64,
  6573065336976312626i64,
  4918282861625599730i64,
  521080616182373377i64,
  4676159419766483198i64,
  -7122711090445598925i64,
  1171850762074711351i64,
  3389556858219143173i64,
  4567652807466825643i64,
  2900380158409573209i64,
  -4465526613817769930i64,
  18982381936858416i64,
  1097611926043787361i64,
  3979563815846197306i64,
  1120900463695771617i64,
  2240297846320466496i64,
  -1071230722142939825i64,
  -8121932853207350191i64,
  1443487660134906095i64,
  4103354361037834289i64,
  3436836216876036639i64,
  4608094155984426313i64,
  -5039801830121908911i64,
  1680707010416559409i64,
  -2836703356958845950i64,
  -7194756590004125732i64,
  3996688505969530679i64,
  2878737204557082399i64,
  1816922075019359202i64,
  4044895354680457272i64,
  4748302542457800457i64,
  7856353632536705339i64,
  1143479694095617838i64,
  2883728966774375433i64,
  4011351613636673572i64,
  1676855632069174017i64,
  1590969378316176175i64,
  1778923202508510912i64,
  4554338888175329338i64,
  1925360559063092225i64,
  -5109538216618019652i64,
  5048330935520333872i64,
  4565053824932577338i64,
  74574523154912630i64,
  94991307580754985i64,
  795465024893301000i64,
  1753169228754460520i64,
  6557522636718539186i64,
  365984084057615i64,
  -1152577420460474563i64,
  8369715358111170567i64,
  -6757844656095343305i64,
  1812734986221182168i64,
  86238369425550796i64,
  460281733155404863i64,
  6576884224466884895i64,
  -9136693037735147712i64,
  2814243761293376096i64,
  4831945924119309475i64,
  2813122645187694601i64,
  604622574250375083i64,
  5064359779364503907i64,
  2310128089649439836i64,
  506497282057635638i64,
  3381481818011928818i64,
  4402390819921801018i64,
  -6972908350836101814i64,
  6158171049863894125i64,
  6096509405974569529i64,
  7716639930217220393i64,
  1664353896713132116i64,
  4242751427798741528i64,
  87913999909402880i64,
  6544019661435373808i64,
  3994693746075832879i64,
  4007130397365385014i64,
  6012067123585575440i64,
  459028723755661832i64,
  -5072539328354707145i64,
  126157685119991872i64,
  4699861600398477577i64,
  4007384565018214157i64,
  736378293377357329i64,
  4135307238974834479i64,
  5352590155516215645i64,
  -9140242325520251042i64,
  5245621589435752498i64,
  2320485552884496396i64,
  5692567376231209071i64,
  5623035871764624648i64,
  644333851242538996i64,
  -3733122174251489535i64,
  -783845993142614426i64,
  -3730754999764859135i64,
  939051758389954546i64,
  147193825871873839i64,
  3534815887686506282i64,
  -7486327162218008628i64,
  -951322688263416048i64,
  3825815882027986727i64,
  38671069761468967i64,
  301348165194353680i64,
  4914563263400250112i64,
  1437154302191148809i64,
  736378297365838205i64,
  6848074406199413817i64,
  5420191067752122865i64,
  8079682244879540404i64,
  4308934616705075976i64,
  -7463749773269327882i64,
  -1112263741164555725i64,
  644333853324410955i64,
  1042974589692679425i64,
  4078056755157537864i64,
  -6334398531300100833i64,
  6005089437905344826i64,
  -1152919956605433091i64,
  5985889774524598289i64,
  5203807319478621955i64,
  4007129683454787680i64,
  4181683990890138681i64,
  1317610992534238504i64,
  4460352709255046959i64,
  3986555607379624255i64,
  -3730875795845366012i64,
  364888400787740659i64,
  5834356387638420520i64,
  -2001741046148406941i64,
  7583788025121553197i64,
  1135212152541611980i64,
  7502452672830179217i64,
  652784177603690351i64,
  4109874302580181313i64,
  -1355317431776749986i64,
  -1797137282430323685i64,
  -1776681009395492602i64,
  1786831688445726474i64,
  1729606597367902130i64,
  -1056849205499200511i64,
  3388628131818504504i64,
  4009091001295197101i64,
  4007130397315072265i64,
  4179432191210671161i64,
  14100375387190568i64,
  7009671538963724033i64,
  4829903030269731336i64,
  4125648069721728775i64,
  1826228579456250316i64,
  -735149923113885603i64,
  7209683896672674760i64,
  -3690399555079609577i64,
  74432715117707529i64,
  -692361149005416220i64,
  -1784260603859705569i64,
  667440981187574543i64,
  7233793219099117004i64,
  -3735445175876638474i64,
  -575606387127793359i64,
  2242886890020382785i64,
  1248984940865440793i64,
  5854465213987113420i64,
  5985916196707448917i64,
  4103372141864433911i64,
  -565983526970132953i64,
  3968022963800834360i64,
  -359943864868519066i64,
  2666580663254656056i64,
  4048780322446832384i64,
  -784408147770411223i64,
  4038929465487180809i64,
  7502442015765084949i64,
  4055818024650998022i64,
  2249599831394349848i64,
  4103062079719815417i64,
  6025372030025137431i64,
  26724507246784519i64,
  87978638706737464i64,
  1378928319568676592i64,
  1809391213829240961i64,
  -1095436897792544528i64,
  -3571621753612320987i64,
  -1150948301572396516i64,
  4049000029942738878i64,
  449656437470209i64,
  -1143874712477110265i64,
  4751305643028236533i64,
  -1142217079014765511i64,
  3958677275313807272i64,
  -1095437666877295297i64,
  260791995533336141i64,
  1185976247495553028i64,
  -7058002627970207743i64,
  -6991895350177954007i64,
  4772202407208685108i64,
  4108109767121964016i64,
  4040837178706882635i64,
  2094261421077295178i64,
  1197453856053893019i64,
  3831527679961133091i64,
  4121935634915021874i64,
  -1873154358260467508i64,
  -8991404554567145929i64,
  87909382549604606i64,
  6341393971607138290i64,
  1528197982967038560i64,
  5348035483919715824i64,
  87830023045193200i64,
  -4024546778297781264i64,
  3175265276462967622i64,
  -663092242621664214i64,
  -8602078060478911890i64,
  -7808114544153783722i64,
  -1008463015101966470i64,
  -1095437933168551266i64,
  2265398707103479658i64,
  1089062353509489577i64,
  2057343968028859210i64,
  1112440953333879304i64,
  7907936240443268313i64,
  1081959508141354024i64,
  6058519198106599743i64,
  1100087043051781903i64,
  3101074934446169233i64,
  -8601249415978597147i64,
  1085337888198184817i64,
  -2080912539286885625i64,
  572309251495480660i64,
  3678948438521090496i64,
  -1800747947178044759i64,
  376678631416078849i64,
  2314156000877961320i64,
  7523008553744271405i64,
  4268062538091770919i64,
  3537744681570943796i64,
  -6694507546123886297i64,
  -1438884641405189546i64,
  3317222324896374697i64,
  -6260190913478584008i64,
  6178164255013414940i64,
  87885274196490741i64,
  1658179456452332272i64,
  -4670498776591404976i64,
  5419830681324558448i64,
  1971546450568040304i64,
  -2799145295564173305i64,
  572287248523829788i64,
  4698167049214825578i64,
  1777241545659301647i64,
  4626448356573559617i64,
  1648052727088496612i64,
  4773877473548616463i64,
  720639910697787967i64,
  2104341114719402647i64,
  -8648581380822200604i64,
  1083454249272365731i64,
  -2441203575543678157i64,
  6665397856479133780i64,
  3899422829058721600i64,
  -5467599417336387816i64,
  5426908160604407580i64,
  2878713894945278008i64,
  5089938756590837025i64,
  7704638891618697283i64,
  218712212684501296i64,
  4563703605669476594i64,
  6178164255027910078i64,
  87885239853529589i64,
  2234640208755755760i64,
  -7469500976251055111i64,
  -761025598992941027i64,
  504684844232631888i64,
  8132752211391945920i64,
  4179388903272194563i64,
  -3703912037440184313i64,
  8048270149694931264i64,
  665142418893717618i64,
  -2081564416814149684i64,
  -3307951060971460992i64,
  2254665205596480795i64,
  4812565732385443121i64,
  -3883190192931206844i64,
  4315613925917068314i64,
  2128073054545462074i64,
  2311846985325947219i64,
  -3746630916806275083i64,
  4063378386463961376i64,
  7848753829494129059i64,
  1817253066925764912i64,
  -4738067114328975366i64,
  4541591373293351765i64,
  4051877328793982397i64,
  218827156477374465i64,
  413567065669261128i64,
  7703169084140100920i64,
  2247595358800350495i64,
  -6772285585947681600i64,
  -8573857218705199681i64,
  4628104014626226959i64,
  -7262261067605875468i64,
  -4121065019230675172i64,
  4057404790927997217i64,
  8502828060551838785i64,
  666603450092066304i64,
  234856796138832001i64,
  1793014722927562279i64,
  2978294487268309343i64,
  6126985763614869708i64,
  651276579213805335i64,
  -3746687313687535373i64,
  6723663410406400816i64,
  2608130666011364887i64,
  4032156769741299311i64,
  -6331793526493325944i64,
  3527858073439157567i64,
  7936381628891347003i64,
  2850220208620297i64,
  4175126152431536641i64,
  2302126905565049292i64,
  3489654891828944064i64,
  7930443785558641196i64,
  -5673784283991094798i64,
  -1937494247620447674i64,
  2843481165735935751i64,
  7646503328947298i64,
  4558503786701238646i64,
  2023355657649608504i64,
  922227661410467854i64,
  7506945705898989915i64,
  3330852412007189543i64,
  5426901602693595145i64,
  -1023380132153523909i64,
  4957129520926137128i64,
  1869289001558411588i64,
  4610575620805364033i64,
  -6331794626004953720i64,
  579303339347671113i64,
  4103407326276893146i64,
  2065516039915499521i64,
  8124264410566335249i64,
  -8279924911652201192i64,
  2071681890594334748i64,
  8009377244312864263i64,
  1165359190608992027i64,
  7495460966338978893i64,
  -8786741670573763473i64,
  4766312843086733093i64,
  4270012616069625165i64,
  2394967529585418808i64,
  6891915311574174114i64,
  664663303551789413i64,
  2023364419382888243i64,
  8721163681315823362i64,
  5412632338551752732i64,
  -2009533285758523608i64,
  5406738492271051067i64,
  -2661684377462715391i64,
  4903928392739729236i64,
  5206231829598634564i64,
  4688653035098613518i64,
  2054511186745166308i64,
  -6257939113531074248i64,
  6178164255015051292i64,
  7668850753208334837i64,
  218736016835407879i64,
  8065146054650931735i64,
  -1023380218193068241i64,
  -4600654545478946497i64,
  2234788489020966684i64,
  1669753960353176431i64,
  -6972915664180645712i64,
  -5686918289443302380i64,
  664282629721911877i64,
  7077190433483365897i64,
  8379406849417695004i64,
  531167606221600256i64,
  -6254300096091584824i64,
  634050641772310610i64,
  8010505280591753729i64,
  5724379859286891912i64,
  4181938664172100788i64,
  3540053613039598351i64,
  6215710036979665961i64,
  4270662482208688959i64,
  76362774565646696i64,
  -8631157373632913905i64,
  1013404191623352405i64,
  577316149197353289i64,
  -7247634162612946470i64,
  461738287322755076i64,
  1156000254173115137i64,
  148442895997701154i64,
  -3915871075067529697i64,
  541085005967786271i64,
  87835792542336536i64,
  4050765969432446824i64,
  -574362781008464505i64,
  586911013446817480i64,
  1830793582551540231i64,
  2492909523560773715i64,
  -788349831864964579i64,
  3491423237369827896i64,
  -425247073924525768i64,
  2306951321353723952i64,
  2465987003293771777i64,
  721671362929834228i64,
  7494288880277327624i64,
  -7965730252939784438i64,
  -8689711968445857588i64,
  -3427516462058163367i64,
  -502343766124841149i64,
  -742351763059435432i64,
  -5228793443699024065i64,
  4043303760824389913i64,
  -1152577361339156223i64,
  7562957799729176465i64,
  3335293051910358283i64,
  4902670633613303298i64,
  4107828223179637305i64,
  -3730676883275186485i64,
  -7379129327017916176i64,
  2390790315236262093i64,
  504762264842143515i64,
  8475309336593717744i64,
  103301089777807367i64,
  2399407089090574840i64,
  -7485562943289360144i64,
  1810517298419604481i64,
  4138605719659027440i64,
  -6771178754791565489i64,
  129876452387124455i64,
  4603787226241703152i64,
  2415699257960977025i64,
  644239296111895915i64,
  2891407722509133373i64,
  -1142792532557561544i64,
  509925618356402208i64,
  128399809419484400i64,
  -576420487018118632i64,
  -1150862448161862599i64,
  3706210637056261889i64,
  -1126671489648543921i64,
  2096427587177391386i64,
  -3730678136684216569i64,
  44475178050625274i64
}; // weak
__int64 qword_80000[512] =
{
  513781911392891701i64,
  7566390524706199611i64,
  -781030885469650140i64,
  4050999132046816559i64,
  -3861835546346243702i64,
  7713604022467884289i64,
  7561829692088978072i64,
  -1080519793075355083i64,
  -870821816162945992i64,
  889484085255936600i64,
  -697431847008659455i64,
  79080583782139193i64,
  4049633279770417720i64,
  -8119725096950827443i64,
  5636524108785129483i64,
  3537297269389826107i64,
  -7261502108342208491i64,
  -3298885417302017805i64,
  -769490759850647303i64,
  4152944508722486536i64,
  5404645619124212399i64,
  793484590942783954i64,
  1735788110531613367i64,
  -689268999800878847i64,
  4038181201514594616i64,
  -2073637929253988141i64,
  3619805588459827446i64,
  -7484718044060178429i64,
  428009347831630081i64,
  793478387937192248i64,
  870408830246195443i64,
  5204190398717172808i64,
  5328047575432706546i64,
  -1065883105036140336i64,
  644986955529454393i64,
  144262294797957164i64,
  101335429182255626i64,
  7568871260091721741i64,
  -837889428437073092i64,
  3459634574776598808i64,
  4179226362525857843i64,
  788297315272159749i64,
  5636399210397524891i64,
  2950419851008227829i64,
  1948673601805891585i64,
  1826156893669832767i64,
  749887856015575303i64,
  1657325936568759045i64,
  580809080340288904i64,
  939453280642361351i64,
  4104308928154759689i64,
  1054416809380802561i64,
  -7463790481670320096i64,
  -3575588699214643954i64,
  4319530207128588803i64,
  7221593581778237592i64,
  78818595867799797i64,
  -781030885469838279i64,
  650208443832402184i64,
  693423354722920650i64,
  8158537675329376270i64,
  -6631818077509240323i64,
  3464421437613812512i64,
  646242601891280897i64,
  592944677912215857i64,
  1823739011911477263i64,
  1798448324437948754i64,
  3497357269315880961i64,
  579723458406856755i64,
  -501019509846421469i64,
  500066938480833800i64,
  5636313413946199337i64,
  -56029346363537162i64,
  812613663088255217i64,
  1295639923836437519i64,
  -5099775709715130211i64,
  326066279617266i64,
  360922435747481796i64,
  -7833994633682497464i64,
  8014576787485776138i64,
  756719468591266036i64,
  686521905054790144i64,
  -2073898856737066786i64,
  506375562115901942i64,
  2916955094232077067i64,
  941641626421836758i64,
  1515853873159234664i64,
  4035551057260380730i64,
  2590827254332044i64,
  5768158259339349515i64,
  -184303494319570593i64,
  -893899439963461528i64,
  -502092637122005479i64,
  506385581573259106i64,
  2375624858818328580i64,
  4037345395314610177i64,
  -791162433724354303i64,
  1787374902919388984i64,
  5564253655319204270i64,
  5776457449883502837i64,
  6928842958539590422i64,
  4251698168208034521i64,
  -7261497847743188840i64,
  -3298885520178282216i64,
  5924495212366336251i64,
  -1004859230444781321i64,
  2922335836437086480i64,
  3385956930945025i64,
  2379286438978736313i64,
  88088951276904494i64,
  3607944087639054576i64,
  604915095340469339i64,
  5777890695498660361i64,
  -6265123873184150463i64,
  1943470622441920104i64,
  -764423373032521510i64,
  6202966350819124496i64,
  4104507937728621911i64,
  243299627852970124i64,
  6919075354550340620i64,
  -951886766534554560i64,
  5202230234949972280i64,
  5911307011306947496i64,
  577351310370147618i64,
  -654648162296502067i64,
  2598600117872958311i64,
  7579306488939639058i64,
  6861503435095212114i64,
  689693742675859701i64,
  4103913077812611343i64,
  7206334734857549i64,
  3601766791726041880i64,
  306184405327421736i64,
  4039228382220913415i64,
  -56290663410831051i64,
  -7414899906164221708i64,
  1222059037387604227i64,
  2529040614321723501i64,
  1366564990830626106i64,
  2205663245149573257i64,
  2342162331108421481i64,
  6985084362169602063i64,
  6744049225220930665i64,
  1135761963671555080i64,
  -461554053302706119i64,
  76523810358964000i64,
  6992688383157573383i64,
  547252246822785578i64,
  -764424328867016723i64,
  3461590298860267280i64,
  1035944488331456712i64,
  2970389538788153588i64,
  145256549399331060i64,
  6773494114048085512i64,
  434357191869343056i64,
  -256361084062525432i64,
  1218268910698604816i64,
  866984944740861953i64,
  225729965759400709i64,
  8374456822971316495i64,
  3611050628252887608i64,
  -2839737233780581744i64,
  -769489861650542839i64,
  -765830803803761912i64,
  7350148391101792536i64,
  5257193043797743128i64,
  1177699057264561097i64,
  2894114510204241932i64,
  -931337372215667623i64,
  4176330231896905787i64,
  4035534181633684379i64,
  5938055519244712914i64,
  85604782468298754i64,
  1798039309604525594i64,
  894254883274557441i64,
  797031661327091733i64,
  4052160490221930502i64,
  641227039057047553i64,
  -3706173264449038079i64,
  234840255687558669i64,
  649096246993355016i64,
  -7477374688756926945i64,
  7221714507340931320i64,
  6717128581171321333i64,
  4035525038332913240i64,
  2723331921478742412i64,
  362645336261441561i64,
  4104354014722828544i64,
  -932525498099499919i64,
  3404439847744900713i64,
  6986548911923013328i64,
  8374452375789176423i64,
  581364788776024307i64,
  -769489621625980368i64,
  76832082503206201i64,
  3690701033705101832i64,
  1156257804941342961i64,
  -806081806997561840i64,
  1123677838124329009i64,
  4251697144091052108i64,
  4036052765544411288i64,
  2376724366345958655i64,
  -575492731087729511i64,
  -4235071191299596516i64,
  3677190302431132147i64,
  651343442584621840i64,
  1731774072747415561i64,
  7518460515983309199i64,
  3996120808680393445i64,
  653795517394394901i64,
  1022151076538968076i64,
  3232501526708770805i64,
  3519509209748010i64,
  644969364080244485i64,
  5646704730955384848i64,
  4104340811667421702i64,
  85291318533288489i64,
  -3366098756086511570i64,
  -749784406384080127i64,
  510331050669142328i64,
  6337576479895692173i64,
  3834881071506468209i64,
  8374449374037760500i64,
  -7052649204632975117i64,
  2017998600467080980i64,
  4107574166445713921i64,
  -693773188290972846i64,
  1802648527123251464i64,
  5256630097048451221i64,
  653189098932996889i64,
  3599449469022827018i64,
  6872791003122121512i64,
  -1109230189837534455i64,
  -3298885554707417085i64,
  650781575324707066i64,
  -900939200433196999i64,
  646832929920894266i64,
  689564365430730515i64,
  612313688369072398i64,
  -24088169440330710i64,
  88093988336043006i64,
  247404424634237173i64,
  -864269559544543760i64,
  -766394496186883016i64,
  -5407651932054486728i64,
  -1151993070082731991i64,
  3618913666157127683i64,
  4608929787373238526i64,
  -1569233491106641905i64,
  4107617120022051061i64,
  -8706873343505928110i64,
  8244111028942353720i64,
  -432001461812397309i64,
  4035550764250524223i64,
  -474785666778401714i64,
  -705033201327572120i64,
  -761388540471873110i64,
  -359996148201553086i64,
  4104455181787201848i64,
  1764465645476376577i64,
  4542587277908377912i64,
  1292814499333015484i64,
  1581044879758235707i64,
  4039462062400911191i64,
  -1110072342723170303i64,
  1446519769823705599i64,
  85595984177267477i64,
  2025234460988348395i64,
  4252788904679120413i64,
  -9034485993455685480i64,
  -1152577452224477174i64,
  -1149813176503120084i64,
  2384684727721258495i64,
  4036394210816172834i64,
  3110343748387860481i64,
  8464131075681580i64,
  -1149813113669813510i64,
  -7235029185276594062i64,
  4044497447413026199i64,
  3321153013945921537i64,
  -1649741356875176959i64,
  3610764407727009832i64,
  -1148616642227275264i64,
  -1856343964349548333i64,
  8405740010917270047i64,
  3685887387801565212i64,
  -4228720829458380i64,
  1449847896746819568i64,
  87869604490849305i64,
  -6408030538493925902i64,
  -4222193349674499i64,
  2969870083882934512i64,
  3252769800265464324i64,
  -4222189175825126i64,
  4551507659985319664i64,
  -1947242547916044506i64,
  -1150888236485631194i64,
  1590304962141745407i64,
  -1994267796946279112i64,
  -1147835992290284760i64,
  -3748418757798577950i64,
  83416580821160084i64,
  -1082552682143471387i64,
  -1152052330201943809i64,
  6336566883808419688i64,
  3094743971976508223i64,
  305186206489262876i64,
  231988042593730872i64,
  4584647927736696848i64,
  2229283156416033127i64,
  8000740326834878575i64,
  3623024671427921006i64,
  4540077293371929621i64,
  4628059017427349508i64,
  -5179249587064342016i64,
  3471553487355525964i64,
  -2076160522493235196i64,
  -1150897032482713744i64,
  2882588607600470060i64,
  4557430501106857988i64,
  3548621501379381310i64,
  779860512539734023i64,
  -6336671392763731664i64,
  4280653877182099261i64,
  3670479889737314456i64,
  87944382370262583i64,
  1589935370208290800i64,
  595007318735974455i64,
  4414445606925254920i64,
  3325314936158107652i64,
  7464136939486707740i64,
  4279246483980892810i64,
  589672489262968984i64,
  4252787836179553181i64,
  -3341855710161341800i64,
  4577892528283136010i64,
  8000643113099424067i64,
  -853089009012626409i64,
  6068680885240411960i64,
  -7477368424211990282i64,
  -6560451373865748239i64,
  2249552345316215431i64,
  2376867307077516273i64,
  -7131376127996511999i64,
  4902336359613858200i64,
  -7477307872355735490i64,
  87893005098957052i64,
  4051591203566925552i64,
  8102326920273719297i64,
  8184236733356261368i64,
  5001255097125658609i64,
  -3731388632121964769i64,
  -8136028771073704127i64,
  -3594152944894394512i64,
  2596117394921498690i64,
  4609277148431657776i64,
  645996644004360881i64,
  -544639513779816578i64,
  -2071864301617799657i64,
  5257265614432039280i64,
  4543275916793480239i64,
  -3019871520655969627i64,
  6470343656779530353i64,
  595331729565698120i64,
  5280832598334915351i64,
  5191593654069774852i64,
  306887199948277835i64,
  3082788824872648708i64,
  4540759727168752703i64,
  2236105665108527939i64,
  5352890179453714792i64,
  -917809320972515056i64,
  5190480111576354888i64,
  2819382899003883832i64,
  808255331199105335i64,
  1085745746633038665i64,
  6913994734470378255i64,
  382318970827378970i64,
  2760707705604998503i64,
  1725783797091675906i64,
  -8773074664657779052i64,
  2236917237078357105i64,
  965820129892317918i64,
  1177692440589719912i64,
  -8917327132129161210i64,
  2610104756726658117i64,
  7494538848618169332i64,
  4037272365379487467i64,
  6363942684977067407i64,
  6341377194521529790i64,
  806500613870652435i64,
  1731377971429837336i64,
  957090290030217985i64,
  -8578785233816401846i64,
  1409694966099493347i64,
  889473056341969726i64,
  6342315435419979594i64,
  6724085365331921991i64,
  530755438026199044i64,
  2741232705012253448i64,
  4568904553314906188i64,
  644420909959377009i64,
  741544896041858825i64,
  99080412658403963i64,
  -40027448947437824i64,
  -7853168947867209456i64,
  -1996774495283966687i64,
  -7490869365692756984i64,
  8264456064879384888i64,
  576769652587118581i64,
  -854495419634073805i64,
  1003010187654043651i64,
  -968492778338620430i64,
  8261078562727499835i64,
  5423303540487487734i64,
  -2015602661265832115i64,
  640990038615868227i64,
  223224084555710988i64,
  5324463157310621566i64,
  4848657244100968766i64,
  597018207797854787i64,
  794639110651972675i64,
  578791997251839375i64,
  -1947357984623335366i64,
  4413305602399995977i64,
  228284132996411410i64,
  -328638255388885008i64,
  2166356811581136394i64,
  5335361510997689926i64,
  3834536997805675287i64,
  8199717550416396294i64,
  1141753941368245243i64,
  728739064896232704i64,
  556212069056318186i64,
  6362858495829613068i64,
  3387024628600278630i64,
  1175645177355177568i64,
  7562394115200061478i64,
  5440352301568492324i64,
  -7477124198649035798i64,
  -2722154841044250824i64,
  4172316891093737716i64,
  -9143646138274724815i64,
  5337621433864864023i64,
  759524258989226499i64,
  4109702039387258632i64,
  4344713729074335568i64,
  4319519425034718022i64,
  4902242991937681816i64,
  74339013204849007i64,
  -4228721433038876i64,
  -5968957149589899280i64,
  1876526732884798575i64,
  5833292949425933221i64,
  -777089778662636003i64,
  8511801591253168947i64,
  1948115093059033863i64,
  2882621481779030271i64,
  8221337114476621997i64,
  4067457552353354088i64,
  580418342318830884i64,
  4319672467453393855i64,
  308915811776152i64,
  2925144370722351372i64,
  4784536978287121153i64,
  515960885529319483i64,
  4290526545032497235i64,
  4568970061616050328i64,
  83285918181570622i64,
  4571981553784717331i64,
  1710253697494577265i64,
  906993793823305837i64,
  -3860990592207598334i64,
  -112085040404696305i64,
  6010387958958783082i64,
  1087627054933804547i64,
  6442559834206910475i64,
  4352896350323537667i64,
  4043396991907792901i64,
  6565747932278616367i64,
  -968492754504315487i64,
  81334011388401723i64,
  4776224521999816256i64,
  4341257031445092411i64,
  7066994371642456332i64,
  2339355089485497486i64,
  4832451433099625582i64,
  1738935101763013023i64,
  -1080881347954774271i64,
  6389810697130295153i64,
  4614644937380069656i64,
  1000443487465770501i64,
  4539918811558198335i64,
  1155743677956125131i64,
  4319236860863580673i64,
  6349829192735781144i64,
  3098803039951651082i64,
  2319929995261931416i64,
  -782438857498484726i64,
  4106324339678264104i64,
  -715727151676263025i64,
  1173543949326090504i64,
  -7477369239759317232i64,
  4931045987922614680i64,
  7729188833825653232i64,
  4906750828530974606i64,
  2733689423426750984i64,
  -1080881398984575073i64,
  8102326478159479151i64,
  937144787375368948i64,
  -5383367052855275440i64,
  76828383607691783i64
}; // weak
__int64 qword_82000[512] =
{
  -644128876860473855i64,
  78135793187770374i64,
  -2152165814194337606i64,
  3389059909412847896i64,
  7221879593008905784i64,
  7640406284454870003i64,
  812605120455387904i64,
  6919832435802285882i64,
  -3303570402087614456i64,
  511554450882431006i64,
  655448638881538560i64,
  -2875488949910882456i64,
  7562555582550251880i64,
  7863286154077408790i64,
  894280143907877936i64,
  87930251203745899i64,
  4086506492876697844i64,
  1669721915705783116i64,
  8727761702392151516i64,
  8721954096818309130i64,
  1026581056004695816i64,
  1182201534756573198i64,
  7945204410826813762i64,
  1309712927952758844i64,
  4724390407416580326i64,
  1957123093471625480i64,
  5267644317369973144i64,
  538214493735114482i64,
  2375332384624653608i64,
  646331662402599681i64,
  5394864010681195533i64,
  -1938729716117325578i64,
  -6318509592717576436i64,
  -7628807568929908133i64,
  83595878797603081i64,
  -5039235498581125077i64,
  -778213395708975079i64,
  528890527555722345i64,
  4180730504125300563i64,
  2447186573077526853i64,
  4037227820608805517i64,
  3454262258327566907i64,
  5765900926833929815i64,
  3607157158628033805i64,
  -3236080389368223514i64,
  645482835698098909i64,
  -7477115466668107722i64,
  1441166867575348467i64,
  1203881069055530295i64,
  319467055811203435i64,
  4086507548756819960i64,
  1314388366404176460i64,
  110555005637692243i64,
  439487180924206091i64,
  -7463668435827880127i64,
  772669558481744201i64,
  1177418667570240432i64,
  6645062452898897735i64,
  7732681695211376884i64,
  67907557863266377i64,
  -933766386947831807i64,
  4125694044212284682i64,
  -5951441830030716687i64,
  5231048658296315915i64,
  2600275697091479280i64,
  1221845732151806036i64,
  6421019917584500745i64,
  7532592536236053528i64,
  5982792837150432861i64,
  -143477012909456347i64,
  4821994038351626536i64,
  5764898829245156400i64,
  1793059326936155716i64,
  -1135407963556070911i64,
  -7477115144536967162i64,
  960199407340159229i64,
  -1152577406201349320i64,
  7209102297200873775i64,
  -7481747780047992147i64,
  1950059979251648342i64,
  -1073765230750189768i64,
  -3810009994750129640i64,
  1247530258020652351i64,
  7997273190491561985i64,
  -5318476421163649789i64,
  -5899084798945440712i64,
  5909030841062263312i64,
  -857003362074542693i64,
  4103559223357542474i64,
  1375850957675120650i64,
  4870760838974561336i64,
  603272613464205046i64,
  1175665008827695384i64,
  -1053770394117005557i64,
  6731741284717338112i64,
  4251724559708386108i64,
  -1041394775032792936i64,
  1390241141751330835i64,
  7136526396255674033i64,
  -7463870616785896296i64,
  4035551800747294467i64,
  1756134530194862402i64,
  535638738419129123i64,
  89624426941409528i64,
  -980595110448592912i64,
  828398002572240696i64,
  4262673597023997975i64,
  5273979051692107578i64,
  4292220746540714283i64,
  -7425705454292896952i64,
  3979163508746815745i64,
  507305977292208374i64,
  -2353922955748272069i64,
  4255058770365324840i64,
  79081571609014424i64,
  6996332706613737008i64,
  -2158841264037414046i64,
  4319582730314121576i64,
  954764222913508760i64,
  5404768157625236299i64,
  4320742288416895561i64,
  6396818063287054488i64,
  -1017860520761357894i64,
  -1133659224749991925i64,
  -1149422596878406136i64,
  78827713561617413i64,
  2952184571672696891i64,
  726652945713725441i64,
  576462198533589519i64,
  1580930848431818762i64,
  4108391182628880494i64,
  619284488890413668i64,
  4267357468218182423i64,
  4101972274857924872i64,
  1366002301246631937i64,
  1116699215559305717i64,
  4036829900268731952i64,
  4102560411402433025i64,
  -1585263838807692519i64,
  578745713339356479i64,
  -7477273655794204312i64,
  -5318749953218758405i64,
  -7836489450121638880i64,
  288626733097882889i64,
  8719800763214932723i64,
  -29208207305325681i64,
  6645326237726013546i64,
  3967666427983116533i64,
  3462065627371424273i64,
  591236336910153677i64,
  4105977993457717249i64,
  5363391551075055072i64,
  3462173451968448240i64,
  211751018974167006i64,
  4287753804678914816i64,
  1873823979609453720i64,
  5765480234770051113i64,
  -1148813268744993212i64,
  427910375562846721i64,
  2826118928952598280i64,
  6341640330712277238i64,
  101340922573229875i64,
  650596895768244224i64,
  -2303405379046881623i64,
  -5862804906507642832i64,
  1803954678689904702i64,
  866487724418990958i64,
  7163523869882983432i64,
  650771346195812361i64,
  79082671136348219i64,
  288513604751767097i64,
  4251698194465186211i64,
  4266043834479344792i64,
  88085496410602648i64,
  -7477333033677473551i64,
  -5034941102634696453i64,
  2503227399654712i64,
  6718034854936267040i64,
  3199808776339208443i64,
  4330218670679157516i64,
  5428797202261091340i64,
  47317757130200328i64,
  -1698135128284842215i64,
  4248187729854671027i64,
  645589500787489604i64,
  -3213028929297966286i64,
  4546385954261723914i64,
  4180730504125182800i64,
  3167762511053321797i64,
  -1080008780025560424i64,
  -1152577406201349320i64,
  -3023594101127184335i64,
  9081519958735312736i64,
  6269339881956247118i64,
  -777090833348889553i64,
  6707891777640838200i64,
  25913298374900499i64,
  223476237509986916i64,
  2328369972572540703i64,
  -773150183670925302i64,
  7872938767616573720i64,
  738408176300197690i64,
  5864733494000107667i64,
  -605668517645248447i64,
  4034548220867646992i64,
  6645074152546515393i64,
  -7412358712652186636i64,
  -3670229148738582447i64,
  4404684816648230207i64,
  4267232152183127622i64,
  81336236171408370i64,
  4267427686881639171i64,
  7510887556130932987i64,
  878017536085933790i64,
  -2859769239817482496i64,
  2963256418066733163i64,
  4916510877898844446i64,
  5431911818140365558i64,
  58838578238662668i64,
  1799495059879232067i64,
  -416275112606891450i64,
  4180730504125104729i64,
  3744223265760229701i64,
  4196009725364406424i64,
  6413179676746380711i64,
  -2440037097377697745i64,
  16288419047539186i64,
  578151822810981632i64,
  4320983081379059765i64,
  7719294105566114100i64,
  6142718611119147416i64,
  4543964964622758623i64,
  -2423993092610597096i64,
  -701092589755866056i64,
  8561145016955175184i64,
  9010106407447777574i64,
  439962345567888151i64,
  4301239968133029528i64,
  1138409080982074520i64,
  -4025354956277340525i64,
  6645189012765818206i64,
  -5179412224848413708i64,
  1205284672329130314i64,
  5251150122838278349i64,
  -1059967366692593584i64,
  -2289808430708147400i64,
  -2371919487445163791i64,
  -2366009380966811407i64,
  -3924814202780370703i64,
  -7939978047672597949i64,
  4582531304708573418i64,
  4287753843117785897i64,
  2313753953570583704i64,
  4592020102115584001i64,
  -2237832300665380607i64,
  -2228842021228179704i64,
  355852780937283592i64,
  -709535798277880518i64,
  720891603564455272i64,
  -1152577401906382024i64,
  635307568783036464i64,
  -2145390124977022719i64,
  590859961026417395i64,
  -8002557630772463615i64,
  362267210440179990i64,
  619265977877666033i64,
  8370185464421877977i64,
  2810541218677594175i64,
  4035525370055286364i64,
  4607664249724008005i64,
  -7329540165423800694i64,
  1750505046065103288i64,
  2621363917803301406i64,
  3458087471730986820i64,
  6645062422462342911i64,
  -282887195324499725i64,
  3557027924020429056i64,
  293385746172086109i64,
  6718231866415576124i64,
  1610038107877423348i64,
  647457561881421633i64,
  -2434159245736271850i64,
  23381050423667185i64,
  -7484120528541503609i64,
  -7477240740003183815i64,
  8878803827160267509i64,
  -729300290408793335i64,
  4109028141816632072i64,
  3542106438661894626i64,
  4988304967148827403i64,
  3744223265743452657i64,
  -1064194579303036776i64,
  590516914203436858i64,
  -802204512519759762i64,
  -718042214365649653i64,
  4539936315127243352i64,
  555702024327192118i64,
  4611290447729253512i64,
  -2371075435808694443i64,
  -980596198801129482i64,
  -5316223521838399216i64,
  -2411062526179505422i64,
  1314287890758690637i64,
  -5680458310820652955i64,
  -8485339753620400069i64,
  6919778182749636753i64,
  6645314187833250317i64,
  -2376186434817606670i64,
  6393449069465438692i64,
  -2317921095634581299i64,
  5192663909572691008i64,
  81337335693466939i64,
  1223918314533623103i64,
  6842056594749538070i64,
  4939191272049759755i64,
  230132333304238142i64,
  -749783912025590455i64,
  1732208531684541498i64,
  -801357884446721279i64,
  654547582776801933i64,
  289135871181470476i64,
  4988302768125559338i64,
  4320684018030098930i64,
  -6396527614227036520i64,
  -2450170128424158987i64,
  -297691398948032778i64,
  4093566066056115775i64,
  1094647248031052289i64,
  237166238455732799i64,
  2396764856036886000i64,
  -3007942810844512478i64,
  4957912266734766703i64,
  4558810057804891199i64,
  7571659548816470013i64,
  5956326557499533279i64,
  -2386275532045121176i64,
  -359943879436976132i64,
  4654749351459925539i64,
  221232078450736964i64,
  4916250671519386479i64,
  -2233434636872959246i64,
  4048501873767067124i64,
  -3010080274479778512i64,
  -504060102309496588i64,
  -1152578392808098241i64,
  1629901674713095927i64,
  5327762884431114240i64,
  8009352875350640183i64,
  1953896333398665298i64,
  8678291281982521656i64,
  4609998510726582869i64,
  293017203185318278i64,
  332756132864674288i64,
  -7840362339814608840i64,
  -6363603211825975246i64,
  -7477316854319931416i64,
  -1151745445807980560i64,
  -2366009071729545550i64,
  6624839851297419760i64,
  -8651133477736215602i64,
  -7477217898225401448i64,
  -7642604100855003920i64,
  -580682944323367313i64,
  4294164670483595720i64,
  4106300069633978520i64,
  298256689289752577i64,
  8448668172386277104i64,
  -1080881497520082861i64,
  87955365932318677i64,
  30967678830838256i64,
  -1080881373107022096i64,
  6264788488604917492i64,
  8067056339584615582i64,
  -1110071780097148241i64,
  87920179994771380i64,
  4541606475937935344i64,
  -7908473846477870878i64,
  -7010432708306800418i64,
  3388694772380078390i64,
  -3377948278379823288i64,
  895702020810414194i64,
  297411787601557748i64,
  4541300605653588720i64,
  -4016102554643041671i64,
  114892300424987755i64,
  104511222093709361i64,
  4103606344315044152i64,
  2373464543046725633i64,
  8012763585379820457i64,
  -1632713744619593371i64,
  355922669576319026i64,
  -1152578285176958817i64,
  -1152578404598059188i64,
  -1698671866352787934i64,
  4037419490483105803i64,
  516489643907280897i64,
  2340165406589468287i64,
  2874819317328133889i64,
  -3818787526837721818i64,
  -1110071357862887835i64,
  2965590753443999237i64,
  -7626816346659608283i64,
  283728117681754455i64,
  -3873106669404110536i64,
  -1080880848928444406i64,
  87836719334863645i64,
  7345392515235672304i64,
  -8671083930748507932i64,
  283790630651866063i64,
  -3517891197279780957i64,
  2298227805137580883i64,
  1652869575960500800i64,
  868138329752704552i64,
  2566492067483620336i64,
  -1080880848928378880i64,
  3364030046242158621i64,
  4046653709074296863i64,
  -7477104302953369835i64,
  -6983060102727975440i64,
  7870911093723436695i64,
  788177454327400944i64,
  571958496827624511i64,
  2948299356906756155i64,
  -6325292409704073196i64,
  -1079960760731682575i64,
  3527849171223707758i64,
  88095085377497124i64,
  8282751937954209343i64,
  4256102445959035127i64,
  572025504531738628i64,
  -544298667030339528i64,
  -4744272469788117089i64,
  4248382328680672591i64,
  7998278843612853207i64,
  -768364068880189951i64,
  -5407130886348833208i64,
  4607807182494376181i64,
  -720230721960315939i64,
  -274371080381523156i64,
  427845736221138543i64,
  -1138785145478977743i64,
  4105313829854973965i64,
  2970392369188499488i64,
  -1136550803149932301i64,
  -1152578427174897423i64,
  4609276508481530665i64,
  -3368705589903200167i64,
  8076106364716905330i64,
  -4609709044569996730i64,
  2811957283552898881i64,
  -1053217308220112422i64,
  5134674290262850367i64,
  14082725452267925i64,
  -993262535943766236i64,
  5696790131051026448i64,
  -4157093446636254599i64,
  5280826684618063729i64,
  595576996517646140i64,
  67961596461187608i64,
  1952039693373745184i64,
  8233775568404973635i64,
  -6960532080835018764i64,
  8351995826216268708i64,
  76829930279246066i64,
  5436525996681314895i64,
  -9133414344353304760i64,
  5983055504029644145i64,
  4595114674505590424i64,
  -8061697769372880011i64,
  1746290222591518836i64,
  4607532207005372417i64,
  6550581960722576349i64,
  -4452026961666885566i64,
  -1048238926893860749i64,
  1679662439905913088i64,
  -2145727517308638791i64,
  -1138785529548561924i64,
  659769314971887376i64,
  -665060556984402169i64,
  8296544246959771152i64,
  4104732246449338867i64,
  2534664578328359030i64,
  -8052716473690878056i64,
  2119019431245316208i64,
  1056199980126041863i64,
  2310069133568515384i64,
  5503403178663673936i64,
  884969577501497359i64,
  2822667290231859214i64,
  5300471839449945558i64,
  4074086461187595273i64,
  4564408063036552193i64,
  4786013651720040697i64,
  288600082763238334i64,
  -2009437691911914750i64,
  -3954374704453216993i64,
  -1209496839801198774i64,
  8019566333535475764i64,
  5115613345890457023i64,
  -7564807775786748088i64,
  6919364456517420744i64,
  3687648816470098341i64,
  -7497858388379948813i64,
  6437041515990107890i64,
  1123871316570080835i64,
  4050164602156099840i64,
  -992082297978031425i64,
  1281045336751097616i64,
  2380514435045308936i64,
  2979577799829085503i64,
  -4449775196229715907i64,
  -976181332872710029i64
}; // weak
char byte_8EBD7[] = { '\x04' }; // weak
__int64 qword_8EBE0[2] = { -3021472305951808845i64, -5986335702806125417i64 }; // weak
__int64 qword_8EC20[4] = { 335007449156i64, 339302416453i64, 356482285645i64, 0i64 }; // weak
__int64 qword_8ECC0[48] =
{
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64
}; // weak
__int64 qword_8EFC0[16] =
{
  -1i64,
  -1i64,
  -1i64,
  -1i64,
  -1i64,
  4611686015189385215i64,
  4267786510494217524i64,
  -280375465132740i64,
  433757350076154111i64,
  1012478732780767239i64,
  1591200115485380623i64,
  -15132649i64,
  2314601843866147583i64,
  2893323226570760737i64,
  3472044609275374121i64,
  -13422031i64
}; // weak
__int128 xmmword_8F040 = 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAi64; // weak
__int64 qword_8F050[2] = { 2052358350097965987i64, -2710214973855916321i64 }; // weak
__int64 qword_8F060[8] =
{
  133143986176i64,
  386547056699i64,
  648540061816i64,
  910533066933i64,
  1172526072051i64,
  1434519077168i64,
  365i64,
  0i64
}; // weak
__int64 qword_8F0A0[8] =
{
  133143986176i64,
  390842023996i64,
  652835029113i64,
  914828034230i64,
  1176821039348i64,
  1438814044465i64,
  366i64,
  0i64
}; // weak
__int64 qword_8F100[128] =
{
  8576877436153626624i64,
  -7419309047816494804i64,
  8100555774921393177i64,
  -7033332186818042571i64,
  8781096388229040178i64,
  -7506698446962300642i64,
  9129215071010311211i64,
  -8016656299201123065i64,
  7687680788174147684i64,
  -8881588989300477624i64,
  7916735418406196349i64,
  -8947660940802476719i64,
  7236062769213904982i64,
  -8474145104127133318i64,
  7135510339214466127i64,
  -8284356164434576029i64,
  5505950016347185352i64,
  -6744297178943962652i64,
  5405678855166092497i64,
  -6554226832994105859i64,
  4806071342882728186i64,
  -5999646546604602922i64,
  5034844566857477347i64,
  -6065999766924948017i64,
  5899152811661799596i64,
  -4625090066822770304i64,
  6247552763261416629i64,
  -5134766512804293223i64,
  6847028377099090078i64,
  -5689197360101664334i64,
  6370425309609557127i64,
  -5303501767921558101i64,
  133824886515450256i64,
  -1165007153466826564i64,
  483773156644980105i64,
  -1677357543006935899i64,
  1081137914316310946i64,
  -2229677534137964402i64,
  607208790385364411i64,
  -1845530260487770985i64,
  2048119005883617780i64,
  -981221431567896360i64,
  1946018463512696301i64,
  -788195529643723583i64,
  1348803144933497286i64,
  -236007436958385942i64,
  1574620812933930463i64,
  -300531276088902413i64,
  4230377371493097816i64,
  -3117844567056187276i64,
  4456476583189783873i64,
  -3182086725051497363i64,
  3778196814896425322i64,
  -2710963769275086778i64,
  3675814591390297459i64,
  -2518219411047166881i64,
  2810881317175390524i64,
  -3959754209279406064i64,
  2337233736940696869i64,
  -3575325254494006263i64,
  3015663081765140750i64,
  -4046580246155061214i64,
  3365329670759464215i64,
  -4559212179391423429i64,
  -7295915273063202016i64,
  8408733538206540300i64,
  -7074460467202799815i64,
  8348572561216054805i64,
  -7754007216488510702i64,
  8820962497984817726i64,
  -7851463421742625013i64,
  9009344062792183335i64,
  -8716536952409582780i64,
  7567950620523623016i64,
  -9194828938480560291i64,
  7956460756313847409i64,
  -8515414225079493770i64,
  7484220396076169818i64,
  -8160821617833156753i64,
  6967225669419253315i64,
  -6786480990491073560i64,
  5755585283757753028i64,
  -6432170064379942927i64,
  5238309013404583645i64,
  -5833820350448849958i64,
  4685004066013793014i64,
  -6311830792823574589i64,
  5073795882939223791i64,
  -4871061795850046580i64,
  5938244830872195744i64,
  -4968799682239367275i64,
  6126344851983308473i64,
  -5567281294616151106i64,
  6679799238466230930i64,
  -5345544945059496025i64,
  6619919942610951819i64,
  -1413019610434452816i64,
  174957633666196380i64,
  -1509209178293860695i64,
  360383711218722693i64,
  -2109802196592801150i64,
  915949503623801774i64,
  -1885391903477559653i64,
  854521889238609847i64,
  -1020942440148512044i64,
  2295291470327690232i64,
  -668460895227210035i64,
  1780970755948836833i64,
  -67718437836137754i64,
  1225273065098066890i64,
  -548684436185178369i64,
  1615894263213326291i64,
  -2950470258528689544i64,
  4108324932205970260i64,
  -3431717663135029663i64,
  4498664861502883661i64,
  -2749910618590844342i64,
  4024032170122087270i64,
  -2397147804851196333i64,
  3509992862000533375i64,
  -3838541831235309028i64,
  2644918815937499952i64,
  -3614412944377367035i64,
  2583209932733962025i64,
  -4296070412390467026i64,
  3057710588230114050i64,
  -4391978711431528905i64,
  3243418072039939867i64
}; // weak
__int64 qword_8F500[128] =
{
  -978544445114810368i64,
  1391880517933822199i64,
  3886910067237885727i64,
  -3113565231245039640i64,
  8697255501955160271i64,
  -7383181842395813832i64,
  -4672400142978789424i64,
  6778827992332812071i64,
  -2146734416450369681i64,
  220171276162283416i64,
  2715621594822365296i64,
  -4281617557468798841i64,
  7560449363446046624i64,
  -8514217460411601065i64,
  -5803297428688009025i64,
  5642442210862856264i64,
  -3254398437340377378i64,
  3741784488003698217i64,
  1534771734918928833i64,
  -830938092769875658i64,
  6345383938644825617i64,
  -5101410811161631002i64,
  -6947433487213379314i64,
  9128430283899875833i64,
  -4429067366845691471i64,
  2572604621194803526i64,
  365457521533116078i64,
  -2006022294073069991i64,
  5211107312537309566i64,
  -6238925249908219511i64,
  -8085362785440987551i64,
  7994018624020674198i64,
  -5543756597018550852i64,
  5921088130802281803i64,
  8397535040248056483i64,
  -7660208074868983212i64,
  4164077518235780467i64,
  -2813986125501614716i64,
  -120663227620601236i64,
  2263095753448858267i64,
  -6679302446094361901i64,
  4788779029213653540i64,
  7265659489838124492i64,
  -8795602397498688197i64,
  2996865313384727068i64,
  -3986686327897197845i64,
  -1293212590764845821i64,
  1096317512093361652i64,
  -7805564568724925598i64,
  8256893166355866517i64,
  6068468000931710077i64,
  -5400669684143524726i64,
  1834170864352873389i64,
  -554162274069857446i64,
  -2382721200783270734i64,
  4599775313063193669i64,
  -8938564378364980211i64,
  7118123901374375162i64,
  4929541711945974546i64,
  -6534106343497157659i64,
  660498358670003394i64,
  -1724316574468637643i64,
  -3553312763212489763i64,
  3425946470570847018i64,
  8114844944209165176i64,
  -7951447586780656753i64,
  -5258181932223779737i64,
  6213946673586494608i64,
  -412958201975184457i64,
  1981460982413923136i64,
  4458132260951291048i64,
  -2529607523199187873i64,
  6972556374436281367i64,
  -9081491179021562656i64,
  -6387819461076686072i64,
  5071784341492276223i64,
  -1577904897478515496i64,
  802018059321267247i64,
  3278814888342533063i64,
  -3694147742997658832i64,
  5773674807309350310i64,
  -5684872785492392623i64,
  -7513515206370057543i64,
  8539336499343807054i64,
  -2667979902014001815i64,
  4306037856761650590i64,
  2117810534711065206i64,
  -263309386524194175i64,
  4647417718366368457i64,
  -6825907559821606338i64,
  -8654679516912818730i64,
  7412667849454687521i64,
  -3843917917044594170i64,
  3142626277059943153i64,
  953986981746359577i64,
  -1439376250573566482i64,
  3595743629899802308i64,
  -3396324141249964493i64,
  -685617139904171557i64,
  1677382159694610732i64,
  -4953962853052416501i64,
  6486465492502384380i64,
  8981701681273039124i64,
  -7089199212181218845i64,
  2429800476214288811i64,
  -4574792596392996516i64,
  -1863657129109784908i64,
  511586546725553731i64,
  -6097528204933023388i64,
  5357676692136642963i64,
  7853061108818521723i64,
  -8232336510441267572i64,
  1250640711711238170i64,
  -1125798829047949075i64,
  -2971887544516854011i64,
  4033761755037519858i64,
  -7241097886121201451i64,
  8843102785882980386i64,
  6636305605796784074i64,
  -4817844181017290947i64,
  73724964555878261i64,
  -2288219482485350526i64,
  -4134450241112573846i64,
  2856420840479623325i64,
  -8368615298857224262i64,
  7703341529486346061i64,
  5496119594314473637i64,
  -5945504324106399662i64
}; // weak
__int64 qword_8F900[64] =
{
  18084222862426112i64,
  4557924847644065537i64,
  4485868353134542337i64,
  90140717371949312i64,
  4341755364115495937i64,
  234253706390995712i64,
  162197211881472512i64,
  4413811858625019137i64,
  4053529386077403137i64,
  522479684429088512i64,
  450423189919565312i64,
  4125585880586926337i64,
  306310200900518912i64,
  4269698869605972737i64,
  4197642375096449537i64,
  378366695410042112i64,
  3477077430001217537i64,
  1098931640505274112i64,
  1026875145995750912i64,
  3549133924510740737i64,
  882762156976704512i64,
  3693246913529787137i64,
  3621190419020263937i64,
  954818651486227712i64,
  594536178938611712i64,
  3981472891567879937i64,
  3909416397058356737i64,
  666592673448134912i64,
  3765303408039310337i64,
  810705662467181312i64,
  738649167957658112i64,
  3837359902548833537i64,
  2324173517848846337i64,
  2251835552657645312i64,
  2179779058148122112i64,
  2396230012358369537i64,
  2035666069129075712i64,
  2540343001377415937i64,
  2468286506867892737i64,
  2107722563638598912i64,
  1747440091090982912i64,
  2828568979415508737i64,
  2756512484905985537i64,
  1819496585600506112i64,
  2612399495886939137i64,
  1963609574619552512i64,
  1891553080110029312i64,
  2684455990396462337i64,
  1170988135014797312i64,
  3405020935491694337i64,
  3332964440982171137i64,
  1243044629524320512i64,
  3188851451963124737i64,
  1387157618543366912i64,
  1315101124033843712i64,
  3260907946472647937i64,
  2900625473925031937i64,
  1675383596581459712i64,
  1603327102071936512i64,
  2972681968434555137i64,
  1459214113052890112i64,
  3116794957453601537i64,
  3044738462944078337i64,
  1531270607562413312i64
}; // weak
__int64 qword_8FB10[3] = { 21474836480i64, 12884901890i64, 4i64 }; // weak
__int64 qword_8FB28[5] = { 20i64, 28i64, 32i64, 48i64, 64i64 }; // weak
char byte_8FB57 = ''; // weak
__int64 qword_8FB70[4] =
{
  -4942790177982912921i64,
  -6534734903820487822i64,
  -7276294671082564993i64,
  6620516960021240235i64
}; // weak
__int64 qword_8FB90[32] =
{
  8158064640682241944i64,
  -1606136187322303537i64,
  6480981066509632091i64,
  -6116909922501295452i64,
  1334009978109274776i64,
  6128411470023722430i64,
  -9160688885620122252i64,
  -4495734319865919833i64,
  -1171420208383170111i64,
  2597628982895680966i64,
  5365058922554666095i64,
  8573033837115779548i64,
  -6327057827470880430i64,
  -4658551843909851192i64,
  -3051310485054944269i64,
  1452737877275992913i64,
  3322285675184065157i64,
  5996557280394112508i64,
  8532644243977171796i64,
  -7894198244907759314i64,
  -6333637450904115039i64,
  -4076793798895891600i64,
  -2983346522951587815i64,
  1182934259129529733i64,
  2177327726902690070i64,
  3796741972107491148i64,
  5681478165690322099i64,
  7507060719877933647i64,
  8693463986056692462i64,
  -8302665152423495660i64,
  -6606660894350966790i64,
  -4147400797850065929i64
}; // weak
__int64 qword_8FC90[18] =
{
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64,
  -6148914691236517206i64
}; // weak
__int64 qword_8FD20[6] =
{
  120259084319i64,
  128849018911i64,
  128849018911i64,
  133143986207i64,
  133143986206i64,
  133143986206i64
}; // weak
__int16 a0123456789abcd_0[16] = { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70 }; // weak
__int64 qword_8FD70[2] = { 6618611909121i64, 0i64 }; // weak
__int64 qword_8FD80[36] =
{
  395136991247i64,
  30064771023i64,
  549755813959i64,
  1073741824002i64,
  343597383709i64,
  -292057763303i64,
  132186208468923i64,
  38654736442i64,
  70007966924826i64,
  70012261908398i64,
  132130373910447i64,
  77309411281i64,
  -73014444049i64,
  4771708665857i64,
  12884901948i64,
  132130373894094i64,
  -90194282449i64,
  -2147483647950i64,
  17179869407i64,
  132117489023021i64,
  -214748365301i64,
  55834573648i64,
  -51539607564i64,
  132233453140010i64,
  -167503724534i64,
  -5153960755238i64,
  132190503416767i64,
  -283467810757i64,
  373662154760i64,
  30064771296i64,
  81604378609i64,
  -103079215085i64,
  -150323855395i64,
  -8589934592i64,
  -134140418573673i64,
  4294966506i64
}; // weak
__int64 qword_8FEC0[552] =
{
  4909147619328i64,
  14727442860271i64,
  24528558232027i64,
  34299608832706i64,
  44032004727712i64,
  53704271080564i64,
  63316407891257i64,
  72846940323310i64,
  82291573409424i64,
  91637422247707i64,
  100871601936270i64,
  109976932605926i64,
  118953414256671i64,
  127783867019321i64,
  136459700959279i64,
  144968031174655i64,
  153300267730856i64,
  161443525725991i64,
  169393510192761i64,
  177137336229275i64,
  184662118933645i64,
  191963563338572i64,
  199028784542165i64,
  205853487577126i64,
  212429082508862i64,
  218746979402779i64,
  224794293356987i64,
  230566729404187i64,
  236064287544379i64,
  241269787908377i64,
  246183230496179i64,
  250796025373192i64,
  255099582604823i64,
  259098197158366i64,
  262778984131931i64,
  266137648558223i64,
  269174190437240i64,
  271880019834389i64,
  274259431716965i64,
  276299541183079i64,
  278008938167324i64,
  279374737767810i64,
  280401234951832i64,
  281088429719392i64,
  281432027103192i64,
  281432027103232i64,
  281088429719512i64,
  280401234952032i64,
  279374737768088i64,
  278008938167682i64,
  276299541183516i64,
  274259431717479i64,
  271880019834981i64,
  269174190437909i64,
  266137648558968i64,
  262778984132751i64,
  259098197159259i64,
  255099582605790i64,
  250796025374231i64,
  246183230497288i64,
  241269787909555i64,
  236064287545625i64,
  230566729405499i64,
  224794293358363i64,
  218746979404219i64,
  212429082510363i64,
  205853487578686i64,
  199028784543782i64,
  191963563340245i64,
  184662118935372i64,
  177137336231053i64,
  169393510194587i64,
  161443525727865i64,
  153300267732775i64,
  144968031176616i64,
  136459700961279i64,
  127783867021359i64,
  118953414258745i64,
  109976932608031i64,
  100871601938406i64,
  91637422249870i64,
  82291573411611i64,
  72846940325520i64,
  63316407893486i64,
  53704271082809i64,
  44032004729972i64,
  34299608834976i64,
  24528558234306i64,
  14727442862555i64,
  4909147621615i64,
  -4909147619328i64,
  -14723147892975i64,
  -24524263264731i64,
  -34295313865410i64,
  -44027709760416i64,
  -53699976113268i64,
  -63312112923961i64,
  -72842645356014i64,
  -82287278442128i64,
  -91633127280411i64,
  -100867306968974i64,
  -109972637638630i64,
  -118949119289375i64,
  -127779572052025i64,
  -136455405991983i64,
  -144963736207360i64,
  -153295972763560i64,
  -161439230758695i64,
  -169389215225465i64,
  -177133041261979i64,
  -184657823966349i64,
  -191959268371276i64,
  -199024489574869i64,
  -205849192609830i64,
  -212424787541566i64,
  -218742684435483i64,
  -224789998389691i64,
  -230562434436891i64,
  -236059992577083i64,
  -241265492941081i64,
  -246178935528883i64,
  -250791730405896i64,
  -255095287637527i64,
  -259093902191070i64,
  -262774689164635i64,
  -266133353590927i64,
  -269169895469944i64,
  -271875724867093i64,
  -274255136749669i64,
  -276295246215783i64,
  -278004643200028i64,
  -279370442800514i64,
  -280396939984536i64,
  -281084134752096i64,
  -281427732135896i64,
  -281427732135936i64,
  -281084134752216i64,
  -280396939984736i64,
  -279370442800792i64,
  -278004643200386i64,
  -276295246216220i64,
  -274255136750183i64,
  -271875724867685i64,
  -269169895470613i64,
  -266133353591672i64,
  -262774689165455i64,
  -259093902191963i64,
  -255095287638494i64,
  -250791730406935i64,
  -246178935529992i64,
  -241265492942259i64,
  -236059992578329i64,
  -230562434438203i64,
  -224789998391067i64,
  -218742684436923i64,
  -212424787543067i64,
  -205849192611390i64,
  -199024489576486i64,
  -191959268372949i64,
  -184657823968076i64,
  -177133041263757i64,
  -169389215227291i64,
  -161439230760569i64,
  -153295972765479i64,
  -144963736209320i64,
  -136455405993984i64,
  -127779572054063i64,
  -118949119291449i64,
  -109972637640735i64,
  -100867306971110i64,
  -91633127282574i64,
  -82287278444315i64,
  -72842645358224i64,
  -63312112926190i64,
  -53699976115513i64,
  -44027709762676i64,
  -34295313867680i64,
  -24524263267010i64,
  -14723147895259i64,
  -4904852654319i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64
}; // weak
__int64 off_91438 = 594928i64; // weak
__int16 *off_91480[4] = { &aMedia, &asc_406D8, &aMedia, &aMedia }; // weak
char *off_914A0 = "D"; // weak
__int16 *off_914C0 = &aFloppy; // weak
char *off_91508 = "gt"; // weak
char *off_91580[11] =
{
  "none",
  "dict",
  "key",
  "string",
  "integer",
  "data",
  "date",
  "false",
  "true",
  "array",
  "real"
}; // weak
char *off_915E0[13] =
{
  "INIT",
  "VERBOSE",
  "EXIT",
  "RESET:OK",
  "RESET:FAIL",
  "RESET:RECOVERY",
  "RECOVERY",
  "REAN:START",
  "REAN:END",
  "DT",
  "EXITBS:START",
  "EXITBS:END",
  "UNKNOWN"
}; // weak
__int64 (__fastcall *off_91650[3])() = { &sub_207EC, &sub_20858, &sub_209A2 }; // weak
void *off_91680 = &loc_22C60; // weak
__int64 qword_91E80[] = { 0i64 }; // weak
char *off_91EA8 = "battery_missing.png"; // weak
__int64 (__fastcall *off_91ED0[7])() =
{
  &sub_3E262,
  &sub_3E230,
  &sub_3E794,
  &sub_3E7E0,
  &sub_3E8BA,
  &sub_3E1FE,
  &sub_3EA33
}; // weak
__int64 qword_91F10[2] = { 5255284498567764764i64, 7136066134236585093i64 }; // weak
__int64 qword_91F20[2] = { 5116689061565117782i64, -289397820954335102i64 }; // weak
char byte_91F30 = '\x02'; // weak
__int64 (__fastcall *off_91F38[12])() =
{
  &sub_1617,
  &sub_1713,
  &sub_176C,
  &sub_1810,
  &sub_18D2,
  &sub_1995,
  &sub_1A0A,
  &sub_1A3E,
  &sub_1A54,
  &sub_1A72,
  &sub_1B0F,
  &sub_1B5A
}; // weak
__int64 qword_91F98[2] = { 5293917687598117908i64, -4668641741748559724i64 }; // weak
char byte_91FA9 = '\0'; // weak
char byte_91FAA = '\0'; // weak
char byte_91FAB = '\0'; // weak
char *off_91FB0[3] = { "rp", "root-dmg", "auth-root-dmg" }; // weak
__int64 qword_91FC8[2] = { 5525345963005459666i64, -3007793936059688019i64 }; // weak
char byte_91FF0 = '\x01'; // weak
char byte_91FF1 = '\x01'; // weak
int dword_91FF4 = 1293868549; // weak
int dword_92004 = 2347032417; // weak
int dword_92014 = 1907658812; // weak
int dword_92024 = 1; // weak
char *off_92030[10] =
{
  "Mac-35C1E88140C3E6CF",
  "Mac-7DF21CB3ED6977E5",
  "Mac-3CBD00234E554E41",
  "Mac-2BD1B31983FE1663",
  "Mac-031B6874CF7F642A",
  "Mac-77EB7D7DAF985301",
  "Mac-27ADBB7B4CEE8E61",
  "Mac-189A3D4F975D5FFC",
  "Mac-742912EFDBEE19B3",
  "Mac-C08A6BB70A942AC2"
}; // weak
__int64 qword_92080[2] = { 281474976710656i64, 128i64 }; // weak
char *off_92090[14] =
{
  "Mac-C08A6BB70A942AC2",
  "Mac-742912EFDBEE19B3",
  "Mac-6F01561E16C75D06",
  "Mac-4B7AC7E43945597E",
  "Mac-94245B3640C91C81",
  "Mac-94245AF5819B141B",
  "Mac-94245A3940C91C80",
  "Mac-942459F5819B171B",
  "Mac-942B5BF58194151B",
  "Mac-942B5B3A40C91381",
  "Mac-942B59F58194171B",
  "Mac-8ED6AF5B48C039E1",
  "Mac-4BC72D62AD45599E",
  "Mac-7BA5B2794B2CDB12"
}; // weak
int dword_92100 = 3; // weak
__int64 qword_92110 = 257i64; // weak
int dword_92308 = 12566463; // weak
int dword_9230C = 4294967295; // weak
__int64 qword_92318 = 0i64; // weak
__int64 qword_92360[2] = { 5457143572451254544i64, -9034400514174975832i64 }; // weak
char *off_92370[4] = { "debug", "kdp_match_name", "-x", "-v" }; // weak
char *off_923A0 = "-s"; // weak
char *off_923B0[4] =
{
  "-s",
  "chunklist-security-epoch",
  "-chunklist-no-rev1",
  "-chunklist-no-rev2-dev"
}; // weak
__int64 qword_923D8[3] = { 5387074690583506213i64, -8347526068734212446i64, 0i64 }; // weak
__int64 qword_923F0 = 2i64; // weak
__int64 qword_923F8 = 2i64; // weak
__int64 qword_92418 = 0i64; // weak
__int64 qword_92420 = 1i64; // weak
char *off_92468 = "wake-save-log"; // weak
__int64 qword_92648[3] = { 5116689059686069590i64, -865858573257758590i64, 0i64 }; // weak
__int64 qword_92660[8] = { 128i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64 }; // weak
int dword_926A0 = 4294967295; // weak
__int64 qword_926B0 = -1i64; // weak
__int64 qword_926B8 = -1i64; // weak
__int64 qword_92700 = 2i64; // weak
__int64 qword_92790[2] = { 5381165197545428222i64, -2323492816580895352i64 }; // weak
char byte_927A8 = '\x90'; // weak
__int64 qword_927B8 = 65536i64; // weak
int dword_927D0 = 240; // weak
int dword_927D4 = 2171029998; // weak
int dword_927E4 = 27962554; // weak
int dword_927F4 = 437285935; // weak
int dword_92804 = 2000286284; // weak
int dword_92814 = 2927677473; // weak
int dword_92824 = 949974303; // weak
int dword_92834 = 4014662365; // weak
__int64 qword_92850 = 0i64; // weak
__int64 qword_92A30[2] = { 1284420384822471984i64, 5602828850577807002i64 }; // weak
__int64 qword_92A40[2] = { 1284622044757551217i64, -9112967018440547652i64 }; // weak
__int64 qword_92A50[2] = { 1284420384822471985i64, 5602828850577807002i64 }; // weak
__int64 qword_92A60[2] = { 1284199179690597153i64, 4283602510276475278i64 }; // weak
__int64 qword_92A70[2] = { 5425781034660958394i64, -1684022352837373781i64 }; // weak
__int64 qword_92A90[2] = { 1284208961261104785i64, 4283602510276475278i64 }; // weak
__int64 qword_92AA0[2] = { 1284293403620954481i64, 4283602510276480910i64 }; // weak
__int64 qword_92AB0[2] = { 4966519546539937878i64, -8756825617117828974i64 }; // weak
__int64 qword_92AC0[2] = { 1284208961261104786i64, 4283602510276475278i64 }; // weak
__int64 qword_92AD0[2] = { 5348063987722529246i64, 7661046075708078998i64 }; // weak
__int64 qword_92AE0[2] = { 4949637355180399768i64, -3614024873025757789i64 }; // weak
__int64 qword_92AF0[2] = { 5105916107577379122i64, 3824854443859163813i64 }; // weak
__int64 qword_92B00[2] = { 4653695824413972495i64, -5312354926286229065i64 }; // weak
__int64 qword_92B10[2] = { 1284253093421855137i64, 4283602510276476814i64 }; // weak
__int64 qword_92B20[2] = { 1284252998862385297i64, 4283602510276476814i64 }; // weak
__int64 qword_92B30[2] = { 5522935658814222848i64, -7349223409350153058i64 }; // weak
__int64 qword_92B40[2] = { 1284199179690597154i64, 4283602510276475278i64 }; // weak
__int64 qword_92B50[2] = { 1284945866654190727i64, 5602828850577821594i64 }; // weak
__int64 qword_92B60[2] = { 4741152389869611403i64, 4159231935575963832i64 }; // weak
__int64 qword_92B70[2] = { 5481444997640189826i64, 2447429612490806937i64 }; // weak
__int64 qword_92B80[2] = { 5756159248327455455i64, -3664633420052801389i64 }; // weak
__int64 qword_92B90[2] = { 4626661863361025766i64, -7452152007806327878i64 }; // weak
__int64 qword_92BA0[2] = { 4814879503467367626i64, 4667602652620322225i64 }; // weak
__int64 qword_92BB0[2] = { 5363094228517654257i64, -5109661921940234309i64 }; // weak
__int64 qword_92BC0[2] = { 5260607281474647111i64, 8260085447568978340i64 }; // weak
__int64 qword_92BD0[2] = { 5254291328102708475i64, -2054814281312300110i64 }; // weak
__int64 qword_92BE0[2] = { 4721578213332916731i64, 8384071629953425047i64 }; // weak
__int64 qword_92BF0[2] = { 4710361154120525371i64, 1421072368329334408i64 }; // weak
__int64 qword_92C00[2] = { 5158325613556891166i64, 1623726376795887760i64 }; // weak
__int64 qword_92C10[2] = { 5039136844133035015i64, 2433355502873196208i64 }; // weak
__int64 qword_92C20[2] = { 5116689059686069590i64, -937916167295686526i64 }; // weak
__int64 qword_92C30[2] = { 5057626599671655226i64, 2092317391797370752i64 }; // weak
__int64 qword_92C40[2] = { 5685987408336682586i64, -2752452520054839144i64 }; // weak
__int64 qword_92C50[2] = { 5535711997719321246i64, 1295236061533082762i64 }; // weak
__int64 qword_92C60[2] = { 6393576640949810835i64, 8682045170467163828i64 }; // weak
__int64 qword_92C70[2] = { 4753202464316503857i64, -7604558665832918878i64 }; // weak
__int64 qword_92C80[2] = { 4970837933557617406i64, -2289463948991154267i64 }; // weak
__int64 qword_92C90[2] = { 5036851070669019797i64, 8575048492332872114i64 }; // weak
__int64 qword_92CA0[2] = { 5039181512545462774i64, 551013910231673504i64 }; // weak
__int64 qword_92CB0[2] = { 4831138457144133848i64, 5370796649984405671i64 }; // weak
__int64 qword_92CC0[2] = { 5496932868466073856i64, 227791864467052176i64 }; // weak
__int64 qword_92CD0[2] = { 5560426211591629925i64, 3820282465770591931i64 }; // weak
__int64 qword_92CE0[2] = { 4712479831286218329i64, 7107213190655666593i64 }; // weak
__int64 qword_92CF0[2] = { 6171963263938947812i64, 2332986464124494004i64 }; // weak
__int64 qword_92D00[2] = { 1284774123615734961i64, -9112967018440497220i64 }; // weak
int dword_92D28 = 1; // weak
int dword_92D2C = 1064185512; // weak
void *off_92D40 = &off_92D40; // weak
__int64 qword_92D50 = 7i64; // weak
void *off_92D80 = &off_92D80; // weak
__int64 qword_92D90[4] = { 64i64, 0i64, 0i64, 0i64 }; // weak
__int16 word_92DB0 = 0; // weak
__int64 qword_92DC8[4] = { 32i64, 0i64, 0i64, 0i64 }; // weak
__int16 word_92DE8 = 0; // weak
__int64 qword_92E00[114] =
{
  416611856388i64,
  27584549597020225i64,
  123171076440064i64,
  8072421144847712355i64,
  19140298422878208i64,
  433791725576i64,
  28710449504124997i64,
  123188256571392i64,
  8073547061934424167i64,
  20266198329982976i64,
  450971594764i64,
  29836349411229769i64,
  123205436702720i64,
  8074672979021135979i64,
  21392098237087744i64,
  468151463952i64,
  30962249318334541i64,
  123222616834048i64,
  8075798896107847791i64,
  22517998144192512i64,
  485331333140i64,
  32088149225439313i64,
  123239796965376i64,
  8076924813194559603i64,
  23643898051297280i64,
  502511202328i64,
  33214049132544085i64,
  123256977096704i64,
  8078050730281271415i64,
  24769797958402048i64,
  519691071516i64,
  34339949039648857i64,
  123274157228032i64,
  8079176398259879985i64,
  18014398512758784i64,
  219043360800i64,
  14636700670165027i64,
  123291333558272i64,
  8080302315346591797i64,
  26458647814340608i64,
  236223229988i64,
  15762600577269798i64,
  123308513820672i64,
  8081428228138336313i64,
  11540474048282624i64,
  55834603560i64,
  100665982989i64,
  123325690937367i64,
  8082553990606225416i64,
  2533274790985728i64,
  137438982188i64,
  12666375833976864i64,
  123342877032448i64,
  8083680040836923453i64,
  34621422141374464i64,
  399431987248i64,
  25895699739639933i64,
  123364353769472i64,
  8085087480144986171i64,
  9570149210718208i64,
  412316889141i64,
  12384900857856126i64,
  123381529444352i64,
  8086213397231697966i64,
  17732923535851520i64,
  3096224744566842i64,
  53422522368i64,
  3782577697587212i64,
  8087620505828130816i64,
  60129542158i64,
  4222124651671614i64,
  70602653696i64,
  4908494784299024i64,
  8088746405735235584i64,
  77309411346i64,
  5348024558776386i64,
  87782785024i64,
  6034411871010836i64,
  8089872305642340352i64,
  94489280534i64,
  1970324837462089i64,
  23358734336i64,
  2656742215254021i64,
  8091842630478528512i64,
  34359738376i64,
  1688849860685901i64,
  44833832960i64,
  967909534859274i64,
  8092968530384977920i64,
  17179869188i64,
  562949953581137i64,
  6179389440i64,
  123506079563777i64,
  8094376107131797551i64,
  11821949024600064i64,
  193273557078i64,
  12103425883308077i64,
  123523262251008i64,
  8095501861009752077i64,
  13792273862033408i64,
  214748393562i64,
  14355225697255474i64,
  123540442644480i64,
  8096627928420319284i64,
  14918173769138176i64,
  231928262750i64,
  15481125604360246i64,
  123557622775808i64,
  8097753845507031096i64,
  16044073676242944i64,
  206158458978i64,
  12947850814226480i64,
  123587686957056i64,
  261993005117i64
}; // weak
__int64 qword_93190[26] =
{
  1095216660735i64,
  1095216660735i64,
  47244640256i64,
  8589934600i64,
  12884901902i64,
  17179869189i64,
  163208757282i64,
  158913789992i64,
  193273528366i64,
  150323855391i64,
  64424509452i64,
  73014444033i64,
  38654705696i64,
  30064771085i64,
  25769803792i64,
  81604378642i64,
  90194313236i64,
  94489280535i64,
  120259084314i64,
  124554051609i64,
  227633266724i64,
  206158430259i64,
  115964117041i64,
  141733920792i64,
  180388626462i64,
  176093659178i64
}; // weak
int dword_93264 = 50; // weak
__int64 qword_93320[80] =
{
  472446402570i64,
  347892351103i64,
  459561500777i64,
  455266533489i64,
  339302416448i64,
  386547056720i64,
  1095216660735i64,
  1095216660735i64,
  489626271999i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  317827580159i64,
  313532612680i64,
  1095216660735i64,
  408021893375i64,
  403726926079i64,
  399431958783i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  438086664296i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  240518168635i64,
  236223201338i64,
  257698037822i64,
  231928234045i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  1095216660735i64,
  0i64,
  0i64
}; // weak
int dword_935C4 = 1; // weak
int dword_9360C = 1; // weak
__int64 qword_93610[2] = { 5640536612378127725i64, -4515641812773105513i64 }; // weak
int dword_9362C = 4294967295; // weak
__int64 qword_93630[2] = { 1290039658193554296i64, -379942466776193883i64 }; // weak
__int64 qword_93640[2] = { 5103401036687913321i64, 6868692469331098039i64 }; // weak
__int64 qword_93650[2] = { 5457143572451254544i64, -9034400514174975832i64 }; // weak
__int64 qword_93670 = 0i64; // weak
__int64 qword_93678 = 0i64; // weak
__int64 qword_93680 = 0i64; // weak
__int64 qword_93690[7] = { 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64 }; // weak
char byte_936CF = '\0'; // weak
__int64 qword_936D0 = 0i64; // weak
__int64 qword_936D8 = 0i64; // weak
char byte_936E0 = '\0'; // weak
__int64 qword_936E8 = 0i64; // weak
char byte_936F0 = '\0'; // weak
__int64 qword_93730[128] =
{
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64
}; // weak
__int64 qword_93B30 = 0i64; // weak
__int64 qword_93B38 = 0i64; // weak
__int64 qword_93B40 = 0i64; // weak
__int64 qword_93B48 = 0i64; // weak
__int64 qword_93B50 = 0i64; // weak
int dword_93B58 = 0; // weak
int dword_93B5C = 0; // weak
int dword_93B60 = 0; // weak
int dword_93B68 = 0; // weak
int dword_93B6C = 0; // weak
__int64 qword_93B70 = 0i64; // weak
__int64 qword_93B78 = 0i64; // weak
__int64 qword_93B80 = 0i64; // weak
int dword_93B88 = 0; // weak
int dword_93B8C = 0; // weak
__int64 qword_93B90 = 0i64; // weak
char byte_93B98 = '\0'; // weak
__int64 qword_93BA0 = 0i64; // weak
int dword_93BA8 = 0; // weak
int dword_93BAC = 0; // weak
int dword_93BB0 = 0; // weak
int dword_93BB4 = 0; // weak
__int64 qword_93BB8 = 0i64; // weak
__int64 qword_93BC0 = 0i64; // weak
__int64 qword_93BC8 = 0i64; // weak
__int64 qword_93BD0 = 0i64; // weak
int dword_93BD8 = 0; // weak
__int64 qword_93BE0 = 0i64; // weak
__int64 qword_93BE8 = 0i64; // weak
__int64 qword_93BF0 = 0i64; // weak
__int64 qword_93BF8 = 0i64; // weak
__int64 qword_93C00 = 0i64; // weak
__int64 qword_93C10[126] =
{
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64
}; // weak
char byte_94C28; // weak
__int64 qword_94C30; // weak
char byte_94C38; // weak
__int64 qword_94C40; // weak
__int64 qword_94C48; // weak
__int64 qword_94C50; // weak
__int64 qword_94C58; // weak
__int64 qword_94C60; // weak
int dword_94C68; // weak
__int64 qword_94C70; // weak
__int64 qword_94C78; // weak
int dword_94C80; // weak
__int64 qword_94C88; // weak
__int64 qword_94C90; // weak
__int64 qword_94C98; // weak
__int64 qword_94CA0; // weak
char byte_94CB0; // weak
__int64 qword_94CB8; // weak
__int64 qword_94CC0; // weak
__int64 qword_94CC8; // weak
__int64 qword_94CD0; // weak
__int64 qword_94CD8; // weak
__int64 qword_94CE0[32]; // weak
__int64 qword_94DE0; // weak
__int64 qword_94DF0; // weak
__int16 word_94DFE; // weak
__int16 word_94E2E; // weak
__int16 word_94E48; // weak
char byte_94EF0; // weak
char byte_94EF1; // weak
char byte_94EF8; // weak
__int64 qword_94F00; // weak
char byte_94F08; // weak
char byte_94F09; // weak
__int64 qword_94F10; // weak
char byte_94F18; // weak
__int64 qword_94F20; // weak
__int64 qword_94F28; // weak
char byte_94F30; // weak
int dword_94F34; // weak
__int64 qword_94F38; // weak
__int64 qword_94F40; // weak
__int64 qword_94F48; // weak
__int64 qword_94F50; // weak
int dword_94F58; // weak
int dword_94F5C; // weak
__int64 qword_94FE0; // weak
__int64 qword_94FE8; // weak
int dword_94FF0; // weak
__int64 qword_94FF8; // weak
__int64 qword_95000; // weak
int dword_95008; // weak
__int64 qword_95010; // weak
__int64 qword_95018[2]; // weak
__int64 qword_95028; // weak
char byte_95030; // weak
int dword_95034; // weak
__int64 qword_95038; // weak
__int64 qword_95040; // weak
char byte_95048; // weak
__int64 qword_95050; // weak
__int64 qword_95058; // weak
__int64 qword_95060; // weak
__int64 qword_95068[3]; // weak
__int64 qword_95080; // weak
char byte_95088; // weak
__int64 qword_95090; // weak
__int64 qword_95098; // weak
char byte_950A0; // weak
int dword_950A4; // weak
int dword_950A8; // weak
__int64 qword_950B0; // weak
char byte_950B8; // weak
__int64 qword_950C0; // weak
int dword_950C8; // weak
__int64 qword_950D0; // weak
char byte_950E0; // weak
__int64 qword_950F0[]; // weak
__int64 qword_950F8; // weak
__int64 qword_95100[28]; // weak
__int16 word_951E0; // weak
char byte_951E2; // weak
char byte_951E3; // weak
__int64 qword_951E8; // weak
char byte_951F0; // weak
char byte_951F1; // weak
__int64 qword_951F8; // weak
__int64 qword_95200; // weak
int dword_95208; // weak
int dword_9520C; // weak
__int64 qword_95210; // weak
char byte_95218; // weak
__int64 qword_95220; // weak
char byte_95230; // weak
__int64 qword_95240[256]; // weak
__int64 qword_95A40[256]; // weak
__int64 qword_96240[256]; // weak
char byte_96A40; // weak
int dword_96A44; // weak
char byte_96A48; // weak
int dword_96A4C; // weak
char byte_96A50; // weak
__int64 qword_96A58; // weak
__int64 qword_96A60; // weak
__int64 qword_96A68; // weak
__int64 qword_96A78; // weak
__int64 qword_96A80; // weak
__int64 qword_96A88; // weak
__int64 qword_96A90; // weak
__int64 qword_96A98; // weak
__int64 qword_96AA0; // weak
__int64 qword_96AA8; // weak
__int64 qword_96AB0; // weak
__int64 qword_96AB8; // weak
__int64 qword_96AC0; // weak
__int64 (__fastcall *qword_96AC8)(_QWORD, _QWORD); // weak
char byte_96AD0; // weak
__int64 qword_96AD8; // weak
__int64 qword_96AE0; // weak
__int64 qword_96AE8; // weak
__int64 qword_96AF0; // weak
__int64 qword_96AF8; // weak
_QWORD qword_96B00; // idb
__int64 qword_96B08; // weak
int dword_96B10; // weak
__int64 qword_96B18; // weak
__int64 qword_96B20; // weak
char byte_96B28; // weak
char byte_96B29; // weak
__int64 qword_96B30; // weak
__int64 qword_96B38; // weak
__int64 qword_96B40; // weak
char byte_96B48; // weak
char byte_96B49; // weak
__int64 qword_96B50; // weak
__int64 qword_96B58; // weak
__int64 qword_96B60; // weak
__int64 qword_96B68; // weak
int dword_96B70; // weak
__int64 qword_96B78; // weak
__int64 qword_96B80; // weak
__int64 qword_96B88; // weak
__int64 qword_96B90; // weak
__int64 qword_96B98; // weak
__int64 qword_96BA0; // weak
__int64 qword_96BA8; // weak
__int64 qword_96BB0; // weak
int dword_96BCC; // weak
int dword_96BDC; // weak
__int64 qword_96BE0; // weak
__int64 qword_96BE8; // weak
__int64 qword_96BF0; // weak
int dword_96BF8; // weak
int dword_96BFC; // weak
__int64 qword_96C00; // weak
__int64 qword_96C08; // weak
__int64 qword_96C10; // weak
__int64 qword_96C18; // weak
__int64 qword_96C20; // weak
__int64 qword_96C28; // weak
__int64 qword_96C30; // weak
__int64 qword_96C38; // weak
__int64 qword_96C40; // weak
int dword_96C48; // weak
int dword_96C4C; // weak
char byte_96CCC; // weak
char byte_96CCD; // weak
__int64 qword_96CD0; // weak
__int64 qword_96CD8; // weak
__int64 qword_96CE0; // weak
__int64 qword_96CE8; // weak
char byte_96CF0; // weak
__int64 qword_96CF8; // weak
char byte_96D00[4]; // weak
int dword_96D04; // weak
__int64 qword_96D08; // weak
__int64 qword_96D10; // weak
__int64 qword_96D18; // weak
char byte_96D20; // weak
int dword_96D24; // weak
__int64 qword_96D28; // weak
__int64 qword_96D30; // weak
__int64 qword_96D38; // weak


//----- (0000000000001000) ----------------------------------------------------
__int64 __fastcall sub_1000(unsigned __int8 a1)
{
  __int64 v1; // rdi
  unsigned __int8 v2; // si
  __int64 v3; // rax
  __int64 v5; // [rsp+28h] [rbp-38h]
  __int64 v6; // [rsp+30h] [rbp-30h]
  __int64 v7; // [rsp+38h] [rbp-28h]
  int v8; // [rsp+44h] [rbp-1Ch]

  v1 = -9223372036854775806i64;
  v8 = -1431655766;
  v7 = -6148914691236517206i64;
  v6 = -6148914691236517206i64;
  v5 = -6148914691236517206i64;
  if ( a1 <= 0x3Fu )
  {
    v2 = a1;
    v7 = 0i64;
    if ( (*(__int64 (__fastcall **)(const __int16 *, __int64 *, int *))(qword_96CE0 + 72))(
           L"boot-feature-usage",
           qword_91F10,
           &v8) != -9223372036854775794i64
      && v7 != 8 )
    {
      (*(void (__fastcall **)(const __int16 *, __int64 *, _QWORD, _QWORD, _QWORD, __int64))(qword_96CE0 + 88))(
        L"boot-feature-usage",
        qword_91F10,
        0i64,
        0i64,
        0i64,
        v5);
    }
    v7 = 8i64;
    v1 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, int *))(qword_96CE0 + 72))(
           L"boot-feature-usage",
           qword_91F10,
           &v8);
    if ( v1 == -9223372036854775794i64 )
    {
      v3 = 0i64;
      goto LABEL_9;
    }
    if ( !v1 )
    {
      v3 = v6;
LABEL_9:
      v5 = v3 | (1i64 << v2);
      v7 = 8i64;
      v1 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, signed __int64, signed __int64, __int64 *))(qword_96CE0 + 88))(
             L"boot-feature-usage",
             qword_91F10,
             7i64,
             8i64,
             &v5);
      sub_1A2B6(1, (__int64)"[EB|#RBFU] F: %d U: 0x%016qx\n", v2, v5);
      return v1;
    }
  }
  return v1;
}
// 402DC: using guessed type __int16 aBootFeatureUsa[19];
// 91F10: using guessed type __int64 qword_91F10[2];
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000001153) ----------------------------------------------------
char sub_1153()
{
  __int64 v0; // rax
  __int64 v1; // rax
  __int64 v2; // r9
  char result; // al

  v0 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92C20, 0i64, &qword_93670);
  if ( v0 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`SB:EN] %r @ LocP %g\n", v0, (__int64)qword_92C20);
    result = 0;
  }
  else
  {
    v1 = MEMORY[0x20](0i64, &byte_91F30);
    if ( v1 < 0 )
      sub_1A2B6(1, (__int64)"[EB|`SB:EN] %r @ %g.GP\n", v1, (__int64)qword_92C20);
    sub_1A2B6(1, (__int64)"[EB|#SB:P] 0x%X\n", 2i64, v2);
    result = 1;
  }
  return result;
}
// 20: using guessed type __int64 (__fastcall *)(_QWORD, _QWORD);
// 91F30: using guessed type char byte_91F30;
// 92C20: using guessed type __int64 qword_92C20[2];
// 93670: using guessed type __int64 qword_93670;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000001202) ----------------------------------------------------
signed __int64 __fastcall sub_1202(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r14
  __int64 v5; // r15
  __int64 v6; // r12
  __int64 v7; // rsi
  __int64 v8; // rax
  __int64 v9; // rax
  signed __int64 v10; // rdi
  const char *v11; // rdx
  __int64 *v12; // r9
  __int64 v13; // rdx
  __int64 v15; // r9
  __int64 v16; // rax
  __int64 v17; // r9
  __int64 v18; // rax
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rdx
  __int64 v22; // rax
  __int64 v23; // r9
  __int64 v24; // [rsp+28h] [rbp-288h]
  __int64 v25; // [rsp+28h] [rbp-288h]
  _QWORD v26[2]; // [rsp+30h] [rbp-280h]
  char v27; // [rsp+40h] [rbp-270h]
  __int64 v28; // [rsp+240h] [rbp-70h]
  __int64 v29; // [rsp+248h] [rbp-68h]
  __int64 v30; // [rsp+258h] [rbp-58h]
  __int64 v31; // [rsp+260h] [rbp-50h]
  __int64 v32; // [rsp+268h] [rbp-48h]
  __int64 v33; // [rsp+270h] [rbp-40h]
  int v34; // [rsp+27Ch] [rbp-34h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  LOBYTE(a2) = -86;
  sub_F180(&v27, a2, 0x200ui64);
  v28 = -6148914691236517206i64;
  v29 = -6148914691236517206i64;
  v34 = -1431655766;
  v33 = -6148914691236517206i64;
  v30 = 0i64;
  v31 = 0i64;
  v32 = -6148914691236517206i64;
  v8 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92C20, 0i64, &qword_93670);
  if ( v8 < 0 )
  {
    v10 = v8;
    sub_1A2B6(1, (__int64)"[EB|`SB:VK] %r @ LocP %g\n", v8, (__int64)qword_92C20);
    return v10;
  }
  v33 = 16i64;
  v9 = (*(__int64 (__fastcall **)(const char *, __int64 *, int *))(qword_96CE0 + 72))("H", qword_91F20, &v34);
  if ( !v9 )
  {
    sub_1A2B6(1, (__int64)"[EB|#SB:HW] %.*e\n", v33, (__int64)&v28);
    v33 = 8i64;
    v9 = (*(__int64 (__fastcall **)(const char *, __int64 *, int *))(qword_96CE0 + 72))("A", qword_91F20, &v34);
    if ( v9 || v33 != 8 )
    {
      v10 = -9223372036854775807i64;
      v11 = "[EB|`SB:VK] %r @ GV %S\n";
      v12 = (__int64 *)"A";
      goto LABEL_4;
    }
    sub_1A2B6(1, (__int64)"[EB|`SB:VK] %S: 0x%qX\n", (__int64)"A", v32);
    sub_22ED4((__int64)&v27, 256i64, (__int64)L"%S.%a.%x.im4m", v7, &v28, v32);
    sub_1A2B6(1, (__int64)"[EB|#SB:MF] (%E)\n", (__int64)&v27, v15);
    v16 = sub_D739(0i64, v6, (__int64)&v27, 0i64, &v30, &v31);
    if ( v16 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`SB:VK] %r @ LD:LF\n", v16, v17);
      LOBYTE(v21) = 17;
    }
    else
    {
      LODWORD(v24) = 1835758190;
      v18 = MEMORY[0x18](0i64, v5, v4, v31, v30, v24, 0);
      if ( v18 >= 0 )
      {
        sub_1A2B6(1, (__int64)"[EB|#SB:MKRN]\n", v19, v20);
LABEL_18:
        v10 = 0i64;
        v13 = 0i64;
        goto LABEL_5;
      }
      sub_1A2B6(1, (__int64)"[EB|`SB:VK] %r @ MKRN\n", v18, v20);
      LOBYTE(v26[0]) = 0;
      LODWORD(v25) = 1835758180;
      v22 = MEMORY[0x18](0i64, v5, v4, v31, v30, v25, v26[0]);
      if ( v22 >= 0 )
      {
        sub_1A2B6(1, (__int64)"[EB|#SB:MKRD]\n", v22, v23);
        goto LABEL_18;
      }
      sub_1A2B6(1, (__int64)"[EB|`SB:VK] %r @ MKRD\n", v22, v23);
      LOBYTE(v21) = 18;
    }
    MEMORY[0x40](0i64, v21);
    return -9223372036854775782i64;
  }
  v10 = -9223372036854775807i64;
  v11 = "[EB|`SB:VK] %r @ GV %g:%S\n";
  v12 = qword_92C20;
LABEL_4:
  sub_1A2B6(1, (__int64)v11, v9, (__int64)v12);
  LOBYTE(v13) = -1;
LABEL_5:
  MEMORY[0x40](0i64, v13);
  return v10;
}
// 18: using guessed type __int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 40: using guessed type __int64 (__fastcall *)(_QWORD, _QWORD);
// 4032C: using guessed type __int16 aSAXIm4m[14];
// 91F20: using guessed type __int64 qword_91F20[2];
// 91F30: using guessed type char byte_91F30;
// 92C20: using guessed type __int64 qword_92C20[2];
// 93670: using guessed type __int64 qword_93670;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (00000000000015A8) ----------------------------------------------------
_BYTE *sub_15A8()
{
  __int64 v0; // rax
  __int64 v1; // rdx

  v0 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92C20, 0i64, &qword_93670);
  if ( v0 < 0 )
    return sub_1A2B6(1, (__int64)"[`EB|SB:NB] %r @ LocP %g\n", v0, (__int64)qword_92C20);
  LOBYTE(v1) = 32;
  MEMORY[0x40](0i64, v1);
  return sub_5ABA(1);
}
// 40: using guessed type __int64 (__fastcall *)(_QWORD, _QWORD);
// 92C20: using guessed type __int64 qword_92C20[2];
// 93670: using guessed type __int64 qword_93670;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000001617) ----------------------------------------------------
signed __int64 __fastcall sub_1617(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r15
  __int64 v4; // r12
  _QWORD *v5; // rdi
  signed __int64 v6; // rbx
  __int64 v8; // rax
  _QWORD *v9; // rsi
  __int64 *v10; // r14
  __int64 v11; // rcx
  __int64 v12; // rax
  _BYTE *v13; // rcx
  signed __int64 v14; // rdi

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = -9223372036854775799i64;
  if ( sub_1CCF(a1) )
    return -9223372036854775788i64;
  v8 = sub_24136(136i64);
  if ( !v8 )
    return v6;
  v9 = (_QWORD *)v8;
  v10 = (__int64 *)(v8 + 16);
  (*(void (__fastcall **)(__int64, _QWORD *, signed __int64))(qword_96CD8 + 352))(v8 + 40, v5, 12i64);
  v9[4] = v4;
  v11 = *(_QWORD *)(v4 + 12);
  v9[2] = v11;
  v9[3] = sub_24136(v11 << 6);
  v9[12] = v3;
  sub_1D2C((__int64)(v9 + 2), v4);
  if ( qword_96A58 )
    sub_1DA0(v9 + 2);
  v12 = *v10;
  if ( *v10 )
  {
    v13 = (_BYTE *)(v9[3] + 57i64);
    do
    {
      *v13 |= 1u;
      ++v9[8];
      v13 += 64;
      --v12;
    }
    while ( v12 );
  }
  v9[7] = v9[8];
  v14 = sub_1E67((__int64)(v9 + 2));
  sub_23BF5((__int64)&qword_96A68, v9);
  return v14;
}
// 96A58: using guessed type __int64 qword_96A58;
// 96A68: using guessed type __int64 qword_96A68;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000001713) ----------------------------------------------------
signed __int64 __fastcall sub_1713(_QWORD *a1, __int64 *a2)
{
  __int64 *v2; // rdi
  signed __int64 v3; // rsi
  __int64 *v4; // rax
  __int64 v5; // rcx

  v2 = a2;
  v3 = -9223372036854775802i64;
  v4 = (__int64 *)sub_1CCF(a1);
  if ( !v4 )
    return -9223372036854775794i64;
  v5 = *v4;
  *v2 = *v4;
  v2[1] = v4[5];
  v2[2] = v4[6];
  if ( v5 == v4[6] && !v4[5] )
    v3 = 0i64;
  return v3;
}

//----- (000000000000176C) ----------------------------------------------------
signed __int64 __fastcall sub_176C(_QWORD *a1, unsigned __int64 *a2, signed __int64 *a3)
{
  signed __int64 *v3; // r14
  unsigned __int64 *v4; // r12
  signed __int64 v5; // r15
  unsigned __int64 *v6; // rax
  _BYTE *v7; // rdx
  unsigned __int64 v8; // rsi
  char v9; // di
  unsigned __int8 v10; // cl
  signed __int64 v11; // rdx

  v3 = a3;
  v4 = a2;
  v5 = -9223372036854775794i64;
  v6 = (unsigned __int64 *)sub_1CCF(a1);
  if ( v6 )
  {
    if ( *v6 )
    {
      v7 = (_BYTE *)(v6[1] + 57);
      v8 = 0i64;
      v9 = 0;
      do
      {
        v10 = *v7 & 1;
        if ( !((unsigned __int8)v9 | v10) )
        {
          *v4 = v8;
          v9 = 1;
        }
        if ( v10 && v9 )
        {
          v11 = v8 - 1;
          v5 = 0i64;
          goto LABEL_14;
        }
        ++v8;
        v7 += 64;
      }
      while ( v8 < *v6 );
      if ( !v9 )
        goto LABEL_12;
      v5 = 0i64;
    }
    else
    {
      v8 = 0i64;
LABEL_12:
      *v4 = 0i64;
      v11 = 0i64;
LABEL_14:
      *v3 = v11;
    }
    if ( v8 == *v6 )
      *v3 = v8 - 1;
  }
  return v5;
}

//----- (0000000000001810) ----------------------------------------------------
signed __int64 __fastcall sub_1810(_QWORD *a1, __int64 a2)
{
  __int64 v2; // r14
  signed __int64 v3; // rax
  __int64 v4; // rsi
  unsigned __int64 v5; // rdx
  __int64 v6; // rbx
  unsigned __int64 v7; // rdi
  signed __int64 result; // rax
  __int64 v9; // rcx
  unsigned __int64 v10; // rbx

  v2 = a2;
  v3 = sub_1CCF(a1);
  if ( !v3 )
    return -9223372036854775794i64;
  v4 = v3;
  v5 = *(_QWORD *)v3;
  if ( *(_BYTE *)(v3 + 113) == 1 )
  {
    if ( v5 )
    {
      v6 = *(_QWORD *)(v3 + 8);
      v7 = 0i64;
      result = 0i64;
      do
      {
        if ( (*(_BYTE *)(v6 + 57) & 3) == 1 )
        {
          result = sub_1F58(v6, v4);
          v5 = *(_QWORD *)v4;
        }
        ++v7;
        v6 += 64i64;
      }
      while ( v7 < v5 );
    }
    else
    {
      v5 = 0i64;
      result = 0i64;
    }
    *(_BYTE *)(v4 + 113) = 0;
  }
  else
  {
    result = 0i64;
  }
  v9 = *(_QWORD *)(v4 + 8);
  if ( v5 )
  {
    v10 = 0i64;
    while ( *(_QWORD *)v9 != v2 )
    {
      ++v10;
      v9 += 64i64;
      if ( v10 >= v5 )
        goto LABEL_19;
    }
    *(_BYTE *)(v9 + 57) |= 1u;
  }
LABEL_19:
  ++*(_QWORD *)(v4 + 48);
  ++*(_QWORD *)(v4 + 40);
  if ( *(_BYTE *)(v4 + 112) == 1 )
    result = sub_1F58(v9, v4);
  return result;
}

//----- (00000000000018D2) ----------------------------------------------------
signed __int64 __fastcall sub_18D2(_QWORD *a1, _QWORD *a2, signed __int64 *a3)
{
  signed __int64 *v3; // r14
  _QWORD *v4; // r12
  signed __int64 v5; // r15
  unsigned __int64 *v6; // rax
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rsi
  char v9; // di
  unsigned __int8 v10; // dl
  signed __int64 v11; // rbx
  __int64 v12; // rdx
  __int64 v13; // rbx

  v3 = a3;
  v4 = a2;
  v5 = -9223372036854775794i64;
  v6 = (unsigned __int64 *)sub_1CCF(a1);
  if ( v6 )
  {
    v7 = v6[1];
    if ( *v6 )
    {
      v8 = 0i64;
      v9 = 0;
      do
      {
        v10 = *(_BYTE *)(v7 + 57) & 1;
        if ( !((unsigned __int8)v9 | v10) )
        {
          *v4 = *(_QWORD *)v7;
          v9 = 1;
        }
        if ( v10 && v9 )
        {
          v12 = *(_QWORD *)(v7 - 64);
          v13 = *(_QWORD *)(v7 - 56);
          v7 -= 64i64;
          v11 = v12 + v13 - 1;
          v5 = 0i64;
          goto LABEL_14;
        }
        ++v8;
        v7 += 64i64;
      }
      while ( v8 < *v6 );
      if ( !v9 )
        goto LABEL_12;
      v5 = 0i64;
    }
    else
    {
      v8 = 0i64;
LABEL_12:
      *v4 = 0i64;
      v11 = 0i64;
LABEL_14:
      *v3 = v11;
    }
    if ( v8 == *v6 )
      *v3 = *(_QWORD *)(v7 - 56) + *(_QWORD *)(v7 - 64) - 1i64;
  }
  return v5;
}

//----- (0000000000001995) ----------------------------------------------------
signed __int64 __fastcall sub_1995(_QWORD *a1, __int64 a2, _QWORD *a3, _BYTE *a4)
{
  _BYTE *v4; // r14
  _QWORD *v5; // rbx
  __int64 v6; // rdi
  signed __int64 v7; // rsi
  unsigned __int64 *v8; // rax
  unsigned __int64 v9; // rcx
  _BYTE *v10; // rax
  unsigned __int64 v11; // rdx

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = -9223372036854775794i64;
  v8 = (unsigned __int64 *)sub_1CCF(a1);
  if ( v8 )
  {
    v9 = *v8;
    if ( *v8 )
    {
      v10 = (_BYTE *)(v8[1] + 56);
      v11 = 0i64;
      while ( *((_QWORD *)v10 - 7) != v6 )
      {
        ++v11;
        v10 += 64;
        if ( v11 >= v9 )
          return v7;
      }
      *v5 = v6 + *((_QWORD *)v10 - 6) - 1;
      *v4 = (*v10)++;
      v7 = 0i64;
    }
  }
  return v7;
}

//----- (0000000000001A0A) ----------------------------------------------------
__int64 __fastcall sub_1A0A(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax
  unsigned int *v3; // r8
  __int64 v4; // r9
  unsigned __int64 v5; // r10

  result = 0i64;
  *a2 = 0i64;
  if ( *(_QWORD *)(a1 + 12) )
  {
    v3 = (unsigned int *)(a1 + *(_QWORD *)(a1 + 20));
    v4 = 0i64;
    v5 = 0i64;
    do
    {
      result = *v3;
      v4 += result;
      *a2 = v4;
      ++v5;
      v3 += 9;
    }
    while ( v5 < *(_QWORD *)(a1 + 12) );
  }
  return result;
}

//----- (0000000000001A3E) ----------------------------------------------------
__int64 __fastcall sub_1A3E(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  if ( a1 )
    result = *(_QWORD *)(a1 + 12);
  else
    result = 0i64;
  *a2 = result;
  return result;
}

//----- (0000000000001A54) ----------------------------------------------------
__int64 __fastcall sub_1A54(__int64 a1)
{
  __int64 result; // rax

  if ( *(_DWORD *)a1 == 1280003651 )
    result = sub_255B(a1);
  else
    result = -9223372036854775805i64;
  return result;
}

//----- (0000000000001A72) ----------------------------------------------------
signed __int64 __fastcall sub_1A72(_QWORD *a1)
{
  _QWORD *v1; // rbx
  signed __int64 v2; // r14
  __int64 v3; // rsi
  _QWORD *v4; // rdi

  v1 = a1;
  v2 = -9223372036854775794i64;
  if ( !sub_23BD5(&qword_96A68) )
  {
    v3 = qword_96A68;
    while ( (__int64 *)v3 != &qword_96A68 )
    {
      v4 = (_QWORD *)v3;
      v3 = *(_QWORD *)v3;
      if ( !sub_236BB(v1, v4 + 5, 12i64) )
      {
        (*(void (__fastcall **)(_QWORD))(qword_96CD8 + 72))(v4[3]);
        (*(void (__fastcall **)(_QWORD))(qword_96CD8 + 72))(v4[11]);
        sub_23BE1(*(__int64 **)(v3 + 8));
        (*(void (__fastcall **)(_QWORD *))(qword_96CD8 + 72))(v4);
        return 0i64;
      }
    }
  }
  return v2;
}
// 96A68: using guessed type __int64 qword_96A68;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000001B0F) ----------------------------------------------------
signed __int64 __fastcall sub_1B0F(_QWORD *a1, __int64 a2, __int64 a3)
{
  signed __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rdi
  signed __int64 v6; // rax

  v3 = -9223372036854775806i64;
  if ( a1 )
  {
    v4 = a2;
    if ( a2 )
    {
      v5 = a3;
      v6 = sub_1CCF(a1);
      if ( v6 )
      {
        *(_QWORD *)(v6 + 88) = v4;
        *(_QWORD *)(v6 + 96) = v5;
        v3 = 0i64;
      }
      else
      {
        v3 = -9223372036854775794i64;
      }
    }
  }
  return v3;
}

//----- (0000000000001B5A) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_1B5A(_QWORD *a1)
{
  _QWORD *v1; // rdi
  signed __int64 v2; // rbx
  signed __int64 v4; // rax
  signed __int64 v5; // rdi
  __int64 v6; // rdx
  unsigned __int64 v7; // rbx
  __int64 *v8; // rdi
  __int64 v9; // rsi

  v1 = a1;
  v2 = -9223372036854775794i64;
  if ( !sub_23BD5(&qword_96A68) )
  {
    v4 = sub_1CCF(v1);
    if ( v4 )
    {
      v5 = v4;
      if ( qword_96A80
        && (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(qword_96CD8 + 88))(qword_96A80, 0i64, 0i64) >= 0 )
      {
        (*(void (__fastcall **)(__int64))(qword_96CD8 + 112))(qword_96A80);
        qword_96A80 = 0i64;
      }
      v6 = qword_96CD8;
      if ( *(_BYTE *)(v5 + 64) )
      {
        v7 = 1i64;
        do
        {
          (*(void (__fastcall **)(signed __int64))(v6 + 248))(1000000i64);
          v6 = qword_96CD8;
          if ( v7 > 4 )
            break;
          ++v7;
        }
        while ( *(_BYTE *)(v5 + 64) );
      }
      (*(void (__fastcall **)(__int64))(v6 + 112))(qword_96A78);
      qword_96A78 = 0i64;
      v8 = (__int64 *)qword_96A68;
      v2 = 0i64;
      if ( (__int64 *)qword_96A68 != &qword_96A68 )
      {
        do
        {
          v9 = *v8;
          (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v8[3]);
          (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v8[11]);
          sub_23BE1(*(__int64 **)(v9 + 8));
          (*(void (__fastcall **)(__int64 *))(qword_96CD8 + 72))(v8);
          v8 = (__int64 *)v9;
        }
        while ( (__int64 *)v9 != &qword_96A68 );
      }
    }
  }
  return v2;
}
// 1BD6: write access to const memory at 96A80 has been detected
// 1C1F: write access to const memory at 96A78 has been detected
// 96A68: using guessed type __int64 qword_96A68;
// 96A78: using guessed type __int64 qword_96A78;
// 96A80: using guessed type __int64 qword_96A80;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000001C7E) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_1C7E()
{
  __int64 v0; // rsi

  v0 = (*(__int64 (__fastcall **)(__int64 (__fastcall __far *)(), _QWORD, __int64 *))(qword_96CD8 + 320))(
         sub_926C0,
         0i64,
         &qword_96A58);
  if ( v0 < 0 )
  {
    qword_96A58 = 0i64;
    v0 = 0i64;
  }
  sub_23BC8(&qword_96A68);
  return v0;
}
// 1CAC: write access to const memory at 96A58 has been detected
// 926C0: using guessed type __int64 __fastcall __far sub_926C0();
// 96A58: using guessed type __int64 qword_96A58;
// 96A68: using guessed type __int64 qword_96A68;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000001CCF) ----------------------------------------------------
signed __int64 __fastcall sub_1CCF(_QWORD *a1)
{
  _QWORD *v1; // rdi
  __int64 *i; // rsi

  v1 = a1;
  if ( !sub_23BD5(&qword_96A68) )
  {
    for ( i = (__int64 *)qword_96A68; i != &qword_96A68; i = (__int64 *)*i )
    {
      if ( !sub_236BB(v1, i + 5, 12i64) )
        return (signed __int64)(i + 2);
    }
  }
  return 0i64;
}
// 96A68: using guessed type __int64 qword_96A68;

//----- (0000000000001D2C) ----------------------------------------------------
__int64 __fastcall sub_1D2C(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  _QWORD *v3; // rdi
  unsigned int *v4; // rbx
  __int64 v5; // r15
  unsigned __int64 v6; // rsi
  __int64 result; // rax

  if ( *(_QWORD *)(a2 + 12) )
  {
    v2 = a2;
    v3 = *(_QWORD **)(a1 + 8);
    v4 = (unsigned int *)(a2 + *(_QWORD *)(a2 + 20));
    v5 = 0i64;
    v6 = 0i64;
    do
    {
      *v3 = v5;
      v3[1] = *v4;
      v3[6] = v6;
      (*(void (__fastcall **)(_QWORD *, unsigned int *, signed __int64))(qword_96CD8 + 352))(v3 + 2, v4 + 1, 32i64);
      result = *v4;
      v5 += result;
      ++v6;
      v3 += 8;
      v4 += 9;
    }
    while ( v6 < *(_QWORD *)(v2 + 12) );
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000001DA0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_1DA0(_QWORD *a1)
{
  _QWORD *v1; // rdi
  signed __int64 v2; // r14
  unsigned __int64 *v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v11; // [rsp+30h] [rbp-40h]
  __int64 v12; // [rsp+38h] [rbp-38h]
  __int64 v13; // [rsp+40h] [rbp-30h]
  __int64 v14; // [rsp+48h] [rbp-28h]

  v1 = a1;
  v2 = -9223372036854775799i64;
  v11 = -6148914691236517206i64;
  v12 = -6148914691236517206i64;
  v13 = -6148914691236517206i64;
  v14 = -6148914691236517206i64;
  v3 = a1 + 7;
  (*(void (__fastcall **)(__int64, _QWORD *))qword_96A58)(qword_96A58, a1 + 7);
  v4 = v1[7];
  qword_96A60 = v4;
  v1[7] = v4 - 1;
  v5 = sub_24103(8 * v4 - 8);
  v1[13] = v5;
  if ( v5 )
  {
    v6 = *v3;
    if ( *v3 )
    {
      v7 = 0i64;
      do
      {
        *(_QWORD *)(v5 + 8 * v7++) = v6 + 1;
        v6 = *v3;
      }
      while ( v7 < *v3 );
      v8 = 56 * v6;
    }
    else
    {
      v8 = 0i64;
    }
    v9 = sub_24136(v8);
    v1[9] = v9;
    if ( v9 )
      v2 = 0i64;
  }
  return v2;
}
// 1DFE: write access to const memory at 96A60 has been detected
// 96A58: using guessed type __int64 qword_96A58;
// 96A60: using guessed type __int64 qword_96A60;

//----- (0000000000001E67) ----------------------------------------------------
signed __int64 __fastcall sub_1E67(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi
  signed __int64 result; // rax

  v1 = a1;
  if ( qword_96A58 && !*(_BYTE *)(a1 + 112) )
  {
    (*(void (__fastcall **)(signed __int64, signed __int64, void (__fastcall *)(__int64, _QWORD *), __int64, __int64 *))(qword_96CD8 + 80))(
      512i64,
      8i64,
      sub_20D7,
      a1,
      &qword_96A78);
    *(_BYTE *)(v1 + 64) = 1;
    if ( qword_96A78 )
      (*(void (**)(void))(qword_96CD8 + 104))();
    (*(void (__fastcall **)(signed __int64, signed __int64, void (__fastcall *)(__int64, __int64), __int64, __int64 *))(qword_96CD8 + 80))(
      2147484160i64,
      8i64,
      sub_22EC,
      v1,
      &qword_96A80);
    result = (*(__int64 (__fastcall **)(__int64, signed __int64, void *))(qword_96CD8 + 88))(
               qword_96A80,
               1i64,
               &loc_186A0);
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 8);
    if ( *(_QWORD *)(a1 + 40) )
    {
      result = 0i64;
      do
      {
        if ( (*(_BYTE *)(v2 + 57) & 3) == 1 )
        {
          result = sub_1F58(v2, v1);
          if ( result < 0 )
            break;
        }
        v2 += 64i64;
      }
      while ( *(_QWORD *)(v1 + 40) );
    }
    else
    {
      result = 0i64;
    }
  }
  return result;
}
// 96A58: using guessed type __int64 qword_96A58;
// 96A78: using guessed type __int64 qword_96A78;
// 96A80: using guessed type __int64 qword_96A80;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000001F58) ----------------------------------------------------
signed __int64 __fastcall sub_1F58(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rbx
  __int64 v4; // rax
  char *v5; // r14
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // r9
  __int64 v8; // rdi
  signed __int64 v9; // rax
  char v10; // cl
  void (__fastcall *v11)(__int64 *, _QWORD); // rax
  signed __int64 v12; // rcx
  __int64 v14; // [rsp+20h] [rbp-80h]
  __int64 v15; // [rsp+28h] [rbp-78h]
  __int64 v16; // [rsp+30h] [rbp-70h]
  __int64 v17; // [rsp+38h] [rbp-68h]
  __int64 v18; // [rsp+40h] [rbp-60h]
  __int64 v19; // [rsp+48h] [rbp-58h]
  __int64 v20; // [rsp+50h] [rbp-50h]
  __int64 v21; // [rsp+58h] [rbp-48h]
  __int64 v22; // [rsp+60h] [rbp-40h]
  __int64 v23; // [rsp+68h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  v20 = -6148914691236517206i64;
  v21 = -6148914691236517206i64;
  v22 = -6148914691236517206i64;
  v23 = -6148914691236517206i64;
  v19 = -6148914691236517206i64;
  v18 = -6148914691236517206i64;
  v17 = -6148914691236517206i64;
  v16 = -6148914691236517206i64;
  v15 = -6148914691236517206i64;
  v14 = -6148914691236517206i64;
  v4 = sub_24103(*(_QWORD *)(a1 + 8));
  if ( v4 )
  {
    v5 = (char *)v4;
    if ( *(_QWORD *)(v2 + 88) )
    {
      (*(void (__fastcall **)(__int64 *, signed __int64, _QWORD))(qword_96CD8 + 360))(&v14, 48i64, 0i64);
      (*(void (__fastcall **)(__int64 *, __int64, signed __int64))(qword_96CD8 + 352))(&v14, v2 + 24, 12i64);
      v16 = *(_QWORD *)(v3 + 48);
      v6 = *(_QWORD *)v3;
      v17 = *(_QWORD *)v3;
      v7 = *(_QWORD *)(v3 + 8);
      v18 = *(_QWORD *)(v3 + 8);
    }
    else
    {
      v6 = *(_QWORD *)v3;
      v7 = *(_QWORD *)(v3 + 8);
    }
    sub_22AE1((__int64)v5, *(unsigned __int64 **)(v2 + 80), v6, v7);
    v8 = sub_2624(2i64, v5, *(_QWORD *)(v3 + 8), (__int64)&v20);
    if ( v8 < 0 )
    {
      v11 = *(void (__fastcall **)(__int64 *, _QWORD))(v2 + 88);
      if ( !v11 )
        goto LABEL_17;
    }
    else
    {
      v9 = sub_236BB(&v20, (_QWORD *)(v3 + 16), 32i64);
      v10 = *(_BYTE *)(v3 + 57);
      if ( v9 )
      {
        *(_BYTE *)(v3 + 57) = v10 & 0xFC;
        --*(_QWORD *)(v2 + 48);
        --*(_QWORD *)(v2 + 40);
        v11 = *(void (__fastcall **)(__int64 *, _QWORD))(v2 + 88);
        if ( !v11 )
        {
          v8 = -9223372036854775793i64;
          goto LABEL_17;
        }
        v12 = -9223372036854775782i64;
        v8 = -9223372036854775793i64;
      }
      else
      {
        *(_BYTE *)(v3 + 57) = v10 | 2;
        --*(_QWORD *)(v2 + 40);
        v11 = *(void (__fastcall **)(__int64 *, _QWORD))(v2 + 88);
        if ( !v11 )
        {
LABEL_17:
          (*(void (__fastcall **)(char *))(qword_96CD8 + 72))(v5);
          return v8;
        }
        v12 = 0i64;
      }
      v19 = v12;
    }
    v11(&v14, *(_QWORD *)(v2 + 96));
    goto LABEL_17;
  }
  return -9223372036854775799i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000020D7) ----------------------------------------------------
void __fastcall sub_20D7(__int64 a1, _QWORD *a2)
{
  __int64 v2; // r15
  _QWORD *v3; // rsi
  unsigned __int64 v4; // rdi
  _BYTE *v5; // rax
  void (__fastcall *v6)(__int64 *, _QWORD); // rax
  unsigned __int64 v7; // rax
  signed __int64 v8; // rdx
  __int64 v9; // rbx
  __int64 v10; // rdi
  signed __int64 v11; // r14
  unsigned __int64 v12; // rsi
  __int64 v13; // r12
  unsigned __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rax
  signed __int64 v17; // rcx
  __int64 v18; // [rsp+28h] [rbp-68h]
  __int64 v19; // [rsp+30h] [rbp-60h]
  __int64 v20; // [rsp+38h] [rbp-58h]
  __int64 v21; // [rsp+40h] [rbp-50h]
  __int64 v22; // [rsp+48h] [rbp-48h]
  __int64 v23; // [rsp+50h] [rbp-40h]

  v2 = (__int64)a2;
  v23 = -6148914691236517206i64;
  v22 = -6148914691236517206i64;
  v21 = -6148914691236517206i64;
  v20 = -6148914691236517206i64;
  v19 = -6148914691236517206i64;
  v18 = -6148914691236517206i64;
  if ( a2[5] )
  {
    if ( a2[7] )
    {
      v3 = (_QWORD *)a2[9];
      v4 = 0i64;
      do
      {
        if ( *v3 )
        {
          if ( *(_QWORD *)(v2 + 88) )
          {
            (*(void (__fastcall **)(__int64 *, signed __int64, _QWORD))(qword_96CD8 + 360))(&v18, 48i64, 0i64);
            (*(void (__fastcall **)(__int64 *, __int64, signed __int64))(qword_96CD8 + 352))(&v18, v2 + 24, 12i64);
            v20 = v3[4];
            v21 = v3[3];
            v22 = v3[1];
          }
          v5 = (_BYTE *)v3[5];
          if ( !(*v5 & 1) )
          {
            --*(_QWORD *)(v2 + 40);
            --*(_QWORD *)(v2 + 48);
            if ( *(_QWORD *)(v2 + 88) )
              v23 = -9223372036854775782i64;
          }
          if ( *v5 & 2 )
          {
            --*(_QWORD *)(v2 + 40);
            if ( *(_QWORD *)(v2 + 88) )
              v23 = 0i64;
          }
          (*(void (__fastcall **)(_QWORD))(qword_96CD8 + 72))(*v3);
          v6 = *(void (__fastcall **)(__int64 *, _QWORD))(v2 + 88);
          if ( v6 )
            v6(&v18, *(_QWORD *)(v2 + 96));
        }
        ++v4;
        v3 += 7;
        v7 = *(_QWORD *)(v2 + 56);
      }
      while ( v4 < v7 );
      v8 = 56 * v7;
    }
    else
    {
      v8 = 0i64;
    }
    (*(void (__fastcall **)(_QWORD, signed __int64, _QWORD))(qword_96CD8 + 360))(*(_QWORD *)(v2 + 72), v8, 0i64);
    if ( *(_QWORD *)(v2 + 40) )
    {
      v9 = *(_QWORD *)(v2 + 56);
      if ( v9 )
      {
        v10 = *(_QWORD *)(v2 + 8);
        v11 = *(_QWORD *)(v2 + 72) - 56i64;
        v12 = 0i64;
        do
        {
          v13 = v9--;
          v14 = *(_QWORD *)(v2 + 56);
          if ( !v14 )
            goto LABEL_25;
          v15 = 0i64;
          while ( *(_QWORD *)(*(_QWORD *)(v2 + 104) + 8 * v15) != v9 )
          {
            if ( ++v15 >= v14 )
            {
LABEL_25:
              while ( v12 < *(_QWORD *)v2 )
              {
                if ( (*(_BYTE *)(v10 + 57) & 3) == 1 )
                {
                  v16 = sub_2470(v10, v2);
                  v17 = 56 * v13;
                  *(_QWORD *)(v11 + v17) = v16;
                  *(_QWORD *)(v11 + v17 + 8) = *(_QWORD *)(v10 + 8);
                  *(_QWORD *)(v11 + v17 + 16) = v10 + 16;
                  *(_QWORD *)(v11 + v17 + 40) = v10 + 57;
                  *(_QWORD *)(v11 + v17 + 24) = *(_QWORD *)v10;
                  *(_QWORD *)(v11 + v17 + 32) = *(_QWORD *)(v10 + 48);
                  ++v12;
                  v10 += 64i64;
                  goto LABEL_29;
                }
                ++v12;
                v10 += 64i64;
              }
              break;
            }
          }
LABEL_29:
          ;
        }
        while ( v9 );
      }
      sub_24B1(v2);
    }
  }
  *(_BYTE *)(v2 + 64) = 0;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000022EC) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_22EC(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rsi

  v2 = (_QWORD *)a2;
  if ( *(_QWORD *)(a2 + 40) )
  {
    if ( !*(_BYTE *)(a2 + 64) )
    {
      if ( *(_QWORD *)(a2 + 40) )
      {
        *(_BYTE *)(a2 + 64) = 1;
        if ( !(*(__int64 (__fastcall **)(__int64, __int64 (__fastcall *)(__int64), _QWORD, __int64, signed __int64, _QWORD, _QWORD))(qword_96A58 + 16))(
                qword_96A58,
                sub_23D4,
                0i64,
                qword_96A78,
                1i64,
                *(_QWORD *)(a2 + 72),
                *(_QWORD *)(a2 + 104)) )
          (*(void (__fastcall **)(__int64))(qword_96CD8 + 104))(qword_96A78);
      }
    }
  }
  if ( !v2[5] && v2[6] == *v2 )
  {
    if ( qword_96A80 )
    {
      if ( (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(qword_96CD8 + 88))(qword_96A80, 0i64, 0i64) >= 0 )
      {
        (*(void (__fastcall **)(__int64))(qword_96CD8 + 112))(qword_96A80);
        qword_96A80 = 0i64;
      }
    }
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 112))(qword_96A78);
    qword_96A78 = 0i64;
  }
}
// 2346: write access to const memory at 96A80 has been detected
// 2362: write access to const memory at 96A78 has been detected
// 96A58: using guessed type __int64 qword_96A58;
// 96A78: using guessed type __int64 qword_96A78;
// 96A80: using guessed type __int64 qword_96A80;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000023D4) ----------------------------------------------------
__int64 __fastcall sub_23D4(__int64 a1)
{
  __int64 v1; // rsi
  __int64 result; // rax
  char *v3; // rdx
  __int64 v4; // rsi
  char *v5; // rcx
  char v6; // dl
  __int64 v7; // [rsp+28h] [rbp-38h]
  __int64 v8; // [rsp+30h] [rbp-30h]
  __int64 v9; // [rsp+38h] [rbp-28h]
  __int64 v10; // [rsp+40h] [rbp-20h]
  __int64 v11; // [rsp+48h] [rbp-18h]

  v1 = a1;
  v7 = -6148914691236517206i64;
  v8 = -6148914691236517206i64;
  v9 = -6148914691236517206i64;
  v10 = -6148914691236517206i64;
  v11 = -6148914691236517206i64;
  (*(void (__fastcall **)(__int64, __int64 *))(qword_96A58 + 56))(qword_96A58, &v7);
  result = 56 * v7;
  v3 = *(char **)(v1 + 56 * v7 - 56);
  if ( v3 )
  {
    v4 = result + v1;
    result = sub_2624(2i64, v3, *(_QWORD *)(v4 - 48), (__int64)&v8);
    if ( result >= 0 )
    {
      result = sub_236BB(&v8, *(_QWORD **)(v4 - 40), 32i64);
      v5 = *(char **)(v4 - 16);
      v6 = *v5;
      if ( result )
      {
        *v5 = v6 & 0xFD;
        result = *(_QWORD *)(v4 - 16);
        *(_BYTE *)result &= 0xFEu;
      }
      else
      {
        *v5 = v6 | 2;
      }
    }
  }
  return result;
}
// 96A58: using guessed type __int64 qword_96A58;

//----- (0000000000002470) ----------------------------------------------------
__int64 __fastcall sub_2470(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned __int64 *v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rsi

  v2 = a2;
  v3 = (unsigned __int64 *)a1;
  v4 = sub_24103(*(_QWORD *)(a1 + 8));
  v5 = v4;
  if ( v4 )
    sub_22AE1(v4, *(unsigned __int64 **)(v2 + 80), *v3, v3[1]);
  return v5;
}

//----- (00000000000024B1) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_24B1(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int64 v2; // rax
  __int64 v3; // rdx
  unsigned __int64 v4; // rdi

  if ( a1 )
  {
    v1 = a1;
    v2 = *(_QWORD *)(a1 + 56);
    if ( !v2 )
      goto LABEL_12;
    v3 = 0i64;
    v4 = 0i64;
    do
      v3 += *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8 * v4++) < v2 + 1;
    while ( v4 < v2 );
    if ( v3 == v2 )
    {
LABEL_12:
      if ( qword_96A80 )
      {
        if ( (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(qword_96CD8 + 88))(qword_96A80, 0i64, 0i64) >= 0 )
        {
          (*(void (__fastcall **)(__int64))(qword_96CD8 + 112))(qword_96A80);
          qword_96A80 = 0i64;
        }
      }
      (*(void (__fastcall **)(__int64))(qword_96CD8 + 112))(qword_96A78);
      qword_96A78 = 0i64;
      *(_BYTE *)(v1 + 112) = 1;
      *(_BYTE *)(v1 + 113) = 1;
    }
  }
}
// 2523: write access to const memory at 96A80 has been detected
// 253F: write access to const memory at 96A78 has been detected
// 96A78: using guessed type __int64 qword_96A78;
// 96A80: using guessed type __int64 qword_96A80;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000255B) ----------------------------------------------------
__int64 __fastcall sub_255B(__int64 a1)
{
  __int64 v1; // rsi
  int v2; // edi
  int v3; // eax
  __int64 result; // rax
  __int64 v5; // rdi
  unsigned __int64 v6; // rbx
  __int64 v7; // [rsp+30h] [rbp-50h]
  __int64 v8; // [rsp+38h] [rbp-48h]
  __int64 v9; // [rsp+40h] [rbp-40h]
  __int64 v10; // [rsp+48h] [rbp-38h]
  __int64 (__fastcall **v11)(_QWORD, __int64 *, signed __int64, __int64, __int64 *); // [rsp+50h] [rbp-30h]

  v1 = a1;
  v11 = (__int64 (__fastcall **)(_QWORD, __int64 *, signed __int64, __int64, __int64 *))-6148914691236517206i64;
  v7 = -6148914691236517206i64;
  v8 = -6148914691236517206i64;
  v9 = -6148914691236517206i64;
  v10 = -6148914691236517206i64;
  v2 = *(_DWORD *)(a1 + 20);
  v3 = sub_23C92(*(_QWORD *)(a1 + 12), 36i64);
  sub_1B89D((char *)v1, v3 + v2, (__int64)&v7);
  result = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 (__fastcall ***)(_QWORD, __int64 *, signed __int64, __int64, __int64 *)))(qword_96CD8 + 320))(
             qword_92B90,
             0i64,
             &v11);
  if ( result >= 0 )
  {
    v5 = v1 + *(_QWORD *)(v1 + 28);
    v6 = -1i64;
    do
    {
      result = (*v11)(v11, &v7, 32i64, v5, qword_91F98);
      if ( result >= 0 )
        break;
      v5 += 256i64;
      ++v6;
    }
    while ( v6 < *(unsigned __int8 *)(v1 + 11) );
  }
  return result;
}
// 91F98: using guessed type __int64 qword_91F98[2];
// 92B90: using guessed type __int64 qword_92B90[2];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000002624) ----------------------------------------------------
__int64 __fastcall sub_2624(__int64 a1, char *a2, unsigned int a3, __int64 a4)
{
  sub_1B89D(a2, a3, a4);
  return 0i64;
}

//----- (0000000000002642) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_BYTE *sub_2642()
{
  __int64 v0; // r9
  __int64 v1; // rax
  __int64 v3; // [rsp+28h] [rbp-8h]

  v3 = -6148914691236517206i64;
  if ( sub_1487D() )
  {
    qword_93678 = 1i64;
    v1 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92C50, 0i64, &v3);
    if ( v1 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`WL:INIT] %r @ LocP %g\n", v1, (__int64)qword_92C50);
    }
    else if ( (*(unsigned __int8 (**)(void))(v3 + 8))() )
    {
      qword_93678 = 2i64;
    }
  }
  return sub_1A2B6(1, (__int64)"[EB|#WL:MODE] %d\n", 0i64, v0);
}
// 2661: write access to const memory at 93678 has been detected
// 2696: write access to const memory at 93678 has been detected
// 92C50: using guessed type __int64 qword_92C50[2];
// 93678: using guessed type __int64 qword_93678;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000026DC) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_26DC()
{
  ;
}
// 2713: write access to const memory at 93678 has been detected
// 93678: using guessed type __int64 qword_93678;

//----- (0000000000002724) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_BYTE *__fastcall sub_2724(char a1, __int64 a2, int a3)
{
  __int64 v3; // r8
  __int64 v4; // r9

  byte_91FA9 = a1;
  if ( a2 )
    byte_91FAB = a2;
  if ( a3 )
    byte_91FAA = a3;
  qword_93680 = 1i64;
  sub_1A2B6(1, (__int64)"[EB|#WL|%d] 0x%02X 0x%02X % 3d 0x%02X", 0i64, 1i64);
  return sub_1A2B6(1, (__int64)"\n", v3, v4);
}
// 2739: write access to const memory at 91FA9 has been detected
// 2744: write access to const memory at 91FAB has been detected
// 2752: write access to const memory at 91FAA has been detected
// 276D: write access to const memory at 93680 has been detected
// 91FA9: using guessed type char byte_91FA9;
// 91FAA: using guessed type char byte_91FAA;
// 91FAB: using guessed type char byte_91FAB;
// 93678: using guessed type __int64 qword_93678;
// 93680: using guessed type __int64 qword_93680;

//----- (0000000000002801) ----------------------------------------------------
__int64 sub_2801()
{
  __int64 v0; // rax
  __int64 v1; // rax
  __int64 v2; // r9
  __int64 v3; // rsi
  __int64 v5; // [rsp+30h] [rbp-10h]

  v5 = 4i64;
  v0 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("w", qword_92360, 0i64);
  if ( v0 < 0 )
  {
    v3 = v0;
    sub_1A2B6(1, (__int64)"[EB|`WL:PWLFNV] %r @ GV %S\n", v0, (__int64)"w");
  }
  else
  {
    v1 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
           "w",
           qword_92360,
           0i64,
           0i64,
           0i64);
    v3 = v1;
    if ( v1 < 0 )
      sub_1A2B6(1, (__int64)"[EB|`WL:PWLFNV] %r @ SV- wake-failure\n", v1, v2);
  }
  return v3;
}
// 92360: using guessed type __int64 qword_92360[2];
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (00000000000028A7) ----------------------------------------------------
signed __int64 __fastcall sub_28A7(char *a1)
{
  char *v1; // rdi
  __int64 v2; // rax
  __int64 v3; // r8
  __int64 v4; // r9
  signed __int64 v5; // rsi
  int v7; // [rsp+28h] [rbp-18h]

  v1 = a1;
  v7 = -1431655766;
  v2 = sub_19819(a1, 4u, 0xB0u);
  v5 = v2;
  if ( v2 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`WL:PWLFRTC] %r @ RTC:R\n", v2, v4);
  }
  else if ( (unsigned __int8)v1[2] | (unsigned __int8)(v1[3] | *v1 | v1[1]) )
  {
    sub_F180((char *)&v7, 0, 4ui64);
    sub_199A0((unsigned __int8 *)&v7, 4u, 0xB0u);
  }
  else
  {
    sub_1A2B6(1, (__int64)"[EB|`WL:PWLFRTC] ! @ RTC:R\n", v3, v4);
    v5 = -9223372036854775794i64;
  }
  return v5;
}

//----- (0000000000002939) ----------------------------------------------------
_BYTE *sub_2939()
{
  __int64 v0; // rax
  __int64 v1; // r9
  __int64 v2; // rsi
  signed __int64 *v3; // rax
  __int64 v4; // r9
  _BYTE *result; // rax
  const char *v6; // rdx
  int v7; // [rsp+30h] [rbp-10h]

  v7 = -1431655766;
  v0 = sub_2801();
  v2 = v0;
  if ( v0 >= 0 )
    goto LABEL_11;
  sub_1A2B6(1, (__int64)"[EB|`WL:DT] %r @ WL:PWLFNV\n", v0, v1);
  result = (_BYTE *)-9223372036854775794i64;
  if ( v2 != -9223372036854775794i64 )
    return result;
  v2 = sub_28A7((char *)&v7);
  if ( v2 >= 0 )
  {
LABEL_11:
    v3 = (signed __int64 *)sub_A398();
    if ( v3 )
    {
      sub_9EC7(v3, "wake-failure", 4ui64, (char *)&v7, 1);
      return sub_1A2B6(1, (__int64)"[EB|#WL:DT] 0x%02X 0x%02X % 3d 0x%02X\n", (unsigned __int8)v7, BYTE1(v7));
    }
    v6 = "[EB|`WL:DT] %r @ DT:FN /chosen\n";
  }
  else
  {
    v6 = "[EB|`WL:DT] %r @ WL:PWLFRTC\n";
  }
  return sub_1A2B6(1, (__int64)v6, v2, v4);
}

//----- (0000000000002A19) ----------------------------------------------------
__int64 sub_2A19()
{
  __int64 v0; // rax
  __int64 v1; // rax
  __int64 v2; // rax
  char **v3; // rbx
  unsigned __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // r9
  __int64 v7; // r9
  __int64 v8; // rbx
  __int64 v9; // rsi
  __int64 v11; // rax
  unsigned __int64 v12; // rdi
  __int64 v13; // r9
  _BYTE *i; // rax
  __int64 v15; // rax
  __int64 v16; // r12
  __int64 v17; // r9
  signed __int64 v18; // rax
  __int64 v19; // r9
  unsigned __int64 v20; // rdi
  __int64 v21; // rbx
  bool v22; // cf
  __int64 v23; // r9
  const char *v24; // rdx
  __int64 v25; // r9
  const char *v26; // rdx
  __int64 v27; // rcx
  __int64 v28; // rax
  __int64 v29; // rdi
  __int64 *v30; // r9
  __int64 v31; // r9
  signed __int64 v32; // rax
  unsigned __int64 v33; // r15
  unsigned __int64 v34; // rbx
  __int64 v35; // r14
  unsigned __int64 v36; // rdi
  unsigned __int64 *v37; // rax
  signed __int64 *v38; // rax
  unsigned __int64 v39; // rcx
  signed __int64 v40; // rbx
  __int64 v41; // rax
  __int64 (__fastcall **v42)(); // r15
  __int64 v43; // r9
  signed __int64 v44; // rdi
  unsigned __int64 v45; // [rsp+30h] [rbp-A0h]
  __int64 v46; // [rsp+38h] [rbp-98h]
  __int64 v47; // [rsp+40h] [rbp-90h]
  __int64 v48; // [rsp+48h] [rbp-88h]
  __int64 v49; // [rsp+50h] [rbp-80h]
  __int64 v50; // [rsp+58h] [rbp-78h]
  __int64 v51; // [rsp+60h] [rbp-70h]
  int v52; // [rsp+68h] [rbp-68h]
  unsigned __int64 v53; // [rsp+70h] [rbp-60h]
  _QWORD *v54; // [rsp+78h] [rbp-58h]
  unsigned __int64 v55; // [rsp+80h] [rbp-50h]
  __int64 (__fastcall **v56)(); // [rsp+88h] [rbp-48h]
  __int64 v57; // [rsp+90h] [rbp-40h]

  v56 = (__int64 (__fastcall **)())-6148914691236517206i64;
  v57 = 0i64;
  v53 = -6148914691236517206i64;
  v50 = 0i64;
  v46 = -6148914691236517206i64;
  v51 = -6148914691236517206i64;
  v52 = -1431655766;
  v45 = 0i64;
  v0 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(qword_96CD8 + 320))(qword_92C70, 0i64);
  if ( v0 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`R:VBI] %r @ LocP %g\n", v0, (__int64)qword_92C70);
    v56 = off_91F38;
    v1 = sub_1C7E();
    if ( v1 < 0 )
      return v1;
  }
  v2 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_91FC8, 0i64, &qword_96A88);
  if ( v2 < 0 )
    sub_1A2B6(1, (__int64)"[EB|`R:VBI] %r @ LocP %g\n", v2, (__int64)qword_91FC8);
  v47 = -6148914691236517206i64;
  v55 = -6148914691236517206i64;
  v3 = off_91FB0;
  v4 = 0i64;
  while ( 1 )
  {
    v5 = sub_F1CC((char *)qword_96AA0, *v3, &v47, (char **)&v55);
    if ( v5 >= 0 )
      break;
    ++v4;
    ++v3;
    if ( v4 >= 3 )
    {
      v6 = v55;
      goto LABEL_14;
    }
  }
  if ( !v55 )
  {
    v6 = 0i64;
LABEL_14:
    sub_1A2B6(1, (__int64)"[EB|`R:GBII] %r, %qd @ 'BIARG\n", v5, v6);
    v8 = -9223372036854775794i64;
LABEL_15:
    v9 = 0i64;
    goto LABEL_16;
  }
  sub_1A2B6(1, (__int64)"[EB|#R:BIARG] %.*e\n", v55, v47);
  if ( v55 < 7 || sub_238B5((unsigned __int8 *)v47, "file://", 7ui64) )
  {
    v8 = -9223372036854775805i64;
    sub_1A2B6(1, (__int64)"[EB|`R:GBII] %r @ 'PFX\n", -9223372036854775805i64, v7);
    goto LABEL_15;
  }
  v11 = sub_1364F(v55 + 3);
  v9 = v11;
  v12 = v55;
  if ( v55 >= 9 )
  {
    do
    {
      if ( *(_BYTE *)(v47 + v12) == 46 )
        break;
      --v12;
    }
    while ( v12 > 8 );
  }
  sub_23853(v11, (char *)(v47 + 7), v12 - 7);
  *(_BYTE *)(v9 + v12 - 7) = 0;
  for ( i = (_BYTE *)v9; *i == 47; ++i )
  {
    *i = 92;
LABEL_32:
    ;
  }
  if ( *i )
    goto LABEL_32;
  sub_1A2B6(1, (__int64)"[EB|#R:IBN] %e\n", v9, v13);
  v15 = sub_1364F(2048i64);
  if ( !v15 )
  {
    v8 = -9223372036854775799i64;
    goto LABEL_16;
  }
  v16 = v15;
  sub_22ED4(v15, 1024i64, (__int64)L"%a.chunklist", v9);
  sub_1A2B6(1, (__int64)"[EB|#R:CL] %E\n", v16, v17);
  v18 = sub_D739(0i64, qword_96AE8, v16, 0i64, &v53, &v57);
  if ( v18 < 0 )
  {
    v8 = v18;
    v26 = "[EB|`R:VBI] %r @ LD:LF CL\n";
LABEL_45:
    sub_1A2B6(1, (__int64)v26, v8, v19);
LABEL_46:
    v27 = v16;
    goto LABEL_47;
  }
  v20 = v53;
  if ( v53 < 0x24
    || *(_QWORD *)(v57 + 20) >> 32
    || *(_QWORD *)(v57 + 12) >> 32
    || *(_DWORD *)(v57 + 32)
    || (v21 = *(_QWORD *)(v57 + 20), v22 = v20 < v21 + sub_23C92(*(_QWORD *)(v57 + 12), 36i64), v20 = v53, v22)
    || v53 < ((unsigned __int64)*(unsigned __int8 *)(v57 + 11) << 8) + *(_QWORD *)(v57 + 28) + 256 )
  {
    v8 = -9223372036854775804i64;
    v24 = "[EB|`R:VBI] %r @ 'CLS: %qd\n";
    v25 = v20;
    goto LABEL_42;
  }
  sub_1A2B6(1, (__int64)"[EB|#R:SM] %d\n", *(unsigned __int8 *)(v57 + 10), v23);
  if ( qword_96A88 && (unsigned __int8)(*(_BYTE *)(v57 + 10) - 3) <= 1u )
  {
    v28 = (*(__int64 (__fastcall **)(__int64, unsigned __int64, _QWORD))(qword_96A88 + 16))(v57, v53, 0i64);
    v29 = v28;
    v30 = qword_91FC8;
  }
  else
  {
    v28 = ((__int64 (__fastcall *)(__int64))v56[8])(v57);
    v29 = v28;
    v30 = qword_92C70;
  }
  sub_1A2B6(1, (__int64)"[EB|`R:VBI] %r @ %g.VCLS\n", v28, (__int64)v30);
  if ( v29 < 0 )
  {
    v8 = -9223372036854775784i64;
    if ( v29 != -9223372036854775794i64 )
      v8 = v29;
    v26 = "[EB|`R:VBI] %r @ VCL\n";
    goto LABEL_45;
  }
  sub_22ED4(v16, 1024i64, (__int64)"%", v9);
  sub_1A2B6(1, (__int64)"[EB|#R:DMG] %E\n", v16, v31);
  v32 = sub_D739(0i64, qword_96AE8, v16, 0i64, &v46, &v50);
  if ( v32 < 0 )
  {
    v8 = v32;
    v26 = "[EB|`R:VBI] %r @ LD:LF DMG\n";
    goto LABEL_45;
  }
  ((void (__fastcall *)(__int64, unsigned __int64 *))v56[6])(v57, &v45);
  v33 = v45;
  if ( v45 != v46 )
  {
    v8 = -9223372036854775804i64;
    v24 = "[EB|`R:VBI] %r @ 'CLS: (A: %qd, D: %qd)\n";
    v25 = v45;
LABEL_42:
    sub_1A2B6(1, (__int64)v24, -9223372036854775804i64, v25);
    goto LABEL_46;
  }
  v34 = v45 + 10485759;
  v35 = v50;
  v36 = (unsigned __int64)(0xCCCCCCCCCCCCCCCDui64 * (unsigned __int128)(v45 + 10485759) >> 64) >> 23;
  v54 = (_QWORD *)sub_1364F(16 * v36 + 24);
  if ( !v54 )
  {
    v8 = -9223372036854775799i64;
    goto LABEL_46;
  }
  v37 = v54;
  v54[1] = 0i64;
  v37[2] = v33;
  *v37 = v36;
  if ( v34 >= 0xA00000 )
  {
    v38 = v54 + 4;
    v39 = 0i64;
    do
    {
      *(v38 - 1) = v35;
      v40 = 10485760i64;
      if ( v33 < 0xA00000 )
        v40 = v33;
      *v38 = v40;
      v33 -= v40;
      ++v39;
      v38 += 2;
      v35 += 10485760i64;
    }
    while ( v39 < v36 );
  }
  v51 = *(_QWORD *)(*(_QWORD *)(v57 + 20) + v57 + 4);
  v52 = -889274641;
  v41 = ((__int64 (__fastcall *)(__int64 *, __int64, _QWORD *))*v56)(&v51, v57, v54);
  if ( v41 < 0 )
  {
    v8 = v41;
    sub_1A2B6(1, (__int64)"[EB|`R:VBI] %r @ %g.INIT\n", v41, (__int64)qword_92C70);
  }
  else
  {
    v42 = v56;
    v47 = -6148914691236517206i64;
    v48 = -6148914691236517206i64;
    v49 = -6148914691236517206i64;
    v8 = ((__int64 (__fastcall *)(__int64 *, __int64 *))v56[1])(&v51, &v47);
    if ( v48 && v49 == v47 )
    {
      v44 = -59i64;
      do
      {
        (*(void (__fastcall **)(signed __int64))(qword_96CD8 + 248))(5000000i64);
        v8 = ((__int64 (__fastcall *)(__int64 *, __int64 *))v42[1])(&v51, &v47);
        if ( !v48 )
          break;
        if ( !v44 )
          break;
        ++v44;
      }
      while ( v49 == v47 );
    }
    if ( v8 < 0 )
      sub_1A2B6(1, (__int64)"[EB|`R:VBI] %r @ R:WAIT\n", v8, v43);
    ((void (__fastcall *)(__int64 *))v56[9])(&v51);
  }
  sub_136C5(v16);
  v27 = (__int64)v54;
LABEL_47:
  sub_136C5(v27);
LABEL_16:
  if ( v50 )
    sub_136C5(v50);
  if ( v57 )
    sub_136C5(v57);
  if ( v9 )
    sub_136C5(v9);
  return v8;
}
// 40378: using guessed type __int16 aAChunklist[13];
// 91F38: using guessed type __int64 (__fastcall *off_91F38[12])();
// 91FB0: using guessed type char *off_91FB0[3];
// 91FC8: using guessed type __int64 qword_91FC8[2];
// 92C70: using guessed type __int64[2];
// 96A88: using guessed type __int64 qword_96A88;
// 96AA0: using guessed type __int64 qword_96AA0;
// 96AE8: using guessed type __int64 qword_96AE8;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000030C0) ----------------------------------------------------
_DWORD *__fastcall sub_30C0(__int64 a1)
{
  unsigned int v1; // er8
  _DWORD *result; // rax
  _DWORD *v3; // rcx
  int v4; // er9

  v1 = *(_DWORD *)(a1 + 16);
  result = 0i64;
  if ( v1 )
  {
    v3 = (_DWORD *)(a1 + 32);
    v4 = 0;
    while ( *v3 != 25 )
    {
      v3 = (_DWORD *)((char *)v3 + (unsigned int)v3[1]);
      if ( ++v4 >= v1 )
        return result;
    }
    result = v3;
  }
  return result;
}

//----- (00000000000030F0) ----------------------------------------------------
_DWORD *__fastcall sub_30F0(__int64 a1, signed __int64 a2)
{
  signed __int64 v2; // r8
  unsigned int v3; // er9
  unsigned int v4; // ecx
  unsigned int v5; // ecx
  _DWORD *v6; // r8
  _DWORD *result; // rax

  v2 = a1 + 32;
  v3 = *(_DWORD *)(a1 + 16);
  v4 = 0;
  while ( v2 != a2 )
  {
    if ( v4 >= v3 )
    {
      a2 = v2;
      break;
    }
    v2 += *(unsigned int *)(v2 + 4);
    ++v4;
  }
  v5 = v4 + 1;
  if ( v5 >= v3 )
    return 0i64;
  v6 = (_DWORD *)(*(unsigned int *)(a2 + 4) + v2);
  result = 0i64;
  while ( *v6 != 25 )
  {
    v6 = (_DWORD *)((char *)v6 + (unsigned int)v6[1]);
    if ( ++v5 >= v3 )
      return result;
  }
  return v6;
}

//----- (0000000000003144) ----------------------------------------------------
signed __int64 __fastcall sub_3144(__int64 a1)
{
  signed __int64 result; // rax

  if ( a1 && *(_DWORD *)(a1 + 64) )
    result = a1 + 72;
  else
    result = 0i64;
  return result;
}

//----- (0000000000003160) ----------------------------------------------------
signed __int64 __fastcall sub_3160(__int64 a1, __int64 a2)
{
  unsigned int v2; // er8
  __int64 v3; // rcx
  unsigned __int64 v4; // rcx
  __int64 v5; // rdx
  signed __int64 result; // rax

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 64);
    if ( v2 )
    {
      v3 = a1 + 72;
      goto LABEL_7;
    }
    v2 = 0;
  }
  else
  {
    v2 = (unsigned int)MEMORY[0x40];
  }
  v3 = 0i64;
LABEL_7:
  v4 = -3689348814741910323i64 * ((a2 - v3) >> 4) + 1;
  v5 = a2 + 80;
  result = 0i64;
  if ( v4 < v2 )
    result = v5;
  return result;
}
// 40: using guessed type __int64 (__fastcall *)(_QWORD, _QWORD);

//----- (00000000000031B4) ----------------------------------------------------
signed __int64 sub_31B4()
{
  int v0; // eax
  _DWORD *v1; // rcx
  __int64 v2; // r8
  int *v3; // rdx
  int *v4; // rsi
  __int64 v5; // rax
  int *v7; // r11
  unsigned int v8; // eax
  __m128i v9; // xmm0
  __m128i v10; // xmm1
  __m128i v11; // xmm2
  int *v12; // r10
  int v13; // er8
  int v14; // ebx
  int v15; // ecx
  int v16; // edx
  int v17; // er8
  int v18; // edx
  unsigned int v19; // eax
  int v20; // ecx
  int v21; // ebx
  unsigned int v22; // eax
  int v23; // ebx
  int v24; // er8
  int v25; // edx
  int v26; // ecx
  unsigned int v27; // eax
  int v28; // ecx
  int v29; // ebx
  int v30; // er8
  int v31; // edx
  unsigned int v32; // eax
  int v33; // edx
  int v34; // ecx
  int v35; // ebx
  int v36; // er8
  int v37; // edx
  unsigned int v38; // eax
  int v39; // ecx
  int v40; // ebx
  unsigned int v41; // eax
  int v42; // ebx
  int v43; // er8
  int v44; // edx
  int v45; // ecx
  unsigned int v46; // eax
  int v47; // ecx
  int v48; // ebx
  int v49; // er8
  int v50; // edx
  unsigned int v51; // eax
  int v52; // edx
  int v53; // ecx
  int v54; // ebx

  LOBYTE(v0) = sub_9DAB();
  JUMPOUT(v0, 0, sub_1F3B0);
  v4 = v3;
  v5 = *(unsigned __int8 *)(v2 + 240);
  if ( v5 != 160 && v5 != 192 && v5 != 224 )
    return -1i64;
  v7 = (int *)(v2 + v5);
  v8 = *(_DWORD *)v2 ^ *v1;
  v9 = _mm_cvtsi32_si128(*(_DWORD *)(v2 + 4) ^ v1[1]);
  v10 = _mm_cvtsi32_si128(*(_DWORD *)(v2 + 8) ^ v1[2]);
  v11 = _mm_cvtsi32_si128(*(_DWORD *)(v2 + 12) ^ v1[3]);
  v12 = (int *)(v2 + 16);
  v13 = *(_DWORD *)(v2 + 16);
  v14 = v12[1];
  v15 = v12[2];
  v16 = v12[3];
  do
  {
    v17 = dword_4F38C[(unsigned __int8)v8] ^ v13;
    v18 = dword_4F38C[BYTE1(v8) + 256] ^ v16;
    v19 = v8 >> 16;
    v20 = dword_4F38C[(unsigned __int8)v19 + 512] ^ v15;
    v21 = dword_4F38C[BYTE1(v19) + 768] ^ v14;
    v22 = _mm_cvtsi128_si32(v9);
    v23 = dword_4F38C[(unsigned __int8)v22] ^ v21;
    v24 = dword_4F38C[BYTE1(v22) + 256] ^ v17;
    v22 >>= 16;
    v25 = dword_4F38C[(unsigned __int8)v22 + 512] ^ v18;
    v26 = dword_4F38C[BYTE1(v22) + 768] ^ v20;
    v27 = _mm_cvtsi128_si32(v10);
    v28 = dword_4F38C[(unsigned __int8)v27] ^ v26;
    v29 = dword_4F38C[BYTE1(v27) + 256] ^ v23;
    v27 >>= 16;
    v30 = dword_4F38C[(unsigned __int8)v27 + 512] ^ v24;
    v31 = dword_4F38C[BYTE1(v27) + 768] ^ v25;
    v32 = _mm_cvtsi128_si32(v11);
    v33 = dword_4F38C[(unsigned __int8)v32] ^ v31;
    v34 = dword_4F38C[BYTE1(v32) + 256] ^ v28;
    v32 >>= 16;
    v35 = dword_4F38C[(unsigned __int8)v32 + 512] ^ v29;
    v12 += 4;
    v8 = dword_4F38C[BYTE1(v32) + 768] ^ v30;
    v13 = *v12;
    v9 = _mm_cvtsi32_si128(v35);
    v14 = v12[1];
    v10 = _mm_cvtsi32_si128(v34);
    v15 = v12[2];
    v11 = _mm_cvtsi32_si128(v33);
    v16 = v12[3];
  }
  while ( v12 != v7 );
  v36 = dword_5138C[(unsigned __int8)v8] ^ v13;
  v37 = dword_5138C[BYTE1(v8) + 256] ^ v16;
  v38 = v8 >> 16;
  v39 = dword_5138C[(unsigned __int8)v38 + 512] ^ v15;
  v40 = dword_5138C[BYTE1(v38) + 768] ^ v14;
  v41 = _mm_cvtsi128_si32(v9);
  v42 = dword_5138C[(unsigned __int8)v41] ^ v40;
  v43 = dword_5138C[BYTE1(v41) + 256] ^ v36;
  v41 >>= 16;
  v44 = dword_5138C[(unsigned __int8)v41 + 512] ^ v37;
  v45 = dword_5138C[BYTE1(v41) + 768] ^ v39;
  v46 = _mm_cvtsi128_si32(v10);
  v47 = dword_5138C[(unsigned __int8)v46] ^ v45;
  v48 = dword_5138C[BYTE1(v46) + 256] ^ v42;
  v46 >>= 16;
  v49 = dword_5138C[(unsigned __int8)v46 + 512] ^ v43;
  v50 = dword_5138C[BYTE1(v46) + 768] ^ v44;
  v51 = _mm_cvtsi128_si32(v11);
  v52 = dword_5138C[(unsigned __int8)v51] ^ v50;
  v53 = dword_5138C[BYTE1(v51) + 256] ^ v47;
  v51 >>= 16;
  v54 = dword_5138C[(unsigned __int8)v51 + 512] ^ v48;
  *v4 = dword_5138C[BYTE1(v51) + 768] ^ v49;
  v4[1] = v54;
  v4[2] = v53;
  v4[3] = v52;
  return 0i64;
}
// 4F38C: using guessed type int dword_4F38C[];
// 5138C: using guessed type int dword_5138C[];

//----- (000000000000341F) ----------------------------------------------------
signed __int64 sub_341F()
{
  int v0; // eax
  _DWORD *v1; // rcx
  __int64 v2; // r8
  int *v3; // rdx
  int *v4; // rsi
  __int64 v5; // rax
  int *v7; // r11
  _DWORD *v8; // r10
  unsigned int v9; // eax
  __m128i v10; // xmm0
  __m128i v11; // xmm1
  __m128i v12; // xmm2
  int *v13; // r10
  int v14; // er8
  int v15; // ebx
  int v16; // ecx
  int v17; // edx
  int v18; // er8
  int v19; // ebx
  unsigned int v20; // eax
  int v21; // ecx
  int v22; // edx
  unsigned int v23; // eax
  int v24; // ebx
  int v25; // ecx
  int v26; // edx
  int v27; // er8
  unsigned int v28; // eax
  int v29; // ecx
  int v30; // edx
  int v31; // er8
  int v32; // ebx
  unsigned int v33; // eax
  int v34; // edx
  int v35; // er8
  int v36; // ebx
  int v37; // ecx
  int v38; // er8
  int v39; // ebx
  unsigned int v40; // eax
  int v41; // ecx
  int v42; // edx
  unsigned int v43; // eax
  int v44; // ebx
  int v45; // ecx
  int v46; // edx
  int v47; // er8
  unsigned int v48; // eax
  int v49; // ecx
  int v50; // edx
  int v51; // er8
  int v52; // ebx
  unsigned int v53; // eax
  int v54; // edx
  int v55; // er8
  int v56; // ebx
  int v57; // ecx

  LOBYTE(v0) = sub_9DAB();
  JUMPOUT(v0, 0, sub_1F770);
  v4 = v3;
  v5 = *(unsigned __int8 *)(v2 + 240);
  if ( v5 != 160 && v5 != 192 && v5 != 224 )
    return -1i64;
  v7 = (int *)v2;
  v8 = (_DWORD *)(v5 + v2);
  v9 = *(_DWORD *)(v5 + v2) ^ *v1;
  v10 = _mm_cvtsi32_si128(v8[1] ^ v1[1]);
  v11 = _mm_cvtsi32_si128(v8[2] ^ v1[2]);
  v12 = _mm_cvtsi32_si128(v8[3] ^ v1[3]);
  v13 = v8 - 4;
  v14 = *v13;
  v15 = v13[1];
  v16 = v13[2];
  v17 = v13[3];
  do
  {
    v18 = dword_5038C[(unsigned __int8)v9] ^ v14;
    v19 = dword_5038C[BYTE1(v9) + 256] ^ v15;
    v20 = v9 >> 16;
    v21 = dword_5038C[(unsigned __int8)v20 + 512] ^ v16;
    v22 = dword_5038C[BYTE1(v20) + 768] ^ v17;
    v23 = _mm_cvtsi128_si32(v10);
    v24 = dword_5038C[(unsigned __int8)v23] ^ v19;
    v25 = dword_5038C[BYTE1(v23) + 256] ^ v21;
    v23 >>= 16;
    v26 = dword_5038C[(unsigned __int8)v23 + 512] ^ v22;
    v27 = dword_5038C[BYTE1(v23) + 768] ^ v18;
    v28 = _mm_cvtsi128_si32(v11);
    v29 = dword_5038C[(unsigned __int8)v28] ^ v25;
    v30 = dword_5038C[BYTE1(v28) + 256] ^ v26;
    v28 >>= 16;
    v31 = dword_5038C[(unsigned __int8)v28 + 512] ^ v27;
    v32 = dword_5038C[BYTE1(v28) + 768] ^ v24;
    v33 = _mm_cvtsi128_si32(v12);
    v34 = dword_5038C[(unsigned __int8)v33] ^ v30;
    v35 = dword_5038C[BYTE1(v33) + 256] ^ v31;
    v33 >>= 16;
    v36 = dword_5038C[(unsigned __int8)v33 + 512] ^ v32;
    v37 = dword_5038C[BYTE1(v33) + 768] ^ v29;
    v13 -= 4;
    v9 = v35;
    v14 = *v13;
    v10 = _mm_cvtsi32_si128(v36);
    v15 = v13[1];
    v11 = _mm_cvtsi32_si128(v37);
    v16 = v13[2];
    v12 = _mm_cvtsi32_si128(v34);
    v17 = v13[3];
  }
  while ( v13 != v7 );
  v38 = dword_5238C[(unsigned __int8)v9] ^ v14;
  v39 = dword_5238C[BYTE1(v9) + 256] ^ v15;
  v40 = v9 >> 16;
  v41 = dword_5238C[(unsigned __int8)v40 + 512] ^ v16;
  v42 = dword_5238C[BYTE1(v40) + 768] ^ v17;
  v43 = _mm_cvtsi128_si32(v10);
  v44 = dword_5238C[(unsigned __int8)v43] ^ v39;
  v45 = dword_5238C[BYTE1(v43) + 256] ^ v41;
  v43 >>= 16;
  v46 = dword_5238C[(unsigned __int8)v43 + 512] ^ v42;
  v47 = dword_5238C[BYTE1(v43) + 768] ^ v38;
  v48 = _mm_cvtsi128_si32(v11);
  v49 = dword_5238C[(unsigned __int8)v48] ^ v45;
  v50 = dword_5238C[BYTE1(v48) + 256] ^ v46;
  v48 >>= 16;
  v51 = dword_5238C[(unsigned __int8)v48 + 512] ^ v47;
  v52 = dword_5238C[BYTE1(v48) + 768] ^ v44;
  v53 = _mm_cvtsi128_si32(v12);
  v54 = dword_5238C[(unsigned __int8)v53] ^ v50;
  v55 = dword_5238C[BYTE1(v53) + 256] ^ v51;
  v53 >>= 16;
  v56 = dword_5238C[(unsigned __int8)v53 + 512] ^ v52;
  v57 = dword_5238C[BYTE1(v53) + 768] ^ v49;
  *v4 = v55;
  v4[1] = v56;
  v4[2] = v57;
  v4[3] = v54;
  return 0i64;
}
// 5038C: using guessed type int dword_5038C[];
// 5238C: using guessed type int dword_5238C[];

//----- (000000000000368A) ----------------------------------------------------
signed __int64 __fastcall sub_368A(_DWORD *a1, int *a2, __int64 a3)
{
  int *v3; // rsi
  __int64 v4; // rax
  int *v6; // r11
  unsigned int v7; // eax
  __m128i v8; // xmm0
  __m128i v9; // xmm1
  __m128i v10; // xmm2
  int *v11; // r10
  int v12; // er8
  int v13; // ebx
  int v14; // ecx
  int v15; // edx
  int v16; // er8
  int v17; // edx
  unsigned int v18; // eax
  int v19; // ecx
  int v20; // ebx
  unsigned int v21; // eax
  int v22; // ebx
  int v23; // er8
  int v24; // edx
  int v25; // ecx
  unsigned int v26; // eax
  int v27; // ecx
  int v28; // ebx
  int v29; // er8
  int v30; // edx
  unsigned int v31; // eax
  int v32; // edx
  int v33; // ecx
  int v34; // ebx
  int v35; // er8
  int v36; // edx
  unsigned int v37; // eax
  int v38; // ecx
  int v39; // ebx
  unsigned int v40; // eax
  int v41; // ebx
  int v42; // er8
  int v43; // edx
  int v44; // ecx
  unsigned int v45; // eax
  int v46; // ecx
  int v47; // ebx
  int v48; // er8
  int v49; // edx
  unsigned int v50; // eax
  int v51; // edx
  int v52; // ecx
  int v53; // ebx

  v3 = a2;
  v4 = *(unsigned __int8 *)(a3 + 240);
  if ( v4 != 160 && v4 != 192 && v4 != 224 )
    return -1i64;
  v6 = (int *)(a3 + v4);
  v7 = *(_DWORD *)a3 ^ *a1;
  v8 = _mm_cvtsi32_si128(*(_DWORD *)(a3 + 4) ^ a1[1]);
  v9 = _mm_cvtsi32_si128(*(_DWORD *)(a3 + 8) ^ a1[2]);
  v10 = _mm_cvtsi32_si128(*(_DWORD *)(a3 + 12) ^ a1[3]);
  v11 = (int *)(a3 + 16);
  v12 = *(_DWORD *)(a3 + 16);
  v13 = v11[1];
  v14 = v11[2];
  v15 = v11[3];
  do
  {
    v16 = dword_4F38C[(unsigned __int8)v7] ^ v12;
    v17 = dword_4F38C[BYTE1(v7) + 256] ^ v15;
    v18 = v7 >> 16;
    v19 = dword_4F38C[(unsigned __int8)v18 + 512] ^ v14;
    v20 = dword_4F38C[BYTE1(v18) + 768] ^ v13;
    v21 = _mm_cvtsi128_si32(v8);
    v22 = dword_4F38C[(unsigned __int8)v21] ^ v20;
    v23 = dword_4F38C[BYTE1(v21) + 256] ^ v16;
    v21 >>= 16;
    v24 = dword_4F38C[(unsigned __int8)v21 + 512] ^ v17;
    v25 = dword_4F38C[BYTE1(v21) + 768] ^ v19;
    v26 = _mm_cvtsi128_si32(v9);
    v27 = dword_4F38C[(unsigned __int8)v26] ^ v25;
    v28 = dword_4F38C[BYTE1(v26) + 256] ^ v22;
    v26 >>= 16;
    v29 = dword_4F38C[(unsigned __int8)v26 + 512] ^ v23;
    v30 = dword_4F38C[BYTE1(v26) + 768] ^ v24;
    v31 = _mm_cvtsi128_si32(v10);
    v32 = dword_4F38C[(unsigned __int8)v31] ^ v30;
    v33 = dword_4F38C[BYTE1(v31) + 256] ^ v27;
    v31 >>= 16;
    v34 = dword_4F38C[(unsigned __int8)v31 + 512] ^ v28;
    v11 += 4;
    v7 = dword_4F38C[BYTE1(v31) + 768] ^ v29;
    v12 = *v11;
    v8 = _mm_cvtsi32_si128(v34);
    v13 = v11[1];
    v9 = _mm_cvtsi32_si128(v33);
    v14 = v11[2];
    v10 = _mm_cvtsi32_si128(v32);
    v15 = v11[3];
  }
  while ( v11 != v6 );
  v35 = dword_5138C[(unsigned __int8)v7] ^ v12;
  v36 = dword_5138C[BYTE1(v7) + 256] ^ v15;
  v37 = v7 >> 16;
  v38 = dword_5138C[(unsigned __int8)v37 + 512] ^ v14;
  v39 = dword_5138C[BYTE1(v37) + 768] ^ v13;
  v40 = _mm_cvtsi128_si32(v8);
  v41 = dword_5138C[(unsigned __int8)v40] ^ v39;
  v42 = dword_5138C[BYTE1(v40) + 256] ^ v35;
  v40 >>= 16;
  v43 = dword_5138C[(unsigned __int8)v40 + 512] ^ v36;
  v44 = dword_5138C[BYTE1(v40) + 768] ^ v38;
  v45 = _mm_cvtsi128_si32(v9);
  v46 = dword_5138C[(unsigned __int8)v45] ^ v44;
  v47 = dword_5138C[BYTE1(v45) + 256] ^ v41;
  v45 >>= 16;
  v48 = dword_5138C[(unsigned __int8)v45 + 512] ^ v42;
  v49 = dword_5138C[BYTE1(v45) + 768] ^ v43;
  v50 = _mm_cvtsi128_si32(v10);
  v51 = dword_5138C[(unsigned __int8)v50] ^ v49;
  v52 = dword_5138C[BYTE1(v50) + 256] ^ v46;
  v50 >>= 16;
  v53 = dword_5138C[(unsigned __int8)v50 + 512] ^ v47;
  *v3 = dword_5138C[BYTE1(v50) + 768] ^ v48;
  v3[1] = v53;
  v3[2] = v52;
  v3[3] = v51;
  return 0i64;
}
// 4F38C: using guessed type int[];
// 5138C: using guessed type int[];

//----- (00000000000038CC) ----------------------------------------------------
signed __int64 __fastcall sub_38CC(_DWORD *a1, int *a2, __int64 a3)
{
  int *v3; // rsi
  __int64 v4; // rax
  int *v6; // r11
  _DWORD *v7; // r10
  unsigned int v8; // eax
  __m128i v9; // xmm0
  __m128i v10; // xmm1
  __m128i v11; // xmm2
  int *v12; // r10
  int v13; // er8
  int v14; // ebx
  int v15; // ecx
  int v16; // edx
  int v17; // er8
  int v18; // ebx
  unsigned int v19; // eax
  int v20; // ecx
  int v21; // edx
  unsigned int v22; // eax
  int v23; // ebx
  int v24; // ecx
  int v25; // edx
  int v26; // er8
  unsigned int v27; // eax
  int v28; // ecx
  int v29; // edx
  int v30; // er8
  int v31; // ebx
  unsigned int v32; // eax
  int v33; // edx
  int v34; // er8
  int v35; // ebx
  int v36; // ecx
  int v37; // er8
  int v38; // ebx
  unsigned int v39; // eax
  int v40; // ecx
  int v41; // edx
  unsigned int v42; // eax
  int v43; // ebx
  int v44; // ecx
  int v45; // edx
  int v46; // er8
  unsigned int v47; // eax
  int v48; // ecx
  int v49; // edx
  int v50; // er8
  int v51; // ebx
  unsigned int v52; // eax
  int v53; // edx
  int v54; // er8
  int v55; // ebx
  int v56; // ecx

  v3 = a2;
  v4 = *(unsigned __int8 *)(a3 + 240);
  if ( v4 != 160 && v4 != 192 && v4 != 224 )
    return -1i64;
  v6 = (int *)a3;
  v7 = (_DWORD *)(v4 + a3);
  v8 = *(_DWORD *)(v4 + a3) ^ *a1;
  v9 = _mm_cvtsi32_si128(v7[1] ^ a1[1]);
  v10 = _mm_cvtsi32_si128(v7[2] ^ a1[2]);
  v11 = _mm_cvtsi32_si128(v7[3] ^ a1[3]);
  v12 = v7 - 4;
  v13 = *v12;
  v14 = v12[1];
  v15 = v12[2];
  v16 = v12[3];
  do
  {
    v17 = dword_5038C[(unsigned __int8)v8] ^ v13;
    v18 = dword_5038C[BYTE1(v8) + 256] ^ v14;
    v19 = v8 >> 16;
    v20 = dword_5038C[(unsigned __int8)v19 + 512] ^ v15;
    v21 = dword_5038C[BYTE1(v19) + 768] ^ v16;
    v22 = _mm_cvtsi128_si32(v9);
    v23 = dword_5038C[(unsigned __int8)v22] ^ v18;
    v24 = dword_5038C[BYTE1(v22) + 256] ^ v20;
    v22 >>= 16;
    v25 = dword_5038C[(unsigned __int8)v22 + 512] ^ v21;
    v26 = dword_5038C[BYTE1(v22) + 768] ^ v17;
    v27 = _mm_cvtsi128_si32(v10);
    v28 = dword_5038C[(unsigned __int8)v27] ^ v24;
    v29 = dword_5038C[BYTE1(v27) + 256] ^ v25;
    v27 >>= 16;
    v30 = dword_5038C[(unsigned __int8)v27 + 512] ^ v26;
    v31 = dword_5038C[BYTE1(v27) + 768] ^ v23;
    v32 = _mm_cvtsi128_si32(v11);
    v33 = dword_5038C[(unsigned __int8)v32] ^ v29;
    v34 = dword_5038C[BYTE1(v32) + 256] ^ v30;
    v32 >>= 16;
    v35 = dword_5038C[(unsigned __int8)v32 + 512] ^ v31;
    v36 = dword_5038C[BYTE1(v32) + 768] ^ v28;
    v12 -= 4;
    v8 = v34;
    v13 = *v12;
    v9 = _mm_cvtsi32_si128(v35);
    v14 = v12[1];
    v10 = _mm_cvtsi32_si128(v36);
    v15 = v12[2];
    v11 = _mm_cvtsi32_si128(v33);
    v16 = v12[3];
  }
  while ( v12 != v6 );
  v37 = dword_5238C[(unsigned __int8)v8] ^ v13;
  v38 = dword_5238C[BYTE1(v8) + 256] ^ v14;
  v39 = v8 >> 16;
  v40 = dword_5238C[(unsigned __int8)v39 + 512] ^ v15;
  v41 = dword_5238C[BYTE1(v39) + 768] ^ v16;
  v42 = _mm_cvtsi128_si32(v9);
  v43 = dword_5238C[(unsigned __int8)v42] ^ v38;
  v44 = dword_5238C[BYTE1(v42) + 256] ^ v40;
  v42 >>= 16;
  v45 = dword_5238C[(unsigned __int8)v42 + 512] ^ v41;
  v46 = dword_5238C[BYTE1(v42) + 768] ^ v37;
  v47 = _mm_cvtsi128_si32(v10);
  v48 = dword_5238C[(unsigned __int8)v47] ^ v44;
  v49 = dword_5238C[BYTE1(v47) + 256] ^ v45;
  v47 >>= 16;
  v50 = dword_5238C[(unsigned __int8)v47 + 512] ^ v46;
  v51 = dword_5238C[BYTE1(v47) + 768] ^ v43;
  v52 = _mm_cvtsi128_si32(v11);
  v53 = dword_5238C[(unsigned __int8)v52] ^ v49;
  v54 = dword_5238C[BYTE1(v52) + 256] ^ v50;
  v52 >>= 16;
  v55 = dword_5238C[(unsigned __int8)v52 + 512] ^ v51;
  v56 = dword_5238C[BYTE1(v52) + 768] ^ v48;
  *v3 = v54;
  v3[1] = v55;
  v3[2] = v56;
  v3[3] = v53;
  return 0i64;
}
// 5038C: using guessed type int dword_5038C[];
// 5238C: using guessed type int dword_5238C[];

//----- (0000000000003B0E) ----------------------------------------------------
__m128 __usercall sub_3B0E@<xmm0>(signed int a1@<edx>, unsigned int *a2@<rcx>, __int64 a3@<r8>, __m128 result@<xmm0>)
{
  int v4; // er9
  unsigned int *v5; // rsi
  bool v6; // zf
  unsigned int v7; // edx
  unsigned int v8; // ebx
  unsigned int v9; // er11
  unsigned int v10; // edi
  unsigned int v11; // eax
  int v12; // ecx
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  __m128i v15; // xmm2
  __m128i v16; // xmm3
  __m128i v17; // xmm4
  __m128i v18; // xmm5
  __int64 *v19; // rdi
  signed __int64 v20; // r11
  signed __int64 v21; // rsi
  unsigned int v22; // eax
  __m128i v23; // xmm7
  __m128i v24; // xmm6
  __m128i v25; // xmm0
  __m128i v26; // xmm1
  __m128i v27; // xmm2
  __m128i v28; // xmm3
  __m128i v29; // xmm1
  __m128i v30; // xmm2
  __m128i v31; // xmm3
  __int64 *v32; // rdi
  signed __int64 v33; // r11
  signed __int64 v34; // rsi
  unsigned int v35; // eax
  __m128i v36; // xmm7
  __m128i v37; // xmm6
  __m128i v38; // xmm0
  __m128i v39; // xmm1
  __m128i v40; // xmm2
  __m128i v41; // xmm3
  __m128i v42; // xmm1
  __m128i v43; // xmm2
  unsigned int v44; // eax
  __m128i v45; // xmm7
  __m128i v46; // xmm6
  __m128i v47; // xmm0
  __m128i v48; // xmm1
  __m128i v49; // xmm2
  __m128i v50; // xmm3
  __m128i v51; // xmm1
  __m128i v52; // xmm2
  __m128i v53; // xmm3
  __m128 v54; // [rsp+98h] [rbp-98h]

  v54 = result;
  v4 = a1;
  v5 = (unsigned int *)a3;
  v6 = a1 == 128;
  if ( a1 < 128 )
  {
    v4 = 8 * a1;
    v6 = 8 * a1 == 128;
  }
  if ( v6 )
  {
    v7 = *a2;
    v8 = a2[1];
    v9 = a2[2];
    v10 = a2[3];
    *(_DWORD *)(a3 + 240) = 160;
    *(_BYTE *)(a3 + 16) = 1;
    *(_BYTE *)(a3 + 32) = 2;
    *(_BYTE *)(a3 + 48) = 4;
    *(_BYTE *)(a3 + 64) = 8;
    *(_BYTE *)(a3 + 80) = 16;
    *(_BYTE *)(a3 + 96) = 32;
    *(_BYTE *)(a3 + 112) = 64;
    *(_BYTE *)(a3 + 128) = -128;
    *(_BYTE *)(a3 + 144) = 27;
    *(_BYTE *)(a3 + 160) = 54;
    *(_DWORD *)a3 = v7;
    *(_DWORD *)(a3 + 4) = v8;
    *(_DWORD *)(a3 + 8) = v9;
    *(_DWORD *)(a3 + 12) = v10;
    do
    {
      v11 = v10 >> 16;
      v5 += 4;
      v12 = *(unsigned __int8 *)v5;
      v7 ^= v12 ^ dword_5138C[BYTE1(v11) + 512] ^ dword_5138C[BYTE2(v10) + 256] ^ dword_5138C[BYTE1(v10)] ^ dword_5138C[(unsigned __int8)v10 + 768];
      *v5 = v7;
      v8 ^= v7;
      v5[1] = v8;
      v9 ^= v8;
      v5[2] = v9;
      v10 ^= v9;
      v5[3] = v10;
    }
    while ( v12 != 54 );
  }
  else if ( v4 == 192 )
  {
    v13 = _mm_cvtsi32_si128(*a2);
    v14 = _mm_cvtsi32_si128(a2[1]);
    v15 = _mm_cvtsi32_si128(a2[2]);
    v16 = _mm_cvtsi32_si128(a2[3]);
    *(_DWORD *)(a3 + 240) = 192;
    v17 = _mm_cvtsi32_si128(a2[4]);
    v18 = _mm_cvtsi32_si128(a2[5]);
    v19 = &qword_4E380;
    v20 = -192i64;
    v21 = a3 + 192;
    *(_DWORD *)(v21 - 192) = _mm_cvtsi128_si32(v13);
    *(_DWORD *)(v21 - 192 + 4) = _mm_cvtsi128_si32(v14);
    *(_DWORD *)(v21 - 192 + 8) = _mm_cvtsi128_si32(v15);
    *(_DWORD *)(v21 - 192 + 12) = _mm_cvtsi128_si32(v16);
    *(_DWORD *)(v21 - 192 + 16) = _mm_cvtsi128_si32(v17);
    *(_DWORD *)(v21 - 192 + 20) = _mm_cvtsi128_si32(v18);
    while ( 1 )
    {
      v19 = (__int64 *)((char *)v19 + 1);
      v22 = _mm_cvtsi128_si32(v18);
      v23 = _mm_cvtsi32_si128(dword_5138C[(unsigned __int8)v22 + 768]);
      v24 = _mm_cvtsi32_si128(dword_5138C[BYTE1(v22)]);
      v22 >>= 16;
      v13 = _mm_xor_si128(
              _mm_xor_si128(_mm_xor_si128(v13, _mm_cvtsi32_si128(*(unsigned __int8 *)v19)), _mm_xor_si128(v23, v24)),
              _mm_xor_si128(
                _mm_cvtsi32_si128(dword_5138C[(unsigned __int8)v22 + 256]),
                _mm_cvtsi32_si128(dword_5138C[BYTE1(v22) + 512])));
      v6 = v20 == -24;
      v20 += 24i64;
      *(_DWORD *)(v21 + v20) = _mm_cvtsi128_si32(v13);
      v14 = _mm_xor_si128(v14, v13);
      *(_DWORD *)(v21 + v20 + 4) = _mm_cvtsi128_si32(v14);
      v15 = _mm_xor_si128(v15, v14);
      *(_DWORD *)(v21 + v20 + 8) = _mm_cvtsi128_si32(v15);
      v16 = _mm_xor_si128(v16, v15);
      *(_DWORD *)(v21 + v20 + 12) = _mm_cvtsi128_si32(v16);
      if ( v6 )
        break;
      v17 = _mm_xor_si128(v17, v16);
      *(_DWORD *)(v21 + v20 + 16) = _mm_cvtsi128_si32(v17);
      v18 = _mm_xor_si128(v18, v17);
      *(_DWORD *)(v21 + v20 + 20) = _mm_cvtsi128_si32(v18);
    }
    result = v54;
  }
  else if ( v4 == 256 )
  {
    v25 = _mm_cvtsi32_si128(*a2);
    v26 = _mm_cvtsi32_si128(a2[1]);
    v27 = _mm_cvtsi32_si128(a2[2]);
    v28 = _mm_cvtsi32_si128(a2[3]);
    *(_DWORD *)(a3 + 240) = 224;
    *(_DWORD *)a3 = _mm_cvtsi128_si32(v25);
    *(_DWORD *)(a3 + 4) = _mm_cvtsi128_si32(v26);
    *(_DWORD *)(a3 + 8) = _mm_cvtsi128_si32(v27);
    *(_DWORD *)(a3 + 12) = _mm_cvtsi128_si32(v28);
    v29 = _mm_cvtsi32_si128(a2[5]);
    v30 = _mm_cvtsi32_si128(a2[6]);
    v31 = _mm_cvtsi32_si128(a2[7]);
    v32 = &qword_4E380;
    v33 = -224i64;
    v34 = a3 + 224;
    *(_DWORD *)(v34 - 224 + 16) = _mm_cvtsi128_si32(_mm_cvtsi32_si128(a2[4]));
    *(_DWORD *)(v34 - 224 + 20) = _mm_cvtsi128_si32(v29);
    *(_DWORD *)(v34 - 224 + 24) = _mm_cvtsi128_si32(v30);
    *(_DWORD *)(v34 - 224 + 28) = _mm_cvtsi128_si32(v31);
    while ( 1 )
    {
      v32 = (__int64 *)((char *)v32 + 1);
      v44 = _mm_cvtsi128_si32(v31);
      v45 = _mm_cvtsi32_si128(dword_5138C[(unsigned __int8)v44 + 768]);
      v46 = _mm_cvtsi32_si128(dword_5138C[BYTE1(v44)]);
      v44 >>= 16;
      v47 = _mm_xor_si128(
              _mm_xor_si128(
                _mm_xor_si128(_mm_cvtsi32_si128(*(_DWORD *)(v34 + v33)), _mm_cvtsi32_si128(*(unsigned __int8 *)v32)),
                _mm_xor_si128(v45, v46)),
              _mm_xor_si128(
                _mm_cvtsi32_si128(dword_5138C[(unsigned __int8)v44 + 256]),
                _mm_cvtsi32_si128(dword_5138C[BYTE1(v44) + 512])));
      v48 = _mm_cvtsi32_si128(*(_DWORD *)(v34 + v33 + 4));
      v49 = _mm_cvtsi32_si128(*(_DWORD *)(v34 + v33 + 8));
      v50 = _mm_cvtsi32_si128(*(_DWORD *)(v34 + v33 + 12));
      v6 = v33 == -32;
      v33 += 32i64;
      *(_DWORD *)(v34 + v33) = _mm_cvtsi128_si32(v47);
      v51 = _mm_xor_si128(v48, v47);
      *(_DWORD *)(v34 + v33 + 4) = _mm_cvtsi128_si32(v51);
      v52 = _mm_xor_si128(v49, v51);
      *(_DWORD *)(v34 + v33 + 8) = _mm_cvtsi128_si32(v52);
      v53 = _mm_xor_si128(v50, v52);
      *(_DWORD *)(v34 + v33 + 12) = _mm_cvtsi128_si32(v53);
      if ( v6 )
        break;
      v35 = _mm_cvtsi128_si32(v53);
      v36 = _mm_cvtsi32_si128(dword_5138C[(unsigned __int8)v35]);
      v37 = _mm_cvtsi32_si128(dword_5138C[BYTE1(v35) + 256]);
      v35 >>= 16;
      v38 = _mm_xor_si128(
              _mm_xor_si128(_mm_cvtsi32_si128(*(_DWORD *)(v34 + v33 - 16)), _mm_xor_si128(v36, v37)),
              _mm_xor_si128(
                _mm_cvtsi32_si128(dword_5138C[(unsigned __int8)v35 + 512]),
                _mm_cvtsi32_si128(dword_5138C[BYTE1(v35) + 768])));
      v39 = _mm_cvtsi32_si128(*(_DWORD *)(v34 + v33 - 12));
      v40 = _mm_cvtsi32_si128(*(_DWORD *)(v34 + v33 - 8));
      v41 = _mm_cvtsi32_si128(*(_DWORD *)(v34 + v33 - 4));
      *(_DWORD *)(v34 + v33 + 16) = _mm_cvtsi128_si32(v38);
      v42 = _mm_xor_si128(v39, v38);
      *(_DWORD *)(v34 + v33 + 20) = _mm_cvtsi128_si32(v42);
      v43 = _mm_xor_si128(v40, v42);
      *(_DWORD *)(v34 + v33 + 24) = _mm_cvtsi128_si32(v43);
      v31 = _mm_xor_si128(v41, v43);
      *(_DWORD *)(v34 + v33 + 28) = _mm_cvtsi128_si32(v31);
    }
    result = v54;
  }
  return result;
}
// 4E380: using guessed type __int64 qword_4E380;
// 5138C: using guessed type int dword_5138C[];

//----- (000000000000402A) ----------------------------------------------------
__int64 __usercall sub_402A@<rax>(unsigned int a1@<eax>)
{
  return a1 >> 16;
}

//----- (0000000000004067) ----------------------------------------------------
__m128 __usercall sub_4067@<xmm0>(signed int a1@<edx>, unsigned int *a2@<rcx>, _DWORD *a3@<r8>, __m128i a4@<xmm7>)
{
  int v4; // er9
  bool v5; // zf
  __m128i v6; // xmm0
  __m128i v7; // xmm1
  __m128i v8; // xmm2
  __m128i v9; // xmm3
  __m128i v10; // xmm4
  signed __int64 v11; // rsi
  __int64 v12; // r11
  __m128i v13; // xmm5
  __int64 v14; // r11
  unsigned __int8 *v15; // rdi
  __m128i v16; // xmm5
  unsigned int v17; // eax
  __int64 v18; // rdx
  __m128i v19; // xmm7
  __m128i v20; // xmm7
  __m128i v21; // xmm0
  __m128i v22; // xmm1
  __m128i v23; // xmm2
  __m128i v24; // xmm3
  __int64 v25; // r11
  __int64 v26; // r11
  __int64 v27; // r11
  __int64 v28; // rdx
  __m128i v29; // xmm5
  __int64 v30; // r11
  __m128i v31; // xmm7
  unsigned int v32; // eax
  __m128i v33; // xmm7
  __m128i v34; // xmm7
  __int64 v35; // r11
  bool v36; // sf
  unsigned __int8 v37; // of
  signed __int64 v38; // r11
  __m128i v39; // xmm7
  __m128i v40; // xmm7
  __m128i v41; // xmm7
  __m128i v42; // xmm7
  __m128i v43; // xmm7
  unsigned int v44; // eax
  __m128i v45; // xmm7
  __m128i v46; // xmm0
  __m128i v47; // xmm1
  __m128i v48; // xmm2
  __m128 result; // xmm0
  __m128i v50; // xmm0
  __m128i v51; // xmm1
  __m128i v52; // xmm2
  __m128i v53; // xmm3
  __m128i v54; // xmm3
  signed __int64 v55; // rsi
  unsigned int v56; // ST90_4
  unsigned int v57; // ST94_4
  unsigned int v58; // ST98_4
  unsigned int v59; // ST9C_4
  __int64 v60; // r11
  __int64 v61; // r11
  __int64 v62; // r11
  __int64 v63; // r11
  unsigned __int8 *v64; // rdi
  unsigned int v65; // eax
  __int64 v66; // rdx
  __m128i v67; // xmm7
  __m128i v68; // xmm7
  __m128i v69; // xmm0
  __int64 v70; // r11
  __m128i v71; // xmm1
  __int64 v72; // r11
  __m128i v73; // xmm2
  __int64 v74; // r11
  __m128i v75; // xmm3
  __int64 v76; // r11
  unsigned int v77; // eax
  __int64 v78; // rdx
  __m128i v79; // xmm7
  __m128i v80; // xmm7
  __m128i v81; // xmm0
  __m128i v82; // xmm1
  __m128i v83; // xmm2
  __m128i v84; // xmm3
  __int64 v85; // rdx
  __int64 v86; // r11
  __m128i v87; // xmm7
  __m128i v88; // xmm7
  __m128i v89; // xmm7
  unsigned int v90; // eax
  __m128i v91; // xmm7
  __m128i v92; // xmm7
  __m128i v93; // xmm0
  __m128i v94; // xmm1
  __m128i v95; // xmm2
  __m128i v96; // xmm3
  __int64 v97; // r11
  __m128i v98; // xmm7
  __m128i v99; // xmm7
  __m128i v100; // xmm7
  unsigned int v101; // eax
  __int64 v102; // rdx
  __m128i v103; // xmm7
  __m128i v104; // xmm7
  __m128i v105; // xmm0
  __m128i v106; // xmm1
  __m128i v107; // xmm2
  __int64 v108; // r11
  __m128i v109; // xmm7
  __m128i v110; // xmm7
  __m128i v111; // xmm7
  signed __int64 v112; // r11
  unsigned int v113; // eax
  __m128i v114; // xmm7
  __m128i v115; // xmm0
  __m128i v116; // xmm1
  __m128i v117; // xmm2
  __m128 v118; // [rsp+0h] [rbp-B8h]
  __m128 v119; // [rsp+0h] [rbp-B8h]
  unsigned int v120; // [rsp+80h] [rbp-38h]
  unsigned int v121; // [rsp+84h] [rbp-34h]
  unsigned int v122; // [rsp+88h] [rbp-30h]
  unsigned int v123; // [rsp+8Ch] [rbp-2Ch]
  unsigned int v124; // [rsp+90h] [rbp-28h]
  unsigned int v125; // [rsp+94h] [rbp-24h]
  unsigned int v126; // [rsp+98h] [rbp-20h]
  unsigned int v127; // [rsp+9Ch] [rbp-1Ch]

  v4 = a1;
  v5 = a1 == 128;
  if ( a1 < 128 )
  {
    v4 = 8 * a1;
    v5 = 8 * a1 == 128;
  }
  JUMPOUT(v5, &loc_4118);
  if ( v4 == 192 )
  {
    v6 = _mm_cvtsi32_si128(*a2);
    v7 = _mm_cvtsi32_si128(a2[1]);
    v8 = _mm_cvtsi32_si128(a2[2]);
    v9 = _mm_cvtsi32_si128(a2[3]);
    a3[60] = 192;
    v10 = _mm_cvtsi32_si128(a2[4]);
    v11 = (signed __int64)(a3 + 40);
    *(_DWORD *)(v11 - 160) = _mm_cvtsi128_si32(v6);
    *(_DWORD *)(v11 - 160 + 4) = _mm_cvtsi128_si32(v7);
    *(_DWORD *)(v11 - 160 + 8) = _mm_cvtsi128_si32(v8);
    *(_DWORD *)(v11 - 160 + 12) = _mm_cvtsi128_si32(v9);
    sub_402A(_mm_cvtsi128_si32(v10));
    *(_DWORD *)(v11 + v12 + 16) = _mm_cvtsi128_si32(a4);
    sub_402A(_mm_cvtsi128_si32(v13));
    *(_DWORD *)(v11 + v14 + 20) = _mm_cvtsi128_si32(a4);
    v15 = (unsigned __int8 *)&qword_4E380 + 1;
    v17 = _mm_cvtsi128_si32(v16);
    v19 = _mm_xor_si128(
            _mm_xor_si128(
              _mm_cvtsi32_si128(BYTE1(qword_4E380)),
              _mm_cvtsi32_si128(*(_DWORD *)(v18 + 4i64 * (unsigned __int8)v17 + 3072))),
            _mm_cvtsi32_si128(*(_DWORD *)(v18 + 4i64 * BYTE1(v17))));
    v17 >>= 16;
    v20 = _mm_xor_si128(
            _mm_xor_si128(v19, _mm_cvtsi32_si128(*(_DWORD *)(v18 + 4i64 * (unsigned __int8)v17 + 1024))),
            _mm_cvtsi32_si128(*(_DWORD *)(v18 + 4i64 * BYTE1(v17) + 2048)));
    v21 = _mm_xor_si128(v6, v20);
    v22 = _mm_xor_si128(v7, v21);
    v23 = _mm_xor_si128(v8, v22);
    v24 = _mm_xor_si128(v9, v23);
    sub_402A(_mm_cvtsi128_si32(v21));
    *(_DWORD *)(v11 + v25) = _mm_cvtsi128_si32(v20);
    sub_402A(_mm_cvtsi128_si32(v22));
    *(_DWORD *)(v11 + v26 + 4) = _mm_cvtsi128_si32(v20);
    sub_402A(_mm_cvtsi128_si32(v23));
    *(_DWORD *)(v11 + v27 + 8) = _mm_cvtsi128_si32(v20);
    sub_402A(_mm_cvtsi128_si32(v24));
    *(_DWORD *)(v11 + v30 + 12) = _mm_cvtsi128_si32(v20);
    v31 = _mm_xor_si128(v20, _mm_cvtsi32_si128(*(_DWORD *)(v11 + v30 - 8)));
    *(_DWORD *)(v11 + v30 + 16) = _mm_cvtsi128_si32(v31);
    *(_DWORD *)(v11 + v30 + 20) = _mm_cvtsi128_si32(_mm_xor_si128(v31, _mm_cvtsi32_si128(*(_DWORD *)(v11 + v30 - 4))));
    do
    {
      ++v15;
      v32 = _mm_cvtsi128_si32(v29);
      v33 = _mm_xor_si128(
              _mm_xor_si128(
                _mm_cvtsi32_si128(*v15),
                _mm_cvtsi32_si128(*(_DWORD *)(v28 + 4i64 * (unsigned __int8)v32 + 3072))),
              _mm_cvtsi32_si128(*(_DWORD *)(v28 + 4i64 * BYTE1(v32))));
      v32 >>= 16;
      v34 = _mm_xor_si128(
              _mm_xor_si128(v33, _mm_cvtsi32_si128(*(_DWORD *)(v28 + 4i64 * (unsigned __int8)v32 + 1024))),
              _mm_cvtsi32_si128(*(_DWORD *)(v28 + 4i64 * BYTE1(v32) + 2048)));
      v21 = _mm_xor_si128(v21, v34);
      v22 = _mm_xor_si128(v22, v21);
      v23 = _mm_xor_si128(v23, v22);
      v24 = _mm_xor_si128(v24, v23);
      sub_402A(_mm_cvtsi128_si32(v34));
      v37 = __OFADD__(24i64, v35);
      v5 = v35 == -24;
      v36 = v35 + 24 < 0;
      v38 = v35 + 24;
      v39 = _mm_xor_si128(v34, _mm_cvtsi32_si128(*(_DWORD *)(v11 + v38 - 24)));
      *(_DWORD *)(v11 + v38) = _mm_cvtsi128_si32(v39);
      v40 = _mm_xor_si128(v39, _mm_cvtsi32_si128(*(_DWORD *)(v11 + v38 - 20)));
      *(_DWORD *)(v11 + v38 + 4) = _mm_cvtsi128_si32(v40);
      v41 = _mm_xor_si128(v40, _mm_cvtsi32_si128(*(_DWORD *)(v11 + v38 - 16)));
      *(_DWORD *)(v11 + v38 + 8) = _mm_cvtsi128_si32(v41);
      v42 = _mm_xor_si128(v41, _mm_cvtsi32_si128(*(_DWORD *)(v11 + v38 - 12)));
      *(_DWORD *)(v11 + v38 + 12) = _mm_cvtsi128_si32(v42);
      v43 = _mm_xor_si128(v42, _mm_cvtsi32_si128(*(_DWORD *)(v11 + v38 - 8)));
      *(_DWORD *)(v11 + v38 + 16) = _mm_cvtsi128_si32(v43);
      *(_DWORD *)(v11 + v38 + 20) = _mm_cvtsi128_si32(_mm_xor_si128(v43, _mm_cvtsi32_si128(*(_DWORD *)(v11 + v38 - 4))));
    }
    while ( (unsigned __int8)(v36 ^ v37) | v5 );
    v44 = _mm_cvtsi128_si32(v29);
    v45 = _mm_xor_si128(
            _mm_xor_si128(
              _mm_cvtsi32_si128(v15[1]),
              _mm_cvtsi32_si128(*(_DWORD *)(v28 + 4i64 * (unsigned __int8)v44 + 3072))),
            _mm_cvtsi32_si128(*(_DWORD *)(v28 + 4i64 * BYTE1(v44))));
    v44 >>= 16;
    v46 = _mm_xor_si128(
            v21,
            _mm_xor_si128(
              _mm_xor_si128(v45, _mm_cvtsi32_si128(*(_DWORD *)(v28 + 4i64 * (unsigned __int8)v44 + 1024))),
              _mm_cvtsi32_si128(*(_DWORD *)(v28 + 4i64 * BYTE1(v44) + 2048))));
    *(_DWORD *)(v11 + v38 + 24) = _mm_cvtsi128_si32(v46);
    v47 = _mm_xor_si128(v22, v46);
    *(_DWORD *)(v11 + v38 + 28) = _mm_cvtsi128_si32(v47);
    v48 = _mm_xor_si128(v23, v47);
    *(_DWORD *)(v11 + v38 + 32) = _mm_cvtsi128_si32(v48);
    *(_DWORD *)(v11 + v38 + 36) = _mm_cvtsi128_si32(_mm_xor_si128(v24, v48));
    result = v118;
  }
  else
  {
    if ( v4 != 256 )
      JUMPOUT(&loc_4345);
    v50 = _mm_cvtsi32_si128(*a2);
    v51 = _mm_cvtsi32_si128(a2[1]);
    v52 = _mm_cvtsi32_si128(a2[2]);
    v53 = _mm_cvtsi32_si128(a2[3]);
    a3[60] = 224;
    *a3 = _mm_cvtsi128_si32(v50);
    a3[1] = _mm_cvtsi128_si32(v51);
    a3[2] = _mm_cvtsi128_si32(v52);
    a3[3] = _mm_cvtsi128_si32(v53);
    v54 = _mm_cvtsi32_si128(a2[7]);
    v55 = (signed __int64)(a3 + 48);
    v56 = _mm_cvtsi128_si32(_mm_cvtsi32_si128(a2[4]));
    v57 = _mm_cvtsi128_si32(_mm_cvtsi32_si128(a2[5]));
    v58 = _mm_cvtsi128_si32(_mm_cvtsi32_si128(a2[6]));
    v59 = _mm_cvtsi128_si32(v54);
    sub_402A(v56);
    *(_DWORD *)(v55 + v60 + 16) = _mm_cvtsi128_si32(a4);
    sub_402A(v57);
    *(_DWORD *)(v55 + v61 + 20) = _mm_cvtsi128_si32(a4);
    sub_402A(v58);
    *(_DWORD *)(v55 + v62 + 24) = _mm_cvtsi128_si32(a4);
    sub_402A(v59);
    *(_DWORD *)(v55 + v63 + 28) = _mm_cvtsi128_si32(a4);
    v64 = (unsigned __int8 *)&qword_4E380 + 1;
    v65 = v59;
    v67 = _mm_xor_si128(
            _mm_xor_si128(
              _mm_cvtsi32_si128(BYTE1(qword_4E380)),
              _mm_cvtsi32_si128(*(_DWORD *)(v66 + 4i64 * (unsigned __int8)v65 + 3072))),
            _mm_cvtsi32_si128(*(_DWORD *)(v66 + 4i64 * BYTE1(v65))));
    v65 >>= 16;
    v68 = _mm_xor_si128(
            _mm_xor_si128(v67, _mm_cvtsi32_si128(*(_DWORD *)(v66 + 4i64 * (unsigned __int8)v65 + 1024))),
            _mm_cvtsi32_si128(*(_DWORD *)(v66 + 4i64 * BYTE1(v65) + 2048)));
    v69 = _mm_xor_si128(_mm_cvtsi32_si128(*(_DWORD *)(v55 + v63)), v68);
    v120 = _mm_cvtsi128_si32(v69);
    sub_402A(v120);
    *(_DWORD *)(v55 + v70) = _mm_cvtsi128_si32(v68);
    v71 = _mm_xor_si128(_mm_cvtsi32_si128(*(_DWORD *)(v55 + v70 - 28)), v69);
    v121 = _mm_cvtsi128_si32(v71);
    sub_402A(v121);
    *(_DWORD *)(v55 + v72 + 4) = _mm_cvtsi128_si32(v68);
    v73 = _mm_xor_si128(_mm_cvtsi32_si128(*(_DWORD *)(v55 + v72 - 24)), v71);
    v122 = _mm_cvtsi128_si32(v73);
    sub_402A(v122);
    *(_DWORD *)(v55 + v74 + 8) = _mm_cvtsi128_si32(v68);
    v75 = _mm_xor_si128(_mm_cvtsi32_si128(*(_DWORD *)(v55 + v74 - 20)), v73);
    v123 = _mm_cvtsi128_si32(v75);
    sub_402A(v123);
    *(_DWORD *)(v55 + v76 + 12) = _mm_cvtsi128_si32(v68);
    v77 = v123;
    v79 = _mm_xor_si128(
            _mm_cvtsi32_si128(*(_DWORD *)(v78 + 4i64 * (unsigned __int8)v77)),
            _mm_cvtsi32_si128(*(_DWORD *)(v78 + 4i64 * BYTE1(v77) + 1024)));
    v77 >>= 16;
    v80 = _mm_xor_si128(
            _mm_xor_si128(v79, _mm_cvtsi32_si128(*(_DWORD *)(v78 + 4i64 * (unsigned __int8)v77 + 2048))),
            _mm_cvtsi32_si128(*(_DWORD *)(v78 + 4i64 * BYTE1(v77) + 3072)));
    v81 = _mm_xor_si128(_mm_cvtsi32_si128(v56), v80);
    v124 = _mm_cvtsi128_si32(v81);
    v82 = _mm_xor_si128(_mm_cvtsi32_si128(v57), v81);
    v125 = _mm_cvtsi128_si32(v82);
    v83 = _mm_xor_si128(_mm_cvtsi32_si128(v58), v82);
    v126 = _mm_cvtsi128_si32(v83);
    v84 = _mm_xor_si128(_mm_cvtsi32_si128(v59), v83);
    v127 = _mm_cvtsi128_si32(v84);
    sub_402A(_mm_cvtsi128_si32(v80));
    v87 = _mm_xor_si128(v80, _mm_cvtsi32_si128(*(_DWORD *)(v55 + v86 - 16)));
    *(_DWORD *)(v55 + v86 + 16) = _mm_cvtsi128_si32(v87);
    v88 = _mm_xor_si128(v87, _mm_cvtsi32_si128(*(_DWORD *)(v55 + v86 - 12)));
    *(_DWORD *)(v55 + v86 + 20) = _mm_cvtsi128_si32(v88);
    v89 = _mm_xor_si128(v88, _mm_cvtsi32_si128(*(_DWORD *)(v55 + v86 - 8)));
    *(_DWORD *)(v55 + v86 + 24) = _mm_cvtsi128_si32(v89);
    *(_DWORD *)(v55 + v86 + 28) = _mm_cvtsi128_si32(_mm_xor_si128(v89, _mm_cvtsi32_si128(*(_DWORD *)(v55 + v86 - 4))));
    do
    {
      ++v64;
      v90 = _mm_cvtsi128_si32(v84);
      v91 = _mm_xor_si128(
              _mm_xor_si128(
                _mm_cvtsi32_si128(*v64),
                _mm_cvtsi32_si128(*(_DWORD *)(v85 + 4i64 * (unsigned __int8)v90 + 3072))),
              _mm_cvtsi32_si128(*(_DWORD *)(v85 + 4i64 * BYTE1(v90))));
      v90 >>= 16;
      v92 = _mm_xor_si128(
              _mm_xor_si128(v91, _mm_cvtsi32_si128(*(_DWORD *)(v85 + 4i64 * (unsigned __int8)v90 + 1024))),
              _mm_cvtsi32_si128(*(_DWORD *)(v85 + 4i64 * BYTE1(v90) + 2048)));
      v93 = _mm_xor_si128(_mm_cvtsi32_si128(v120), v92);
      v120 = _mm_cvtsi128_si32(v93);
      v94 = _mm_xor_si128(_mm_cvtsi32_si128(v121), v93);
      v121 = _mm_cvtsi128_si32(v94);
      v95 = _mm_xor_si128(_mm_cvtsi32_si128(v122), v94);
      v122 = _mm_cvtsi128_si32(v95);
      v96 = _mm_xor_si128(_mm_cvtsi32_si128(v123), v95);
      v123 = _mm_cvtsi128_si32(v96);
      sub_402A(_mm_cvtsi128_si32(v92));
      v98 = _mm_xor_si128(v92, _mm_cvtsi32_si128(*(_DWORD *)(v55 + v97)));
      *(_DWORD *)(v55 + v97 + 32) = _mm_cvtsi128_si32(v98);
      v99 = _mm_xor_si128(v98, _mm_cvtsi32_si128(*(_DWORD *)(v55 + v97 + 4)));
      *(_DWORD *)(v55 + v97 + 36) = _mm_cvtsi128_si32(v99);
      v100 = _mm_xor_si128(v99, _mm_cvtsi32_si128(*(_DWORD *)(v55 + v97 + 8)));
      *(_DWORD *)(v55 + v97 + 40) = _mm_cvtsi128_si32(v100);
      *(_DWORD *)(v55 + v97 + 44) = _mm_cvtsi128_si32(_mm_xor_si128(v100, _mm_cvtsi32_si128(*(_DWORD *)(v55 + v97 + 12))));
      v101 = v123;
      v103 = _mm_xor_si128(
               _mm_cvtsi32_si128(*(_DWORD *)(v102 + 4i64 * (unsigned __int8)v101)),
               _mm_cvtsi32_si128(*(_DWORD *)(v102 + 4i64 * BYTE1(v101) + 1024)));
      v101 >>= 16;
      v104 = _mm_xor_si128(
               _mm_xor_si128(v103, _mm_cvtsi32_si128(*(_DWORD *)(v102 + 4i64 * (unsigned __int8)v101 + 2048))),
               _mm_cvtsi32_si128(*(_DWORD *)(v102 + 4i64 * BYTE1(v101) + 3072)));
      v105 = _mm_xor_si128(_mm_cvtsi32_si128(v124), v104);
      v124 = _mm_cvtsi128_si32(v105);
      v106 = _mm_xor_si128(_mm_cvtsi32_si128(v125), v105);
      v125 = _mm_cvtsi128_si32(v106);
      v107 = _mm_xor_si128(_mm_cvtsi32_si128(v126), v106);
      v126 = _mm_cvtsi128_si32(v107);
      v84 = _mm_xor_si128(_mm_cvtsi32_si128(v127), v107);
      v127 = _mm_cvtsi128_si32(v84);
      sub_402A(_mm_cvtsi128_si32(v104));
      v109 = _mm_xor_si128(v104, _mm_cvtsi32_si128(*(_DWORD *)(v55 + v108 + 16)));
      *(_DWORD *)(v55 + v108 + 48) = _mm_cvtsi128_si32(v109);
      v110 = _mm_xor_si128(v109, _mm_cvtsi32_si128(*(_DWORD *)(v55 + v108 + 20)));
      *(_DWORD *)(v55 + v108 + 52) = _mm_cvtsi128_si32(v110);
      v111 = _mm_xor_si128(v110, _mm_cvtsi32_si128(*(_DWORD *)(v55 + v108 + 24)));
      *(_DWORD *)(v55 + v108 + 56) = _mm_cvtsi128_si32(v111);
      *(_DWORD *)(v55 + v108 + 60) = _mm_cvtsi128_si32(_mm_xor_si128(v111, _mm_cvtsi32_si128(*(_DWORD *)(v55 + v108 + 28))));
      v37 = __OFADD__(32i64, v108);
      v36 = v108 + 32 < 0;
      v112 = v108 + 32;
    }
    while ( v36 ^ v37 );
    v113 = _mm_cvtsi128_si32(v84);
    v114 = _mm_xor_si128(
             _mm_xor_si128(
               _mm_cvtsi32_si128(v64[1]),
               _mm_cvtsi32_si128(*(_DWORD *)(v85 + 4i64 * (unsigned __int8)v113 + 3072))),
             _mm_cvtsi32_si128(*(_DWORD *)(v85 + 4i64 * BYTE1(v113))));
    v113 >>= 16;
    v115 = _mm_xor_si128(
             _mm_cvtsi32_si128(v120),
             _mm_xor_si128(
               _mm_xor_si128(v114, _mm_cvtsi32_si128(*(_DWORD *)(v85 + 4i64 * (unsigned __int8)v113 + 1024))),
               _mm_cvtsi32_si128(*(_DWORD *)(v85 + 4i64 * BYTE1(v113) + 2048))));
    *(_DWORD *)(v55 + v112 + 32) = _mm_cvtsi128_si32(v115);
    v116 = _mm_xor_si128(_mm_cvtsi32_si128(v121), v115);
    *(_DWORD *)(v55 + v112 + 36) = _mm_cvtsi128_si32(v116);
    v117 = _mm_xor_si128(_mm_cvtsi32_si128(v122), v116);
    *(_DWORD *)(v55 + v112 + 40) = _mm_cvtsi128_si32(v117);
    *(_DWORD *)(v55 + v112 + 44) = _mm_cvtsi128_si32(_mm_xor_si128(_mm_cvtsi32_si128(v123), v117));
    result = v119;
  }
  return result;
}
// 4E380: using guessed type __int64 qword_4E380;

//----- (00000000000040E1) ----------------------------------------------------
__m128 __fastcall sub_40E1(unsigned int *a1, __int64 a2)
{
  __m128i v2; // xmm0
  __m128i v3; // xmm1
  __m128i v4; // xmm2
  __m128i v5; // xmm3
  signed __int64 v6; // rsi
  unsigned __int8 *v7; // rdi
  unsigned int v8; // eax
  __m128i v9; // xmm7
  __m128i v10; // xmm7
  __m128i v11; // xmm0
  __m128i v12; // xmm1
  __m128i v13; // xmm2
  __m128i v14; // xmm3
  __int64 v15; // r11
  __int64 v16; // r11
  __int64 v17; // r11
  __int64 v18; // rdx
  __int64 v19; // r11
  unsigned int v20; // eax
  __m128i v21; // xmm7
  __m128i v22; // xmm7
  __int64 v23; // r11
  bool v24; // sf
  unsigned __int8 v25; // of
  signed __int64 v26; // r11
  __m128i v27; // xmm7
  __m128i v28; // xmm7
  __m128i v29; // xmm7
  unsigned int v30; // eax
  __m128i v31; // xmm7
  __m128i v32; // xmm0
  __m128i v33; // xmm1
  __m128i v34; // xmm2
  __int128 v36; // [rsp+0h] [rbp-B8h]

  v2 = _mm_cvtsi32_si128(*a1);
  v3 = _mm_cvtsi32_si128(a1[1]);
  v4 = _mm_cvtsi32_si128(a1[2]);
  v5 = _mm_cvtsi32_si128(a1[3]);
  *(_DWORD *)(a2 + 240) = 160;
  v6 = a2 + 144;
  *(_DWORD *)(v6 - 144) = _mm_cvtsi128_si32(v2);
  *(_DWORD *)(v6 - 144 + 4) = _mm_cvtsi128_si32(v3);
  *(_DWORD *)(v6 - 144 + 8) = _mm_cvtsi128_si32(v4);
  *(_DWORD *)(v6 - 144 + 12) = _mm_cvtsi128_si32(v5);
  v7 = (unsigned __int8 *)&qword_4E380 + 1;
  v8 = _mm_cvtsi128_si32(v5);
  v9 = _mm_xor_si128(
         _mm_xor_si128(_mm_cvtsi32_si128(BYTE1(qword_4E380)), _mm_cvtsi32_si128(dword_5138C[(unsigned __int8)v8 + 768])),
         _mm_cvtsi32_si128(dword_5138C[BYTE1(v8)]));
  v8 >>= 16;
  v10 = _mm_xor_si128(
          _mm_xor_si128(v9, _mm_cvtsi32_si128(dword_5138C[(unsigned __int8)v8 + 256])),
          _mm_cvtsi32_si128(dword_5138C[BYTE1(v8) + 512]));
  v11 = _mm_xor_si128(v2, v10);
  v12 = _mm_xor_si128(v3, v11);
  v13 = _mm_xor_si128(v4, v12);
  v14 = _mm_xor_si128(v5, v13);
  sub_402A(_mm_cvtsi128_si32(v11));
  *(_DWORD *)(v6 + v15) = _mm_cvtsi128_si32(v10);
  sub_402A(_mm_cvtsi128_si32(v12));
  *(_DWORD *)(v6 + v16 + 4) = _mm_cvtsi128_si32(v10);
  sub_402A(_mm_cvtsi128_si32(v13));
  *(_DWORD *)(v6 + v17 + 8) = _mm_cvtsi128_si32(v10);
  sub_402A(_mm_cvtsi128_si32(v14));
  *(_DWORD *)(v6 + v19 + 12) = _mm_cvtsi128_si32(v10);
  do
  {
    ++v7;
    v20 = _mm_cvtsi128_si32(v14);
    v21 = _mm_xor_si128(
            _mm_xor_si128(
              _mm_cvtsi32_si128(*v7),
              _mm_cvtsi32_si128(*(_DWORD *)(v18 + 4i64 * (unsigned __int8)v20 + 3072))),
            _mm_cvtsi32_si128(*(_DWORD *)(v18 + 4i64 * BYTE1(v20))));
    v20 >>= 16;
    v22 = _mm_xor_si128(
            _mm_xor_si128(v21, _mm_cvtsi32_si128(*(_DWORD *)(v18 + 4i64 * (unsigned __int8)v20 + 1024))),
            _mm_cvtsi32_si128(*(_DWORD *)(v18 + 4i64 * BYTE1(v20) + 2048)));
    v11 = _mm_xor_si128(v11, v22);
    v12 = _mm_xor_si128(v12, v11);
    v13 = _mm_xor_si128(v13, v12);
    v14 = _mm_xor_si128(v14, v13);
    sub_402A(_mm_cvtsi128_si32(v22));
    v25 = __OFADD__(16i64, v23);
    v24 = v23 + 16 < 0;
    v26 = v23 + 16;
    v27 = _mm_xor_si128(v22, _mm_cvtsi32_si128(*(_DWORD *)(v6 + v26 - 16)));
    *(_DWORD *)(v6 + v26) = _mm_cvtsi128_si32(v27);
    v28 = _mm_xor_si128(v27, _mm_cvtsi32_si128(*(_DWORD *)(v6 + v26 - 12)));
    *(_DWORD *)(v6 + v26 + 4) = _mm_cvtsi128_si32(v28);
    v29 = _mm_xor_si128(v28, _mm_cvtsi32_si128(*(_DWORD *)(v6 + v26 - 8)));
    *(_DWORD *)(v6 + v26 + 8) = _mm_cvtsi128_si32(v29);
    *(_DWORD *)(v6 + v26 + 12) = _mm_cvtsi128_si32(_mm_xor_si128(v29, _mm_cvtsi32_si128(*(_DWORD *)(v6 + v26 - 4))));
  }
  while ( v24 ^ v25 );
  v30 = _mm_cvtsi128_si32(v14);
  v31 = _mm_xor_si128(
          _mm_xor_si128(
            _mm_cvtsi32_si128(v7[1]),
            _mm_cvtsi32_si128(*(_DWORD *)(v18 + 4i64 * (unsigned __int8)v30 + 3072))),
          _mm_cvtsi32_si128(*(_DWORD *)(v18 + 4i64 * BYTE1(v30))));
  v30 >>= 16;
  v32 = _mm_xor_si128(
          v11,
          _mm_xor_si128(
            _mm_xor_si128(v31, _mm_cvtsi32_si128(*(_DWORD *)(v18 + 4i64 * (unsigned __int8)v30 + 1024))),
            _mm_cvtsi32_si128(*(_DWORD *)(v18 + 4i64 * BYTE1(v30) + 2048))));
  *(_DWORD *)(v6 + v26 + 16) = _mm_cvtsi128_si32(v32);
  v33 = _mm_xor_si128(v12, v32);
  *(_DWORD *)(v6 + v26 + 20) = _mm_cvtsi128_si32(v33);
  v34 = _mm_xor_si128(v13, v33);
  *(_DWORD *)(v6 + v26 + 24) = _mm_cvtsi128_si32(v34);
  *(_DWORD *)(v6 + v26 + 28) = _mm_cvtsi128_si32(_mm_xor_si128(v14, v34));
  return (__m128)v36;
}
// 4E380: using guessed type __int64 qword_4E380;
// 5138C: using guessed type int dword_5138C[];

//----- (0000000000004C13) ----------------------------------------------------
signed __int64 __fastcall sub_4C13(char *a1, __int64 **a2)
{
  signed __int64 v2; // rsi
  __int64 *v3; // rdi
  __int64 **v4; // r14
  char *v5; // rbx

  v2 = -9223372036854775794i64;
  v3 = &off_91438;
  if ( &off_91438 )
  {
    v4 = a2;
    v5 = a1;
    while ( (unsigned int)sub_18A1A(v5, (_BYTE *)v3[1]) )
    {
      v3 = (__int64 *)*v3;
      if ( !v3 )
        return v2;
    }
    *v4 = v3;
    v2 = 0i64;
  }
  return v2;
}
// 91438: using guessed type __int64 off_91438;

//----- (0000000000004C69) ----------------------------------------------------
signed __int64 __fastcall sub_4C69(__int64 a1, __int64 *a2, _QWORD *a3, _QWORD *a4)
{
  signed __int64 v4; // rsi
  __int64 *v5; // r15
  _QWORD *v6; // r13
  __int64 v7; // rdi
  unsigned __int64 v8; // r14
  _BYTE *v9; // r12
  char v10; // al
  __int64 v11; // rax
  _BYTE *v12; // r13
  char v13; // al
  __int64 v14; // rax
  unsigned __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rsi
  char v19; // dl
  _QWORD *v21; // [rsp+28h] [rbp-48h]
  _QWORD *v22; // [rsp+30h] [rbp-40h]

  v4 = -9223372036854775806i64;
  if ( !a1 )
    return v4;
  v5 = a2;
  if ( !a2 )
    return v4;
  v6 = a4;
  v7 = a1;
  v21 = a3;
  v8 = *(unsigned __int16 *)(a1 + 16) * (unsigned __int64)*(unsigned __int16 *)(a1 + 18);
  v9 = (_BYTE *)sub_1364F(v8);
  v10 = *(_BYTE *)(v7 + 20);
  if ( v10 )
  {
    if ( v10 != 1 )
      goto LABEL_13;
    v11 = sub_22C00((__int64)v9, v8, *(_QWORD **)(v7 + 24), *(unsigned int *)(v7 + 32));
  }
  else
  {
    v11 = (__int64)sub_116D9(v9, *(char **)(v7 + 24), *(unsigned int *)(v7 + 32));
  }
  if ( v11 && v11 == v8 )
  {
    v22 = v6;
    if ( *(_QWORD *)(v7 + 40) )
    {
      v12 = (_BYTE *)sub_1364F(v8);
      v13 = *(_BYTE *)(v7 + 20);
      if ( v13 )
      {
        if ( v13 != 1 )
          goto LABEL_26;
        v14 = sub_22C00((__int64)v12, v8, *(_QWORD **)(v7 + 40), *(unsigned int *)(v7 + 48));
      }
      else
      {
        v14 = (__int64)sub_116D9(v12, *(char **)(v7 + 40), *(unsigned int *)(v7 + 48));
      }
      if ( !v14 || v14 != v8 )
        goto LABEL_26;
    }
    else
    {
      v12 = 0i64;
    }
    *v5 = sub_1364F(4 * v8);
    if ( !v8 )
    {
LABEL_25:
      *v21 = *(unsigned __int16 *)(v7 + 16);
      *v22 = *(unsigned __int16 *)(v7 + 18);
      v4 = 0i64;
      goto LABEL_27;
    }
    v15 = 0i64;
    while ( 1 )
    {
      v16 = (unsigned __int8)v9[v15];
      if ( *(_DWORD *)(v7 + 64) <= (unsigned int)v16 )
        break;
      v17 = *(_QWORD *)(v7 + 56);
      v18 = *v5;
      *(_BYTE *)(v18 + 4 * v15 + 2) = *(_BYTE *)(v17 + 3 * v16);
      *(_BYTE *)(v18 + 4 * v15 + 1) = *(_BYTE *)(v17 + 3 * v16 + 1);
      *(_BYTE *)(v18 + 4 * v15) = *(_BYTE *)(v17 + 3 * v16 + 2);
      if ( v12 )
        v19 = v12[v15];
      else
        v19 = -1;
      *(_BYTE *)(v18 + 4 * v15++ + 3) = v19;
      if ( v15 >= v8 )
        goto LABEL_25;
    }
LABEL_26:
    v4 = -9223372036854775807i64;
LABEL_27:
    if ( v12 )
      sub_136C5((__int64)v12);
    goto LABEL_29;
  }
LABEL_13:
  v4 = -9223372036854775807i64;
LABEL_29:
  if ( v9 )
    sub_136C5((__int64)v9);
  return v4;
}

//----- (0000000000004E0C) ----------------------------------------------------
signed __int64 __fastcall sub_4E0C(char *a1, __int64 *a2, _QWORD *a3, _QWORD *a4)
{
  __int64 *v4; // rsi
  _QWORD *v5; // r14
  _QWORD *v6; // r15
  __int64 *v7; // rbx
  char *v8; // rdi

  v4 = &off_91438;
  if ( !&off_91438 )
    return -9223372036854775794i64;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  while ( (unsigned int)sub_18A1A(v8, (_BYTE *)v4[1]) )
  {
    v4 = (__int64 *)*v4;
    if ( !v4 )
      return -9223372036854775794i64;
  }
  return sub_4C69((__int64)v4, v7, v6, v5);
}
// 91438: using guessed type __int64 off_91438;

//----- (0000000000004E7F) ----------------------------------------------------
signed __int64 __fastcall sub_4E7F(unsigned __int8 *a1, unsigned __int64 a2)
{
  unsigned int v3; // er8
  __int64 v4; // r9
  unsigned int v5; // eax
  unsigned int v6; // eax
  int v7; // ecx
  unsigned int v8; // er8
  unsigned int v9; // eax
  __int64 v10; // rsi
  int v11; // er10
  int v12; // er8
  int v13; // eax
  int v14; // er10
  int v15; // er8
  int v16; // eax
  int v17; // er10
  int v18; // er8
  int v19; // eax
  int v20; // er10
  int v21; // er8
  int v22; // eax
  int v23; // er10
  int v24; // er8
  int v25; // eax
  int v26; // er10
  int v27; // er8
  int v28; // eax
  int v29; // er10
  int v30; // er8
  int v31; // eax
  int v32; // er10
  unsigned __int64 v33; // r10
  signed __int64 v34; // rdx
  unsigned __int64 v35; // r9
  unsigned __int8 *v36; // rsi
  int v37; // edi
  int v38; // er8
  int v39; // eax
  int v40; // edi
  int v41; // er8
  int v42; // eax
  int v43; // edi
  int v44; // er8
  int v45; // eax
  int v46; // edi
  int v47; // er8
  int v48; // eax
  int v49; // edi
  int v50; // er8
  int v51; // eax
  int v52; // edi
  int v53; // er8
  int v54; // eax
  int v55; // edi
  int v56; // er8
  int v57; // eax
  int v58; // edi
  __int64 v59; // rsi

  if ( a2 == 1 )
    return ((*a1 + 1) << 16) + (unsigned int)*a1 + 1;
  if ( !a1 )
    return 1i64;
  if ( a2 >= 0x10 )
  {
    if ( a2 < 0x15B0 )
    {
      v9 = 0;
      v8 = 1;
    }
    else
    {
      v8 = 1;
      v9 = 0;
      do
      {
        a2 -= 5552i64;
        v10 = 0i64;
        do
        {
          v11 = v8 + a1[v10];
          v12 = v11 + a1[v10 + 1];
          v13 = v12 + v11 + v9;
          v14 = v12 + a1[v10 + 2];
          v15 = v14 + a1[v10 + 3];
          v16 = v15 + v14 + v13;
          v17 = v15 + a1[v10 + 4];
          v18 = v17 + a1[v10 + 5];
          v19 = v18 + v17 + v16;
          v20 = v18 + a1[v10 + 6];
          v21 = v20 + a1[v10 + 7];
          v22 = v21 + v20 + v19;
          v23 = v21 + a1[v10 + 8];
          v24 = v23 + a1[v10 + 9];
          v25 = v24 + v23 + v22;
          v26 = v24 + a1[v10 + 10];
          v27 = v26 + a1[v10 + 11];
          v28 = v27 + v26 + v25;
          v29 = v27 + a1[v10 + 12];
          v30 = v29 + a1[v10 + 13];
          v31 = v30 + v29 + v28;
          v32 = v30 + a1[v10 + 14];
          v8 = v32 + a1[v10 + 15];
          v9 = v8 + v32 + v31;
          v10 += 16i64;
        }
        while ( (_DWORD)v10 != 5552 );
        a1 += 5552;
        v8 %= 0xFFF1u;
        v9 %= 0xFFF1u;
      }
      while ( a2 > 0x15AF );
      if ( !a2 )
        return v8 | (v9 << 16);
      if ( a2 < 0x10 )
        goto LABEL_25;
    }
    v33 = a2;
    v34 = a2 - 16;
    v35 = (v34 & 0xFFFFFFFFFFFFFFF0ui64) + 16;
    v36 = a1;
    do
    {
      v33 -= 16i64;
      v37 = v8 + *v36;
      v38 = v37 + v36[1];
      v39 = v38 + v37 + v9;
      v40 = v38 + v36[2];
      v41 = v40 + v36[3];
      v42 = v41 + v40 + v39;
      v43 = v41 + v36[4];
      v44 = v43 + v36[5];
      v45 = v44 + v43 + v42;
      v46 = v44 + v36[6];
      v47 = v46 + v36[7];
      v48 = v47 + v46 + v45;
      v49 = v47 + v36[8];
      v50 = v49 + v36[9];
      v51 = v50 + v49 + v48;
      v52 = v50 + v36[10];
      v53 = v52 + v36[11];
      v54 = v53 + v52 + v51;
      v55 = v53 + v36[12];
      v56 = v55 + v36[13];
      v57 = v56 + v55 + v54;
      v58 = v56 + v36[14];
      v8 = v58 + v36[15];
      v9 = v8 + v58 + v57;
      v36 += 16;
    }
    while ( v33 > 0xF );
    a2 = v34 - (v34 & 0xFFFFFFFFFFFFFFF0ui64);
    if ( !a2 )
      goto LABEL_27;
    a1 += v35;
LABEL_25:
    v59 = 0i64;
    do
    {
      v8 += a1[v59];
      v9 += v8;
      ++v59;
    }
    while ( a2 != v59 );
LABEL_27:
    v8 %= 0xFFF1u;
    v9 %= 0xFFF1u;
    return v8 | (v9 << 16);
  }
  if ( a2 )
  {
    v3 = 1;
    v4 = 0i64;
    v5 = 0;
    do
    {
      v3 += a1[v4];
      v5 += v3;
      ++v4;
    }
    while ( a2 != v4 );
    v6 = v5 % 0xFFF1 << 16;
    v7 = v3 - 65521;
    if ( v3 <= 0xFFF0 )
      v7 = v3;
  }
  else
  {
    v7 = 1;
    v6 = 0;
  }
  return v7 | v6;
}

//----- (0000000000005180) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_5180()
{
  dword_51DA = (unsigned __int64)&byte_51B7;
  qword_51E2 = (__int64)word_51EA;
  __lgdt(byte_51E0);
  JUMPOUT(*MK_FP(16, &dword_51DA + 1), 0i64);
}
// 5187: write access to const memory at 51DA has been detected
// 5194: write access to const memory at 51E2 has been detected
// 51B7: using guessed type char byte_51B7;
// 51DA: using guessed type int dword_51DA;
// 51E2: using guessed type __int64 qword_51E2;
// 51EA: using guessed type __int16 word_51EA[3];

//----- (0000000000005202) ----------------------------------------------------
__int64 __fastcall sub_5202(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // r8
  __int64 v3; // r9

  v1 = a1;
  if ( qword_96B50 )
    (*(void (**)(void))(qword_96CD8 + 112))();
  if ( qword_96C00 )
    (*(void (**)(void))(qword_96CD8 + 112))();
  sub_2724(2, 0i64, 0);
  sub_D212();
  sub_BB0D();
  if ( (unsigned int)sub_BCFC() == 2 )
    sub_1A2B6(1, (__int64)"Boot failed; will sleep for 10 seconds before exiting...\n", v2, v3);
  sub_1A6EF(2u);
  sub_1384F();
  (*(void (__fastcall **)(signed __int64))(qword_96CD8 + 248))(10000000i64);
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(qword_96CD8 + 216))(qword_96A90, v1, 0i64, 0i64);
}
// 96A90: using guessed type __int64 qword_96A90;
// 96B50: using guessed type __int64 qword_96B50;
// 96C00: using guessed type __int64 qword_96C00;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000052BA) ----------------------------------------------------
__int64 __fastcall sub_52BA(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // esi
  unsigned int v3; // edi
  __int64 v4; // r9

  v2 = a2;
  v3 = a1;
  sub_2724(64, 0i64, 0);
  sub_1A2B6(1, (__int64)"[EB|#REBOOT] %d\n", v3, v4);
  sub_1A6EF(v2);
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 104))(v3, 0i64, 0i64, 0i64);
}
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000005310) ----------------------------------------------------
signed __int64 __fastcall sub_5310(__int64 a1, __int64 *a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  unsigned __int64 v4; // rbx
  bool v5; // r12
  __int64 v6; // rax
  unsigned __int64 v7; // r14
  bool v8; // r15
  __int64 *v9; // r13
  bool v10; // si
  char v11; // bl
  char v13; // [rsp+30h] [rbp-860h]
  __int64 v14; // [rsp+838h] [rbp-58h]
  __int64 v15; // [rsp+840h] [rbp-50h]
  __int64 v16; // [rsp+848h] [rbp-48h]
  __int64 *v17; // [rsp+850h] [rbp-40h]

  v17 = a2;
  v2 = a1;
  v16 = -6148914691236517206i64;
  v14 = -6148914691236517206i64;
  v15 = -6148914691236517206i64;
  LOBYTE(a2) = -86;
  sub_F180(&v13, (int)a2, 0x800ui64);
  sub_22ED4((__int64)&v13, 1024i64, (__int64)L"%a", "com.apple.boot.R");
  v3 = (*(__int64 (__fastcall **)(__int64, __int64 *, char *, signed __int64, _QWORD))(v2 + 8))(
         v2,
         &v16,
         &v13,
         1i64,
         0i64);
  v4 = (unsigned __int64)v3 >> 63;
  v5 = v3 >= 0;
  sub_22ED4((__int64)&v13, 1024i64, (__int64)L"%a", "com.apple.boot.P");
  v6 = (*(__int64 (__fastcall **)(__int64, __int64 *, char *, signed __int64, _QWORD))(v2 + 8))(
         v2,
         &v14,
         &v13,
         1i64,
         0i64);
  v7 = (unsigned __int64)v6 >> 63;
  v8 = v6 >= 0;
  sub_22ED4((__int64)&v13, 1024i64, (__int64)L"%a", "com.apple.boot.S");
  v9 = &v15;
  v10 = (*(__int64 (__fastcall **)(__int64, __int64 *, char *, signed __int64, _QWORD))(v2 + 8))(
          v2,
          &v15,
          &v13,
          1i64,
          0i64) >= 0;
  sub_1A2B6(1, (__int64)"[EB|#RPS] R?%d P?%d S?%d\n", v5, v8);
  v11 = v7 | v4;
  if ( !v11 && v10 )
  {
    *v17 = v16;
LABEL_16:
    (*(void (__cdecl **)(__int64))(v14 + 16))(v14);
    goto LABEL_17;
  }
  if ( !v11 )
  {
    v8 = 0;
    v9 = &v14;
LABEL_11:
    *v17 = *v9;
    if ( v5 )
      (*(void (__cdecl **)(__int64))(v16 + 16))(v16);
LABEL_15:
    if ( !v8 )
      goto LABEL_17;
    goto LABEL_16;
  }
  if ( v5 && v10 )
    goto LABEL_28;
  if ( v8 && v10 )
  {
    v10 = 0;
    goto LABEL_11;
  }
  if ( v5 )
  {
LABEL_28:
    *v17 = v16;
    goto LABEL_15;
  }
  if ( v8 )
  {
    *v17 = v14;
LABEL_17:
    if ( v10 )
      (*(void (__cdecl **)(__int64))(v15 + 16))(v15);
    return 0i64;
  }
  if ( v10 )
  {
    *v17 = v15;
    return 0i64;
  }
  return -9223372036854775794i64;
}
// 403A0: using guessed type __int16 aA[3];

//----- (0000000000005505) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_5505()
{
  __int64 v0; // rax
  __int64 v1; // rax
  __int64 v2; // r9
  __int64 v3; // r14
  __int64 v4; // r8
  __int64 v5; // r9
  char *v6; // rbx
  unsigned __int64 v7; // rdi
  char *v8; // rax
  __int64 v9; // rsi
  __int64 v10; // rax
  _WORD *v11; // rax
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 i; // rax
  char v15; // cl
  __int64 v16; // rax
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // r8
  __int64 v20; // r9
  signed __int64 *v21; // rax
  __int64 result; // rax
  __int64 v23; // rsi
  unsigned __int16 *v24; // rax
  unsigned __int16 *v25; // rdi
  unsigned __int16 v26; // ax
  unsigned __int16 *v27; // rax
  unsigned __int16 *v28; // rcx
  unsigned __int16 v29; // dx
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // [rsp+30h] [rbp-60h]
  __int64 v33; // [rsp+38h] [rbp-58h]
  __int64 v34; // [rsp+40h] [rbp-50h]
  __int64 v35; // [rsp+48h] [rbp-48h]
  __int64 v36; // [rsp+50h] [rbp-40h]
  __int64 v37; // [rsp+58h] [rbp-38h]
  __int64 v38; // [rsp+60h] [rbp-30h]

  v32 = -6148914691236517206i64;
  v37 = -6148914691236517206i64;
  v33 = -6148914691236517206i64;
  v38 = -6148914691236517206i64;
  v0 = (*(__int64 (__fastcall **)(__int64, __int64 *))(qword_96CD8 + 152))(qword_96A90, qword_92B10);
  if ( v0 < 0 )
    sub_9CE0((__int64)"[EB|#STOP|`B:OBV] %r @ HdlP %g\n", v0, qword_92B10);
  qword_96A98 = v37;
  v1 = (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
         *(_QWORD *)(qword_96A98 + 24),
         qword_92A90,
         &qword_96AD8);
  v3 = v1;
  if ( v1 < 0 || (v4 = qword_96AD8) == 0 )
  {
    sub_9CE0((__int64)"[EB|#STOP|`B:OBV] %r @ HdlP %g\n", v1, qword_92A90);
    v4 = qword_96AD8;
  }
  sub_1A2B6(1, (__int64)"[EB|#LIMG:DP] %D\n", v4, v2);
  sub_1A2B6(1, (__int64)"[EB|#LIMG:FP] %D\n", *(_QWORD *)(v37 + 32), v5);
  sub_1A2B6(1, (__int64)"[EB|#LIMG:OPT] (%.*E)\n", *(unsigned int *)(v37 + 48), *(_QWORD *)(v37 + 56));
  v6 = *(char **)(v37 + 56);
  v7 = *(unsigned int *)(v37 + 48);
  if ( *(_DWORD *)(v37 + 48) )
  {
    while ( *(_WORD *)v6 == 32 || *(_WORD *)v6 == 9 )
    {
      v6 += 2;
      v7 -= 2i64;
      if ( !v7 )
        goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    v7 = 0i64;
  }
  v8 = (char *)sub_1364F(v7 + 2);
  if ( v8 )
  {
    v9 = (__int64)v8;
    sub_1B950(v6, v8, v7);
    *(_WORD *)(v9 + (v7 & 0xFFFFFFFFFFFFFFFEui64)) = 0;
    qword_96AB0 = v9;
  }
  else
  {
    sub_9CE0((__int64)"[EB|#STOP|`B:OBV] %r @ B:GA\n", v3);
  }
  sub_1905F((__int64)"Start OpenVolume");
  if ( (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
         *(_QWORD *)(v37 + 24),
         qword_92B40,
         &v32) < 0 )
  {
    v38 = 0i64;
    v16 = (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
            *(_QWORD *)(v37 + 24),
            qword_92B20,
            &v33);
    if ( v16 < 0 )
      sub_9CE0((__int64)"[EB|#STOP|`B:OBV] %r @ 'FS|LF\n", v16);
    sub_1A2B6(1, (__int64)"[EB|#B:LF]\n", v17, v18);
    goto LABEL_41;
  }
  v36 = -6148914691236517206i64;
  v10 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v32 + 8))(v32, &v38);
  if ( v10 < 0 )
    sub_9CE0((__int64)"[EB|#STOP|`B:OBV] %r @ %g.OV\n", v10, qword_92B40);
  v11 = (_WORD *)sub_ACAE(*(_BYTE **)(qword_96A98 + 32));
  if ( v11 && sub_238F1(v11, "c") )
  {
    sub_1A2B6(1, (__int64)"[EB|`B:OBV] BM: +ROS\n", v12, v13);
    BYTE1(qword_96AA8) |= 0x10u;
  }
  for ( i = qword_96AD8; ; i += *(unsigned __int16 *)(i + 2) )
  {
    v15 = *(_BYTE *)i & 0x7F;
    if ( v15 == 1 )
      break;
    if ( v15 == 127 && *(_BYTE *)(i + 1) == -1 )
      goto LABEL_31;
LABEL_26:
    ;
  }
  if ( *(_BYTE *)(i + 1) != 3 )
    goto LABEL_26;
  sub_1A2B6(1, (__int64)"[EB|`B:OBV] BM: +DMG\n", v12, v13);
  sub_1A2B6(1, (__int64)"[EB|`B:OBV] BM: +ROS\n", v19, v20);
  qword_96AA8 |= 0x801000ui64;
LABEL_31:
  if ( (*(__int64 (__fastcall **)(__int64, __int64 *, const char *, signed __int64, _QWORD))(v38 + 8))(
         v38,
         &v36,
         "S",
         1i64,
         0i64) >= 0 )
    goto LABEL_32;
  v34 = 0i64;
  if ( sub_B0E9(*(_QWORD *)(v37 + 24), 0i64, 0i64) < 0 )
  {
    if ( sub_5310(v38, &v34) >= 0 )
      goto LABEL_37;
  }
  else
  {
    if ( sub_B3AB(*(_QWORD *)(v37 + 24), *(_QWORD *)(v37 + 32), v38, (__int64)&v34) >= 0 )
    {
      BYTE2(qword_96AA8) |= 8u;
LABEL_37:
      v38 = v34;
      v21 = (signed __int64 *)sub_A398();
      if ( v21 )
        sub_9EC7(v21, "bootroot-active", 0i64, 0i64, 0);
      BYTE1(qword_96AA8) |= 1u;
      goto LABEL_40;
    }
    if ( sub_B1BA(v38) & 4 )
      BYTE1(qword_96AA8) |= 0x10u;
  }
  v35 = 0i64;
  v23 = v38;
  v24 = (unsigned __int16 *)sub_ACAE(*(_BYTE **)(qword_96A98 + 32));
  if ( !v24 )
    goto LABEL_40;
  v25 = v24;
  v26 = *v24;
  if ( v26 != 92 && v26 != 47 )
    goto LABEL_40;
  if ( !sub_2378A(v25, L"\\") || !sub_2378A(v25, L"/") )
  {
LABEL_57:
    *v25 = 46;
    v27 = v25 + 1;
    goto LABEL_58;
  }
  v27 = 0i64;
  v28 = v25;
  while ( 2 )
  {
    v29 = *v28;
    if ( *v28 == 47 || v29 == 92 )
    {
      v27 = v28;
      goto LABEL_55;
    }
    if ( v29 )
    {
LABEL_55:
      ++v28;
      continue;
    }
    break;
  }
  if ( !v27 )
    goto LABEL_57;
LABEL_58:
  *v27 = 0;
  if ( (*(__int64 (__fastcall **)(__int64, __int64 *, unsigned __int16 *, signed __int64, _QWORD))(v23 + 8))(
         v23,
         &v35,
         v25,
         1i64,
         0i64) >= 0
    && (*(__int64 (__fastcall **)(__int64, __int64 *, const char *, signed __int64, _QWORD))(v38 + 8))(
         v35,
         &v36,
         "E",
         1i64,
         0i64) >= 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|#B:ERPLWK]\n", v30, v31);
    BYTE1(qword_96AA8) |= 1u;
    v38 = v35;
LABEL_32:
    (*(void (**)(void))(v36 + 16))();
  }
LABEL_40:
  v33 = 0i64;
LABEL_41:
  sub_1905F((__int64)"End OpenVolume");
  qword_96AE0 = v33;
  result = v38;
  qword_96AE8 = v38;
  return result;
}
// 556B: write access to const memory at 96A98 has been detected
// 565D: write access to const memory at 96AB0 has been detected
// 570E: write access to const memory at 96AA9 has been detected
// 57C4: write access to const memory at 96AA8 has been detected
// 5842: write access to const memory at 96AAA has been detected
// 5896: write access to const memory at 96AA9 has been detected
// 58B5: write access to const memory at 96AE0 has been detected
// 58C0: write access to const memory at 96AE8 has been detected
// 58E1: write access to const memory at 96AA9 has been detected
// 59E1: write access to const memory at 96AA9 has been detected
// 4049C: using guessed type __int16 asc_4049C[2];
// 404A0: using guessed type __int16 asc_404A0[2];
// 92A90: using guessed type __int64 qword_92A90[2];
// 92B10: using guessed type __int64[2];
// 92B20: using guessed type __int64 qword_92B20[2];
// 92B40: using guessed type __int64 qword_92B40[2];
// 96A90: using guessed type __int64 qword_96A90;
// 96A98: using guessed type __int64 qword_96A98;
// 96AA0: using guessed type __int64 qword_96AA0;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AB0: using guessed type __int64 qword_96AB0;
// 96AD8: using guessed type __int64 qword_96AD8;
// 96AE0: using guessed type __int64 qword_96AE0;
// 96AE8: using guessed type __int64 qword_96AE8;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000059F5) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_59F5()
{
  __int64 result; // rax
  __int64 v1; // rax
  __int64 v2; // rsi
  __int64 v3; // rax
  const char *v4; // rcx
  __int64 v5; // [rsp+28h] [rbp-18h]
  __int64 v6; // [rsp+30h] [rbp-10h]

  v5 = -6148914691236517206i64;
  v6 = -6148914691236517206i64;
  if ( !(qword_96AA8 & 0x80000) )
  {
    result = qword_96AE8;
LABEL_7:
    qword_96AF0 = result;
    return result;
  }
  v1 = sub_B3CF(0);
  if ( !v1 )
    return sub_9CE0((__int64)"[EB|#STOP|`B:OKRV] ! @ FS:AGSVH\n");
  v2 = v1;
  sub_1905F((__int64)"Start OpenKernelRootVolume");
  v3 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(v2, qword_92B40, &v5);
  if ( v3 < 0 )
  {
    v4 = "[EB|#STOP|`B:OKRV] %r @ HdlP %g\n";
  }
  else
  {
    v3 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v5 + 8))(v5, &v6);
    if ( v3 >= 0 )
    {
      sub_1905F((__int64)"End OpenKernelRootVolume");
      result = v6;
      goto LABEL_7;
    }
    v4 = "[EB|#STOP|`B:OKRV] %r @ %g.OV\n";
  }
  return sub_9CE0((__int64)v4, v3, qword_92B40);
}
// 5A7D: write access to const memory at 96AF0 has been detected
// 92B40: using guessed type __int64 qword_92B40[2];
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AE8: using guessed type __int64 qword_96AE8;
// 96AF0: using guessed type __int64 qword_96AF0;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000005ABA) ----------------------------------------------------
_BYTE *__fastcall sub_5ABA(char a1)
{
  int v1; // eax
  char v2; // bl
  __int64 v3; // rsi
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 (__fastcall *v6)(const char *, int *, signed __int64, signed __int64, __int64); // rdi
  signed __int64 v7; // rax
  __int64 v8; // rax
  _BYTE *result; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  const char *v14; // rdx
  __int64 v15; // r9
  const char *v16; // rdx
  int v17; // [rsp+30h] [rbp-B0h]
  __int64 v18; // [rsp+B0h] [rbp-30h]
  int v19; // [rsp+BCh] [rbp-24h]
  __int64 v20; // [rsp+C0h] [rbp-20h]

  v20 = -6148914691236517206i64;
  v1 = qword_96AA8;
  if ( qword_96AA8 & 0x1200000 )
  {
    v2 = a1;
    v3 = sub_23DB4(qword_96AD8, *(_QWORD *)(qword_96A98 + 32));
    if ( !v3 )
      sub_1A2B6(1, (__int64)"[EB|`B:RB] ! @ EADP\n", v4, v5);
    if ( v2 )
      sub_1D3D6((__int64)"secure-boot", 11i64, 7u);
    v6 = *(__int64 (__fastcall **)(const char *, int *, signed __int64, signed __int64, __int64))(qword_96CE0 + 88);
    v7 = sub_23D3E(v3);
    v8 = v6("R", &dword_91FF4, 7i64, v7, v3);
    if ( v8 < 0 )
      sub_1A2B6(1, (__int64)"[EB|`B:RB] %r @ SV %g:%S\n", v8, (__int64)&dword_91FF4);
    result = (_BYTE *)sub_52BA(1u, 5u);
    v17 = 1;
    while ( v17 )
      ;
    return result;
  }
  if ( qword_96AA8 & 0x40 )
  {
    memset(&v17, 0, 0x80ui64);
    v18 = 128i64;
    v19 = 0;
    if ( (*(__int64 (__fastcall **)(const char *, __int64 *))(qword_96CE0 + 72))("r", qword_92360)
      || (unsigned int)sub_18A43((__int64)&v17, (__int64)"locked", 6) )
    {
      if ( sub_FE80() )
      {
        v14 = "[EB|#B:ROK:BP]\n";
      }
      else
      {
        if ( !(unsigned __int8)sub_FC87(v11, v10, v12, v13) )
        {
          sub_9CE0((__int64)"[EB|#STOP|`B:RB] ! @ OPT:VFP\n");
          goto LABEL_20;
        }
        v14 = "[EB|#B:ROK:PW]\n";
      }
    }
    else
    {
      sub_1000(6u);
      v14 = "[EB|#B:ROK:FMM]\n";
    }
    sub_1A2B6(1, (__int64)v14, v12, v13);
LABEL_20:
    v1 = qword_96AA8;
  }
  if ( _bittest(&v1, 0x13u) )
    result = (_BYTE *)sub_B59D(*(_QWORD *)(qword_96A98 + 24), *(_QWORD *)(qword_96A98 + 32), &v20, 0i64);
  else
    result = (_BYTE *)sub_1EF8A(qword_96AD8, &v20, 0i64);
  if ( (signed __int64)result < 0 )
  {
    v16 = "[EB|`B:RB] %r @ 'FRB\n";
  }
  else
  {
    sub_1A6EF(6u);
    result = (_BYTE *)(*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(qword_96CD8 + 208))(v20, 0i64, 0i64);
    if ( (signed __int64)result >= 0 )
      return result;
    v16 = "[EB|`B:RB] %r @ BS.SI\n";
  }
  return sub_1A2B6(1, (__int64)v16, (__int64)result, v15);
}
// 91FF4: using guessed type int dword_91FF4;
// 92360: using guessed type __int64 qword_92360[2];
// 96A98: using guessed type __int64 qword_96A98;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AD8: using guessed type __int64 qword_96AD8;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000005D11) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_5D11()
{
  unsigned __int64 v0; // rax
  __int64 result; // rax
  __int64 v2; // [rsp+28h] [rbp-18h]
  unsigned __int64 v3; // [rsp+30h] [rbp-10h]
  unsigned int v4; // [rsp+3Ch] [rbp-4h]

  v2 = 0i64;
  v4 = 0;
  v3 = -6148914691236517206i64;
  if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD))(qword_96CD8 + 320))(qword_92CD0, 0i64) < 0
    || ((*(__int64 (__fastcall **)(unsigned int *))(v2 + 8))(&v4) < 0 ? (qword_96AA0
                                                                      && !sub_F3C2(qword_96AA0, "Background Color", &v3) ? (LOWORD(v4) = v3, v0 = v3 >> 16, HIWORD(v4) = BYTE2(v3)) : (v4 = 12566463, LOBYTE(v0) = -65)) : (LOBYTE(v0) = BYTE2(v4)),
        !(_BYTE)v0) )
  {
    if ( !(_WORD)v4 )
      BYTE2(qword_96AA8) |= 4u;
  }
  result = v4;
  dword_92308 = v4;
  return result;
}
// 5DB9: write access to const memory at 96AAA has been detected
// 5DC3: write access to const memory at 92308 has been detected
// 92308: using guessed type int dword_92308;
// 92CD0: using guessed type __int64 qword_92CD0[2];
// 96AA0: using guessed type __int64 qword_96AA0;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000005DCF) ----------------------------------------------------
_BYTE *__fastcall sub_5DCF(int a1)
{
  int v1; // er15
  __int64 v2; // rax
  __int64 v3; // r9
  _BYTE *result; // rax
  __int64 v5; // r14
  __int64 *v6; // r12
  __int64 v7; // r13
  _QWORD *v8; // rcx
  unsigned __int64 v9; // rdi
  char v10; // di
  __int64 *v11; // rsi
  __int64 v12; // rdi
  __int64 v13; // rax
  __int64 v14; // r8
  __int64 v15; // r9
  int v16; // edi
  __int64 v17; // r12
  __int64 i; // r15
  const char *v19; // rdx
  __int64 v20; // [rsp+30h] [rbp-80h]
  __int64 v21; // [rsp+38h] [rbp-78h]
  __int128 v22; // [rsp+40h] [rbp-70h]
  unsigned __int64 v23; // [rsp+50h] [rbp-60h]
  __int64 v24; // [rsp+58h] [rbp-58h]
  __int64 v25; // [rsp+60h] [rbp-50h]
  unsigned __int64 v26; // [rsp+68h] [rbp-48h]
  __int64 v27; // [rsp+70h] [rbp-40h]

  v1 = a1;
  v22 = 0ui64;
  v23 = 0i64;
  v27 = 0i64;
  v25 = -6148914691236517206i64;
  v26 = -6148914691236517206i64;
  v24 = -6148914691236517206i64;
  v2 = (*(__int64 (__fastcall **)(signed __int64, int *, _QWORD, __int128 *, char *))(qword_96CD8 + 312))(
         2i64,
         &dword_92014,
         0i64,
         &v22,
         (char *)&v22 + 8);
  v3 = v22;
  if ( v2 >= 0
    && (_QWORD)v22
    && (v2 = (*(__int64 (__fastcall **)(signed __int64, __int64 *, _QWORD, unsigned __int64 *, __int64 *))(qword_96CD8 + 312))(
               2i64,
               qword_92B30,
               0i64,
               &v23,
               &v27),
        v3 = v23,
        v2 >= 0)
    && v23 )
  {
    result = (_BYTE *)v22;
    if ( (_QWORD)v22 )
    {
      v5 = 0i64;
      v6 = &v25;
      while ( !v3 )
      {
        v3 = 0i64;
LABEL_41:
        if ( ++v5 >= (unsigned __int64)result )
          goto LABEL_44;
      }
      v7 = 0i64;
      while ( 1 )
      {
        if ( (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *, unsigned __int64 *))(qword_96CD8 + 296))(
               *(_QWORD *)(v27 + 8 * v7),
               qword_92B30,
               v6,
               &v26) < 0 )
        {
          v10 = 0;
          goto LABEL_37;
        }
        if ( v26 )
        {
          v8 = (_QWORD *)(v25 + 8);
          v9 = 0i64;
          while ( *v8 != *(_QWORD *)(*((_QWORD *)&v22 + 1) + 8 * v5) )
          {
            ++v9;
            v8 += 3;
            if ( v9 >= v26 )
              goto LABEL_14;
          }
          if ( (_BYTE)v1 )
            goto LABEL_34;
          v11 = v6;
          v12 = *(_QWORD *)(v27 + 8 * v7);
          v20 = -6148914691236517206i64;
          v21 = -6148914691236517206i64;
          v13 = (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
                  *(_QWORD *)(qword_96A98 + 24),
                  qword_92A90,
                  &v20);
          if ( v13 < 0 )
          {
            v19 = "[EB|`B:WUTB] %r @ HdlP LIMG %g\n";
            goto LABEL_32;
          }
          v13 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(v12, qword_92A90, &v21);
          if ( v13 < 0 )
          {
            v19 = "[EB|`B:WUTB] %r @ HdlP WF %g\n";
LABEL_32:
            sub_1A2B6(1, (__int64)v19, v13, (__int64)qword_92A90);
LABEL_33:
            v6 = v11;
LABEL_34:
            (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(qword_96CD8 + 272))(*(_QWORD *)(v27 + 8 * v7), 0i64, 0i64);
            v10 = 1;
            if ( (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
                   *(_QWORD *)(v27 + 8 * v7),
                   qword_92B30,
                   &v24) >= 0 )
              (*(void (__fastcall **)(__int64, signed __int64, signed __int64, _QWORD))(v24 + 120))(
                v24,
                3i64,
                1024i64,
                0i64);
            goto LABEL_36;
          }
          v16 = v1;
          v17 = v21;
          for ( i = v20; (*(_BYTE *)i & 0x7F) != 127 || *(_BYTE *)(i + 1) != -1; i += *(unsigned __int16 *)(i + 2) )
          {
            if ( (*(_BYTE *)v17 & 0x7F) == 127 && *(_BYTE *)(v17 + 1) == -1 )
              break;
            v14 = *(unsigned __int16 *)(v17 + 2);
            if ( (_DWORD)v14 != *(unsigned __int16 *)(i + 2) || sub_236BB((_QWORD *)v17, (_QWORD *)i, v14) )
              break;
            v17 += *(unsigned __int16 *)(v17 + 2);
          }
          v1 = v16;
          if ( (*(_BYTE *)v17 & 0x7F) != 127 || *(_BYTE *)(v17 + 1) != -1 )
            goto LABEL_33;
          sub_1A2B6(1, (__int64)"[EB|#B:WF]\n", v14, v15);
          v10 = 0;
          v6 = v11;
        }
        else
        {
LABEL_14:
          v10 = 0;
        }
LABEL_36:
        (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v25);
        v25 = 0i64;
LABEL_37:
        v3 = v23;
        if ( !v10 && ++v7 < v23 )
          continue;
        result = (_BYTE *)v22;
        goto LABEL_41;
      }
    }
  }
  else
  {
    result = sub_1A2B6(1, (__int64)"[EB|`B:WFDW] %r, %qd @ LocHB %g\n", v2, v3);
  }
LABEL_44:
  if ( v27 )
    result = (_BYTE *)(*(__int64 (__cdecl **)(__int64))(qword_96CD8 + 72))(v27);
  if ( *((_QWORD *)&v22 + 1) )
    result = (_BYTE *)(*(__int64 (__cdecl **)(_QWORD))(qword_96CD8 + 72))(*((_QWORD *)&v22 + 1));
  return result;
}
// 92014: using guessed type int dword_92014;
// 92A90: using guessed type __int64 qword_92A90[2];
// 92B30: using guessed type __int64 qword_92B30[2];
// 96A98: using guessed type __int64 qword_96A98;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000006178) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
EFI_STATUS __cdecl ModuleEntryPoint(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable)
{
  __m128 *v2; // xmm0_8
  __m128i *v3; // xmm1_8
  __m128i *v4; // xmm2_8
  __m128i *v5; // xmm6_8
  __m128i *v6; // xmm7_8
  EFI_SYSTEM_TABLE *v7; // r12
  EFI_HANDLE v8; // r13
  __int64 v9; // r9
  __int64 v10; // r9
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // r9
  char **v14; // rdi
  unsigned __int64 v15; // rbx
  __int64 *v16; // rsi
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // rax
  __int64 v20; // r8
  __int64 *v21; // rsi
  unsigned __int64 v22; // rax
  signed __int64 v23; // rcx
  signed __int64 v24; // rax
  char *v25; // r14
  signed __int64 v26; // rsi
  char *v28; // rdi
  __int64 v29; // rax
  __int64 v30; // r9
  __int64 v31; // rdx
  __int64 v32; // rcx
  __int64 v33; // r8
  __int64 v34; // r9
  __int64 v35; // rax
  __int64 v36; // r9
  unsigned int v37; // ebx
  __int64 v38; // r8
  __int64 v39; // r9
  signed __int64 v40; // rsi
  const char *v41; // rdx
  __int64 v42; // r8
  __int64 v43; // r9
  __int64 *v44; // rsi
  __int64 v45; // rdi
  __int64 v46; // r8
  __int64 v47; // r9
  __int64 v48; // r8
  __int64 v49; // r9
  __int64 v50; // r8
  __int64 v51; // r9
  __int64 v52; // r8
  __int64 v53; // r9
  __int64 v54; // r9
  __int64 v55; // r8
  __int64 v56; // r9
  char v57; // al
  int v58; // eax
  __int64 v59; // rax
  __int64 v60; // r8
  __int64 v61; // r9
  __int64 v62; // r9
  signed __int64 v63; // rsi
  __int64 v64; // rsi
  __int64 v65; // rax
  __int64 v66; // rax
  const char *v67; // rsi
  __int64 v68; // rsi
  __int64 v69; // r9
  __int64 v70; // r8
  __int64 v71; // r9
  const char *v72; // rdx
  unsigned int *v73; // rax
  __int64 v74; // r9
  signed __int64 *v75; // rsi
  __int64 v76; // rax
  __int64 v77; // r9
  __int64 v78; // rax
  __int64 v79; // rsi
  __int64 v80; // r8
  __int64 v81; // r9
  __int64 v82; // r9
  __int64 v83; // r8
  __int64 v84; // r9
  __int64 v86; // [rsp+30h] [rbp-190h]
  __int64 v87; // [rsp+38h] [rbp-188h]
  __int64 v88; // [rsp+40h] [rbp-180h]
  __int64 v89; // [rsp+48h] [rbp-178h]
  __int64 v90; // [rsp+50h] [rbp-170h]
  __int64 v91; // [rsp+58h] [rbp-168h]
  __int64 v92; // [rsp+60h] [rbp-160h]
  __int64 v93; // [rsp+68h] [rbp-158h]
  __int64 v94; // [rsp+B0h] [rbp-110h]
  __int64 v95; // [rsp+F8h] [rbp-C8h]
  __int64 v96; // [rsp+100h] [rbp-C0h]
  __int64 v97; // [rsp+108h] [rbp-B8h]
  __int64 v98; // [rsp+110h] [rbp-B0h]
  __int64 v99; // [rsp+118h] [rbp-A8h]
  __int64 v100; // [rsp+120h] [rbp-A0h]
  __int64 v101; // [rsp+128h] [rbp-98h]
  __int64 v102; // [rsp+130h] [rbp-90h]
  __int64 v103; // [rsp+138h] [rbp-88h]
  __int64 v104; // [rsp+140h] [rbp-80h]
  __int64 v105; // [rsp+148h] [rbp-78h]
  __int64 v106; // [rsp+150h] [rbp-70h]
  __int64 *v107; // [rsp+158h] [rbp-68h]
  EFI_HANDLE v108; // [rsp+160h] [rbp-60h]
  __int64 (__fastcall **v109)(_QWORD, __int64 *); // [rsp+168h] [rbp-58h]
  __int64 v110; // [rsp+170h] [rbp-50h]
  __int64 v111; // [rsp+178h] [rbp-48h]
  char v112; // [rsp+187h] [rbp-39h]
  __int64 savedregs; // [rsp+1C0h] [rbp+0h]

  v7 = SystemTable;
  v8 = ImageHandle;
  v102 = -6148914691236517206i64;
  v103 = -6148914691236517206i64;
  v104 = -6148914691236517206i64;
  v101 = 0i64;
  v100 = 0i64;
  v99 = 0i64;
  v98 = 0i64;
  v97 = 0i64;
  v96 = 0i64;
  v95 = 0i64;
  v111 = 0i64;
  qword_96A90 = (__int64)ImageHandle;
  sub_23EFD((__int64)ImageHandle, (__int64)SystemTable);
  sub_113A9();
  sub_1A6EF(0);
  sub_1A2B6(
    1,
    (__int64)"[EB|#VERSION] %s\n",
    (__int64)"boot.efi 422.140.4~2 (Official), built 2021-05-20T22:29:16-0700",
    v9);
  sub_1A2B6(
    1,
    (__int64)"[EB|#BUILD] %s\n",
    (__int64)"BUILD-INFO[298]:{\"DisplayName\":\"boot.efi\",\"DisplayVersion\":\"422.140.4~2\",\"RecordUuid\":\"9C0E87DC-"
             "7676-4725-A30E-2CBF70B3EA58\",\"BuildTime\":\"2021-05-20T22:29:16-0700\",\"ProjectName\":\"efiboot\",\"Prod"
             "uctName\":\"boot.efi\",\"SourceVersion\":\"422.140.4\",\"BuildVersion\":\"2\",\"BuildConfiguration\":\"Rele"
             "ase\",\"BuildType\":\"Official\"}",
    v10);
  sub_2642();
  if ( qword_92420 & 1 )
    sub_11577();
  sub_18D87(0i64, 0i64);
  sub_1905F((__int64)"Start");
  sub_2724(1, 0i64, 0);
  v11 = sub_D1B2();
  if ( v11 < 0 )
    sub_9CE0((__int64)"[EB|#STOP|`B:MN] %r @ G:ICM\n", v11);
  if ( qword_96AA8 & 2 )
    sub_BA8B(2u);
  sub_9D57();
  v12 = sub_7623();
  if ( v12 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`B:MN] %r @ BST:IPI\n", v12, v13);
  }
  else
  {
    v14 = off_92030;
    v15 = 0i64;
    v16 = sub_9ADC();
    while ( (unsigned int)sub_18A1A((char *)v16, *v14) )
    {
      ++v15;
      ++v14;
      if ( v15 > 9 )
        goto LABEL_21;
    }
    LODWORD(v94) = 0;
    v86 = 4i64;
    if ( (*(__int64 (__fastcall **)(const __int16 *, int *, _QWORD))(qword_96CE0 + 72))(
           L"epid_provisioned",
           &dword_92004,
           0i64) < 0 )
    {
      v17 = qword_96B40;
      if ( qword_96B40 )
      {
        v18 = 0i64;
      }
      else
      {
        v18 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(
                qword_92CB0,
                0i64,
                &qword_96B40);
        v17 = qword_96B40;
      }
      if ( v17 && v18 >= 0 )
        (*(void (**)(void))(v17 + 24))();
      else
        sub_1A2B6(1, (__int64)"[EB|`B:IEP] %r @ LocP %g\n", v18, (__int64)qword_92CB0);
    }
  }
LABEL_21:
  if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92C90, 0i64, &v111) >= 0 )
  {
    if ( *(_DWORD *)v111 )
    {
      sub_1905F((__int64)"Start OSName");
      (*(void (__fastcall **)(const char *))(v111 + 8))("Mac OS X 10.15");
      sub_1905F((__int64)"End OSName");
      if ( *(_DWORD *)v111 >= 2u )
      {
        sub_1905F((__int64)"Start OSVendor");
        (*(void (__fastcall **)(const char *))(v111 + 16))("Apple Inc.");
        sub_1905F((__int64)"End OSVendor");
      }
    }
  }
  sub_2724(0, 0i64, 2);
  sub_1905F((__int64)"Start InitDeviceTree");
  sub_1936A();
  WORD2(v109) = 0;
  LODWORD(v109) = 0;
  memset(&v86, 0xAAu, 0x80ui64);
  v110 = -6148914691236517206i64;
  if ( (unsigned int)sub_18A43(4294967040i64, (__int64)"__AAPL__", 8) )
  {
    v110 = 6i64;
    if ( (*(__int64 (__fastcall **)(const char *, int *, _QWORD))(qword_96CE0 + 72))("R", &dword_91FF4, 0i64) < 0 )
    {
      v19 = (*(__int64 (__fastcall **)(const char *, int *, signed __int64, signed __int64, signed __int64))(qword_96CE0 + 88))(
              "R",
              &dword_91FF4,
              6i64,
              6i64,
              4294967041i64);
      if ( v19 < 0 )
        sub_1A2B6(1, (__int64)"[EB|`B:SRNO] %r @ SV %g:%S\n", v19, (__int64)&dword_91FF4);
      else
        sub_1A2B6(1, (__int64)"[EB|#B:RRVAR] %.*b\n", 6i64, 4294967041i64);
    }
    v110 = 128i64;
    sub_F1B0(&v86, 128i64);
    if ( (*(__int64 (__fastcall **)(const char *, int *, _QWORD, __int64 *, __int64 *))(qword_96CE0 + 72))(
           "M",
           &dword_91FF4,
           0i64,
           &v110,
           &v86) < 0 )
    {
      v21 = &v94;
      memset(&v94, 0xAAu, 0x48ui64);
      LOBYTE(v20) = -1;
      (*(void (__fastcall **)(__int64 *, signed __int64, __int64))(qword_96CD8 + 360))(&v94, 72i64, v20);
      (*(void (__fastcall **)(__int64 *, signed __int64, signed __int64))(qword_96CD8 + 352))(
        &v94,
        4294967048i64,
        72i64);
      v22 = 0i64;
      while ( *(_BYTE *)v21 != -1 )
      {
        ++v22;
        v21 = (__int64 *)((char *)v21 + 18);
        if ( v22 >= 4 )
          goto LABEL_36;
      }
      if ( !v22 )
        goto LABEL_42;
LABEL_36:
      v108 = v8;
      v23 = 9 * v22;
      v24 = v22 - 1;
      v25 = (char *)&savedregs + 2 * v23 - 272;
      v26 = -1i64;
      while ( v25[v26++ - 17] != 32 )
        ;
      v28 = (char *)&savedregs + 18 * v24 - 272;
      v29 = (*(__int64 (__fastcall **)(const char *, int *, signed __int64, signed __int64, char *))(qword_96CE0 + 88))(
              "M",
              &dword_91FF4,
              6i64,
              v26,
              (char *)&savedregs + 18 * v24 - 272);
      if ( v29 < 0 )
      {
        sub_1A2B6(1, (__int64)"[EB|`B:SRNO] %r @ SV %g:%S\n", v29, (__int64)&dword_91FF4);
      }
      else
      {
        v25[v26 - 18] = 0;
        sub_1A2B6(1, (__int64)"[EB|#B:MLBVAR] %s\n", (__int64)v28, v30);
      }
      v8 = v108;
    }
  }
LABEL_42:
  sub_1905F((__int64)"Start InitDeviceTree");
  sub_7294(v32, v31, v33, v34);
  sub_1905F((__int64)"End InitDeviceTree");
  sub_2724(0, 0i64, 3);
  qword_96AC8 = (__int64 (__fastcall *)(_QWORD, _QWORD))0xFFFFFFFFi64;
  v35 = sub_13759(
          1i64,
          1i64,
          (unsigned __int64)((char *)sub_5202 - (char *)sub_5180 + 4095) >> 12,
          (__int64 *)&qword_96AC8);
  if ( v35 < 0 )
    sub_9CE0(
      (__int64)"[EB|#STOP|`B:MN] %r @ M:BAP %qd @ 'KCG\n",
      v35,
      (unsigned __int64)((char *)sub_5202 - (char *)sub_5180 + 4095) >> 12);
  sub_1B930((char *)qword_96AC8, (char *)sub_5180, (char *)sub_5202 - (char *)sub_5180);
  sub_2724(0, 0i64, 4);
  sub_1905F((__int64)"Start InitMemoryConfig");
  sub_7809();
  sub_1905F((__int64)"End InitMemoryConfig");
  sub_2724(0, 0i64, 5);
  sub_1905F((__int64)"Start CheckHibernate");
  v37 = sub_1498C(&v102, v36, v2, v3, v4, v5, v6);
  if ( (_BYTE)v37 )
  {
    BYTE1(qword_96AA8) |= 0x20u;
  }
  else
  {
    sub_26DC();
    sub_13F31();
  }
  sub_1905F((__int64)"End CheckHibernate");
  sub_D39E();
  sub_B8E5();
  if ( sub_1153() )
  {
    v40 = 0x200000i64;
    v41 = "[EB|`B:MN] BM: +SB\n";
  }
  else
  {
    if ( !(unsigned __int8)sub_11882((unsigned __int64)sub_5180) )
      goto LABEL_52;
    v40 = 0x1000000i64;
    v41 = "[EB|`B:MN] BM: +TB\n";
  }
  sub_1A2B6(1, (__int64)v41, v38, v39);
  qword_96AA8 |= v40;
LABEL_52:
  if ( sub_117B5() )
  {
    sub_1A2B6(1, (__int64)"[EB|`B:MN] BM: +FD\n", v42, v43);
    BYTE3(qword_96AA8) |= 2u;
  }
  sub_FF72();
  sub_5505();
  sub_9E8B(3);
  if ( !sub_9DBE() )
    sub_9E8B(8);
  sub_1905F((__int64)"Start ProcessOptions");
  sub_106AA(qword_96AE0, qword_96AE8, (_WORD *)qword_96AB0, (char **)&qword_96AA0);
  sub_1905F((__int64)"End ProcessOptions");
  sub_5D11();
  v86 = 0i64;
  v44 = sub_9ADC();
  v45 = sub_1040A((__int64)v44, &v86);
  if ( v45 < 0 )
  {
    sub_C2C4(0, 0, v46, v47);
    if ( qword_96AA8 & 2 )
    {
      sub_BA8B(2u);
    }
    else if ( sub_B95F() >= 0 )
    {
      sub_CAE6(0i64, 0i64);
      sub_BB0D();
    }
    sub_1A2B6(1, (__int64)"\n***********************************************************\n", v48, v49);
    sub_1A2B6(1, (__int64)"This version of Mac OS X is not supported on this platform!\n", v50, v51);
    sub_1A2B6(1, (__int64)"***********************************************************\n", v52, v53);
    sub_1A2B6(1, (__int64)"Reason: %s\n", (__int64)v44, v54);
    sub_1A2B6(1, (__int64)"Sleeping for 30 seconds before exiting...\n", v55, v56);
    (*(void (__fastcall **)(signed __int64))(qword_96CD8 + 248))(30000000i64);
    sub_52BA(2u, 4u);
  }
  if ( v111 )
  {
    if ( *(_DWORD *)v111 >= 3u )
    {
      v57 = v86;
      if ( v86 )
      {
        if ( v86 & 1 )
        {
          sub_1A2B6(1, (__int64)"[EB|#B:VAw]\n", v46, v47);
          v57 = v86;
        }
        if ( v57 & 2 )
          sub_1A2B6(1, (__int64)"[EB|#B:IAw]\n", v46, v47);
        (*(void (__fastcall **)(__int64 *))(v111 + 24))(&v86);
      }
    }
  }
  v58 = qword_96AA8;
  if ( _bittest(&v58, 0xCu) )
  {
    qword_96AA8 &= 0xFFFFFFFFFFFFF6FFui64;
    sub_1A2B6(1, (__int64)"[EB|`B:MN] BM: ROS\n", v46, v47);
    sub_2724(0, v45, 19);
  }
  if ( !(qword_96AA8 & 0x3001) )
    sub_21A79((int)v7);
  if ( qword_96AA8 & 0x800 )
  {
    sub_2724(64, 0i64, 25);
    sub_5ABA(1);
  }
  sub_112D5(v37);
  if ( !(_BYTE)v37 && (qword_96AA8 & 0x5000) == 0x4000 )
  {
    v59 = sub_17276();
    if ( v59 < 0 )
      sub_9CE0((__int64)"[EB|`B:MN] %r @ MM:AKMR\n", v59);
  }
  sub_1E8F2((__int64)v8);
  sub_1C099(v2, v6);
  v112 = 1;
  if ( qword_96AA8 & 0x100 )
  {
    sub_2724(0, 0i64, 6);
    sub_1905F((__int64)"Start LoadCoreStorageConfiguration");
    v63 = sub_1C881(qword_96AE8, qword_96AE0, v37, v62, v2, v6);
    sub_1905F((__int64)"End LoadCoreStorageConfiguration");
    if ( (v63 | 0x10) == -9223372036854775778i64 && qword_96AA8 & 0x80000 )
    {
      v65 = sub_1D49C();
      if ( v65 < 0 )
        sub_1A2B6(1, (__int64)"[EB|`B:MN] %r @ CS:UVNO\n", v65, v61);
    }
    else if ( v63 >= 0 )
    {
      sub_1000(0x14u);
      BYTE1(qword_96AA8) |= 2u;
      sub_1905F((__int64)"Start UnlockCoreStorageVolumeKey");
      v64 = sub_1D658((__int64)v7, (__int64)v8, (__int64)&v112, v37, v3, v4, v5, v6);
      sub_1905F((__int64)"End UnlockCoreStorageVolumeKey");
      sub_2724(8, v64, 20);
      if ( v64 < 0 )
        sub_9CE0((__int64)"[EB|#STOP|`B:MN] %r @ CS:UFVK\n", v64);
    }
  }
  v66 = qword_96AA8;
  if ( !_bittest((const signed int *)&v66, 9u) )
  {
    sub_C2C4(0, 0, v60, v61);
    v66 = qword_96AA8;
  }
  if ( v66 & 2 )
  {
    qword_96AA8 = v66 & 0xFFFFFFFFFFFFFFDFui64;
    sub_1905F((__int64)"Start SetConsoleMode");
    sub_BA8B(2u);
    v67 = "End SetConsoleMode";
  }
  else
  {
    sub_1905F((__int64)"Start DrawBootGraphics");
    v67 = "End DrawBootGraphics";
    if ( sub_B95F() >= 0 && v112 )
    {
      sub_CAE6(0i64, 0i64);
      sub_BB0D();
    }
  }
  sub_1905F((__int64)v67);
  if ( (qword_96AA8 & 0x801000) == 4096 )
  {
    v68 = sub_2A19();
    sub_1A2B6(1, (__int64)"[EB|`B:MN] %r @ R:RVBI\n", v68, v69);
    if ( v68 < 0 )
    {
      if ( qword_96AA8 & 0x1200000 )
      {
LABEL_98:
        sub_9CE0((__int64)"[EB|#STOP|`B:MN] %r @ 'VRD\n", v68);
        goto LABEL_104;
      }
      if ( (unsigned int)sub_1BA2E() )
      {
        v72 = "[EB|#B:RCSR]\n";
      }
      else
      {
        if ( v68 != -9223372036854775784i64 )
          goto LABEL_98;
        v72 = "[EB|#B:RWKA]\n";
      }
      sub_1A2B6(1, (__int64)v72, v70, v71);
    }
  }
LABEL_104:
  if ( (_BYTE)v37 )
  {
    v93 = -6148914691236517206i64;
    v92 = -6148914691236517206i64;
    v91 = -6148914691236517206i64;
    v90 = -6148914691236517206i64;
    v89 = -6148914691236517206i64;
    v88 = -6148914691236517206i64;
    v87 = -6148914691236517206i64;
    v86 = -6148914691236517206i64;
    LODWORD(v94) = 64;
    sub_1905F((__int64)"Start LookupCoreStorageVolumeKey");
    v73 = sub_1E6AD(&v102, (__int64)&v86, (unsigned int *)&v94);
    if ( (signed __int64)v73 < 0 )
      sub_1A2B6(1, (__int64)"[EB|`B:MN] %r @ CS:LFVK\n", (__int64)v73, v74);
    sub_1905F((__int64)"Start FinishFDEHibernate");
    sub_17139((unsigned int)v94, (unsigned int *)&v86, v2, v3, v4, v5, v6);
    sub_1905F((__int64)"End FinishFDEHibernate");
  }
  v94 = 0i64;
  v110 = 0i64;
  v109 = 0i64;
  v105 = 0i64;
  v106 = 0i64;
  v86 = -6148914691236517206i64;
  v87 = -6148914691236517206i64;
  LODWORD(v88) = -1431655766;
  v107 = (__int64 *)-6148914691236517206i64;
  if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD))(qword_96CD8 + 320))(qword_92AE0, 0i64) >= 0
    && (*v109)(v109, &v106) >= 0
    && (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *, __int64, _QWORD, signed int))(qword_96CD8 + 280))(
         v106,
         qword_92AF0,
         &v105,
         qword_96A90,
         0i64,
         2) >= 0 )
  {
    v107 = &v86;
    v75 = (signed __int64 *)sub_A398();
    v76 = sub_D739(qword_96AE0, qword_96AE8, 0i64, *(_QWORD *)(qword_96A98 + 32), &v110, &v94);
    if ( v76 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`B:SBS] %r @ LD:LF\n", v76, v77);
    }
    else
    {
      sub_1A2B6(1, (__int64)"[EB|`B:SBS] SZ: %qd\n", v110, v77);
      if ( (*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD, __int64, __int64, __int64 **))(v105 + 8))(
             v105,
             qword_92B00,
             0i64,
             v94,
             v110,
             &v107) >= 0 )
        sub_1A2B6(1, (__int64)"[EB|#B:SHA] %.*b\n", 20i64, (__int64)&v86);
      sub_9EC7(v75, "boot-signature", 0x14ui64, (char *)&v86, 1);
    }
  }
  sub_2939();
  sub_59F5();
  v78 = sub_DE57(qword_96AE0, qword_96AF0, &v95);
  if ( v78 < 0 )
  {
    v79 = v78;
    sub_2724(0, v78, 22);
    sub_9CE0((__int64)"[EB|#STOP|`B:MN] %r @ LD:LKC\n", v79);
  }
  (*(void (__fastcall **)(const char *, int *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
    "D",
    &dword_91FF4,
    0i64,
    0i64,
    0i64);
  sub_1905F((__int64)"Start InitBootStruct");
  sub_7C43(qword_96A98, (char *)qword_96AA0);
  sub_1905F((__int64)"End InitBootStruct");
  sub_1905F((__int64)"Start LoadRAMDisk");
  sub_E3FD(qword_96AE0, qword_96AE8, v80, v81);
  sub_1905F((__int64)"End LoadRAMDisk");
  if ( qword_96B50 )
  {
    sub_1905F((__int64)"Start StopAnimation");
    sub_B88A();
    sub_1905F((__int64)"End StopAnimation");
  }
  sub_1905F((__int64)"Start FinalizeBootStruct");
  sub_82E2(&v104, qword_96AA0, (__int64)&v95, v82);
  sub_1905F((__int64)"End FinalizeBootStruct");
  sub_1A2B6(1, (__int64)"[EB|#B:BOOT]\n", v83, v84);
  sub_1905F((__int64)"End");
  _disable();
  qword_96AC8(qword_96B00, v97);
  sub_9CE0((__int64)"[EB|#STOP|`B:MN] Kernel entry failed\n");
  sub_5202(-9223372036854775787i64);
  return -9223372036854775787i64;
}
// 61E7: write access to const memory at 96A90 has been detected
// 66C0: write access to const memory at 96AC8 has been detected
// 6788: write access to const memory at 96AA9 has been detected
// 67E7: write access to const memory at 96AA8 has been detected
// 6808: write access to const memory at 96AAB has been detected
// 69D2: write access to const memory at 96AA8 has been detected
// 6B02: write access to const memory at 96AA9 has been detected
// 6BDA: write access to const memory at 96AA8 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 404A4: using guessed type __int16 aEpidProvisione[17];
// 91FF0: using guessed type char byte_91FF0;
// 91FF1: using guessed type char byte_91FF1;
// 91FF4: using guessed type int dword_91FF4;
// 92004: using guessed type int dword_92004;
// 92030: using guessed type char *off_92030[10];
// 92420: using guessed type __int64 qword_92420;
// 92AE0: using guessed type __int64 qword_92AE0[2];
// 92AF0: using guessed type __int64 qword_92AF0[2];
// 92B00: using guessed type __int64 qword_92B00[2];
// 92C90: using guessed type __int64 qword_92C90[2];
// 92CB0: using guessed type __int64 qword_92CB0[2];
// 96A90: using guessed type __int64 qword_96A90;
// 96A98: using guessed type __int64 qword_96A98;
// 96AA0: using guessed type __int64 qword_96AA0;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AB0: using guessed type __int64 qword_96AB0;
// 96AC8: using guessed type __int64 (__fastcall *qword_96AC8)(_QWORD, _QWORD);
// 96AE0: using guessed type __int64 qword_96AE0;
// 96AE8: using guessed type __int64 qword_96AE8;
// 96AF0: using guessed type __int64 qword_96AF0;
// 96B40: using guessed type __int64 qword_96B40;
// 96B50: using guessed type __int64 qword_96B50;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000007035) ----------------------------------------------------
char __fastcall sub_7035(signed __int64 a1, int a2, _BYTE *a3, int a4, int a5)
{
  unsigned int v5; // eax
  unsigned __int64 v6; // r11
  signed __int64 v7; // rsi
  int v8; // edi
  int v9; // edx
  unsigned int v10; // esi

  LOBYTE(v5) = a4;
  v6 = (unsigned __int64)&a3[a4 - 1];
LABEL_2:
  v7 = a1 + 2;
  v8 = a2;
  while ( v8 > 0 )
  {
    v9 = v8;
    a1 = v7;
    v10 = *(unsigned __int16 *)(v7 - 2);
    HIWORD(v5) = HIWORD(v10);
    LOWORD(v5) = __ROL2__(v10, 8);
    if ( a5 != 2 )
      v5 = v10;
    if ( (unsigned __int16)v5 > 0x7Fu )
    {
      if ( (unsigned __int16)v5 > 0x7FFu )
      {
        if ( (unsigned __int64)(a3 + 2) >= v6 )
          break;
        *a3 = ((unsigned int)(unsigned __int16)v5 >> 12) | 0xE0;
        a3[1] = (v5 >> 6) & 0x3F | 0x80;
        LOBYTE(v5) = v5 & 0x3F | 0x80;
        a3[2] = v5;
        a3 += 3;
      }
      else
      {
        if ( (unsigned __int64)(a3 + 1) >= v6 )
          break;
        *a3 = (v5 >> 6) | 0xC0;
        LOBYTE(v5) = v5 & 0x3F | 0x80;
        a3[1] = v5;
        a3 += 2;
      }
      goto LABEL_15;
    }
    if ( (unsigned __int64)a3 >= v6 )
      break;
    --v8;
    v7 = a1 + 2;
    if ( (_WORD)v5 )
    {
      *a3++ = v5;
LABEL_15:
      a2 = v9 - 1;
      goto LABEL_2;
    }
  }
  if ( a4 )
    *a3 = 0;
  return v5;
}

//----- (0000000000007102) ----------------------------------------------------
void __fastcall sub_7102(unsigned __int8 *a1, __int64 a2, _WORD *a3, signed __int64 *a4, __int64 a5)
{
  unsigned __int8 v5; // bl
  _WORD *v6; // rdi
  bool v7; // cf
  unsigned __int8 *v8; // rsi
  int v9; // er11
  char v10; // bl
  unsigned __int8 v11; // al
  unsigned __int8 v12; // cl

  v5 = *a1;
  v6 = a3;
  if ( *a1 )
  {
    v6 = a3;
    while ( 1 )
    {
      v7 = a2-- != 0;
      if ( v6 >= (_WORD *)((char *)a3 + a5) || !v7 )
        goto LABEL_15;
      v8 = a1 + 1;
      v9 = v5;
      if ( (v5 & 0x80u) != 0 )
        break;
LABEL_14:
      *v6 = v9;
      ++v6;
      v5 = *v8;
      a1 = v8;
      if ( !*v8 )
        goto LABEL_15;
    }
    v10 = v5 & 0xF0;
    if ( v10 != -64 )
    {
      if ( v10 == -32 )
      {
        v11 = *v8;
        if ( (*v8 & 0xC0) != 128 )
          goto LABEL_16;
        v8 = a1 + 2;
        v9 = ((v9 << 6) | v11 & 0x3F) << 6;
        goto LABEL_12;
      }
      if ( v10 != -48 )
        goto LABEL_16;
    }
    LOWORD(v9) = (v9 & 0x1F) << 6;
LABEL_12:
    v12 = *v8;
    if ( (*v8 & 0xC0) != 128 )
      goto LABEL_16;
    ++v8;
    LOWORD(v9) = v9 | v12 & 0x3F;
    goto LABEL_14;
  }
LABEL_15:
  *v6 = 0;
  ++v6;
LABEL_16:
  *a4 = v6 - a3;
}

//----- (00000000000071CF) ----------------------------------------------------
_BYTE *__fastcall sub_71CF(_WORD *a1)
{
  signed __int64 v1; // r14
  int v2; // eax
  int v3; // edi
  unsigned int v4; // ebx
  _BYTE *v5; // rax
  _BYTE *v6; // rsi

  v1 = (signed __int64)a1;
  v2 = sub_23741(a1);
  v3 = v2;
  v4 = 3 * v2 + 1;
  v5 = (_BYTE *)sub_1364F(v4);
  v6 = v5;
  if ( v5 )
  {
    *v5 = 0;
    sub_7035(v1, v3, v5, v4, 1);
  }
  return v6;
}

//----- (0000000000007226) ----------------------------------------------------
_WORD *__fastcall sub_7226(unsigned __int8 *a1, int a2)
{
  int v2; // er14
  unsigned __int8 *v3; // rsi
  __int64 v4; // rbx
  _WORD *v5; // rax
  _WORD *v6; // rdi
  __int64 v8; // [rsp+28h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  v8 = -6148914691236517206i64;
  v4 = (signed int)(4 * (unsigned __int64)sub_189FE(a1) + 2);
  v5 = (_WORD *)sub_1364F(v4);
  if ( !v5 )
    return 0i64;
  v6 = v5;
  *v5 = 0;
  sub_7102(v3, v2, v5, &v8, v4);
  return v6;
}

//----- (0000000000007294) ----------------------------------------------------
__int64 __fastcall sub_7294(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  signed __int64 *v5; // r13
  __int64 v6; // rdi
  __int64 v7; // r14
  __int64 v8; // rbx
  _BYTE *v9; // rsi
  __int64 v10; // rax
  signed __int64 *v11; // rsi
  __int64 v12; // r8
  __int64 v13; // r9
  int v14; // eax
  __int64 v16; // [rsp+30h] [rbp-B0h]
  __int64 v17; // [rsp+38h] [rbp-A8h]
  __int64 v18; // [rsp+40h] [rbp-A0h]
  __int64 v19; // [rsp+48h] [rbp-98h]
  __int64 v20; // [rsp+50h] [rbp-90h]
  __int64 v21; // [rsp+58h] [rbp-88h]
  __int64 v22; // [rsp+60h] [rbp-80h]
  __int64 v23; // [rsp+68h] [rbp-78h]
  __int64 v24; // [rsp+70h] [rbp-70h]
  __int64 v25; // [rsp+78h] [rbp-68h]
  __int64 v26; // [rsp+88h] [rbp-58h]
  __int64 v27; // [rsp+90h] [rbp-50h]
  __int64 v28; // [rsp+98h] [rbp-48h]
  __int64 v29; // [rsp+A0h] [rbp-40h]

  v25 = -6148914691236517206i64;
  v24 = -6148914691236517206i64;
  v23 = -6148914691236517206i64;
  v22 = -6148914691236517206i64;
  v21 = -6148914691236517206i64;
  v20 = -6148914691236517206i64;
  v19 = -6148914691236517206i64;
  v18 = -6148914691236517206i64;
  v28 = -6148914691236517206i64;
  sub_1A2B6(1, (__int64)"[EB|`BST:IDT] {\n", a3, a4);
  sub_A13F();
  if ( !sub_A398() )
    sub_9CE0((__int64)"[EB|#STOP|`BST:IDT] ! @ DT:FN+ /\n");
  v4 = sub_A398();
  if ( v4 )
  {
    v5 = (signed __int64 *)v4;
    v27 = -6148914691236517206i64;
    if ( (*(__int64 (__fastcall **)(int *, _QWORD))(qword_96CD8 + 320))(&dword_92814, 0i64) >= 0 )
    {
      v6 = v27;
      v29 = -6148914691236517206i64;
      v17 = 8812435846899252400i64;
      v16 = 4634596960510246088i64;
      v26 = 0i64;
      do
      {
        if ( (*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD, __int64 *))(v6 + 8))(v6, &v26, 0i64, &v29) < 0 )
          break;
        if ( sub_23695(v29 + 24, (__int64)&v16) )
        {
          v7 = v29;
          v8 = (unsigned int)(3 * *(_DWORD *)(v29 + 88) + 1);
          v9 = (_BYTE *)sub_1364F(v8);
          sub_7035(v7 + 96, *(_DWORD *)(v7 + 88) >> 1, v9, v8, 1);
          sub_9EC7(v5, v9, *(unsigned int *)(v7 + 92), (char *)(v7 + *(unsigned int *)(v7 + 88) + 96), 1);
        }
      }
      while ( v26 );
    }
  }
  v10 = sub_A398();
  if ( v10 )
  {
    v11 = (signed __int64 *)v10;
    v28 = 63i64;
    if ( (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
           L"BridgeOSBootSessionUUID",
           qword_92360,
           0i64) >= 0 )
    {
      *((_BYTE *)&v18 + v28) = 0;
      sub_1A2B6(1, (__int64)"[EB|#BBSID] %e\n", (__int64)&v18, v13);
      v14 = sub_189FE(&v18);
      sub_9EC7(v11, "bridge-boot-session-uuid", v14 + 1, (char *)&v18, 1);
    }
  }
  else
  {
    sub_9CE0((__int64)"[EB|#STOP|`BST:IDT] ! @ DT:FN+ /chosen\n");
  }
  sub_1A2B6(1, (__int64)"[EB|`BST:IDT] }\n", v12, v13);
  return 0i64;
}
// 40504: using guessed type __int16 aBridgeosbootse[24];
// 92360: using guessed type __int64 qword_92360[2];
// 92814: using guessed type int dword_92814;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (00000000000074E9) ----------------------------------------------------
__int64 __fastcall sub_74E9(_BYTE *a1)
{
  __int64 v1; // r15
  int v2; // eax
  int v3; // er14
  __int64 v4; // rbx
  unsigned __int64 v5; // rdi
  __int64 v6; // rsi
  char v7; // al
  __int64 v8; // rdi
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // r12
  __int64 v11; // rsi
  __int64 result; // rax
  __int64 v13; // r12
  unsigned __int64 v14; // rbx
  unsigned __int64 v15; // rdi
  bool v16; // zf

  v1 = (__int64)a1;
  v2 = sub_189FE(a1);
  if ( !v2 || !*(_QWORD *)(qword_96CD0 + 104) )
    return 0i64;
  v3 = v2;
  v4 = *(_QWORD *)(qword_96CD0 + 112);
  v5 = 0i64;
  v6 = 0i64;
  while ( !sub_23695(v4, (__int64)qword_92A40) )
  {
    if ( sub_23695(v4, (__int64)qword_92A30) )
      v6 = *(_QWORD *)(v4 + 16);
    ++v5;
    v4 += 24i64;
    if ( v5 >= *(_QWORD *)(qword_96CD0 + 104) )
      goto LABEL_10;
  }
  v6 = *(_QWORD *)(v4 + 16);
LABEL_10:
  if ( !v6 )
    return 0i64;
  v7 = *(_BYTE *)(v6 + 15);
  if ( v7 == 1 )
    return 0i64;
  if ( v7 )
  {
    v13 = *(_QWORD *)(v6 + 24);
    v14 = 0i64;
    v15 = ((unsigned __int64)*(unsigned int *)(v13 + 4) - 36) >> 3;
    if ( v15 )
    {
      do
      {
        v11 = *(_QWORD *)(v13 + 8 * v14 + 36);
        if ( !(unsigned int)sub_18A43(*(_QWORD *)(v13 + 8 * v14 + 36), v1, v3) )
          break;
        ++v14;
      }
      while ( v14 < v15 );
    }
    else
    {
      v11 = 0i64;
    }
    result = 0i64;
    v16 = v14 == v15;
  }
  else
  {
    v8 = *(unsigned int *)(v6 + 16);
    v9 = 0i64;
    v10 = ((unsigned __int64)*(unsigned int *)(v8 + 4) - 36) >> 2;
    if ( v10 )
    {
      do
      {
        v11 = *(unsigned int *)(v8 + 4 * v9 + 36);
        if ( !(unsigned int)sub_18A43(v11, v1, v3) )
          break;
        ++v9;
      }
      while ( v9 < v10 );
    }
    else
    {
      v11 = 0i64;
    }
    result = 0i64;
    v16 = v9 == v10;
  }
  if ( !v16 )
    result = v11;
  return result;
}
// 92A30: using guessed type __int64 qword_92A30[2];
// 92A40: using guessed type __int64 qword_92A40[2];
// 96CD0: using guessed type __int64 qword_96CD0;

//----- (0000000000007623) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 sub_7623()
{
  __int64 v0; // r9
  const char *v1; // rdx
  signed __int64 v2; // r14
  __int64 v4; // rdi
  unsigned __int64 v5; // rsi
  __int64 v6; // rdi
  _BYTE *v7; // rcx
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rbx
  unsigned __int8 v10; // dl
  __int64 v11; // rdx
  _BYTE *v12; // rbx
  bool v13; // cf
  const char *v14; // rax
  __int64 v15; // [rsp+28h] [rbp-28h]

  v15 = 64i64;
  if ( (*(__int64 (__fastcall **)(const __int16 *, int *, _QWORD))(qword_96CE0 + 72))(L"HW_BID", &dword_91FF4, 0i64) >= 0 )
  {
    v1 = "[EB|#BRD:NV] %e\n";
LABEL_3:
    sub_1A2B6(1, (__int64)v1, (__int64)qword_93690, v0);
    return 0i64;
  }
  v2 = -9223372036854775794i64;
  if ( *(_QWORD *)(qword_96CD0 + 104) )
  {
    v4 = *(_QWORD *)(qword_96CD0 + 112);
    v5 = 0i64;
    while ( !sub_23695(v4, (__int64)qword_92A50) )
    {
      ++v5;
      v4 += 24i64;
      if ( *(_QWORD *)(qword_96CD0 + 104) <= v5 )
        return v2;
    }
    v6 = *(_QWORD *)(v4 + 16);
    if ( !sub_236BB((_QWORD *)v6, "_SM_", 4i64) )
    {
      v7 = (_BYTE *)*(unsigned int *)(v6 + 24);
      v8 = (unsigned int)v7 + *(unsigned __int16 *)(v6 + 22);
      if ( (unsigned __int64)v7 < v8 && (unsigned __int64)(v7 + 4) <= v8 )
      {
        v9 = *(unsigned int *)(v6 + 24);
        while ( 1 )
        {
          if ( *v7 == 2 )
          {
            if ( (unsigned __int64)(v7 + 17) > v8 )
              return v2;
            v10 = *(_BYTE *)(v9 + 5);
            if ( v10 )
              break;
          }
          v11 = *(unsigned __int8 *)(v9 + 1);
          v9 = (unsigned __int64)&v7[v11];
          if ( (unsigned __int64)&v7[v11] < v8 )
          {
            v12 = &v7[v11 + 1];
            while ( *(v12 - 1) || (unsigned __int64)v12 >= v8 || *v12 )
            {
              v13 = (unsigned __int64)v12++ < v8;
              if ( !v13 )
              {
                v9 = (unsigned __int64)(v12 - 1);
                goto LABEL_24;
              }
            }
            v9 = (unsigned __int64)(v12 + 1);
          }
LABEL_24:
          if ( v9 < v8 )
          {
            v7 = (_BYTE *)v9;
            if ( v9 + 4 <= v8 )
              continue;
          }
          return v2;
        }
        v14 = sub_77C2(&v7[*(unsigned __int8 *)(v9 + 1)], v10);
        sub_18A90((__int64)qword_93690, (__int64)v14, 64i64);
        byte_936CF = 0;
        v1 = "[EB|#BRD:SMBIOS] %e\n";
        goto LABEL_3;
      }
    }
  }
  return v2;
}
// 77A7: write access to const memory at 936CF has been detected
// 40534: using guessed type __int16 aHwBid[7];
// 91FF4: using guessed type int dword_91FF4;
// 92A50: using guessed type __int64 qword_92A50[2];
// 93690: using guessed type __int64 qword_93690[7];
// 936CF: using guessed type char byte_936CF;
// 96CD0: using guessed type __int64 qword_96CD0;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (00000000000077C2) ----------------------------------------------------
const char *__fastcall sub_77C2(char *a1, unsigned __int8 a2)
{
  char *v2; // rsi
  unsigned __int8 v3; // bl
  const char *result; // rax

  v2 = a1;
  if ( a2 >= 2u )
  {
    v3 = a2;
    do
    {
      if ( !*v2 )
        break;
      v2 += (signed int)sub_189FE(v2) + 1;
      --v3;
    }
    while ( v3 > 1u );
  }
  result = "BadIndex";
  if ( *v2 )
    result = v2;
  return result;
}

//----- (0000000000007809) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_7809()
{
  char v0; // r14
  __int64 v1; // r9
  __int64 v2; // rsi
  unsigned __int64 v3; // rbx
  __int64 v4; // rsi
  char *v6; // r12
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r15
  char v9; // al
  __int64 v10; // rax
  unsigned __int8 v11; // dl
  const char *v12; // rax
  __int64 v13; // r9
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  char *v18; // r15
  bool v19; // cf
  char v20; // [rsp+30h] [rbp-C0h]
  __int64 v21; // [rsp+B0h] [rbp-40h]

  v21 = 64i64;
  v0 = 0;
  if ( !(*(__int64 (__fastcall **)(const __int16 *, int *, _QWORD))(qword_96CE0 + 72))(L"HW_BID", &dword_91FF4, 0i64) )
  {
    sub_1A2B6(1, (__int64)"[EB|#BRD:NV] %e\n", (__int64)qword_93690, v1);
    v0 = 1;
  }
  if ( *(_QWORD *)(qword_96CD0 + 104) )
  {
    v2 = *(_QWORD *)(qword_96CD0 + 112);
    v3 = 0i64;
    while ( !sub_23695(v2, (__int64)qword_92A50) )
    {
      ++v3;
      v2 += 24i64;
      if ( *(_QWORD *)(qword_96CD0 + 104) <= v3 )
        return 0i64;
    }
    v4 = *(_QWORD *)(v2 + 16);
    if ( !sub_236BB((_QWORD *)v4, "_SM_", 4i64) )
    {
      v6 = (char *)*(unsigned int *)(v4 + 24);
      v7 = (unsigned int)v6 + *(unsigned __int16 *)(v4 + 22);
      if ( (unsigned __int64)v6 < v7 && (unsigned __int64)(v6 + 4) <= v7 )
      {
        v8 = (unsigned __int64)v6;
        while ( 1 )
        {
          v9 = *v6;
          if ( *v6 == 2 )
          {
            if ( (unsigned __int64)(v6 + 17) > v7 )
              return 0i64;
            v11 = *(_BYTE *)(v8 + 5);
            if ( !((unsigned __int8)v0 | (v11 == 0)) )
            {
              v12 = sub_77C2(&v6[*(unsigned __int8 *)(v8 + 1)], v11);
              sub_18A90((__int64)qword_93690, (__int64)v12, 64i64);
              byte_936CF = 0;
              sub_1A2B6(1, (__int64)"[EB|#BRD:SMBIOS] %e\n", (__int64)qword_93690, v13);
              v9 = *v6;
LABEL_22:
              if ( v9 == 1 )
              {
                memset(&v20, 0xAAu, 0x80ui64);
                if ( (unsigned __int64)(v6 + 27) > v7 )
                  return 0i64;
                v14 = sub_1364F(16i64);
                qword_936D0 = v14;
                if ( v14 )
                {
                  (*(void (__fastcall **)(__int64, unsigned __int64, signed __int64))(qword_96CD8 + 352))(
                    v14,
                    v8 + 8,
                    16i64);
                  sub_7AC8(0i64, (unsigned __int64)&v20);
                }
              }
              goto LABEL_34;
            }
          }
          else
          {
            if ( v9 == 17 )
            {
              if ( (unsigned __int64)(v6 + 34) > v7 )
                return 0i64;
              v15 = *(unsigned __int16 *)(v8 + 12);
              if ( v15 != 0xFFFF )
              {
                if ( (v15 & 0x8000u) != 0i64 )
                {
                  v16 = (unsigned __int64)(v15 & 0x7FFF) << 10;
                }
                else
                {
                  if ( (_DWORD)v15 == 0x7FFF )
                    v15 = *(_DWORD *)(v8 + 28) & 0x7FFFFFFF;
                  v16 = v15 << 20;
                }
                qword_96B18 += v16;
              }
              goto LABEL_34;
            }
            if ( v9 != 16 )
              goto LABEL_22;
            if ( (unsigned __int64)(v6 + 23) > v7 )
              return 0i64;
            v10 = *(unsigned int *)(v8 + 7);
            if ( v10 != 0x80000000i64 )
            {
              qword_96B08 += (unsigned __int64)*(unsigned int *)(v8 + 7) << 10;
              dword_96B10 += *(unsigned __int16 *)(v8 + 13);
            }
          }
LABEL_34:
          v17 = *(unsigned __int8 *)(v8 + 1);
          v8 = (unsigned __int64)&v6[v17];
          if ( (unsigned __int64)&v6[v17] < v7 )
          {
            v18 = &v6[v17 + 1];
            while ( *(v18 - 1) || (unsigned __int64)v18 >= v7 || *v18 )
            {
              v19 = (unsigned __int64)v18++ < v7;
              if ( !v19 )
              {
                v8 = (unsigned __int64)(v18 - 1);
                goto LABEL_41;
              }
            }
            v8 = (unsigned __int64)(v18 + 1);
          }
LABEL_41:
          if ( v8 < v7 )
          {
            v6 = (char *)v8;
            if ( v8 + 4 <= v7 )
              continue;
          }
          return 0i64;
        }
      }
    }
  }
  return 0i64;
}
// 7944: write access to const memory at 96B08 has been detected
// 7950: write access to const memory at 96B10 has been detected
// 79A0: write access to const memory at 936CF has been detected
// 79F4: write access to const memory at 936D0 has been detected
// 7A6A: write access to const memory at 96B18 has been detected
// 40534: using guessed type __int16 aHwBid[7];
// 91FF4: using guessed type int dword_91FF4;
// 92A50: using guessed type __int64 qword_92A50[2];
// 93690: using guessed type __int64 qword_93690[7];
// 936CF: using guessed type char byte_936CF;
// 936D0: using guessed type __int64 qword_936D0;
// 96B08: using guessed type __int64 qword_96B08;
// 96B10: using guessed type int dword_96B10;
// 96B18: using guessed type __int64 qword_96B18;
// 96CD0: using guessed type __int64 qword_96CD0;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000007AC8) ----------------------------------------------------
__int64 __fastcall sub_7AC8(unsigned int *a1, unsigned __int64 a2)
{
  return sub_18905(
           a2,
           (__int64)"%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX",
           *a1,
           *((unsigned __int16 *)a1 + 2),
           *((unsigned __int16 *)a1 + 3),
           *((unsigned __int8 *)a1 + 8),
           *((unsigned __int8 *)a1 + 9),
           *((unsigned __int8 *)a1 + 10),
           *((unsigned __int8 *)a1 + 11),
           *((unsigned __int8 *)a1 + 12),
           *((unsigned __int8 *)a1 + 13),
           *((unsigned __int8 *)a1 + 14),
           *((unsigned __int8 *)a1 + 15));
}

//----- (0000000000007B52) ----------------------------------------------------
bool __fastcall sub_7B52(int a1)
{
  int v1; // esi
  bool result; // al
  int v3; // [rsp+24h] [rbp-Ch]

  v1 = a1;
  v3 = 0;
  if ( sub_7B82((unsigned int *)&v3) < 0 )
    result = 0;
  else
    result = (v1 & v3) != 0;
  return result;
}

//----- (0000000000007B82) ----------------------------------------------------
__int64 __fastcall sub_7B82(unsigned int *a1)
{
  unsigned int *v1; // rsi
  __int64 v2; // rax
  __int64 v3; // rdi
  __int64 v4; // r9
  __int64 v5; // r9
  __int64 v7; // [rsp+30h] [rbp-20h]
  unsigned int v8; // [rsp+38h] [rbp-18h]
  unsigned int v9; // [rsp+3Ch] [rbp-14h]

  v1 = a1;
  v8 = 0;
  v9 = 0;
  v7 = 4i64;
  v2 = (*(__int64 (__fastcall **)(const __int16 *, int *, _QWORD))(qword_96CE0 + 72))(
         L"FirmwareFeatures",
         &dword_91FF4,
         0i64);
  if ( v2 < 0 )
    return v2;
  v7 = 4i64;
  v3 = (*(__int64 (__fastcall **)(const char *, int *, _QWORD))(qword_96CE0 + 72))("F", &dword_91FF4, 0i64);
  if ( v3 >= 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|#FWFM] 0x%08X\n", v9, v4);
    sub_1A2B6(1, (__int64)"[EB|#FWFT] 0x%08X\n", v8, v5);
    *v1 = v9 & v8;
  }
  return v3;
}
// 40584: using guessed type __int16 aFirmwarefeatur[17];
// 91FF4: using guessed type int dword_91FF4;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000007C43) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_7C43(__int64 a1, char *a2)
{
  char *v2; // r12
  __int64 v3; // r14
  __int64 v4; // rsi
  __int64 v5; // rdx
  __int64 v6; // r8
  __int64 v7; // r9
  signed __int64 *v8; // rdi
  signed __int64 *v9; // r15
  char *v10; // rbx
  int v11; // eax
  __int64 *v12; // rbx
  int v13; // eax
  char *v14; // rdi
  int v15; // eax
  signed __int64 v16; // rax
  _BYTE *v17; // rsi
  signed __int64 v18; // rax
  _BYTE *i; // rdi
  char v20; // dl
  unsigned __int8 v21; // al
  unsigned __int8 v22; // bl
  __int64 v23; // r9
  __int64 v24; // r8
  __int64 v26; // rax
  __int64 v27; // rcx
  signed __int64 v28; // rax
  __int64 v29; // [rsp+30h] [rbp-B0h]
  __int64 v30; // [rsp+38h] [rbp-A8h]
  __int64 v31; // [rsp+40h] [rbp-A0h]
  __int64 v32; // [rsp+48h] [rbp-98h]
  __int64 v33; // [rsp+50h] [rbp-90h]
  __int64 v34; // [rsp+58h] [rbp-88h]
  __int64 v35; // [rsp+60h] [rbp-80h]
  __int64 v36; // [rsp+68h] [rbp-78h]
  __int64 v37; // [rsp+70h] [rbp-70h]
  __int64 v38; // [rsp+78h] [rbp-68h]
  __int64 v39; // [rsp+80h] [rbp-60h]
  __int64 v40; // [rsp+88h] [rbp-58h]
  __int64 v41; // [rsp+90h] [rbp-50h]
  __int64 v42; // [rsp+98h] [rbp-48h]
  int v43; // [rsp+A4h] [rbp-3Ch]
  unsigned __int64 v44; // [rsp+A8h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  v39 = -6148914691236517206i64;
  v38 = -6148914691236517206i64;
  v37 = -6148914691236517206i64;
  v36 = -6148914691236517206i64;
  v35 = -6148914691236517206i64;
  v34 = -6148914691236517206i64;
  v33 = -6148914691236517206i64;
  v32 = -6148914691236517206i64;
  v31 = -6148914691236517206i64;
  v40 = -6148914691236517206i64;
  v44 = -6148914691236517206i64;
  v43 = 0;
  v41 = -6148914691236517206i64;
  if ( sub_7B82((unsigned int *)&v43) >= 0 && v43 >= 0 )
  {
    v30 = 3327283121286347933i64;
    v29 = 5227249873927011687i64;
    v42 = 0i64;
    v41 = 8i64;
    if ( (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("A", &v29, 0i64) < 0 )
    {
      v42 = 0i64;
    }
    else if ( v42 )
    {
      qword_936D8 = *(_QWORD *)(v42 + 24);
      byte_936E0 = 1;
    }
  }
  v39 = 4096i64;
  v4 = sub_17500(&v39, 0i64);
  if ( !v4 )
    sub_9CE0((__int64)"[EB|#STOP|`BST:IBS] ! @ MM:AKM %qd\n", 4096i64);
  qword_96B00 = v4;
  (*(void (__fastcall **)(__int64, signed __int64, _QWORD))(qword_96CD8 + 360))(v4, 4096i64, 0i64);
  *(_DWORD *)v4 = (_DWORD)((char *)&loc_1FFFD + 3);
  *(_WORD *)(v4 + 4) = 64;
  sub_1BAD2(v4, v5, v6, v7);
  v8 = (signed __int64 *)sub_A398();
  if ( !v8 )
    sub_9CE0((__int64)"[EB|#STOP|`BST:IBS] ! @ DT:FN%s %s\n", &byte_42BDF, "/");
  v44 = (signed int)((unsigned __int64)sub_189FE("ACPI") + 1);
  sub_9EC7(v8, "compatible", v44, "ACPI", 0);
  sub_9EC7(v8, "model", v44, "ACPI", 0);
  v9 = (signed __int64 *)sub_A398();
  if ( !v9 )
    sub_9CE0((__int64)"[EB|#STOP|`BST:IBS] ! @ DT:FN%s %s\n", "+", "/chosen");
  qword_936E8 = sub_A398();
  sub_1A2B6(1, (__int64)"[EB|`BST:IBS] ! @ DT:FN%s %s\n", (__int64)"+", (__int64)"/chosen/memory-map");
  if ( !sub_F1CC(v2, "rd", &v40, (char **)&v44) )
    goto LABEL_20;
  v10 = (char *)sub_1103F("Root Match");
  if ( v10 )
    goto LABEL_17;
  v12 = (__int64 *)sub_11012("Root UUID");
  if ( v12 )
    goto LABEL_19;
  v26 = sub_81D5();
  if ( v26 )
  {
    v10 = (char *)v26;
    sub_9EC7(v8, "net-boot", 0i64, 0i64, 0);
LABEL_17:
    v11 = sub_189FE(v10);
    sub_9EC7(v9, "root-matching", v11 + 1, v10, 1);
    sub_136C5((__int64)v10);
    goto LABEL_20;
  }
  v27 = *(_QWORD *)(v3 + 24);
  v12 = &v31;
  if ( qword_96AA8 & 0x80000 )
  {
    v28 = sub_B226(v27, *(_QWORD *)(v3 + 32), 64i64, (__int64)&v31, 0i64);
  }
  else
  {
    if ( sub_B0E9(v27, 64i64, (unsigned __int64)&v31) >= 0 )
      goto LABEL_19;
    v12 = &v31;
    if ( sub_AF60(*(_QWORD *)(v3 + 24), 64i64, &v31) >= 0 )
      goto LABEL_19;
    v12 = &v31;
    v28 = sub_AEE6(*(_QWORD *)(v3 + 24), 64i64, (unsigned __int64)&v31);
  }
  if ( v28 >= 0 )
  {
LABEL_19:
    v13 = sub_189FE(v12);
    sub_9EC7(v9, "boot-uuid", v13 + 1, (char *)v12, 1);
  }
LABEL_20:
  if ( !qword_96B60 || (v14 = sub_71CF((_WORD *)qword_96B60)) == 0i64 )
  {
    sub_9CE0((__int64)"[EB|#STOP|`BST:IBS] ! @ BST:U8U16\n");
    v14 = 0i64;
  }
  v15 = sub_189FE(v14);
  sub_9EC7(v9, "boot-file", v15 + 1, v14, 1);
  sub_136C5((__int64)v14);
  v16 = sub_23D3E(qword_96AD8);
  v17 = 0i64;
  sub_9EC7(v9, "boot-device-path", v16, (char *)qword_96AD8, 0);
  v18 = sub_23D3E(*(_QWORD *)(qword_96A98 + 32));
  sub_9EC7(v9, "boot-file-path", v18, *(char **)(qword_96A98 + 32), 0);
  sub_9EC7(v9, "boot-kernelcache-adler32", 4ui64, (char *)&dword_96B70, 0);
  v30 = 7096236940602954928i64;
  v29 = 4791279818216507368i64;
  for ( i = (_BYTE *)qword_96AD8; ; i += v21 | ((unsigned __int64)v22 << 8) )
  {
    v20 = *i & 0x7F;
    if ( v20 == 127 && i[1] == -1 )
      break;
    v21 = i[2];
    v22 = i[3];
    if ( !*((_WORD *)i + 1) )
      break;
    if ( v20 == 3 )
    {
      if ( i[1] == 10 )
      {
        if ( sub_23695((__int64)(i + 4), (__int64)&v29) )
        {
          if ( v17 )
          {
            v23 = *((_QWORD *)v17 + 1);
            if ( (unsigned __int64)(*((_QWORD *)v17 + 2) - v23 + 1) >= 0x1000
              && *(_QWORD *)v23 == 6074885685449146706i64
              && *(_QWORD *)(v23 + 4088) == 6074885685449146706i64
              && *(_DWORD *)(v23 + 8) == (_DWORD)((char *)&loc_FFFF + 1) )
            {
              v24 = *(unsigned int *)(v23 + 12);
              if ( (unsigned int)(v24 - 1) <= 0xFD )
              {
                if ( *(_QWORD *)(i + 20) )
                {
                  sub_9EC7(v9, "boot-ramdmg-extents", 16 * v24, (char *)(v23 + 16), 0);
                  sub_9EC7(v9, "boot-ramdmg-size", 8ui64, i + 20, 0);
                }
              }
            }
          }
          return 0i64;
        }
        v21 = i[2];
        v22 = i[3];
      }
    }
    else if ( v20 == 1 && i[1] == 3 )
    {
      v17 = i;
    }
  }
  return 0i64;
}
// 7D1B: write access to const memory at 936D8 has been detected
// 7D22: write access to const memory at 936E0 has been detected
// 7D5E: write access to const memory at 96B00 has been detected
// 7E49: write access to const memory at 936E8 has been detected
// 42BDF: using guessed type char byte_42BDF;
// 936D8: using guessed type __int64 qword_936D8;
// 936E0: using guessed type char byte_936E0;
// 936E8: using guessed type __int64 qword_936E8;
// 96A98: using guessed type __int64 qword_96A98;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AD8: using guessed type __int64 qword_96AD8;
// 96B60: using guessed type __int64 qword_96B60;
// 96B70: using guessed type int dword_96B70;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (00000000000081D5) ----------------------------------------------------
__int64 sub_81D5()
{
  __int64 v0; // rsi
  __int64 v1; // r15
  char v2; // al
  __int64 v3; // rdi
  int v4; // eax
  __int64 v5; // rax
  char v6; // cl
  __int64 v7; // rax
  unsigned __int64 v8; // r13
  char *v9; // rbx
  unsigned __int64 v10; // rdi
  char v11; // cl
  signed __int64 v12; // rax

  v0 = qword_96AD8;
  v1 = 0i64;
  while ( 1 )
  {
    v2 = *(_BYTE *)v0 & 0x7F;
    if ( v2 == 3 )
      break;
    if ( v2 == 127 && *(_BYTE *)(v0 + 1) == -1 )
      return v1;
LABEL_7:
    v0 += *(unsigned __int16 *)(v0 + 2);
  }
  if ( *(_BYTE *)(v0 + 1) != 11 )
    goto LABEL_7;
  v3 = (signed int)sub_189FE(
                     "<dict><key>IOProviderClass</key><string>IONetworkInterface</string><key>IOParentMatch</key><dict><k"
                     "ey>IOPropertyMatch</key><dict><key>IOMACAddress</key><data format=\"hex\">");
  v4 = sub_189FE("</data></dict></dict></dict>");
  v5 = sub_1364F(v3 + v4 + 80);
  if ( !v5 )
    return 0i64;
  v1 = v5;
  v6 = 60;
  v7 = 0i64;
  do
  {
    *(_BYTE *)(v1 + v7) = v6;
    v6 = aDictKeyIoprovi[v7++ + 1];
  }
  while ( v6 );
  v8 = 32i64;
  if ( *(_BYTE *)(v0 + 36) < 2u )
    v8 = 6i64;
  v9 = (char *)(v7 + v1);
  v10 = 0i64;
  do
  {
    sub_18905((unsigned __int64)v9, (__int64)"%02x", *(unsigned __int8 *)(v0 + v10 + 4));
    v9 += 2;
    ++v10;
  }
  while ( v10 < v8 );
  v11 = 60;
  v12 = 1i64;
  do
  {
    *v9++ = v11;
    v11 = aDataDictDictDi[v12++];
  }
  while ( v12 != 29 );
  *v9 = 0;
  return v1;
}
// 96AD8: using guessed type __int64 qword_96AD8;

//----- (00000000000082E2) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_82E2(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r15
  __int64 *v5; // rax
  char *v6; // rdi
  __int64 v7; // rax
  char *v8; // rbx
  __int64 v9; // rax
  __int64 v10; // r9
  __int64 *v11; // rsi
  __int64 v12; // r12
  char *v13; // rax
  __int64 v14; // r9
  signed __int64 v15; // rax
  signed __int64 *v16; // rsi
  __int64 v17; // rax
  char *v18; // rdi
  __int64 v19; // rax
  __int64 v20; // rdi
  __int64 v21; // r13
  unsigned __int64 v22; // r14
  signed __int64 *v23; // r12
  signed __int64 *v24; // rsi
  __int64 v25; // rax
  __int64 v26; // rbx
  signed __int64 *v27; // rsi
  __int64 v28; // rax
  char *v29; // rdi
  int v30; // eax
  signed __int64 *v31; // rax
  signed __int64 *v32; // rdi
  int v33; // eax
  int v34; // eax
  __int64 v35; // rax
  __int64 v36; // r9
  __int64 v37; // r9
  __int64 v38; // r8
  __int64 v39; // r9
  __int64 v40; // r8
  unsigned __int64 v41; // rsi
  char *v42; // rdi
  char *v43; // rax
  __int64 v44; // r15
  __int64 v45; // rsi
  __int64 *v46; // rax
  __int64 v47; // rax
  int v48; // ecx
  __int64 v49; // rax
  __int16 v50; // dx
  __int16 v51; // ax
  int v52; // ecx
  __int16 v53; // dx
  __int64 v54; // r8
  __int64 v55; // rax
  __int64 v56; // r8
  unsigned __int8 v57; // di
  bool v58; // cf
  bool v59; // zf
  unsigned __int8 v60; // cl
  __int64 v61; // rax
  __int64 v62; // rcx
  unsigned __int64 v68; // rsi
  char *v69; // r14
  char **v70; // rbx
  unsigned __int64 v71; // rsi
  __int64 v72; // rbx
  __int64 v73; // rsi
  __int64 v74; // rax
  __int64 v75; // rax
  int v76; // eax
  _DWORD *v77; // rcx
  __int64 v78; // rax
  __int64 v79; // rdx
  __int64 v80; // r9
  __int64 v81; // r8
  __int64 v82; // r13
  unsigned __int64 v83; // r12
  unsigned __int64 v95; // r14
  __int64 v96; // rbx
  __int64 v97; // r14
  __int64 v98; // rsi
  _DWORD *v99; // rax
  __int64 v100; // r15
  __int64 v101; // rax
  unsigned __int64 v102; // rsi
  __int64 v103; // r9
  __int64 v104; // rbx
  __int64 v105; // r9
  char *v120; // rbx
  int v121; // eax
  __int64 v122; // r8
  __int64 v123; // r9
  __int64 v125; // [rsp+20h] [rbp-210h]
  char v126; // [rsp+40h] [rbp-1F0h]
  __int64 v127; // [rsp+C0h] [rbp-170h]
  __int64 v128; // [rsp+C8h] [rbp-168h]
  __int64 v129; // [rsp+D0h] [rbp-160h]
  __int64 v130; // [rsp+D8h] [rbp-158h]
  __int64 v131; // [rsp+E0h] [rbp-150h]
  __int64 v132; // [rsp+E8h] [rbp-148h]
  __int64 v133; // [rsp+F0h] [rbp-140h]
  __int64 v134; // [rsp+F8h] [rbp-138h]
  __int64 v135; // [rsp+108h] [rbp-128h]
  __int64 v136; // [rsp+110h] [rbp-120h]
  unsigned __int64 v137; // [rsp+118h] [rbp-118h]
  unsigned __int64 v138; // [rsp+120h] [rbp-110h]
  unsigned __int64 v139; // [rsp+128h] [rbp-108h]
  __int64 v140; // [rsp+130h] [rbp-100h]
  __int64 v141; // [rsp+138h] [rbp-F8h]
  __int64 v142; // [rsp+140h] [rbp-F0h]
  __int64 v143; // [rsp+148h] [rbp-E8h]
  __int64 v144; // [rsp+150h] [rbp-E0h]
  __int64 v145; // [rsp+158h] [rbp-D8h]
  __int64 v146; // [rsp+160h] [rbp-D0h]
  __int64 v147; // [rsp+168h] [rbp-C8h]
  _QWORD *v148; // [rsp+170h] [rbp-C0h]
  __int64 v149; // [rsp+178h] [rbp-B8h]
  __int64 i; // [rsp+180h] [rbp-B0h]
  char *v151; // [rsp+188h] [rbp-A8h]
  __int64 *v152; // [rsp+190h] [rbp-A0h]
  _DWORD *v153; // [rsp+198h] [rbp-98h]
  unsigned __int64 v154; // [rsp+1A0h] [rbp-90h]
  __int64 (__fastcall **v155)(_QWORD, __int64 *, __int64); // [rsp+1A8h] [rbp-88h]
  __int64 v156; // [rsp+1B0h] [rbp-80h]
  __int64 v157; // [rsp+1B8h] [rbp-78h]
  char *v158; // [rsp+1C0h] [rbp-70h]
  unsigned __int64 v159; // [rsp+1C8h] [rbp-68h]
  unsigned __int64 v160; // [rsp+1D0h] [rbp-60h]
  __int64 v161; // [rsp+1D8h] [rbp-58h]
  unsigned int v162; // [rsp+1E4h] [rbp-4Ch]
  char *v163; // [rsp+1E8h] [rbp-48h]
  __int64 v164; // [rsp+1F0h] [rbp-40h]

  v149 = a2;
  v148 = a1;
  v163 = 0i64;
  v135 = -6148914691236517206i64;
  v136 = -6148914691236517206i64;
  v142 = 0i64;
  v160 = 0i64;
  v164 = -6148914691236517206i64;
  v161 = -6148914691236517206i64;
  v162 = -1431655766;
  v4 = qword_96B00;
  memset(&v126, 0xAAu, 0x80ui64);
  v155 = (__int64 (__fastcall **)(_QWORD, __int64 *, __int64))-6148914691236517206i64;
  v145 = -6148914691236517206i64;
  v139 = -6148914691236517206i64;
  v146 = -6148914691236517206i64;
  v147 = -6148914691236517206i64;
  v143 = -6148914691236517206i64;
  v159 = -6148914691236517206i64;
  v144 = -6148914691236517206i64;
  sub_1A2B6(1, (__int64)"[EB|`BST:FBS] {\n", a3, a4);
  v5 = (__int64 *)sub_A398();
  if ( v5 )
  {
    if ( !sub_A012(v5, "system-id") )
    {
      v127 = -6148914691236517206i64;
      v128 = -6148914691236517206i64;
      v156 = 16i64;
      if ( (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
             L"platform-uuid",
             qword_92360,
             0i64) == -9223372036854775794i64 )
      {
        sub_98E2();
        if ( (!(unsigned int)sub_18A1A("iMac7,1", &byte_936F0) || !(unsigned int)sub_18A1A("MacBookPro3,1", &byte_936F0))
          && MEMORY[0xFFFFFF00] == -22 )
        {
          (*(void (__fastcall **)(__int64 *, __int64 *, signed __int64))(qword_96CD8 + 352))(&v127, qword_92080, 16i64);
          (*(void (__fastcall **)(char *, signed __int64, signed __int64))(qword_96CD8 + 352))(
            (char *)&v128 + 2,
            4294967041i64,
            6i64);
          (*(void (__fastcall **)(const __int16 *, __int64 *, signed __int64, signed __int64, __int64 *))(qword_96CE0 + 88))(
            L"platform-uuid",
            qword_92360,
            7i64,
            16i64,
            &v127);
        }
      }
    }
  }
  v6 = (char *)&v127;
  v127 = -6148914691236517206i64;
  v128 = -6148914691236517206i64;
  v129 = -6148914691236517206i64;
  v130 = -6148914691236517206i64;
  v154 = 0i64;
  v156 = 32i64;
  sub_F1B0(&v127, 32i64);
  v7 = (*(__int64 (__fastcall **)(const __int16 *, int *, _QWORD, __int64 *, __int64 *))(qword_96CE0 + 72))(
         L"IASCurrentInstallPhase",
         &dword_91FF4,
         0i64,
         &v156,
         &v127);
  v153 = (_DWORD *)qword_96B00;
  if ( v7 == -9223372036854775803i64 )
  {
    v6 = (char *)sub_1364F(v156);
    if ( !v6 )
    {
      sub_1A2B6(1, (__int64)"[EB|`BST:GIP] ! @ M:BMA %qd @ GV %g:%S\n", v156, (__int64)&dword_91FF4);
      v12 = -9223372036854775803i64;
      goto LABEL_31;
    }
  }
  v8 = 0i64;
  v9 = (*(__int64 (__fastcall **)(const __int16 *, int *, _QWORD, __int64 *, char *))(qword_96CE0 + 72))(
         L"IASCurrentInstallPhase",
         &dword_91FF4,
         0i64,
         &v156,
         v6);
  if ( v9 < 0 )
  {
    v12 = v9;
LABEL_21:
    v11 = 0i64;
    goto LABEL_22;
  }
  sub_1A2B6(1, (__int64)"[EB|#GIP:PHS.1] %e\n", (__int64)v6, v10);
  v156 = 1024i64;
  v8 = (char *)qword_93730;
  sub_F1B0(qword_93730, 1024i64);
  if ( (*(__int64 (__fastcall **)(const char *, int *, _QWORD, __int64 *, __int64 *))(qword_96CE0 + 72))(
         "I",
         &dword_91FF4,
         0i64,
         &v156,
         qword_93730) == -9223372036854775803i64 )
  {
    v8 = (char *)sub_1364F(v156);
    if ( !v8 )
    {
      sub_1A2B6(1, (__int64)"[EB|`BST:GIP] ! @ M:BMA %qd @ GV %g:%S\n", v156, (__int64)&dword_91FF4);
      v8 = 0i64;
      v12 = -9223372036854775803i64;
      goto LABEL_21;
    }
  }
  v11 = 0i64;
  v12 = (*(__int64 (__fastcall **)(const char *, int *, _QWORD, __int64 *, char *))(qword_96CE0 + 72))(
          "I",
          &dword_91FF4,
          0i64,
          &v156,
          v8);
  if ( v12 < 0 )
    goto LABEL_22;
  *(_DWORD *)(qword_96B00 + 1188i64) = 0;
  v13 = (char *)sub_1364F(v156);
  if ( !v13 )
  {
    sub_1A2B6(1, (__int64)"[EB|`BST:GIP] ! @ M:BMA %qd @ 'TMP\n", v156, v14);
    goto LABEL_21;
  }
  v11 = (__int64 *)v13;
  sub_1B930(v13, v8, v156);
  v15 = sub_12512((__int64)v11, &v154);
  if ( v15 )
  {
    v12 = v15;
    goto LABEL_22;
  }
  i = sub_12D6F(v154);
  if ( i <= 0 )
  {
    v12 = 0i64;
    goto LABEL_22;
  }
  v152 = v11;
  v12 = 0i64;
  v97 = 0i64;
  v98 = i;
  v151 = v8;
  while ( 1 )
  {
    v99 = (_DWORD *)sub_12D9A(v154, v97);
    if ( !v99 )
      goto LABEL_149;
    v100 = (__int64)v99;
    if ( *v99 != 1 )
      goto LABEL_149;
    v101 = sub_124B2((__int64)v99, "InstallPhasePercentageKey");
    v102 = ((unsigned __int64)(0xFFFFi64 * *(_QWORD *)(v101 + 16)
                             + ((unsigned __int128)(-6640827866535438581i64
                                                  * (signed __int128)(0xFFFFi64 * *(_QWORD *)(v101 + 16))) >> 64)) >> 63)
         + ((signed __int64)(0xFFFFi64 * *(_QWORD *)(v101 + 16)
                           + ((unsigned __int128)(-6640827866535438581i64
                                                * (signed __int128)(0xFFFFi64 * *(_QWORD *)(v101 + 16))) >> 64)) >> 6);
    sub_1A2B6(1, (__int64)"[EB|#GIP:PCT] 0x%lx\n", *(_QWORD *)(v101 + 16), v103);
    v104 = sub_124B2(v100, "InstallPhase");
    sub_1A2B6(1, (__int64)"[EB|#GIP:PHS.2] %e\n", *(_QWORD *)(v104 + 8), v105);
    if ( !(unsigned int)sub_18A1A(v6, *(_BYTE **)(v104 + 8)) )
      break;
    *(_WORD *)(qword_96B00 + 1188i64) += v102;
    v8 = v151;
    v98 = i;
LABEL_149:
    if ( v98 <= ++v97 )
    {
      v4 = (__int64)v153;
      goto LABEL_163;
    }
  }
  *(_WORD *)(qword_96B00 + 1190i64) = *(_WORD *)(qword_96B00 + 1188i64) + v102;
  v12 = 0i64;
  v4 = (__int64)v153;
  v8 = v151;
LABEL_163:
  v11 = v152;
LABEL_22:
  if ( v6 && &v127 != (__int64 *)v6 )
    sub_136C5((__int64)v6);
  if ( v11 && v11 != qword_93730 )
    sub_136C5((__int64)v11);
  if ( v8 && v8 != (char *)qword_93730 )
    sub_136C5((__int64)v8);
LABEL_31:
  if ( !v12 )
    *(_BYTE *)(v4 + 7) |= 1u;
  if ( (*(__int64 (__fastcall **)(_QWORD, __int64 *, _QWORD))(qword_96CD8 + 152))(
         *(_QWORD *)(qword_96A98 + 24),
         qword_92BE0,
         &v155) >= 0
    || (*(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD))(qword_96CD8 + 320))(qword_92BE0, 0i64, &v155) >= 0 )
  {
    v16 = (signed __int64 *)sub_A398();
    if ( !v16 )
      sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] ! @ DT:FN%s %s\n", "+", "/chosen");
    v164 = 0i64;
    if ( (*v155)(v155, &v164, 0i64) == -9223372036854775803i64 )
    {
      v17 = sub_1364F(v164);
      if ( v17 )
      {
        v18 = (char *)v17;
        if ( (*v155)(v155, &v164, v17) < 0 )
          goto LABEL_44;
        sub_9EC7(v16, "dhcp-response", v164, v18, 0);
        v164 = 0i64;
        if ( v155[1](v155, &v164, 0i64) == -9223372036854775803i64 )
        {
          v19 = sub_1364F(v164);
          if ( v19 )
          {
            v18 = (char *)v19;
            if ( v155[1](v155, &v164, v19) >= 0 )
            {
              sub_9EC7(v16, "bsdp-response", v164, v18, 0);
              goto LABEL_45;
            }
LABEL_44:
            sub_136C5((__int64)v18);
          }
        }
      }
    }
  }
LABEL_45:
  v20 = *(_QWORD *)(qword_96CD0 + 112);
  v21 = sub_A398();
  if ( !v21 )
    sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] ! @ DT:FN%s %s\n", "+", "/efi/configuration-table");
  if ( *(_QWORD *)(qword_96CD0 + 104) )
  {
    v22 = 0i64;
    do
    {
      sub_7AC8((unsigned int *)v20, (unsigned __int64)&v126);
      v23 = sub_A04C(v21, &v126);
      if ( !v23 )
        sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] ! @ DT:AC %s, %s\n", "/efi/configuration-table", &v126);
      sub_9EC7(v23, "guid", 0x10ui64, (char *)v20, 0);
      sub_9EC7(v23, "table", 8ui64, (char *)(v20 + 16), 0);
      if ( sub_23695(v20, (__int64)qword_92A40) )
        sub_9EC7(v23, "alias", 8ui64, "ACPI_20", 0);
      if ( sub_23695(v20, (__int64)qword_92A30) )
        sub_9EC7(v23, "alias", 5ui64, "ACPI", 0);
      ++v22;
      v20 += 24i64;
    }
    while ( *(_QWORD *)(qword_96CD0 + 104) > v22 );
  }
  v24 = (signed __int64 *)sub_A398();
  if ( !v24 )
    sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] ! @ DT:FN%s %s\n", "+", "/efi/runtime-services");
  sub_9EC7(v24, "table", 8ui64, (char *)(qword_96CD0 + 88), 0);
  v25 = sub_A398();
  v26 = (__int64)v153;
  if ( v25 )
  {
    v27 = (signed __int64 *)v25;
    v28 = sub_23741(*(_WORD **)(qword_96CD0 + 24));
    sub_9EC7(v27, "firmware-vendor", 2 * v28 + 2, *(char **)(qword_96CD0 + 24), 0);
    sub_9EC7(v27, "firmware-revision", 4ui64, (char *)(qword_96CD0 + 32), 0);
    v29 = "EFI32";
    if ( *(_BYTE *)(v26 + 4) == 64 )
      v29 = "EFI64";
    v30 = sub_189FE(v29);
    sub_9EC7(v27, "firmware-abi", v30 + 1, v29, 0);
  }
  sub_99EE();
  v31 = (signed __int64 *)sub_A398();
  if ( v31 )
  {
    LODWORD(v127) = 1;
    sub_9EC7(v31, "x86_64", 4ui64, (char *)&v127, 0);
  }
  sub_CFB6(v26);
  sub_18A90(v26 + 8, v149, 1024i64);
  *(_BYTE *)(v26 + 1031) = 0;
  v32 = (signed __int64 *)sub_A398();
  if ( !v32 )
    sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] ! @ DT:FN%s %s\n", "+", "/chosen");
  v33 = sub_189FE((_BYTE *)(v26 + 8));
  sub_9EC7(v32, "boot-args", v33 + 1, (char *)(v26 + 8), 0);
  sub_1905F((__int64)"Start RandomSeed");
  v134 = -6148914691236517206i64;
  v133 = -6148914691236517206i64;
  v132 = -6148914691236517206i64;
  v131 = -6148914691236517206i64;
  v130 = -6148914691236517206i64;
  v129 = -6148914691236517206i64;
  v128 = -6148914691236517206i64;
  v127 = -6148914691236517206i64;
  sub_F1B0(&v127, 64i64);
  sub_20782((__int64)&v127, 0x40u);
  sub_9EC7(v32, "random-seed", 0x40ui64, (char *)&v127, 0);
  sub_1905F((__int64)"End RandomSeed");
  v34 = sub_189FE(
          "BUILD-INFO[298]:{\"DisplayName\":\"boot.efi\",\"DisplayVersion\":\"422.140.4~2\",\"RecordUuid\":\"9C0E87DC-767"
          "6-4725-A30E-2CBF70B3EA58\",\"BuildTime\":\"2021-05-20T22:29:16-0700\",\"ProjectName\":\"efiboot\",\"ProductNam"
          "e\":\"boot.efi\",\"SourceVersion\":\"422.140.4\",\"BuildVersion\":\"2\",\"BuildConfiguration\":\"Release\",\"B"
          "uildType\":\"Official\"}");
  sub_9EC7(
    v32,
    "booter-build-info",
    v34 + 1,
    "BUILD-INFO[298]:{\"DisplayName\":\"boot.efi\",\"DisplayVersion\":\"422.140.4~2\",\"RecordUuid\":\"9C0E87DC-7676-4725"
    "-A30E-2CBF70B3EA58\",\"BuildTime\":\"2021-05-20T22:29:16-0700\",\"ProjectName\":\"efiboot\",\"ProductName\":\"boot.e"
    "fi\",\"SourceVersion\":\"422.140.4\",\"BuildVersion\":\"2\",\"BuildConfiguration\":\"Release\",\"BuildType\":\"Official\"}",
    1);
  sub_9EC7(v32, "booter-name", 9ui64, "boot.efi", 1);
  v35 = sub_74E9("FACP");
  if ( v35 )
  {
    if ( *(_BYTE *)(v35 + 8) >= 3u && (v36 = *(_QWORD *)(v35 + 132)) != 0
      || (v36 = *(unsigned int *)(v35 + 36), *(_DWORD *)(v35 + 36)) )
    {
      sub_9EC7(v32, "machine-signature", 4ui64, (char *)(v36 + 8), 0);
    }
  }
  *(_QWORD *)(v26 + 1120) = 0i64;
  *(_QWORD *)(v26 + 1248) = 0i64;
  sub_1E2B5();
  v163 = 0i64;
  v160 = 0i64;
  if ( sub_1E202(&v163, (__int64 *)&v160) >= 0 )
  {
    *(_DWORD *)(v26 + 1248) = (_DWORD)v163;
    v38 = v160;
    *(_DWORD *)(v26 + 1252) = v160;
    sub_1A2B6(1, (__int64)"[EB|`BST:FBS] BA.ADSZ: %d\n", v38, v37);
  }
  v163 = 0i64;
  v160 = 0i64;
  if ( sub_1E360((unsigned __int64 *)&v163, &v160) >= 0 )
  {
    *(_DWORD *)(v26 + 1120) = (_DWORD)v163;
    v40 = v160;
    *(_DWORD *)(v26 + 1124) = v160;
    sub_1A2B6(1, (__int64)"[EB|`BST:FBS] BA.KSDSZ: %d\n", v40, v39);
  }
  v154 = -6148914691236517206i64;
  v140 = 0i64;
  v156 = -6148914691236517206i64;
  v157 = -6148914691236517206i64;
  v158 = (char *)-6148914691236517206i64;
  v141 = 24i64;
  if ( (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("P", qword_92360, 0i64) >= 0
    && v141 == 24 )
  {
    v41 = v156;
    if ( v156 )
    {
      v42 = v158;
      if ( v158 )
      {
        v154 = v156;
        v43 = (char *)sub_17500((__int64 *)&v154, (unsigned __int64 *)&v140);
        v44 = (__int64)v43;
        if ( v41 <= v154 )
        {
          sub_1B950(v42, v43, v41);
          v158 = (char *)v44;
          (*(void (__fastcall **)(const char *, __int64 *, signed __int64, __int64, __int64 *))(qword_96CE0 + 88))(
            "P",
            qword_92360,
            7i64,
            v141,
            &v156);
        }
        else
        {
          sub_176C6((unsigned __int64)v43, v140, v154);
          (*(void (__fastcall **)(const char *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
            "P",
            qword_92360,
            0i64,
            0i64,
            0i64);
        }
      }
    }
  }
  *(_QWORD *)(v26 + 1144) = qword_96B18;
  v45 = 0i64;
  v46 = (__int64 *)sub_A398();
  if ( v46 )
  {
    v47 = sub_A012(v46, "FSBFrequency");
    if ( !v47 )
      goto LABEL_87;
    v48 = *(_DWORD *)(v47 + 8);
    if ( v48 == 8 )
    {
      v45 = **(_QWORD **)(v47 + 16);
    }
    else
    {
      if ( v48 == 4 )
      {
        v45 = **(unsigned int **)(v47 + 16);
        goto LABEL_89;
      }
LABEL_87:
      v45 = 0i64;
    }
  }
LABEL_89:
  *(_QWORD *)(v26 + 1152) = v45;
  if ( qword_96AA8 & 0x4000 )
    *(_DWORD *)(v26 + 1108) = qword_96AB8;
  v49 = sub_74E9("MCFG");
  if ( v49 && *(_BYTE *)(v49 + 8) == 1 )
  {
    *(_QWORD *)(v26 + 1160) = *(_QWORD *)(v49 + 44);
    *(_DWORD *)(v26 + 1168) = *(unsigned __int8 *)(v49 + 54);
    *(_DWORD *)(v26 + 1172) = *(unsigned __int8 *)(v49 + 55);
  }
  v50 = *(_WORD *)(v26 + 6);
  v51 = *(_WORD *)(v26 + 6) | 1;
  *(_WORD *)(v26 + 6) = v51;
  v52 = qword_96AA8;
  if ( (unsigned int)qword_50000 & (unsigned int)qword_96AA8 )
  {
    v53 = v50 | 0x41;
    if ( _bittest(&v52, 0x12u) )
      v51 = v53;
    *(_WORD *)(v26 + 6) = v51 | ((unsigned int)qword_96AA8 >> 14) & 4;
  }
  if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92C40, 0i64, &qword_96B20) >= 0 )
  {
    LOWORD(v156) = 0;
    LOBYTE(v54) = 1;
    v55 = (*(__int64 (__fastcall **)(__int64, signed __int64, __int64, __int64 *))(qword_96B20 + 8))(
            qword_96B20,
            1297306723i64,
            v54,
            &v156);
    v57 = v156;
    if ( v55 < 0 )
      v57 = 0;
    LOBYTE(v56) = 2;
    if ( (*(__int64 (__fastcall **)(__int64, signed __int64, __int64, __int64 *))(qword_96B20 + 8))(
           qword_96B20,
           1297301859i64,
           v56,
           &v156) >= 0 )
    {
      LOBYTE(v156) = v156 + (BYTE1(v156) >> 7);
      v58 = (unsigned __int8)v156 < v57;
      v59 = (_BYTE)v156 == v57;
      v60 = v57;
      v57 = v156;
      if ( v58 || v59 )
        v57 = v60;
    }
    *(_DWORD *)(v26 + 1184) = v57 & 0x7F;
  }
  sub_5DCF(0);
  sub_1A6EF(9u);
  sub_A211(0i64, &v160);
  v164 = v160;
  v163 = (char *)sub_17500(&v164, 0i64);
  if ( !v163 )
    sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] ! MM:AKM %qd @ 'DTFLAT\n", v164);
  sub_A211(&v163, &v160);
  *(_DWORD *)(v26 + 1072) = (_DWORD)v163;
  *(_DWORD *)(v26 + 1076) = v160;
  sub_A192();
  v61 = sub_1738E(&v159, &v145, (__int64)v148, (__int64)&v161, (__int64)&v162);
  if ( v61 < 0 )
    sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] %r @ MM:GBMM\n", v61);
  v139 = v145 + v159;
  sub_174C9(v145, v145 + v159, v161, v162, &v146, &v147);
  sub_136C5(v145);
  v145 = 0i64;
  v62 = v147 + 11;
  v147 += 11i64;
  if ( !(qword_96AA8 & 0x200) )
  {
    _RAX = 1i64;
    __asm { cpuid }
    v68 = 0i64;
    LODWORD(v156) = _RAX;
    LODWORD(v154) = _RBX;
    LODWORD(v140) = _RCX;
    LODWORD(v141) = _RDX;
    v69 = (char *)qword_93690;
    if ( (signed int)_RCX < 0 )
      v69 = "VMM";
    v70 = off_92090;
    while ( (unsigned int)sub_18A1A(v69, *v70) )
    {
      ++v68;
      ++v70;
      if ( v68 > 0xD )
      {
        v62 = v147;
        goto LABEL_117;
      }
    }
    v62 = v147 + 14;
    v147 += 14i64;
  }
LABEL_117:
  ++v146;
  v143 = (unsigned int)sub_23C84(v62, 12);
  v144 = 0i64;
  v71 = sub_17500(&v143, (unsigned __int64 *)&v144);
  if ( !v71 )
    sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] ! @ MM:AKM %qd @ 'RT\n", v143);
  v72 = v143;
  v159 += v161 * (v146 + 2) + 512;
  v163 = (char *)sub_17500((__int64 *)&v159, (unsigned __int64 *)&v142);
  if ( !v163 )
    sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] ! @ MM:AKM %qd @ 'MM\n", v159);
  v152 = (__int64 *)v71;
  v137 = v72;
  v138 = v72 + v71;
  sub_192A2();
  sub_1A6EF(0xAu);
  LOBYTE(v149) = 1;
  for ( i = -9223372036854775806i64; ; sub_1A2B6(1, (__int64)"[EB|`BST:FBS] %r @ ExitBS\n", i, v80) )
  {
    v73 = 0i64;
    while ( 1 )
    {
      v160 = 0i64;
      v74 = (*(__int64 (__fastcall **)(unsigned __int64 *, _QWORD, _QWORD *, __int64 *, unsigned int *))(qword_96CD8 + 56))(
              &v160,
              0i64,
              v148,
              &v161,
              &v162);
      if ( v74 != -9223372036854775803i64 )
        sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] %r @ BS.GMM\n", v74);
      if ( v160 > v159 )
      {
        sub_176C6((unsigned __int64)v163, v142, v159);
        v159 = v161 * (v146 + 2) + v160 + 512;
        v163 = (char *)sub_17500((__int64 *)&v159, (unsigned __int64 *)&v142);
        if ( !v163 )
          sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] ! @ MM:AKM %qd @ 'MM.2\n", v159);
      }
      v164 = v159;
      v75 = (*(__int64 (__fastcall **)(__int64 *, char *, _QWORD *, __int64 *, unsigned int *))(qword_96CD8 + 56))(
              &v164,
              v163,
              v148,
              &v161,
              &v162);
      if ( !v75 )
        break;
      if ( (unsigned __int64)++v73 > 3 )
      {
        sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] %r @ BS.GMM (Nth)\n", v75);
        break;
      }
    }
    v76 = v164;
    v77 = v153;
    v151 = v163;
    v153[258] = (_DWORD)v163;
    v77[259] = v76;
    v77[260] = v161;
    v77[261] = v162;
    sub_1905F((__int64)"Start ExitBootServices");
    v78 = (*(__int64 (__fastcall **)(__int64, _QWORD))(qword_96CD8 + 232))(qword_96A90, *v148);
    v81 = i;
    if ( (unsigned __int8)v149 > 4u || v78 != i )
      break;
    LOBYTE(v149) = v149 + 1;
  }
  if ( v78 < 0 )
    sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] %r @ ExitBS\n", v78, i);
  sub_1905F((__int64)"End ExitBootServices", v79, v81);
  sub_1A6EF(0xBu);
  qword_96CD8 = 0i64;
  v82 = (__int64)v153;
  v83 = (unsigned __int64)v152;
  v95 = (unsigned __int64)v163;
  v96 = v164;
  v120 = (char *)(v95 + v96);
  v139 = (unsigned __int64)v120;
  sub_177A5(v95, (unsigned __int64)v120, v161);
  LODWORD(v125) = v162;
  sub_178DE(v95, v120, (char **)&v139, v161, v125, v83, v138, v144);
  sub_177A5(v95, v139, v161);
  *(_DWORD *)(v82 + 1104) = qword_96CD0;
  *(_DWORD *)(v82 + 1036) = v139 - v95;
  qword_96CE0 = 0i64;
  qword_96CD8 = (unsigned __int8)qword_96CE0;
  if ( !(_DWORD)qword_96CD0 )
    sub_9CE0((__int64)"[EB|#STOP|`BST:FBS] ! @ 'BA.EST\n");
  *(_DWORD *)(v82 + 1088) = sub_23C9F(v83, 12);
  *(_DWORD *)(v82 + 1092) = sub_23C9F(v137, 12);
  *(_QWORD *)(v82 + 1096) = sub_23C9F(v144, 12);
  sub_17741(&v135, &v136);
  v121 = v135;
  *(_DWORD *)(v82 + 1080) = v135;
  *(_DWORD *)(v82 + 1084) = v136 - v121;
  sub_1A2B6(1, (__int64)"[EB|`BST:FBS] }\n", v122, v123);
  return 0i64;
}
// 945B: write access to const memory at 96CD8 has been detected
// 97FF: write access to const memory at 96CE0 has been detected
// 9806: write access to const memory at 96CD8 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 40568: using guessed type __int16 aPlatformUuid[14];
// 405D0: using guessed type __int16 aIascurrentinst[23];
// 50000: using guessed type __int64 qword_50000[113];
// 91FF4: using guessed type int dword_91FF4;
// 92080: using guessed type __int64 qword_92080[2];
// 92090: using guessed type char *off_92090[14];
// 92360: using guessed type __int64 qword_92360[2];
// 92A30: using guessed type __int64 qword_92A30[2];
// 92A40: using guessed type __int64 qword_92A40[2];
// 92BE0: using guessed type __int64 qword_92BE0[2];
// 92C40: using guessed type __int64[2];
// 93690: using guessed type __int64 qword_93690[7];
// 936D0: using guessed type __int64 qword_936D0;
// 936D8: using guessed type __int64 qword_936D8;
// 936E0: using guessed type char byte_936E0;
// 936F0: using guessed type char byte_936F0;
// 93730: using guessed type __int64 qword_93730[128];
// 96A90: using guessed type __int64 qword_96A90;
// 96A98: using guessed type __int64 qword_96A98;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AB8: using guessed type __int64 qword_96AB8;
// 96B18: using guessed type __int64 qword_96B18;
// 96B20: using guessed type __int64 qword_96B20;
// 96CD0: using guessed type __int64 qword_96CD0;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;
// 96CE8: using guessed type __int64 qword_96CE8;

//----- (00000000000098E2) ----------------------------------------------------
char *sub_98E2()
{
  __int64 *v0; // rax
  __int64 v1; // rax
  unsigned int v2; // edx
  signed __int64 v3; // rcx
  int v4; // edx
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rdi
  char *v8; // rsi

  v0 = (__int64 *)sub_A398();
  if ( v0 && (v1 = sub_A012(v0, "Model")) != 0 && (v2 = *(_DWORD *)(v1 + 8)) != 0 )
  {
    v3 = *(_QWORD *)(v1 + 16);
    v4 = v2 >> 1;
    v5 = (unsigned int)(v4 - 1);
    if ( !*(_WORD *)(v3 + 2 * v5) )
      v4 = v5;
    sub_7035(v3, v4, &byte_936F0, 64, 1);
  }
  else
  {
    v6 = sub_74E9("FACP");
    if ( v6 )
    {
      if ( *(_BYTE *)(v6 + 8) < 3u )
        v7 = *(unsigned int *)(v6 + 40);
      else
        v7 = *(_QWORD *)(v6 + 140);
      v8 = &byte_936F0;
      (*(void (__fastcall **)(char *, __int64, signed __int64))(qword_96CD8 + 352))(&byte_936F0, v7 + 16, 8i64);
      while ( ((unsigned __int8)*v8 | 0x20) != 32 )
        ++v8;
      sub_18905(
        (unsigned __int64)v8,
        (__int64)"%d,%d",
        (unsigned int)(*(_DWORD *)(v7 + 24) >> 16),
        (unsigned __int16)*(_DWORD *)(v7 + 24));
    }
  }
  sub_18A75(&byte_936F0, "ACPI");
  return &byte_936F0;
}
// 936F0: using guessed type char byte_936F0;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000099EE) ----------------------------------------------------
__int64 sub_99EE()
{
  __int64 v0; // rax
  signed __int64 *v1; // r14
  __int64 i; // rcx
  char *v3; // rbx
  __int64 v5; // [rsp+28h] [rbp-38h]
  unsigned __int64 v6; // [rsp+30h] [rbp-30h]

  v6 = -6148914691236517206i64;
  v0 = sub_A398();
  if ( v0 )
  {
    v1 = (signed __int64 *)v0;
    v5 = -6148914691236517206i64;
    if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD))(qword_96CD8 + 320))(qword_92C80, 0i64) >= 0 )
    {
      v6 = 4096i64;
      for ( i = 4096i64; ; i = v6 )
      {
        v3 = (char *)sub_1364F(i);
        if ( !v3 )
          sub_9CE0((__int64)"[EB|#STOP|`BST:ADPP] ! @ M:BMA %qd @ 'PROP\n", v6);
        if ( (*(__int64 (__fastcall **)(__int64, char *, unsigned __int64 *))(v5 + 32))(v5, v3, &v6) != -9223372036854775803i64 )
          break;
        sub_136C5((__int64)v3);
      }
      if ( v3 )
      {
        sub_9EC7(v1, "device-properties", v6, v3, 1);
        sub_136C5((__int64)v3);
      }
    }
  }
  return 0i64;
}
// 92C80: using guessed type __int64 qword_92C80[2];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000009ADC) ----------------------------------------------------
__int64 *sub_9ADC()
{
  __int64 *result; // rax

  _RAX = 1i64;
  __asm { cpuid }
  result = qword_93690;
  if ( (signed int)_RCX < 0 )
    result = (__int64 *)"VMM";
  return result;
}
// 93690: using guessed type __int64 qword_93690[7];

//----- (0000000000009B19) ----------------------------------------------------
signed __int64 __fastcall sub_9B19(char *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // er14
  unsigned int v4; // edi
  const char *v5; // rsi
  int v6; // eax
  char *v7; // rax
  char *v8; // rbx
  unsigned __int64 v10; // [rsp+28h] [rbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v10 = -6148914691236517206i64;
  v6 = sub_189FE(a1);
  v7 = (char *)sub_1364F(v6 + 1);
  if ( !v7 )
    return -9223372036854775799i64;
  v8 = v7;
  sub_18A75(v7, v5);
  v10 = __PAIR__(v3, v4);
  sub_9EC7(0i64, v8, 8ui64, (char *)&v10, 1);
  return 0i64;
}
// 936E8: using guessed type __int64 qword_936E8;

//----- (0000000000009B9D) ----------------------------------------------------
__int64 __fastcall sub_9B9D(char *a1, unsigned int a2, __int64 a3, _BYTE *a4)
{
  _BYTE *v4; // rsi
  unsigned int v5; // er14
  char *v6; // r15
  signed __int64 v7; // rcx
  char *v8; // rdi
  unsigned __int64 v9; // r11
  __int64 v10; // r10
  unsigned __int64 v11; // r15
  char *v12; // rdi
  unsigned __int64 v13; // rcx
  char v14; // dl
  char v15; // al
  unsigned __int8 v16; // bl
  unsigned __int8 v17; // al
  char v18; // dl
  unsigned __int8 v19; // al
  unsigned __int8 v20; // dl
  signed __int64 v21; // rax
  char v22; // dl
  int v24[22]; // [rsp+28h] [rbp-98h]
  __int64 v25; // [rsp+80h] [rbp-40h]
  __int64 v26; // [rsp+88h] [rbp-38h]

  v4 = a4;
  v5 = a2;
  v6 = a1;
  v7 = 22i64;
  v8 = (char *)v24;
  while ( v7 )
  {
    *(_DWORD *)v8 = -1431655766;
    v8 += 4;
    --v7;
  }
  v25 = -6148914691236517206i64;
  v26 = -6148914691236517206i64;
  sub_F1B0(&v25, 16i64);
  sub_1195E(v24);
  sub_11987(v24, (char *)qword_8EBE0, 0x10u);
  sub_11987(v24, v6, v5);
  sub_1245A((__int64)&v25, v24);
  BYTE6(v25) = BYTE6(v25) & 0xF | 0x30;
  LOBYTE(v26) = v26 & 0x3F | 0x80;
  v9 = 0i64;
  v10 = 0i64;
  do
  {
    v11 = (unsigned __int8)byte_8EBD7[v9];
    v12 = (char *)&v25 + v10;
    v13 = 0i64;
    do
    {
      v14 = v12[v13];
      v15 = (unsigned __int8)v12[v13] >> 4;
      v16 = v15 + 48;
      v17 = v15 + 55;
      if ( v16 > 0x39u )
        v16 = v17;
      *v4 = v16;
      v18 = v14 & 0xF;
      v19 = v18 + 48;
      v20 = v18 + 55;
      if ( v19 > 0x39u )
        v19 = v20;
      v4[1] = v19;
      v4 += 2;
      ++v13;
    }
    while ( v13 < v11 );
    v21 = (signed __int64)(v4 + 1);
    v22 = 0;
    if ( v9 < 4 )
      v22 = 45;
    if ( v9 >= 4 )
      v21 = (signed __int64)v4;
    *v4 = v22;
    ++v9;
    v10 += v13;
    v4 = (_BYTE *)v21;
  }
  while ( v9 != 5 );
  return 0i64;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 8EBE0: using guessed type __int64 qword_8EBE0[2];

//----- (0000000000009CD8) ----------------------------------------------------
__int64 sub_9CD8()
{
  return 0i64;
}

//----- (0000000000009CE0) ----------------------------------------------------
__int64 sub_9CE0(__int64 a1, ...)
{
  __int64 v1; // r8
  __int64 v2; // r9
  va_list v4; // [rsp+20h] [rbp-20h]
  __int64 v5; // [rsp+28h] [rbp-18h]
  __int64 v6; // [rsp+30h] [rbp-10h]
  va_list va; // [rsp+58h] [rbp+18h]

  va_start(va, a1);
  v4 = (va_list)-6148914691236517206i64;
  v5 = -6148914691236517206i64;
  v6 = -6148914691236517206i64;
  if ( qword_92420 & 1 )
  {
    va_copy(v4, va);
    sub_1A301(a1, (unsigned __int64 **)&v4);
  }
  sub_2724(2, 0i64, 0);
  sub_1A2B6(1, (__int64)"Exiting efiboot...\n", v1, v2);
  return sub_5202(-9223372036854775787i64);
}
// 92420: using guessed type __int64 qword_92420;

//----- (0000000000009D57) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_9D57()
{
  __int64 result; // rax

  _RAX = 1i64;
  __asm { cpuid }
  if ( _bittest((const signed int *)&_RCX, 9u) )
    byte_96B29 |= 1u;
  if ( _bittest((const signed int *)&_RCX, 0x19u) )
    byte_96B29 |= 0x10u;
  return result;
}
// 9D90: write access to const memory at 96B29 has been detected
// 9D9D: write access to const memory at 96B29 has been detected
// 96B29: using guessed type char byte_96B29;

//----- (0000000000009DAB) ----------------------------------------------------
char sub_9DAB()
{
  return (*(_QWORD *)&byte_96B28 >> 12) & 1;
}
// 96B28: using guessed type char byte_96B28;

//----- (0000000000009DBE) ----------------------------------------------------
signed __int64 sub_9DBE()
{
  signed __int64 v5; // r8

  _RAX = 0x80000000i64;
  __asm { cpuid }
  v5 = -9223372036854775805i64;
  if ( (unsigned int)_RAX >= 0x80000001 )
  {
    _RAX = 1i64;
    __asm { cpuid }
    if ( (_RCX & 0x10D01000) == 282071040 )
    {
      _RAX = 7i64;
      __asm { cpuid }
      if ( (_RBX & 0x128) == 296 )
      {
        _RAX = 2147483649i64;
        __asm { cpuid }
        if ( _RCX & 0x20 )
          v5 = 0i64;
      }
    }
  }
  return v5;
}

//----- (0000000000009E7F) ----------------------------------------------------
signed __int64 sub_9E7F()
{
  return 3i64;
}

//----- (0000000000009E8B) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_9E8B(int a1)
{
  int v1; // esi
  signed __int64 result; // rax

  v1 = a1;
  if ( a1 == 3 )
  {
    result = 0i64;
    goto LABEL_6;
  }
  if ( a1 != 8 )
    return -9223372036854775805i64;
  result = sub_9DBE();
  if ( result >= 0 )
LABEL_6:
    dword_92100 = v1;
  return result;
}
// 9EAE: write access to const memory at 92100 has been detected
// 92100: using guessed type int dword_92100;

//----- (0000000000009EC7) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_9EC7(signed __int64 *a1, _BYTE *a2, unsigned __int64 a3, char *a4, char a5)
{
  char *v5; // r14
  unsigned __int64 v6; // r15
  _BYTE *v7; // rdi
  signed __int64 *v8; // r12
  __int64 v9; // rbx
  signed __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v12; // rsi
  signed __int64 v13; // rsi
  signed int v14; // ecx
  __int64 v15; // rdx
  __int64 v16; // rax
  char *v17; // rax
  signed __int64 *v18; // rax

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = *a1;
  if ( !*a1 )
  {
LABEL_5:
    v11 = sub_1364F(4096i64);
    if ( v11 )
    {
      v12 = v11;
      sub_F1B0(v11, 4096i64);
      *(_QWORD *)(v12 + 32) = 0i64;
      qword_93B38 = v12;
      *(_QWORD *)(v12 + 16) = v12;
      v13 = v12 + 40;
      v14 = 101;
      v15 = 0i64;
      do
      {
        v16 = v15;
        *(_QWORD *)(v13 + 32) = v15;
        v15 = v13;
        v13 += 40i64;
        --v14;
      }
      while ( v14 );
      v10 = v13 - 40;
      qword_93B30 = v16;
      *(_QWORD *)v10 = v7;
      *(_DWORD *)(v10 + 8) = v6;
      if ( !a5 )
      {
        *(_QWORD *)(v10 + 16) = v5;
        *(_BYTE *)(v10 + 24) = 0;
        goto LABEL_12;
      }
      v17 = (char *)sub_1364F(v6);
      *(_QWORD *)(v10 + 16) = v17;
      if ( v17 )
      {
        *(_BYTE *)(v10 + 24) = 1;
        sub_1B930(v17, v5, v6);
LABEL_12:
        if ( *v8 )
          v18 = (signed __int64 *)(v8[1] + 32);
        else
          v18 = v8;
        *v18 = v10;
        v8[1] = v10;
        *(_QWORD *)(v10 + 32) = 0i64;
        dword_93B5C = 1;
        dword_93B60 = (v6 + 3) & 0xFFFFFFFC;
        return v10;
      }
    }
    return 0i64;
  }
  v10 = 0i64;
  while ( (unsigned int)sub_18A1A(*(char **)v9, v7) )
  {
    v9 = *(_QWORD *)(v9 + 32);
    if ( !v9 )
      goto LABEL_5;
  }
  return v10;
}
// 9F4A: write access to const memory at 93B38 has been detected
// 9F7B: write access to const memory at 93B30 has been detected
// 9F85: write access to const memory at 93B30 has been detected
// 9FED: write access to const memory at 93B5C has been detected
// 9FFA: write access to const memory at 93B60 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 93B30: using guessed type __int64 qword_93B30;
// 93B38: using guessed type __int64 qword_93B38;
// 93B5C: using guessed type int dword_93B5C;
// 93B60: using guessed type int dword_93B60;

//----- (000000000000A012) ----------------------------------------------------
__int64 __fastcall sub_A012(__int64 *a1, _BYTE *a2)
{
  __int64 v2; // rsi
  _BYTE *v3; // rdi

  v2 = *a1;
  if ( !*a1 )
    return 0i64;
  v3 = a2;
  while ( (unsigned int)sub_18A1A(*(char **)v2, v3) )
  {
    v2 = *(_QWORD *)(v2 + 32);
    if ( !v2 )
      return 0i64;
  }
  return v2;
}

//----- (000000000000A04C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 *__fastcall sub_A04C(__int64 a1, _BYTE *a2)
{
  char *v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rsi
  signed __int64 v6; // rsi
  signed int v7; // ecx
  __int64 v8; // rdx
  __int64 v9; // rax
  _QWORD *v10; // rcx
  signed __int64 *v11; // rsi
  int v12; // eax

  v2 = a2;
  v3 = a1;
  v4 = sub_1364F(4096i64);
  if ( !v4 )
    return 0i64;
  v5 = v4;
  sub_F1B0(v4, 4096i64);
  *(_QWORD *)(v5 + 24) = 0i64;
  qword_93B48 = v5;
  *(_QWORD *)(v5 + 16) = v5;
  v6 = v5 + 32;
  v7 = 127;
  v8 = 0i64;
  do
  {
    v9 = v8;
    *(_QWORD *)(v6 + 24) = v8;
    v8 = v6;
    v6 += 32i64;
    --v7;
  }
  while ( v7 );
  v10 = (_QWORD *)(v6 - 8);
  v11 = (signed __int64 *)(v6 - 32);
  qword_93B40 = v9;
  if ( v3 )
  {
    *v10 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 16) = v11;
  }
  else
  {
    qword_93B50 = (__int64)v11;
    v11[3] = 0i64;
  }
  dword_93B58 = 1;
  v12 = sub_189FE(v2);
  sub_9EC7(v11, "name", v12 + 1, v2, 1);
  return v11;
}
// A0A1: write access to const memory at 93B48 has been detected
// A0D6: write access to const memory at 93B40 has been detected
// A0DD: write access to const memory at 93B40 has been detected
// A0F6: write access to const memory at 93B50 has been detected
// A105: write access to const memory at 93B58 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 93B40: using guessed type __int64 qword_93B40;
// 93B48: using guessed type __int64 qword_93B48;
// 93B50: using guessed type __int64 qword_93B50;
// 93B58: using guessed type int dword_93B58;

//----- (000000000000A13F) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 *sub_A13F()
{
  signed __int64 *result; // rax

  qword_93B40 = 0i64;
  qword_93B48 = 0i64;
  qword_93B30 = 0i64;
  qword_93B38 = 0i64;
  dword_93B58 = (unsigned __int8)qword_93B40;
  dword_93B5C = (unsigned __int8)qword_93B40;
  dword_93B60 = (unsigned __int8)qword_93B40;
  result = sub_A04C(0i64, "/");
  qword_93B50 = (__int64)result;
  return result;
}
// A149: write access to const memory at 93B40 has been detected
// A150: write access to const memory at 93B48 has been detected
// A157: write access to const memory at 93B30 has been detected
// A15E: write access to const memory at 93B38 has been detected
// A165: write access to const memory at 93B58 has been detected
// A16B: write access to const memory at 93B5C has been detected
// A171: write access to const memory at 93B60 has been detected
// A185: write access to const memory at 93B50 has been detected
// 93B30: using guessed type __int64 qword_93B30;
// 93B38: using guessed type __int64 qword_93B38;
// 93B40: using guessed type __int64 qword_93B40;
// 93B48: using guessed type __int64 qword_93B48;
// 93B50: using guessed type __int64 qword_93B50;
// 93B58: using guessed type int dword_93B58;
// 93B5C: using guessed type int dword_93B5C;
// 93B60: using guessed type int dword_93B60;

//----- (000000000000A192) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_A192()
{
  __int64 v0; // rsi
  __int64 v1; // rcx
  __int64 result; // rax
  __int64 v3; // rdi
  __int64 v4; // rcx

  v0 = 0i64;
  while ( v0 )
  {
    v1 = *(_QWORD *)(v0 + 16);
    v0 = *(_QWORD *)(v0 + 32);
    result = sub_136C5(v1);
  }
  qword_93B38 = 0i64;
  qword_93B30 = 0i64;
  v3 = 0i64;
  while ( v3 )
  {
    v4 = *(_QWORD *)(v3 + 16);
    v3 = *(_QWORD *)(v3 + 24);
    result = sub_136C5(v4);
  }
  qword_93B48 = 0i64;
  qword_93B40 = 0i64;
  qword_93B50 = 0i64;
  dword_93B58 = 0;
  dword_93B5C = 0;
  dword_93B60 = 0;
  return result;
}
// A1B9: write access to const memory at 93B38 has been detected
// A1C0: write access to const memory at 93B30 has been detected
// A1E2: write access to const memory at 93B48 has been detected
// A1E9: write access to const memory at 93B40 has been detected
// A1F0: write access to const memory at 93B50 has been detected
// A1F7: write access to const memory at 93B58 has been detected
// A1FD: write access to const memory at 93B5C has been detected
// A203: write access to const memory at 93B60 has been detected
// 93B30: using guessed type __int64 qword_93B30;
// 93B38: using guessed type __int64 qword_93B38;
// 93B40: using guessed type __int64 qword_93B40;
// 93B48: using guessed type __int64 qword_93B48;
// 93B50: using guessed type __int64 qword_93B50;
// 93B58: using guessed type int dword_93B58;
// 93B5C: using guessed type int dword_93B5C;
// 93B60: using guessed type int dword_93B60;

//----- (000000000000A211) ----------------------------------------------------
__int64 __fastcall sub_A211(_QWORD *a1, _QWORD *a2)
{
  __int64 result; // rax

  result = 0i64;
  if ( a1 )
    *a1 = 0i64;
  if ( a2 )
    *a2 = 0i64;
  return result;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 93B50: using guessed type __int64 qword_93B50;
// 93B58: using guessed type int dword_93B58;
// 93B5C: using guessed type int dword_93B5C;
// 93B60: using guessed type int dword_93B60;

//----- (000000000000A296) ----------------------------------------------------
_DWORD *__fastcall sub_A296(_QWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // r14
  _QWORD *v3; // r15
  signed __int64 v4; // rdi
  __int64 v5; // rbx
  int v6; // er12
  int v7; // esi
  unsigned __int64 v8; // r8
  char *v9; // rdi
  char *v10; // rcx
  __int64 v11; // rbx

  v2 = a2;
  if ( a1 )
  {
    v3 = a1;
    v4 = (signed __int64)(a2 + 2);
    v5 = *a1;
    v6 = 0;
    v7 = 0;
    while ( v5 )
    {
      sub_18A75((char *)v4, *(const char **)v5);
      v8 = *(unsigned int *)(v5 + 8);
      *(_DWORD *)(v4 + 32) = v8;
      v9 = (char *)(v4 + 36);
      if ( v8 )
      {
        v10 = *(char **)(v5 + 16);
        if ( v10 )
        {
          sub_1B950(v10, v9, v8);
          LODWORD(v8) = *(_DWORD *)(v5 + 8);
        }
      }
      v4 = (signed __int64)&v9[((_DWORD)v8 + 3) & 0xFFFFFFFC];
      ++v7;
      v5 = *(_QWORD *)(v5 + 32);
    }
    *v2 = v7;
    v11 = v3[2];
    if ( v11 )
    {
      v6 = 0;
      do
      {
        v4 = sub_A296(v11, v4);
        ++v6;
        v11 = *(_QWORD *)(v11 + 24);
      }
      while ( v11 );
    }
    v2[1] = v6;
    v2 = (_DWORD *)v4;
  }
  return v2;
}

//----- (000000000000A34D) ----------------------------------------------------
const char *__fastcall sub_A34D(__int64 *a1)
{
  __int64 v1; // rbx
  const char *v2; // rsi

  v1 = *a1;
  v2 = "(null)";
  if ( *a1 )
  {
    while ( (unsigned int)sub_18A1A(*(char **)v1, "name") )
    {
      v1 = *(_QWORD *)(v1 + 32);
      if ( !v1 )
        return v2;
    }
    v2 = *(const char **)(v1 + 16);
  }
  return v2;
}

//----- (000000000000A398) ----------------------------------------------------
__int64 sub_A398()
{
  __int64 v15; // [rsp+20h] [rbp-50h]
  __int64 v16; // [rsp+28h] [rbp-48h]
  __int64 v17; // [rsp+30h] [rbp-40h]
  __int64 v18; // [rsp+38h] [rbp-38h]

  v15 = -6148914691236517206i64;
  v16 = -6148914691236517206i64;
  v17 = -6148914691236517206i64;
  v18 = -6148914691236517206i64;
  return 0i64;
}
// 93B50: using guessed type __int64 qword_93B50;

//----- (000000000000A485) ----------------------------------------------------
__int64 __fastcall sub_A485(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rdi
  unsigned __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // rbx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( a3 )
    v6 = sub_24136(a3);
  else
    v6 = 0i64;
  if ( v5 )
  {
    if ( v6 )
    {
      if ( v4 < v3 )
        v3 = v4;
      (*(void (__fastcall **)(__int64, __int64, unsigned __int64))(qword_96CD8 + 352))(v6, v5, v3);
    }
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v5);
  }
  return v6;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000A4F1) ----------------------------------------------------
__int64 sub_A4F1(__int64 *a1, signed __int16 *a2, ...)
{
  signed __int16 *v2; // rbx
  __int64 *v3; // rsi
  __int64 v4; // rax
  __int16 *v5; // r15
  _WORD *v6; // rdi
  __int64 v7; // rax
  unsigned __int64 v8; // rbx
  __int64 v9; // r14
  signed __int64 v10; // rax
  _WORD *v11; // rax
  va_list v13; // [rsp+20h] [rbp-40h]
  __int64 v14; // [rsp+28h] [rbp-38h]
  __int64 v15; // [rsp+30h] [rbp-30h]
  va_list va; // [rsp+80h] [rbp+20h]

  va_start(va, a2);
  v2 = a2;
  v3 = a1;
  v13 = (va_list)-6148914691236517206i64;
  v14 = -6148914691236517206i64;
  v15 = -6148914691236517206i64;
  v4 = sub_24136(4096i64);
  if ( v4 )
  {
    v5 = (__int16 *)v4;
    va_copy(v13, va);
    sub_22EF5(v4, 0x1000ui64, v2, (unsigned __int64 **)&v13);
    v6 = (_WORD *)*v3;
    v7 = sub_23764(v5);
    v8 = v7;
    if ( v6 )
    {
      v8 = sub_23764((_WORD *)*v3) + v7 - 2;
      v9 = *v3;
      v10 = sub_23764((_WORD *)*v3);
      v11 = (_WORD *)sub_A485(v9, v10, v8);
    }
    else
    {
      v11 = (_WORD *)sub_24136(v7);
    }
    *v3 = (__int64)v11;
    v3[2] = 960i64;
    if ( v8 <= 0x3BF )
    {
      sub_237BC(v11, v5);
      v3[1] = v8 - 2;
    }
    (*(void (__fastcall **)(__int16 *))(qword_96CD8 + 72))(v5);
  }
  return *v3;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000A5DE) ----------------------------------------------------
__int64 __fastcall sub_A5DE(_BYTE *a1)
{
  _BYTE *v1; // r12
  __int64 v2; // rcx
  _BYTE *i; // rdx
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rdi
  signed __int64 v7; // rcx
  __int64 v8; // rax
  __int64 v9; // r14
  __int64 v10; // rbx
  char v11; // si
  __int64 v12; // rdi
  __int64 v13; // rsi
  signed __int64 v14; // rax
  signed __int64 v15; // rax

  v1 = a1;
  v2 = 0i64;
  for ( i = v1; ; i += v4 )
  {
    v4 = *((unsigned __int16 *)i + 1);
    v5 = v4 + v2;
    v6 = ((_BYTE)v4 + (_BYTE)v2) & 3;
    v7 = 4 - v6;
    if ( !v6 )
      v7 = 0i64;
    v2 = v5 + v7;
    if ( (*i & 0x7F) == 127 && i[1] == -1 )
      break;
  }
  v8 = sub_24136(v2);
  v9 = v8;
  if ( v8 )
  {
    v10 = v8;
    while ( 1 )
    {
      v11 = v1[2];
      v12 = *((unsigned __int16 *)v1 + 1);
      (*(void (__fastcall **)(__int64, _BYTE *, __int64))(qword_96CD8 + 352))(v10, v1, v12);
      v13 = v11 & 3;
      v14 = 4 - v13;
      if ( !v13 )
        v14 = 0i64;
      v15 = v12 + v14;
      *(_WORD *)(v10 + 2) = v15;
      *(_BYTE *)v10 |= 0x80u;
      if ( (*v1 & 0x7F) == 127 && v1[1] == -1 )
        break;
      v10 += v15;
      v1 += *((unsigned __int16 *)v1 + 1);
    }
  }
  return v9;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000A6D3) ----------------------------------------------------
__int64 __fastcall sub_A6D3(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, L"Pci(%x|%x)", *(unsigned __int8 *)(a2 + 5), *(unsigned __int8 *)(a2 + 4));
}
// 40654: using guessed type __int16 aPciXX[11];

//----- (000000000000A6F7) ----------------------------------------------------
__int64 __fastcall sub_A6F7(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, (signed __int16 *)"P", *(unsigned __int8 *)(a2 + 4));
}

//----- (000000000000A716) ----------------------------------------------------
__int64 __fastcall sub_A716(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, L"MemMap(%d:%llx-%llx)", *(unsigned int *)(a2 + 4), *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16));
}
// 40690: using guessed type __int16 aMemmapDLlxLlx[21];

//----- (000000000000A741) ----------------------------------------------------
__int64 __fastcall sub_A741(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, (signed __int16 *)"C", *(unsigned int *)(a2 + 4));
}

//----- (000000000000A75F) ----------------------------------------------------
__int64 __fastcall sub_A75F(__int64 *a1, _BYTE *a2)
{
  __int64 v2; // rax
  const __int16 *v3; // r8

  v2 = *a2 & 0x7F;
  if ( (unsigned int)(v2 - 1) > 3 )
    v3 = L"?";
  else
    v3 = off_91480[v2 - 1];
  return sub_A4F1(a1, L"Ven%s(%g)", v3, a2 + 4);
}
// 406D8: using guessed type __int16 asc_406D8[2];
// 406DC: using guessed type __int16 aVenSG[10];
// 91480: using guessed type __int16 *off_91480[4];

//----- (000000000000A7A3) ----------------------------------------------------
__int64 __fastcall sub_A7A3(__int64 *a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  signed __int16 *v4; // rdx

  v2 = *(unsigned int *)(a2 + 4);
  if ( (unsigned __int16)v2 == 16848 )
  {
    v2 = (unsigned int)v2 >> 16;
    v3 = *(unsigned int *)(a2 + 8);
    v4 = L"Acpi(PNP%04x,%x)";
  }
  else
  {
    v3 = *(unsigned int *)(a2 + 8);
    v4 = (signed __int16 *)"A";
  }
  return sub_A4F1(a1, v4, v2, v3);
}
// 406F0: using guessed type __int16 aAcpiPnp04xX[17];

//----- (000000000000A7E1) ----------------------------------------------------
__int64 __fastcall sub_A7E1(__int64 *a1, __int64 a2)
{
  const __int16 *v2; // r8
  const __int16 *v3; // r9

  v2 = L"Secondary";
  if ( !*(_BYTE *)(a2 + 4) )
    v2 = L"Primary";
  v3 = L"Slave";
  if ( !*(_BYTE *)(a2 + 5) )
    v3 = L"Master";
  return sub_A4F1(a1, (signed __int16 *)"A", v2, v3);
}
// 40744: using guessed type __int16 aSecondary[10];
// 40758: using guessed type __int16 aPrimary[8];
// 40768: using guessed type __int16 aSlave[6];
// 40774: using guessed type __int16 aMaster_0[7];

//----- (000000000000A827) ----------------------------------------------------
__int64 __fastcall sub_A827(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, (signed __int16 *)"S", *(unsigned __int16 *)(a2 + 4), *(unsigned __int16 *)(a2 + 6));
}

//----- (000000000000A84B) ----------------------------------------------------
__int64 __fastcall sub_A84B(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, (signed __int16 *)"S", *(unsigned __int16 *)(a2 + 4), *(unsigned __int16 *)(a2 + 6));
}

//----- (000000000000A86F) ----------------------------------------------------
__int64 __fastcall sub_A86F(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, (signed __int16 *)"F", *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16));
}

//----- (000000000000A891) ----------------------------------------------------
__int64 __fastcall sub_A891(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, (signed __int16 *)"F", *(unsigned int *)(a2 + 12), *(unsigned int *)(a2 + 8));
}

//----- (000000000000A8B3) ----------------------------------------------------
__int64 __fastcall sub_A8B3(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, (signed __int16 *)"F", *(unsigned int *)(a2 + 4), *(unsigned __int16 *)(a2 + 8));
}

//----- (000000000000A8D6) ----------------------------------------------------
__int64 __fastcall sub_A8D6(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, (signed __int16 *)"U", *(unsigned __int8 *)(a2 + 4), *(unsigned __int8 *)(a2 + 5));
}

//----- (000000000000A8FA) ----------------------------------------------------
__int64 __fastcall sub_A8FA(__int64 *a1, __int64 a2)
{
  __int64 v3; // [rsp+20h] [rbp-20h]
  __int64 v4; // [rsp+28h] [rbp-18h]
  _QWORD v5[2]; // [rsp+30h] [rbp-10h]

  LODWORD(v5[0]) = *(unsigned __int8 *)(a2 + 10);
  LODWORD(v4) = *(unsigned __int8 *)(a2 + 9);
  LODWORD(v3) = *(unsigned __int8 *)(a2 + 8);
  return sub_A4F1(
           a1,
           (signed __int16 *)"U",
           *(unsigned __int16 *)(a2 + 4),
           *(unsigned __int16 *)(a2 + 6),
           v3,
           v4,
           v5[0]);
}

//----- (000000000000A938) ----------------------------------------------------
__int64 __fastcall sub_A938(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, (signed __int16 *)"I", *(unsigned int *)(a2 + 4));
}

//----- (000000000000A956) ----------------------------------------------------
__int64 __fastcall sub_A956(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 *v3; // r15
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // rsi

  v2 = a2;
  v3 = a1;
  v4 = 32i64;
  if ( *(_BYTE *)(a2 + 36) < 2u )
    v4 = 6i64;
  sub_A4F1(a1, (signed __int16 *)"M");
  v5 = 0i64;
  do
    sub_A4F1(v3, L"%02x", *(unsigned __int8 *)(v2 + v5++ + 4));
  while ( v5 < v4 );
  return sub_A4F1(v3, (signed __int16 *)")");
}
// 408A8: using guessed type __int16 a02x_0[5];

//----- (000000000000A9C7) ----------------------------------------------------
__int64 __fastcall sub_A9C7(__int64 *a1, __int64 a2)
{
  __int64 v3; // [rsp+20h] [rbp-20h]
  __int64 v4; // [rsp+28h] [rbp-18h]
  _QWORD v5[2]; // [rsp+30h] [rbp-10h]

  LODWORD(v5[0]) = *(unsigned __int16 *)(a2 + 14);
  LODWORD(v4) = *(unsigned __int8 *)(a2 + 11);
  LODWORD(v3) = *(unsigned __int8 *)(a2 + 10);
  return sub_A4F1(a1, (signed __int16 *)"I", *(unsigned __int8 *)(a2 + 8), *(unsigned __int8 *)(a2 + 9), v3, v4, v5[0]);
}

//----- (000000000000AA05) ----------------------------------------------------
__int64 __fastcall sub_AA05(__int64 *a1)
{
  return sub_A4F1(a1, L"IP-v6(not-done)");
}
// 408E0: using guessed type __int16 aIpV6NotDone[16];

//----- (000000000000AA1F) ----------------------------------------------------
__int64 __fastcall sub_AA1F(__int64 *a1)
{
  return sub_A4F1(a1, L"InfiniBand(not-done)");
}
// 40900: using guessed type __int16 aInfinibandNotD[21];

//----- (000000000000AA39) ----------------------------------------------------
__int64 __fastcall sub_AA39(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 *v3; // rsi
  unsigned __int64 v4; // rax
  signed __int64 v5; // r9
  __int64 v6; // r8
  unsigned __int64 v7; // rax
  char *v8; // rdx

  v2 = a2;
  v3 = a1;
  v4 = *(char *)(a2 + 17);
  v5 = 120i64;
  if ( v4 <= 5 )
    v5 = *((unsigned int *)qword_8EC20 + v4);
  v6 = *(_QWORD *)(a2 + 8);
  if ( v6 )
    sub_A4F1(a1, (signed __int16 *)"U", v6, v5);
  else
    sub_A4F1(a1, (signed __int16 *)"U", (unsigned int)v5);
  if ( *(_BYTE *)(v2 + 16) )
    sub_A4F1(v3, L"%d");
  else
    sub_A4F1(v3, L"D");
  v7 = *(char *)(v2 + 18);
  if ( v7 > 3 )
    v8 = "x";
  else
    v8 = (&off_914A0)[v7];
  return sub_A4F1(v3, (signed __int16 *)v8);
}
// 40960: using guessed type __int16 aD_2[2];
// 40964: using guessed type __int16 aD[3];
// 8EC20: using guessed type __int64 qword_8EC20[4];
// 914A0: using guessed type char *off_914A0;

//----- (000000000000AAEA) ----------------------------------------------------
__int64 __fastcall sub_AAEA(__int64 *a1, __int64 a2)
{
  int v2; // eax
  __int64 v3; // r8
  __int64 v4; // r9
  signed __int16 *v5; // rdx
  _QWORD v7[2]; // [rsp+20h] [rbp-10h]

  v2 = *(unsigned __int8 *)(a2 + 41);
  if ( v2 == 2 )
    return sub_A4F1(a1, (signed __int16 *)"H", *(unsigned int *)(a2 + 4), a2 + 24);
  if ( (_BYTE)v2 == 1 )
  {
    v3 = *(unsigned int *)(a2 + 4);
    v4 = *(unsigned int *)(a2 + 24);
    v5 = L"HD(Part%d,Sig%08x)";
  }
  else
  {
    v3 = *(unsigned int *)(a2 + 4);
    v4 = *(unsigned __int8 *)(a2 + 40);
    LODWORD(v7[0]) = *(unsigned __int8 *)(a2 + 41);
    v5 = L"HD(Part%d,MBRType=%02x,SigType=%02x)";
  }
  return sub_A4F1(a1, v5, v3, v4, v7[0]);
}
// 4098C: using guessed type __int16 aHdPartDSig08x[19];
// 409D4: using guessed type __int16 aHdPartDMbrtype[37];

//----- (000000000000AB48) ----------------------------------------------------
__int64 __fastcall sub_AB48(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, (signed __int16 *)"C", *(unsigned int *)(a2 + 4));
}

//----- (000000000000AB66) ----------------------------------------------------
__int64 __fastcall sub_AB66(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, L"%s", a2 + 4);
}
// 40A3C: using guessed type __int16 aS_11[3];

//----- (000000000000AB84) ----------------------------------------------------
__int64 __fastcall sub_AB84(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, (signed __int16 *)"%", a2 + 4);
}

//----- (000000000000ABA2) ----------------------------------------------------
__int64 __fastcall sub_ABA2(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, (signed __int16 *)"%", a2 + 4);
}

//----- (000000000000ABC0) ----------------------------------------------------
__int64 __fastcall sub_ABC0(__int64 *a1, __int64 a2)
{
  const __int16 *v2; // r8

  if ( (unsigned __int16)(*(_WORD *)(a2 + 4) - 1) > 5u )
    v2 = L"?";
  else
    v2 = (&off_914C0)[(signed __int16)(*(_WORD *)(a2 + 4) - 1)];
  return sub_A4F1(a1, L"Legacy-%s", v2);
}
// 406D8: using guessed type __int16 asc_406D8[2];
// 40A94: using guessed type __int16 aLegacyS[10];
// 914C0: using guessed type __int16 *off_914C0;

//----- (000000000000ABFE) ----------------------------------------------------
__int64 __fastcall sub_ABFE(__int64 *a1)
{
  return sub_A4F1(a1, L",");
}
// 40AA8: using guessed type __int16 asc_40AA8[2];

//----- (000000000000AC18) ----------------------------------------------------
__int64 __fastcall sub_AC18(__int64 *a1, __int64 a2)
{
  return sub_A4F1(a1, L"NVME(%x,%lx)", *(unsigned int *)(a2 + 4), *(_QWORD *)(a2 + 8));
}
// 40AAC: using guessed type __int16 aNvmeXLx[13];

//----- (000000000000AC3A) ----------------------------------------------------
__int64 __fastcall sub_AC3A(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 *v3; // r15
  __int64 v4; // rbx
  __int64 v5; // rsi

  v2 = a2;
  v3 = a1;
  sub_A4F1(a1, (signed __int16 *)"?");
  if ( v2 )
  {
    v4 = *(unsigned __int16 *)(v2 + 2);
    if ( *(_WORD *)(v2 + 2) )
    {
      v5 = 0i64;
      do
        sub_A4F1(v3, (signed __int16 *)"0", *(unsigned __int8 *)(v2 + v5++));
      while ( v4 != v5 );
    }
  }
  return sub_A4F1(v3, (signed __int16 *)"]");
}

//----- (000000000000ACAE) ----------------------------------------------------
__int64 __fastcall sub_ACAE(_BYTE *a1)
{
  _BYTE *v1; // rsi
  __int64 v2; // rsi
  char v3; // al
  __int64 (__fastcall *v4)(__int64 *); // r12
  __int64 *v5; // rcx
  __int64 v7; // [rsp+28h] [rbp-58h]
  __int64 v8; // [rsp+30h] [rbp-50h]
  __int64 v9; // [rsp+38h] [rbp-48h]
  __int64 v10; // [rsp+40h] [rbp-40h]

  v1 = a1;
  v7 = -6148914691236517206i64;
  v8 = -6148914691236517206i64;
  v9 = -6148914691236517206i64;
  (*(void (__fastcall **)(__int64 *, signed __int64, _QWORD))(qword_96CD8 + 360))(&v7, 24i64, 0i64);
  if ( v1 )
  {
    v2 = sub_A5DE(v1);
    v10 = v2;
    while ( 1 )
    {
      v3 = *(_BYTE *)v2 & 0x7F;
      if ( v3 == 127 && *(_BYTE *)(v2 + 1) == -1 )
        break;
      v4 = (__int64 (__fastcall *)(__int64 *))sub_A6D3;
      if ( sub_A6D3 )
      {
        v5 = &qword_92110;
        while ( v3 != *(_BYTE *)v5 || *(_BYTE *)(v2 + 1) != *((_BYTE *)v5 + 1) )
        {
          v4 = (__int64 (__fastcall *)(__int64 *))v5[3];
          v5 += 2;
          if ( !v4 )
            goto LABEL_10;
        }
      }
      else
      {
LABEL_10:
        v4 = 0i64;
      }
      if ( !v4 )
        v4 = (__int64 (__fastcall *)(__int64 *))sub_AC3A;
      if ( v4 != sub_ABFE )
      {
        if ( v8 )
          sub_A4F1(&v7, &word_40ADE);
      }
      ((void (__fastcall *)(__int64 *, __int64))v4)(&v7, v2);
      v2 += *(unsigned __int16 *)(v2 + 2);
    }
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v10);
  }
  return v7;
}
// 40ADE: using guessed type __int16 word_40ADE;
// 92110: using guessed type __int64 qword_92110;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000ADC4) ----------------------------------------------------
__int64 __fastcall sub_ADC4(__int64 a1, _WORD *a2)
{
  _WORD *v2; // rbx
  __int64 v3; // r14
  signed __int64 v4; // rax
  signed __int64 v5; // rdi
  _WORD *v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rdi

  v2 = a2;
  v3 = a1;
  v4 = sub_23764(a2);
  v5 = v4;
  v6 = (_WORD *)sub_24136(v4 + 8);
  if ( !v6 )
    return 0i64;
  v7 = (__int64)v6;
  *v6 = 1028;
  v6[1] = v5 + 4;
  (*(void (__fastcall **)(_WORD *, _WORD *, signed __int64))(qword_96CD8 + 352))(v6 + 2, v2, v5);
  *(_DWORD *)(v7 + *(unsigned __int16 *)(v7 + 2)) = (_DWORD)&byte_4FF7F;
  if ( v3 )
  {
    v8 = sub_23DB4(v3, v7);
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v7);
    return v8;
  }
  return v7;
}
// 4FF7F: using guessed type char byte_4FF7F;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000AE6A) ----------------------------------------------------
_WORD *__fastcall sub_AE6A(_BYTE *a1, signed int a2, void (__fastcall *a3)(signed __int64, __int64), __int64 a4)
{
  __int64 v4; // r15
  void (__fastcall *v5)(signed __int64, __int64); // rdi
  signed int v6; // ebx
  _WORD *result; // rax
  _WORD *v8; // r14
  unsigned __int16 v9; // ax
  __int64 v10; // rsi
  int v11; // ebx

  v4 = a4;
  v5 = a3;
  v6 = a2;
  result = (_WORD *)sub_ACAE(a1);
  if ( result )
  {
    v8 = result;
    v9 = *result;
    v10 = 0i64;
    while ( v9 )
    {
      v5(v9, v4);
      v9 = v8[v10++ + 1];
    }
    if ( (signed int)v10 < v6 )
    {
      v11 = v6 - v10;
      do
      {
        v5(32i64, v4);
        --v11;
      }
      while ( v11 );
    }
    result = (_WORD *)(*(__int64 (__fastcall **)(_WORD *))(qword_96CD8 + 72))(v8);
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000AEE6) ----------------------------------------------------
signed __int64 __fastcall sub_AEE6(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rdi
  signed __int64 v4; // rsi
  __int64 v5; // rax
  char v6; // cl

  v3 = a3;
  v4 = -9223372036854775805i64;
  v5 = sub_23D7F(a1);
  if ( v5 )
  {
    while ( 1 )
    {
      v6 = *(_BYTE *)v5 & 0x7F;
      if ( v6 == 4 )
      {
        if ( *(_BYTE *)(v5 + 1) == 1 && *(_BYTE *)(v5 + 40) == 2 && *(_BYTE *)(v5 + 41) == 2 )
        {
          sub_7AC8((unsigned int *)(v5 + 24), v3);
          return 0i64;
        }
      }
      else if ( v6 == 127 && *(_BYTE *)(v5 + 1) == -1 )
      {
        return v4;
      }
      v5 += *(unsigned __int16 *)(v5 + 2);
    }
  }
  return v4;
}

//----- (000000000000AF60) ----------------------------------------------------
__int64 __fastcall sub_AF60(__int64 a1, __int64 a2, _BYTE *a3)
{
  _BYTE *v3; // r14
  __int64 v4; // r15
  __int64 v5; // rbx
  signed __int64 v6; // rsi
  __int64 v7; // rax
  unsigned __int16 *v8; // rdi
  __int64 v9; // rax
  int v10; // eax
  unsigned __int64 v11; // r8
  int v12; // eax
  __int64 v14; // [rsp+30h] [rbp-40h]
  __int64 v15; // [rsp+38h] [rbp-38h]
  __int64 v16; // [rsp+40h] [rbp-30h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = -9223372036854775805i64;
  v15 = -6148914691236517206i64;
  v16 = -6148914691236517206i64;
  v14 = -6148914691236517206i64;
  v7 = sub_1364F(512i64);
  if ( !v7 )
    return -9223372036854775799i64;
  v8 = (unsigned __int16 *)v7;
  v9 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(v5, qword_92A60, &v16);
  if ( v9 < 0 )
    return v9;
  v9 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(v5, qword_92AA0, &v15);
  if ( v9 < 0 )
    return v9;
  v9 = (*(__int64 (__fastcall **)(__int64, _QWORD, signed __int64, signed __int64, unsigned __int16 *))(v15 + 8))(
         v15,
         **(unsigned int **)(v16 + 8),
         1024i64,
         512i64,
         v8);
  if ( v9 < 0 )
    return v9;
  v10 = *v8;
  if ( v10 == 17474 )
  {
    if ( v8[62] != 11080 )
      return v6;
    v11 = ((unsigned __int64)(unsigned __int16)__ROL2__(v8[14], 8) << 9)
        + (unsigned __int16)__ROL2__(v8[63], 8) * (unsigned __int64)_byteswap_ulong(*((_DWORD *)v8 + 5));
    if ( !v11 )
      return v6;
    v9 = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned __int64, signed __int64, unsigned __int16 *))(v15 + 8))(
           v15,
           **(unsigned int **)(v16 + 8),
           v11 + 1024,
           512i64,
           v8);
    if ( v9 < 0 )
      return v9;
    LOWORD(v10) = *v8;
  }
  v12 = (unsigned __int16)__ROL2__(v10, 8);
  if ( v12 == 18520 || v12 == 18475 )
  {
    sub_1B950((char *)v8 + 104, (char *)&v14, 8ui64);
    return sub_9B9D((char *)&v14, 8u, v4, v3);
  }
  return v6;
}
// 92A60: using guessed type __int64 qword_92A60[2];
// 92AA0: using guessed type __int64 qword_92AA0[2];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000B0E9) ----------------------------------------------------
signed __int64 __fastcall sub_B0E9(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r14
  signed __int64 v4; // r15
  __int64 v5; // rax
  __int64 i; // rbx
  char v7; // al
  __int64 v9; // [rsp+20h] [rbp-40h]
  __int64 v10; // [rsp+28h] [rbp-38h]

  v3 = a3;
  v4 = -9223372036854775794i64;
  v5 = sub_23D7F(a1);
  if ( !v5 )
    return v4;
  for ( i = v5; ; i += *(unsigned __int16 *)(i + 2) )
  {
    v7 = *(_BYTE *)i & 0x7F;
    if ( v7 == 4 )
      break;
    if ( v7 == 127 && *(_BYTE *)(i + 1) == -1 )
      return v4;
LABEL_10:
    ;
  }
  if ( *(_BYTE *)(i + 1) != 3 )
    goto LABEL_10;
  if ( *(_WORD *)(i + 2) != 36i64 )
    goto LABEL_10;
  v9 = 5328615414508616951i64;
  v10 = 4785125202889623441i64;
  if ( (unsigned int)sub_189D2(i + 4, (__int64)&v9, 16i64) )
    goto LABEL_10;
  if ( v3 )
    sub_7AC8((unsigned int *)(i + 20), v3);
  return 0i64;
}

//----- (000000000000B1BA) ----------------------------------------------------
__int64 __fastcall sub_B1BA(__int64 a1)
{
  unsigned int v1; // esi
  int v2; // ecx
  __int64 v4; // [rsp+28h] [rbp-28h]
  int v5; // [rsp+30h] [rbp-20h]
  __int64 v6; // [rsp+34h] [rbp-1Ch]
  int v7; // [rsp+3Ch] [rbp-14h]
  unsigned __int64 v8; // [rsp+40h] [rbp-10h]

  v4 = -6148914691236517206i64;
  v5 = -1431655766;
  v6 = -6148914691236517206i64;
  v7 = -1431655766;
  v8 = 24i64;
  v1 = 0;
  if ( a1
    && (*(__int64 (__fastcall **)(__int64, __int64 *, unsigned __int64 *, __int64 *))(a1 + 64))(
         a1,
         qword_92C60,
         &v8,
         &v4) >= 0 )
  {
    v2 = v4;
    if ( (_DWORD)v4 )
      v2 = v7;
    v1 = 0;
    if ( v8 >= 0x18 )
      v1 = v2;
  }
  return v1;
}
// 92C60: using guessed type __int64 qword_92C60[2];

//----- (000000000000B226) ----------------------------------------------------
signed __int64 __fastcall sub_B226(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 *a5)
{
  return sub_B252(a1, a2, 0i64, 0i64, a3, a4, a5);
}

//----- (000000000000B252) ----------------------------------------------------
signed __int64 __fastcall sub_B252(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 *a7)
{
  __int64 v7; // r14
  __int64 v8; // rdi
  _BYTE *v9; // rbx
  __int64 v10; // rsi
  __int16 *v11; // rax
  __int16 *v12; // rbx
  __int16 v13; // ax
  __int16 *i; // rdx
  __int16 *v15; // rcx
  char *v16; // rax
  __int64 v17; // r13
  __int64 v18; // rax
  __int64 v20; // [rsp+28h] [rbp-48h]
  __int64 v21; // [rsp+30h] [rbp-40h]

  v7 = a4;
  v8 = a3;
  v9 = (_BYTE *)a2;
  v10 = -9223372036854775794i64;
  v20 = -6148914691236517206i64;
  v21 = -6148914691236517206i64;
  if ( sub_B0E9(a1, a2, 0i64) >= 0 )
  {
    if ( v8 && !(sub_B1BA(v8) & 0x10) )
      return -9223372036854775805i64;
    v11 = (__int16 *)sub_ACAE(v9);
    if ( v11 )
    {
      v12 = v11;
      v13 = *v11;
      if ( v13 == 92 || v13 == 47 )
      {
        for ( i = v12; ; v13 = *i )
        {
          ++i;
          if ( v13 != 47 && v13 != 92 )
            break;
        }
        v15 = i - 1;
        while ( v13 && v13 != 47 && v13 != 92 )
        {
          v13 = *i;
          ++i;
        }
        *(i - 1) = 0;
        v16 = sub_71CF(v15);
        if ( v16 )
        {
          v17 = (__int64)v16;
          if ( sub_11070(v16, &v20) )
          {
            if ( a6 )
            {
              sub_18AB5(a6, v17, a5);
              sub_136C5(v17);
              if ( a7 )
              {
                v18 = v20;
                a7[1] = v21;
                *a7 = v18;
              }
              return 0i64;
            }
            v10 = (*(__int64 (__fastcall **)(__int64, __int64, __int16 *, signed __int64, _QWORD))(v8 + 8))(
                    v8,
                    v7,
                    v12,
                    1i64,
                    0i64);
          }
          sub_136C5(v17);
          return v10;
        }
      }
    }
  }
  return v10;
}

//----- (000000000000B3AB) ----------------------------------------------------
signed __int64 __fastcall sub_B3AB(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return sub_B252(a1, a2, a3, a4, 0i64, 0i64, 0i64);
}

//----- (000000000000B3CF) ----------------------------------------------------
__int64 __fastcall sub_B3CF(char a1)
{
  char v1; // bl
  __int64 v2; // rax
  __int64 v3; // r9
  __int64 *v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rdx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rsi
  __int64 v10; // rax
  int v11; // eax
  __int64 v12; // rsi
  __int64 v14; // [rsp+40h] [rbp-B0h]
  __int64 v15; // [rsp+48h] [rbp-A8h]
  __int64 v16; // [rsp+50h] [rbp-A0h]
  __int64 v17; // [rsp+58h] [rbp-98h]
  __int64 v18; // [rsp+60h] [rbp-90h]
  __int64 v19; // [rsp+68h] [rbp-88h]
  __int64 v20; // [rsp+70h] [rbp-80h]
  __int64 v21; // [rsp+78h] [rbp-78h]
  __int64 v22; // [rsp+80h] [rbp-70h]
  __int64 v23; // [rsp+88h] [rbp-68h]
  __int64 v24; // [rsp+90h] [rbp-60h]
  __int64 v25; // [rsp+98h] [rbp-58h]
  __int64 v26; // [rsp+A0h] [rbp-50h]
  __int64 v27; // [rsp+A8h] [rbp-48h]
  __int64 v28; // [rsp+B0h] [rbp-40h]
  __int64 v29; // [rsp+B8h] [rbp-38h]
  unsigned __int64 v30; // [rsp+C0h] [rbp-30h]
  __int64 v31; // [rsp+C8h] [rbp-28h]

  v1 = a1;
  v21 = -6148914691236517206i64;
  v20 = -6148914691236517206i64;
  v19 = -6148914691236517206i64;
  v18 = -6148914691236517206i64;
  v17 = -6148914691236517206i64;
  v16 = -6148914691236517206i64;
  v15 = -6148914691236517206i64;
  v14 = -6148914691236517206i64;
  v29 = -6148914691236517206i64;
  v28 = -6148914691236517206i64;
  v27 = -6148914691236517206i64;
  v26 = -6148914691236517206i64;
  v25 = -6148914691236517206i64;
  v24 = -6148914691236517206i64;
  v23 = -6148914691236517206i64;
  v22 = -6148914691236517206i64;
  v30 = 0i64;
  v31 = 0i64;
  v2 = sub_B252(*(_QWORD *)(qword_96A98 + 24), *(_QWORD *)(qword_96A98 + 32), 0i64, 0i64, 64i64, (__int64)&v14, 0i64);
  if ( v2 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`FS:AGSVH] %r @ FS:AGPBSVU\n", v2, v3);
    return 0i64;
  }
  v4 = qword_92CF0;
  if ( !v1 )
    v4 = qword_92B40;
  v5 = (*(__int64 (__fastcall **)(signed __int64, __int64 *, _QWORD, unsigned __int64 *, __int64 *))(qword_96CD8 + 312))(
         2i64,
         v4,
         0i64,
         &v30,
         &v31);
  if ( v5 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`FS:AGSVH] %r @ LocHB %g\n", v5, (__int64)v4);
LABEL_15:
    if ( v31 )
      (*(void (**)(void))(qword_96CD8 + 72))();
    return 0i64;
  }
  if ( !v30 )
  {
LABEL_12:
    sub_1A2B6(1, (__int64)"[EB|`FS:AGSVH] ! @ 'END\n", v7, v8);
    goto LABEL_15;
  }
  v9 = 0i64;
  while ( 1 )
  {
    v10 = sub_B0E9(*(_QWORD *)(v31 + 8 * v9), v6, (unsigned __int64)&v22);
    if ( v10 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`FS:AGSVH] %r @ 'AGU.%d\n", v10, v9);
      goto LABEL_11;
    }
    v11 = sub_189FE(&v14);
    if ( !(unsigned int)sub_18A43((__int64)&v14, (__int64)&v22, v11) )
      break;
LABEL_11:
    if ( ++v9 >= v30 )
      goto LABEL_12;
  }
  if ( v31 )
  {
    v12 = *(_QWORD *)(v31 + 8 * v9);
    (*(void (**)(void))(qword_96CD8 + 72))();
    return v12;
  }
  return 0i64;
}
// 92B40: using guessed type __int64 qword_92B40[2];
// 92CF0: using guessed type __int64[2];
// 96A98: using guessed type __int64 qword_96A98;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000B59D) ----------------------------------------------------
signed __int64 __fastcall sub_B59D(__int64 a1, __int64 a2, _QWORD *a3, __int64 *a4)
{
  __int64 *v4; // r12
  _QWORD *v5; // r14
  __int64 v6; // rsi
  __int64 v7; // rdi
  signed __int64 v8; // rax
  signed __int64 v9; // rbx
  int v10; // eax
  __int64 v11; // rdx
  __int64 v12; // r12
  __int64 v13; // r13
  char v14; // si
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rsi
  __int64 v18; // r9
  char v20; // [rsp+40h] [rbp-1B0h]
  __int64 v21; // [rsp+140h] [rbp-B0h]
  __int64 v22; // [rsp+148h] [rbp-A8h]
  __int64 v23; // [rsp+150h] [rbp-A0h]
  __int64 v24; // [rsp+158h] [rbp-98h]
  __int64 v25; // [rsp+160h] [rbp-90h]
  __int64 v26; // [rsp+168h] [rbp-88h]
  __int64 v27; // [rsp+170h] [rbp-80h]
  __int64 v28; // [rsp+178h] [rbp-78h]
  __int16 *v29; // [rsp+180h] [rbp-70h]
  __int64 *v30; // [rsp+188h] [rbp-68h]
  __int64 v31; // [rsp+190h] [rbp-60h]
  _QWORD *v32; // [rsp+198h] [rbp-58h]
  unsigned __int64 v33; // [rsp+1A0h] [rbp-50h]
  __int64 v34; // [rsp+1A8h] [rbp-48h]
  __int64 v35; // [rsp+1B0h] [rbp-40h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v28 = -6148914691236517206i64;
  v27 = -6148914691236517206i64;
  v26 = -6148914691236517206i64;
  v25 = -6148914691236517206i64;
  v24 = -6148914691236517206i64;
  v23 = -6148914691236517206i64;
  v22 = -6148914691236517206i64;
  v21 = -6148914691236517206i64;
  LOBYTE(a2) = -86;
  sub_F180(&v20, a2, 0x100ui64);
  v33 = 0i64;
  v34 = 0i64;
  *v5 = 0i64;
  v8 = sub_B252(v7, v6, 0i64, 0i64, 64i64, (__int64)&v21, 0i64);
  if ( v8 < 0 )
    return v8;
  v9 = -9223372036854775794i64;
  v10 = sub_189FE(&v21);
  v29 = sub_7226((unsigned __int8 *)&v21, v10);
  if ( !v29 )
    return v9;
  v8 = (*(__int64 (__fastcall **)(signed __int64, __int64 *, _QWORD, unsigned __int64 *, __int64 *))(qword_96CD8 + 312))(
         2i64,
         qword_92B40,
         0i64,
         &v33,
         &v34);
  if ( v8 < 0 )
    return v8;
  v30 = v4;
  v32 = v5;
  if ( v33 )
  {
    v12 = 0i64;
    while ( 1 )
    {
      v13 = *(_QWORD *)(v34 + 8 * v12);
      if ( sub_B0E9(*(_QWORD *)(v34 + 8 * v12), v11, 0i64) >= 0 )
      {
        v31 = -6148914691236517206i64;
        if ( (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(v13, qword_92B40, &v31) >= 0 )
        {
          v35 = -6148914691236517206i64;
          if ( (*(__int64 (__fastcall **)(__int64, __int64 *))(v31 + 8))(v31, &v35) >= 0 )
          {
            v14 = sub_B1BA(v35);
            (*(void (**)(void))(v35 + 16))();
            if ( v14 & 4 )
            {
              sub_2370D(&v20, word_40AE2);
              sub_237BC(&v20, v29);
              sub_237BC(&v20, &word_40AE6);
              v15 = sub_23D7F(v13);
              v16 = sub_ADC4(v15, &v20);
              if ( v16 )
              {
                v17 = v16;
                if ( (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD))(qword_96CD8 + 200))(
                       0i64,
                       qword_96A90,
                       v16,
                       0i64) >= 0 )
                  break;
              }
            }
          }
        }
      }
      if ( ++v12 >= v33 )
        goto LABEL_13;
    }
    sub_1A2B6(1, (__int64)"[EB|#FS:RBDP] %D\n", v17, v18);
    if ( v30 )
      *v30 = v17;
  }
LABEL_13:
  (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v34);
  if ( *v32 )
    v9 = 0i64;
  return v9;
}
// 40AE2: using guessed type __int16 word_40AE2[2];
// 40AE6: using guessed type __int16 word_40AE6;
// 92B40: using guessed type __int64 qword_92B40[2];
// 96A90: using guessed type __int64 qword_96A90;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000B814) ----------------------------------------------------
__int64 sub_B814()
{
  return sub_B830(0i64, 0i64, 0i64, 0i64);
}
// 93B68: using guessed type int dword_93B68;
// 93B6C: using guessed type int dword_93B6C;

//----- (000000000000B830) ----------------------------------------------------
__int64 __fastcall sub_B830(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax

  result = qword_96B38;
  if ( qword_96B38 || (result = qword_96B30) != 0 )
    result = (*(__int64 (__fastcall **)(__int64, int *, _QWORD, _QWORD, _QWORD, __int64, __int64, __int64, __int64, _QWORD))(result + 16))(
               result,
               &dword_92308,
               0i64,
               0i64,
               0i64,
               a1,
               a2,
               a3,
               a4,
               0i64);
  return result;
}
// 92308: using guessed type int dword_92308;
// 96B30: using guessed type __int64 qword_96B30;
// 96B38: using guessed type __int64 qword_96B38;

//----- (000000000000B88A) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_B88A()
{
  (*(void (__fastcall **)(__int64))(qword_96CD8 + 112))(qword_96B50);
  qword_96B50 = 0i64;
  return sub_B830(0i64, 0i64, 0i64, 0i64);
}
// B8A3: write access to const memory at 96B50 has been detected
// 93B68: using guessed type int dword_93B68;
// 93B6C: using guessed type int dword_93B6C;
// 93B70: using guessed type __int64 qword_93B70;
// 93B78: using guessed type __int64 qword_93B78;
// 93B80: using guessed type __int64 qword_93B80;
// 96B50: using guessed type __int64 qword_96B50;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000B8E5) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_B8E5()
{
  __int64 result; // rax
  __int64 v1; // [rsp+30h] [rbp-10h]
  unsigned __int8 v2; // [rsp+3Fh] [rbp-1h]

  v2 = 0;
  v1 = 1i64;
  result = (*(__int64 (__fastcall **)(const char *, int *, _QWORD))(qword_96CE0 + 72))("B", &dword_91FF4, 0i64);
  if ( !result )
  {
    result = v2;
    if ( v2 )
    {
      BYTE2(qword_96AA8) |= 1u;
      result = (*(__int64 (__fastcall **)(const char *, int *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
                 "B",
                 &dword_91FF4,
                 0i64,
                 0i64,
                 0i64);
    }
  }
  return result;
}
// B92B: write access to const memory at 96AAA has been detected
// 91FF4: using guessed type int dword_91FF4;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000000B95F) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_B95F()
{
  __int64 v0; // rax
  __int64 v1; // rsi
  _DWORD *v2; // rcx

  v0 = (*(__int64 (__fastcall **)(__int64, signed __int64))(qword_96B58 + 8))(qword_96B58, 1i64);
  if ( v0 < 0 )
    return v0;
  dword_93BB0 = 1;
  if ( (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
         *(_QWORD *)(qword_96CD0 + 56),
         qword_92AD0,
         &qword_96B38) >= 0
    || (qword_96B38 = 0i64,
        v1 = (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
               *(_QWORD *)(qword_96CD0 + 56),
               qword_92B60,
               &qword_96B30),
        v1 >= 0) )
  {
    LOBYTE(qword_96AA8) = qword_96AA8 | 0x20;
    if ( !qword_96B38 )
      return (*(__int64 (__fastcall **)(__int64, int *, int *, int *, int *))qword_96B30)(
               qword_96B30,
               &dword_93B68,
               &dword_93B6C,
               &dword_93B88,
               &dword_93B8C);
    v2 = *(_DWORD **)(*(_QWORD *)(qword_96B38 + 24) + 8i64);
    dword_93B68 = v2[1];
    dword_93B6C = v2[2];
    dword_93B88 = sub_BAD6(v2);
    v1 = -9223372036854775805i64;
  }
  return v1;
}
// B989: write access to const memory at 93BB0 has been detected
// B9C1: write access to const memory at 96B38 has been detected
// B9FE: write access to const memory at 96AA8 has been detected
// BA1C: write access to const memory at 93B68 has been detected
// BA25: write access to const memory at 93B6C has been detected
// BA30: write access to const memory at 93B88 has been detected
// BA3A: write access to const memory at 93B8C has been detected
// 92AD0: using guessed type __int64 qword_92AD0[2];
// 92B60: using guessed type __int64 qword_92B60[2];
// 93B68: using guessed type int dword_93B68;
// 93B6C: using guessed type int dword_93B6C;
// 93B88: using guessed type int dword_93B88;
// 93B8C: using guessed type int dword_93B8C;
// 93BB0: using guessed type int dword_93BB0;
// 96AA0: using guessed type __int64 qword_96AA0;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96B30: using guessed type __int64 qword_96B30;
// 96B38: using guessed type __int64 qword_96B38;
// 96B58: using guessed type __int64 qword_96B58;
// 96CD0: using guessed type __int64 qword_96CD0;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000BA8B) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_BA8B(unsigned int a1)
{
  unsigned int v1; // esi
  __int64 result; // rax

  v1 = a1;
  if ( a1 != 1 )
  {
    if ( a1 != 2 )
      return -9223372036854775806i64;
    v1 = 0;
  }
  if ( v1 )
  {
    result = (*(__int64 (__fastcall **)(__int64, _QWORD))(qword_96B58 + 8))(qword_96B58, v1);
    if ( result < 0 )
      return result;
    dword_93BB0 = v1;
  }
  return 0i64;
}
// BABB: write access to const memory at 93BB0 has been detected
// 93BB0: using guessed type int dword_93BB0;
// 96B58: using guessed type __int64 qword_96B58;

//----- (000000000000BAD6) ----------------------------------------------------
signed __int64 __fastcall sub_BAD6(_DWORD *a1)
{
  int v1; // edx
  signed __int64 result; // rax
  unsigned int v3; // ecx
  int v4; // eax

  v1 = a1[6] | a1[4] | a1[5];
  result = 0i64;
  if ( a1[3] < 2u )
    return 32i64;
  if ( a1[3] == 2 )
  {
    v3 = 0;
    v4 = 0;
    do
      v4 += _bittest(&v1, v3++);
    while ( v3 != 32 );
    result = (v4 + 7) & 0xFFFFFFF8;
  }
  return result;
}

//----- (000000000000BB0D) ----------------------------------------------------
signed __int64 sub_BB0D()
{
  return -6148914691236517206i64;
}
// 93BB0: using guessed type int dword_93BB0;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000000BCFC) ----------------------------------------------------
signed __int64 sub_BCFC()
{
  return 2i64;
}
// 93BB0: using guessed type int dword_93BB0;

//----- (000000000000BD15) ----------------------------------------------------
void __fastcall sub_BD15(__int64 a1, __int64 *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *v4; // r14
  _QWORD *v5; // r15
  __int64 *v6; // r13
  __int64 v7; // rsi
  char *v8; // rdx
  __int64 v9; // rcx
  int v10; // eax
  const char *v11; // rdx
  char *v12; // rcx
  _WORD *v13; // rax
  signed __int64 v14; // rax
  __int64 v15; // rdi
  __int64 v16; // rdi
  __int64 v17; // rax
  unsigned __int64 v18; // rcx
  __int64 v19; // rdx
  int v20; // esi
  unsigned __int64 v21; // rdi
  unsigned __int64 v22; // rdi
  unsigned __int64 v23; // rdi
  signed __int64 v24; // rcx
  unsigned int v25; // esi
  unsigned int v26; // er12
  unsigned int v27; // eax
  signed int v28; // esi
  int v29; // eax
  unsigned int v30; // esi
  unsigned int v31; // ebx
  unsigned int v32; // edi
  __int64 v33; // rsi
  unsigned int v34; // eax
  __int64 v35; // r12
  unsigned int v36; // edi
  __int64 v37; // rbx
  char v38; // al
  __int64 v39; // rcx
  __int64 v40; // [rsp+38h] [rbp-98h]
  unsigned __int8 *v41; // [rsp+40h] [rbp-90h]
  __int64 v42; // [rsp+48h] [rbp-88h]
  __int64 v43; // [rsp+50h] [rbp-80h]
  unsigned __int64 v44; // [rsp+58h] [rbp-78h]
  unsigned __int64 v45; // [rsp+60h] [rbp-70h]
  __int64 v46; // [rsp+68h] [rbp-68h]
  __int64 v47; // [rsp+70h] [rbp-60h]
  __int64 v48; // [rsp+78h] [rbp-58h]
  __int64 v49; // [rsp+80h] [rbp-50h]
  __int64 v50; // [rsp+88h] [rbp-48h]
  unsigned int v51; // [rsp+90h] [rbp-40h]
  unsigned int v52; // [rsp+94h] [rbp-3Ch]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v46 = 0i64;
  v50 = 0i64;
  v49 = 0i64;
  v47 = 0i64;
  v48 = 0i64;
  v44 = 0i64;
  v51 = 0;
  v52 = 0;
  v45 = 0i64;
  v41 = 0i64;
  v42 = 0i64;
  if ( a1 == 1 )
  {
    v8 = "Boot Logo";
  }
  else
  {
    if ( a1 != 2 )
      goto LABEL_27;
    v8 = "Boot Fail Logo";
  }
  if ( sub_F364((char *)qword_96AA0, v8, (__int64 *)&v41, (char **)&v42) )
    goto LABEL_6;
  if ( !v42 )
    goto LABEL_27;
  v13 = sub_7226(v41, v42);
  v14 = sub_D739(qword_96AE0, qword_96AE8, (__int64)v13, 0i64, &v47, &v49);
  v9 = v49;
  if ( v14 >= 0 && v49 )
  {
    if ( (*(__int64 (__fastcall **)(signed __int64, __int64 *, _QWORD, unsigned __int64 *, __int64 *))(qword_96CD8 + 312))(
           2i64,
           qword_92CA0,
           0i64,
           &v45,
           &v48) < 0
      || (sub_1368E(v48), !v45) )
    {
LABEL_6:
      v9 = v49;
      goto LABEL_7;
    }
    v15 = 0i64;
    while ( 1 )
    {
      if ( (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
             *(_QWORD *)(v48 + 8 * v15),
             qword_92CA0,
             &v46) < 0 )
        goto LABEL_6;
      if ( (*(__int64 (__fastcall **)(__int64, __int64))(v46 + 16))(v49, v47) >= 0 )
        break;
      if ( ++v15 >= v45 )
        goto LABEL_6;
    }
    sub_136C5(v48);
    v48 = 0i64;
    if ( (*(__int64 (__fastcall **)(__int64, __int64, unsigned int *, unsigned int *))(v46 + 24))(v49, v47, &v51, &v52) < 0 )
      goto LABEL_6;
    v16 = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, unsigned __int64 *))(v46 + 32))(v49, v47, &v50, &v44);
    sub_136C5(v49);
    v9 = 0i64;
    v49 = 0i64;
    if ( v16 >= 0 )
    {
      if ( v50 )
      {
        sub_1368E(v50);
        v17 = v50;
        if ( v50 )
        {
          v18 = v44 >> 2;
          if ( v44 >> 2 )
          {
            v19 = 0i64;
            do
            {
              if ( *(_BYTE *)(v17 + 4 * v19 + 3) )
              {
                v20 = *(unsigned __int8 *)(v17 + 4 * v19 + 3) ^ 0xFF;
                v21 = (32897 * v20 * (unsigned int)*(unsigned __int8 *)(v17 + 4 * v19 + 2) >> 23)
                    + (unsigned __int64)BYTE2(dword_92308);
                if ( v21 >= 0xFF )
                  LOBYTE(v21) = -1;
                *(_BYTE *)(v17 + 4 * v19 + 2) = v21;
                v22 = (32897 * v20 * (unsigned int)*(unsigned __int8 *)(v17 + 4 * v19 + 1) >> 23)
                    + (unsigned __int64)BYTE1(dword_92308);
                if ( v22 >= 0xFF )
                  LOBYTE(v22) = -1;
                *(_BYTE *)(v17 + 4 * v19 + 1) = v22;
                v23 = (32897 * v20 * (unsigned int)*(unsigned __int8 *)(v17 + 4 * v19) >> 23)
                    + (unsigned __int64)(unsigned __int8)dword_92308;
                if ( v23 >= 0xFF )
                  LOBYTE(v23) = -1;
                *(_BYTE *)(v17 + 4 * v19) = v23;
              }
              ++v19;
            }
            while ( v18 != v19 );
          }
        }
      }
      v43 = 0i64;
      if ( sub_F3C2(qword_96AA0, "Boot Logo Scale", &v43) )
      {
        v43 = 125i64;
        v24 = 125i64;
      }
      else
      {
        v24 = v43;
      }
      if ( !v24 )
      {
        *v5 = v51;
        goto LABEL_59;
      }
      v25 = sub_2C972(v24, 1000);
      v26 = sub_2C860(1);
      sub_2C860(1);
      v27 = sub_2C860(0);
      v28 = sub_2C899(v27, v25);
      if ( v28 > (signed int)sub_2C860(v51) )
      {
        *v5 = v51;
LABEL_59:
        *v4 = v52;
        *v6 = v50;
        return;
      }
      v29 = sub_2C88C(v26, v51);
      v30 = sub_2C8F8(v28, v29);
      v31 = sub_2C899(v30, v26);
      v32 = sub_2C88C(v30, v52);
      v33 = v51;
      v40 = v52;
      v34 = sub_2C88C(v31, v51);
      v35 = (unsigned int)sub_2C86B(v34);
      v36 = sub_2C86B(v32);
      v37 = sub_1364F(v44);
      if ( v37 )
      {
        if ( !sub_3E19E(v37, v50, v40 + (v33 << 32), (v35 << 32) | v36) )
        {
          *v5 = (signed int)v35;
          *v4 = (signed int)v36;
          *v6 = v37;
          v39 = v50;
LABEL_67:
          sub_136C5(v39);
          return;
        }
        v38 = 0;
      }
      else
      {
        v38 = 1;
      }
      *v5 = v51;
      *v4 = v52;
      *v6 = v50;
      if ( v38 )
        return;
      v39 = v37;
      goto LABEL_67;
    }
  }
LABEL_7:
  if ( v9 )
    sub_136C5(v9);
  if ( v48 )
    sub_136C5(v48);
  if ( v50 )
    sub_136C5(v50);
  if ( v7 == 2 )
  {
    v10 = qword_96AA8;
    if ( byte_96B48 )
    {
      v11 = "CircleSlashBlack2X";
      v12 = "CircleSlash2X";
    }
    else
    {
      v11 = "CircleSlashBlack";
      v12 = "CircleSlash";
    }
    goto LABEL_32;
  }
  if ( v7 != 1 )
  {
LABEL_27:
    *v6 = 0i64;
    *v5 = 0i64;
    *v4 = 0i64;
    return;
  }
  v10 = qword_96AA8;
  if ( byte_96B48 )
  {
    v11 = "AppleLogoBlack2X";
    v12 = "AppleLogo2X";
  }
  else
  {
    v11 = "AppleLogoBlack";
    v12 = "AppleLogo";
  }
LABEL_32:
  if ( (unsigned int)&loc_40000 & v10 )
    v12 = (char *)v11;
  if ( sub_4E0C(v12, v6, v5, v4) >= 0 )
    sub_D31B(*v6, *v5 * *v4);
}
// 92308: using guessed type int dword_92308;
// 92CA0: using guessed type __int64 qword_92CA0[2];
// 96AA0: using guessed type __int64 qword_96AA0;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AE0: using guessed type __int64 qword_96AE0;
// 96AE8: using guessed type __int64 qword_96AE8;
// 96B48: using guessed type char byte_96B48;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000C267) ----------------------------------------------------
__int64 __fastcall sub_C267(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 result; // rax

  result = qword_96B38;
  if ( qword_96B38 || (result = qword_96B30) != 0 )
    result = (*(__int64 (__fastcall **)(__int64, __int64, signed __int64, _QWORD, _QWORD, __int64, __int64, __int64, __int64, _QWORD))(result + 16))(
               result,
               a5,
               2i64,
               0i64,
               0i64,
               a1,
               a2,
               a3,
               a4,
               0i64);
  return result;
}
// 96B30: using guessed type __int64 qword_96B30;
// 96B38: using guessed type __int64 qword_96B38;

//----- (000000000000C2C4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_C2C4(char a1, char a2, __int64 a3, __int64 a4)
{
  char v4; // si
  char v5; // bl
  unsigned __int64 v6; // rax
  __int64 v7; // rdi
  __int64 v8; // rdi
  __int64 v9; // r9
  __int64 v10; // rdi
  __int64 v11; // r9
  __int64 v13; // [rsp+38h] [rbp-28h]
  __int64 v14; // [rsp+40h] [rbp-20h]

  v4 = a2;
  v5 = a1;
  v13 = -6148914691236517206i64;
  v14 = -6148914691236517206i64;
  v6 = qword_96B40;
  if ( !qword_96B40 )
  {
    if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92CB0, 0i64, &qword_96B40) < 0 )
    {
      qword_96B40 = 1i64;
      goto LABEL_13;
    }
    v6 = qword_96B40;
  }
  if ( v6 >= 2 )
  {
    if ( v5 )
    {
      if ( !byte_96B49 )
      {
        byte_96B49 = 1;
        sub_1A2B6(1, (__int64)"[EB|#G:CA]\n", a3, a4);
        sub_1905F((__int64)"Start ConnectAll");
        v7 = (*(__int64 (**)(void))(qword_96B40 + 24))();
        sub_1905F((__int64)"End ConnectAll");
        if ( v7 < 0 )
          sub_1A2B6(1, (__int64)"[EB|`G:CS] %r @ G:CA\n", v7, a4);
      }
    }
    if ( v4 )
    {
      byte_93B98 = 1;
      sub_1A2B6(1, (__int64)"[EB|#G:CD]\n", a3, a4);
      sub_1905F((__int64)"Start ConnectDisplay");
      v8 = (*(__int64 (**)(void))(qword_96B40 + 8))();
      sub_1905F((__int64)"End ConnectDisplay");
      if ( v8 < 0 )
        sub_1A2B6(1, (__int64)"[EB|`G:CS] %r @ G:CD\n", v8, v9);
    }
  }
LABEL_13:
  v10 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_93610, 0i64, &qword_93BA0);
  if ( v10 < 0 )
  {
    qword_93BA0 = 1i64;
    v10 = 0i64;
  }
  v13 = 8i64;
  if ( (*(__int64 (__fastcall **)(const char *, int *, _QWORD))(qword_96CE0 + 72))("g", &dword_91FF4, 0i64) >= 0 )
  {
    dword_9230C = v14;
    if ( v14 < 0 )
      dword_9230C = v14 | 0x80000000;
  }
  sub_1A2B6(1, (__int64)"[EB|`G:CS] } %r\n", v10, v11);
  return v10;
}
// C33D: write access to const memory at 96B49 has been detected
// C3A1: write access to const memory at 93B98 has been detected
// C3F9: write access to const memory at 96B40 has been detected
// C435: write access to const memory at 93BA0 has been detected
// C4AA: write access to const memory at 9230C has been detected
// C4BA: write access to const memory at 9230C has been detected
// 91FF4: using guessed type int dword_91FF4;
// 9230C: using guessed type int dword_9230C;
// 92CB0: using guessed type __int64 qword_92CB0[2];
// 93610: using guessed type __int64 qword_93610[2];
// 93B98: using guessed type char byte_93B98;
// 93BA0: using guessed type __int64 qword_93BA0;
// 96B40: using guessed type __int64 qword_96B40;
// 96B49: using guessed type char byte_96B49;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000000C4E0) ----------------------------------------------------
__int64 __fastcall sub_C4E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 *a7)
{
  __int64 result; // rax
  unsigned __int64 v8; // rdi
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rbx
  int v27; // [rsp+50h] [rbp-C0h]
  int v28; // [rsp+98h] [rbp-78h]
  __int64 v30; // [rsp+B8h] [rbp-58h]

  v30 = -6148914691236517206i64;
  memset(&v27, 0, 0x48ui64);
  v28 = 0;
  if ( (_BYTE)a5 )
    return sub_CAE6(0i64, 0i64);
  v8 = sub_18D72();
  v11 = sub_C2C4(0, 1, v9, v10);
  result = sub_18D72() - v8;
  *a7 = result;
  if ( v11 >= 0 )
  {
    sub_1905F((__int64)"Start OpenBootGraphics");
    result = sub_B95F();
    if ( result >= 0 )
    {
      sub_1905F((__int64)"End OpenBootGraphics");
      return sub_CAE6(0i64, 0i64);
    }
  }
  return result;
}
// 9230C: using guessed type int dword_9230C;
// 93B68: using guessed type int dword_93B68;
// 93B6C: using guessed type int dword_93B6C;
// 93B88: using guessed type int dword_93B88;
// 93B90: using guessed type __int64 qword_93B90;
// 93BA0: using guessed type __int64 qword_93BA0;
// 93BA8: using guessed type int dword_93BA8;
// 96AA8: using guessed type __int64 qword_96AA8;

//----- (000000000000CAE6) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_CAE6(__int64 a1, _DWORD *a2)
{
  __int64 v2; // rsi
  signed __int64 result; // rax
  __int64 v4; // rax
  __int64 v5; // rcx
  _DWORD *v6; // rdi
  __int64 v7; // [rsp+40h] [rbp-40h]
  __int64 v8; // [rsp+48h] [rbp-38h]
  __int64 (__fastcall **v9)(_QWORD, __int64 *, int *, int *, int *, int *, int *); // [rsp+50h] [rbp-30h]
  __int64 v10; // [rsp+58h] [rbp-28h]
  __int64 v11; // [rsp+60h] [rbp-20h]
  int v12; // [rsp+6Ch] [rbp-14h]

  v2 = a1;
  v9 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = -1431655766;
  v8 = 4387501502266150026i64;
  v7 = 5528705028639616242i64;
  if ( a2 )
    *a2 = -1;
  if ( (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
         *(_QWORD *)(qword_96CD0 + 56),
         qword_92AD0,
         &v10) >= 0
    && (v4 = *(_QWORD *)(v10 + 24), (v5 = *(_QWORD *)(v4 + 24)) != 0) )
  {
    v6 = *(_DWORD **)(v4 + 8);
    dword_93B68 = v6[1];
    dword_93B6C = v6[2];
    qword_93B90 = v5;
    dword_93BAC = *(_DWORD *)(v4 + 32);
    result = sub_BAD6(v6);
    dword_93B88 = result;
    if ( !(_DWORD)result )
    {
      qword_93B90 = 0i64;
      return result;
    }
    dword_93BA8 = v6[8] * ((unsigned int)result >> 3);
  }
  else
  {
    result = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 (__fastcall ***)(_QWORD, __int64 *, int *, int *, int *, int *, int *)))(qword_96CD8 + 320))(
               qword_92CC0,
               0i64,
               &v9);
    if ( result < 0 || !v9 )
      return result;
    if ( (*v9)(v9, &qword_93B90, &dword_93BAC, &dword_93BA8, &dword_93B68, &dword_93B6C, &dword_93B88) < 0 )
    {
      qword_93B90 = 0i64;
      dword_93BA8 = 0;
      dword_93B68 = 0;
      dword_93B6C = 0;
      dword_93B88 = 0;
    }
  }
  v12 = 0;
  result = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(&v7, 0i64, &v11);
  if ( result >= 0 && *(_DWORD *)v11 >= (unsigned int)((char *)&loc_FFFF + 3) )
  {
    result = (*(__int64 (__fastcall **)(__int64, int *))(v11 + 48))(v11, &v12);
    if ( result < 0 )
      v12 = 0;
  }
  if ( v2 )
  {
    *(_QWORD *)(v2 + 48) = 0i64;
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
    *(_DWORD *)(v2 + 16) = 0;
    result = (unsigned __int8)v12;
    *(_BYTE *)(v2 + 20) = v12;
  }
  return result;
}
// CBFD: write access to const memory at 93B68 has been detected
// CC06: write access to const memory at 93B6C has been detected
// CC0C: write access to const memory at 93B90 has been detected
// CC16: write access to const memory at 93BAC has been detected
// CC24: write access to const memory at 93B88 has been detected
// CC39: write access to const memory at 93BA8 has been detected
// CCB8: write access to const memory at 93B90 has been detected
// CCC5: write access to const memory at 93BA8 has been detected
// CCCB: write access to const memory at 93B68 has been detected
// CCD1: write access to const memory at 93B6C has been detected
// CCD7: write access to const memory at 93B88 has been detected
// CCE2: write access to const memory at 93B90 has been detected
// 9230C: using guessed type int dword_9230C;
// 92AD0: using guessed type __int64 qword_92AD0[2];
// 92CC0: using guessed type __int64 qword_92CC0[2];
// 93B68: using guessed type int dword_93B68;
// 93B6C: using guessed type int dword_93B6C;
// 93B88: using guessed type int dword_93B88;
// 93B90: using guessed type __int64 qword_93B90;
// 93BA8: using guessed type int dword_93BA8;
// 93BAC: using guessed type int dword_93BAC;
// 93BB0: using guessed type int dword_93BB0;
// 96CD0: using guessed type __int64 qword_96CD0;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000CCF2) ----------------------------------------------------
__int64 __fastcall sub_CCF2(unsigned __int64 a1, __int64 a2, __int64 a3, char a4)
{
  char v4; // r14
  __int64 v5; // rsi
  __int64 v6; // r15
  unsigned __int64 v7; // r12
  __int64 result; // rax
  signed __int64 v9; // r9
  signed __int64 v10; // r12
  __int64 v11; // rbx
  _OWORD *v12; // rdi
  signed __int64 v13; // rdx

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  if ( a4 )
    result = (*(__int64 (__fastcall **)(signed __int64))(qword_96CD8 + 24))(31i64);
  else
    result = 0i64;
  if ( v6 )
  {
    v9 = (v7 >> 2) & 0xFFFFFFFFFFFFFFFi64;
    v10 = 4 * v7;
    v11 = 0i64;
    do
    {
      if ( v9 )
      {
        v12 = 0i64;
        v13 = v9;
        do
        {
          *v12 = *(_OWORD *)((char *)v12 + v5);
          ++v12;
          --v13;
        }
        while ( v13 );
      }
      ++v11;
      v5 += v10;
    }
    while ( v11 != v6 );
  }
  if ( v4 )
    result = (*(__int64 (__fastcall **)(__int64))(qword_96CD8 + 32))(result);
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000CDB1) ----------------------------------------------------
__int64 __fastcall sub_CDB1(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int v19; // [rsp+0h] [rbp-D0h]
  int v20; // [rsp+48h] [rbp-88h]
  __int64 v26; // [rsp+80h] [rbp-50h]

  v26 = a2;
  result = 0i64;
  memset(&v19, 0, 0x48ui64);
  v20 = 0;
  return result;
}

//----- (000000000000CFB6) ----------------------------------------------------
signed __int64 __fastcall sub_CFB6(__int64 a1)
{
  __int64 v1; // rsi
  int v2; // ebx
  __int64 v3; // rax
  int v4; // edi
  int v5; // er9
  int v6; // er8
  int v7; // ecx
  const char *v8; // rbx
  char *v9; // rcx
  signed __int64 result; // rax
  char *v11; // rsi
  unsigned __int64 v12; // rsi
  __int64 v13; // rax
  unsigned __int64 v14; // r8
  __int64 v15; // [rsp+28h] [rbp-38h]
  __int64 v16; // [rsp+30h] [rbp-30h]
  __int64 v17; // [rsp+38h] [rbp-28h]

  v1 = a1;
  v17 = -6148914691236517206i64;
  v15 = -6148914691236517206i64;
  *(_QWORD *)(a1 + 1240) = 0i64;
  v2 = 0;
  sub_CAE6(a1 + 1192, 0i64);
  v3 = *(_QWORD *)(v1 + 1240);
  if ( v3 )
  {
    v4 = *(_DWORD *)(v1 + 1196);
    v5 = *(_DWORD *)(v1 + 1200);
    v6 = *(_DWORD *)(v1 + 1204);
    v2 = *(_DWORD *)(v1 + 1208);
  }
  else
  {
    *(_QWORD *)(v1 + 1240) = 0i64;
    *(_QWORD *)(v1 + 1196) = 0i64;
    *(_QWORD *)(v1 + 1204) = 0i64;
    v6 = 0;
    v5 = 0;
    v4 = 0;
    LODWORD(v3) = 0;
  }
  v7 = (((unsigned __int8)qword_96AA8 & 0x20u) < 1ui64) + 1;
  *(_DWORD *)(v1 + 1192) = v7;
  *(_DWORD *)(v1 + 1048) = v3;
  *(_DWORD *)(v1 + 1056) = v4;
  *(_DWORD *)(v1 + 1060) = v5;
  *(_DWORD *)(v1 + 1064) = v6;
  *(_DWORD *)(v1 + 1068) = v2;
  *(_DWORD *)(v1 + 1052) = v7;
  if ( byte_96B48 )
    *(_BYTE *)(v1 + 6) |= 2u;
  v8 = "CircleSlash2X";
  if ( (unsigned int)&loc_40000 & (unsigned int)qword_96AA8 )
    v8 = "CircleSlashBlack2X";
  v9 = "CircleSlash";
  if ( (unsigned int)&loc_40000 & (unsigned int)qword_96AA8 )
    v9 = "CircleSlashBlack";
  if ( byte_96B48 )
    v9 = (char *)v8;
  v16 = -6148914691236517206i64;
  result = sub_4C13(v9, (__int64 **)&v16);
  if ( result >= 0 )
  {
    v17 = *(unsigned int *)(v16 + 64);
    v15 = v17;
    v11 = (char *)sub_17500(&v17, 0i64);
    if ( !v11 )
      sub_9CE0((__int64)"[EB|#STOP|`G:GMSI] ! @ MM:AKM %qd @ 'FICLUT\n", v17);
    sub_9B19("FailedCLUT", (unsigned int)v11, v17);
    sub_1B950(*(char **)(v16 + 56), v11, v17);
    v17 = *(unsigned int *)(v16 + 32) + 32i64;
    v15 = v17;
    v12 = sub_17500(&v15, 0i64);
    if ( !v12 )
      sub_9CE0((__int64)"[EB|#STOP|`G:GMSI] ! @ MM:AKM %qd @ 'FI\n", v15);
    sub_9B19("FailedImage", v12, v17);
    v13 = v16;
    *(_DWORD *)v12 = *(unsigned __int16 *)(v16 + 16);
    *(_DWORD *)(v12 + 4) = *(unsigned __int16 *)(v13 + 18);
    *(_DWORD *)(v12 + 8) = 0;
    v14 = *(unsigned int *)(v13 + 32);
    *(_DWORD *)(v12 + 12) = v14;
    result = (signed __int64)sub_1B950(*(char **)(v13 + 24), (char *)(v12 + 32), v14);
  }
  return result;
}
// 96AA8: using guessed type __int64 qword_96AA8;
// 96B48: using guessed type char byte_96B48;

//----- (000000000000D1B2) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_D1B2()
{
  __int64 result; // rax
  int v1; // [rsp+2Ch] [rbp-4h]

  v1 = -1431655766;
  result = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(
             qword_92B70,
             0i64,
             &qword_96B58);
  if ( result >= 0 )
  {
    result = (*(__int64 (__fastcall **)(__int64, int *, _QWORD, _QWORD))qword_96B58)(qword_96B58, &v1, 0i64, 0i64);
    if ( result >= 0 )
    {
      dword_93BB0 = v1;
      dword_93BB4 = 0;
      result = 0i64;
    }
  }
  return result;
}
// D1FE: write access to const memory at 93BB0 has been detected
// D204: write access to const memory at 93BB4 has been detected
// 92B70: using guessed type __int64 qword_92B70[2];
// 93BB0: using guessed type int dword_93BB0;
// 93BB4: using guessed type int dword_93BB4;
// 96B58: using guessed type __int64 qword_96B58;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000D212) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_D212()
{
  return 0i64;
}
// D23D: write access to const memory at 93BB0 has been detected
// 93BB0: using guessed type int dword_93BB0;
// 93BB4: using guessed type int dword_93BB4;
// 96B58: using guessed type __int64 qword_96B58;

//----- (000000000000D24B) ----------------------------------------------------
signed __int64 sub_D24B()
{
  const char *v0; // rax
  char *v1; // rcx
  signed __int64 result; // rax
  __int64 v3; // [rsp+28h] [rbp-18h]
  __int64 v4; // [rsp+30h] [rbp-10h]
  __int64 v5; // [rsp+38h] [rbp-8h]

  v3 = -6148914691236517206i64;
  v4 = -6148914691236517206i64;
  v5 = -6148914691236517206i64;
  v0 = "PanicDialog2X";
  if ( (unsigned int)&loc_40000 & (unsigned int)qword_96AA8 )
    v0 = "PanicDialogBlack2X";
  v1 = "PanicDialog";
  if ( (unsigned int)&loc_40000 & (unsigned int)qword_96AA8 )
    v1 = "PanicDialogBlack";
  if ( byte_96B48 )
    v1 = (char *)v0;
  result = sub_4E0C(v1, &v5, &v3, &v4);
  if ( result >= 0 )
  {
    sub_D31B(v5, v3 * v4);
    sub_B830(0i64, 0i64, 0i64, 0i64);
    sub_C267((unsigned __int64)-v3 >> 1, (unsigned __int64)-v4 >> 1, v3, v4, v5);
    result = sub_136C5(v5);
  }
  return result;
}
// 93B68: using guessed type int dword_93B68;
// 93B6C: using guessed type int dword_93B6C;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96B48: using guessed type char byte_96B48;

//----- (000000000000D31B) ----------------------------------------------------
void __fastcall sub_D31B(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  int v3; // er8
  int v4; // er10
  int v5; // ebx

  if ( a1 && a2 )
  {
    v2 = 0i64;
    do
    {
      v3 = *(unsigned __int8 *)(a1 + 4 * v2 + 3);
      v4 = v3 ^ 0xFF;
      *(_BYTE *)(a1 + 4 * v2 + 2) = (unsigned __int16)(v3 * *(unsigned __int8 *)(a1 + 4 * v2 + 2)
                                                     + (*(unsigned __int8 *)(a1 + 4 * v2 + 3) ^ 0xFF)
                                                     * BYTE2(dword_92308)) >> 8;
      *(_BYTE *)(a1 + 4 * v2 + 1) = (unsigned __int16)(v3 * *(unsigned __int8 *)(a1 + 4 * v2 + 1)
                                                     + v4 * BYTE1(dword_92308)) >> 8;
      v5 = v3 * *(unsigned __int8 *)(a1 + 4 * v2) + v4 * (unsigned __int8)dword_92308;
      *(_BYTE *)(a1 + 4 * v2) = BYTE1(v5);
      *(_BYTE *)(a1 + 4 * v2++ + 3) = -1;
    }
    while ( a2 != v2 );
  }
}
// 92308: using guessed type int dword_92308;

//----- (000000000000D39E) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_D39E()
{
  __int64 v0; // rax
  __int64 v2; // [rsp+28h] [rbp-28h]
  __int16 v3; // [rsp+32h] [rbp-1Eh]
  __int16 v4; // [rsp+34h] [rbp-1Ch]
  unsigned __int8 v5; // [rsp+37h] [rbp-19h]

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v2 = 1i64;
  v0 = (*(__int64 (__fastcall **)(const char *, int *, _QWORD))(qword_96CE0 + 72))("U", &dword_91FF4, 0i64);
  if ( v0 >= 0 )
  {
    LOBYTE(v0) = v5;
    if ( v5 )
    {
      v2 = 2i64;
      (*(void (__fastcall **)(const char *, __int64 *, _QWORD, __int64 *, __int16 *, signed __int64))(qword_96CE0 + 72))(
        "A",
        qword_92360,
        0i64,
        &v2,
        &v3,
        2i64);
      v2 = 2i64;
      LOBYTE(v0) = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, __int64 *, __int16 *, signed __int64))(qword_96CE0 + 72))(
                     "D",
                     qword_92360,
                     0i64,
                     &v2,
                     &v4,
                     2i64);
      if ( v5 >= 2u )
        byte_96B48 = 1;
    }
  }
  return v0;
}
// D453: write access to const memory at 96B48 has been detected
// 91FF4: using guessed type int dword_91FF4;
// 92360: using guessed type __int64 qword_92360[2];
// 96B48: using guessed type char byte_96B48;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000000D463) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 sub_D463()
{
  const char *v0; // rdx
  char *v1; // rcx
  signed __int64 v2; // rax
  signed __int64 result; // rax

  v0 = "NetBoot";
  if ( (unsigned int)&loc_40000 & (unsigned int)qword_96AA8 )
    v0 = "NetBootBlack";
  v1 = "NetBoot2X";
  if ( (unsigned int)&loc_40000 & (unsigned int)qword_96AA8 )
    v1 = "NetBootBlack2X";
  v2 = 400i64;
  if ( !byte_96B48 )
    v2 = 200i64;
  if ( !byte_96B48 )
    v1 = (char *)v0;
  qword_93B80 = v2;
  result = sub_4E0C(v1, &qword_93BB8, &qword_93B70, &qword_93B78);
  if ( result >= 0 )
  {
    sub_D31B(0i64, 0i64);
    qword_93B78 = (unsigned __int64)(0 * (unsigned __int128)0xE38E38E38E38E38Fui64 >> 64) >> 4;
    qword_93BC0 = 0i64;
    sub_C267(0i64, 0i64, 0i64, 0i64, 0i64);
    result = (*(__int64 (__fastcall **)(signed __int64, signed __int64, __int64 (*)(), _QWORD, __int64 *))(qword_96CD8 + 80))(
               2147484160i64,
               16i64,
               sub_D5CB,
               0i64,
               &qword_96B50);
    if ( result >= 0 )
    {
      result = (*(__int64 (__fastcall **)(__int64, signed __int64, signed __int64))(qword_96CD8 + 88))(
                 qword_96B50,
                 1i64,
                 1000000i64);
      if ( result < 0 )
      {
        result = (*(__int64 (__fastcall **)(__int64))(qword_96CD8 + 112))(qword_96B50);
        qword_96B50 = 0i64;
      }
    }
  }
  return result;
}
// D4B3: write access to const memory at 93B80 has been detected
// D510: write access to const memory at 93B78 has been detected
// D53D: write access to const memory at 93BC0 has been detected
// D5BA: write access to const memory at 96B50 has been detected
// 93B70: using guessed type __int64 qword_93B70;
// 93B78: using guessed type __int64 qword_93B78;
// 93B80: using guessed type __int64 qword_93B80;
// 93BB8: using guessed type __int64 qword_93BB8;
// 93BC0: using guessed type __int64 qword_93BC0;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96B48: using guessed type char byte_96B48;
// 96B50: using guessed type __int64 qword_96B50;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000D5CB) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_D5CB()
{
  qword_93BC0 = 1i64;
  return sub_C267(0i64, 0i64, 0i64, 0i64, 0i64);
}
// D615: write access to const memory at 93BC0 has been detected
// 93BC0: using guessed type __int64 qword_93BC0;

//----- (000000000000D642) ----------------------------------------------------
_QWORD *__fastcall sub_D642(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rsi
  __int64 v5; // rdi
  __int64 v6; // rbx
  __int64 v7; // rax

  v4 = (_QWORD *)a3;
  v5 = a2;
  v6 = a1;
  sub_1A2B6(1, (__int64)"[EB|#LD:ODPS]\n", a3, a4);
  sub_F1B0(v4, 48i64);
  *v4 = v6;
  v7 = sub_23CF5(v5);
  v4[2] = v7;
  return sub_1368E(v7);
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);

//----- (000000000000D693) ----------------------------------------------------
signed __int64 __fastcall sub_D693(__int64 a1, __int64 *a2)
{
  __int64 *v2; // r14
  __int64 v3; // rsi
  signed __int64 v4; // rdi
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v10; // [rsp+28h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  v4 = -9223372036854775799i64;
  v10 = 208i64;
  v5 = sub_1364F(208i64);
  if ( v5 )
  {
    v6 = v5;
    v7 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *, __int64))(v3 + 64))(v3, qword_92AC0, &v10, v5);
    if ( v7 == -9223372036854775803i64 )
    {
      sub_136C5(v6);
      v8 = sub_1364F(v10);
      if ( !v8 )
        return v4;
      v6 = v8;
      v7 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *, __int64))(v3 + 64))(v3, qword_92AC0, &v10, v8);
    }
    v4 = v7;
    if ( v7 < 0 )
    {
      sub_136C5(v6);
    }
    else
    {
      *v2 = v6;
      v4 = 0i64;
    }
  }
  return v4;
}
// 92AC0: using guessed type __int64 qword_92AC0[2];

//----- (000000000000D739) ----------------------------------------------------
signed __int64 __fastcall sub_D739(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5, __int64 *a6)
{
  __int64 v6; // rdi
  __int64 v7; // rbx
  __int64 v8; // r14
  __int64 v9; // rsi
  __int64 v10; // r8
  __int64 v11; // r9
  signed __int64 v12; // r15
  char v13; // cl
  char v14; // cl
  __int64 v15; // rbx
  __int64 v16; // rax
  _WORD *v17; // rax
  __int16 v18; // cx
  __int16 *v19; // rdx
  __int64 v20; // rdx
  char v21; // cl
  __int64 v22; // rsi
  char *v23; // rax
  __int64 v25; // [rsp+30h] [rbp-60h]
  __int64 v26; // [rsp+38h] [rbp-58h]
  __int64 v27; // [rsp+40h] [rbp-50h]
  __int64 v28; // [rsp+48h] [rbp-48h]
  __int64 v29; // [rsp+50h] [rbp-40h]
  __int64 v30; // [rsp+58h] [rbp-38h]
  __int64 v31; // [rsp+60h] [rbp-30h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v31 = -6148914691236517206i64;
  v25 = -6148914691236517206i64;
  v26 = -6148914691236517206i64;
  v27 = -6148914691236517206i64;
  v28 = -6148914691236517206i64;
  v29 = -6148914691236517206i64;
  v30 = -6148914691236517206i64;
  sub_1A2B6(1, (__int64)"[EB|`LD:LF] FIO: %d, DIR: %d, P: %E, DP: %d\n", a1 != 0, a2 != 0);
  v12 = -9223372036854775805i64;
  if ( v9 || !v6 )
  {
    if ( v6 )
    {
      sub_D642(v9, v6, (__int64)&v25, v11);
      v15 = 0i64;
      goto LABEL_22;
    }
    v22 = sub_D97B(v9, v8, v7, (__int64)&v25);
    v15 = 0i64;
  }
  else
  {
    if ( !v8 )
      return v12;
    while ( 1 )
    {
      v13 = *(_BYTE *)v6 & 0x7F;
      if ( v13 == 127 )
      {
        v14 = *(_BYTE *)(v6 + 1);
        if ( v14 == -1 )
        {
          sub_1A2B6(1, (__int64)"[EB|`LD:LF] ! @ 'FP?\n", v10, v11);
          return v12;
        }
      }
      else
      {
        if ( v13 == 4 )
          break;
        v14 = *(_BYTE *)(v6 + 1);
      }
      if ( v14 == 4 )
        break;
      v6 += *(unsigned __int16 *)(v6 + 2);
    }
    v16 = sub_23D3E(v6);
    v31 = v16;
    v17 = (_WORD *)sub_1364F(v16);
    if ( !v17 )
      return -9223372036854775799i64;
    v15 = (__int64)v17;
    if ( (*(_BYTE *)v6 & 0x7F) == 4 )
    {
      do
      {
        if ( *(_BYTE *)(v6 + 1) != 4 )
          break;
        v18 = *(_WORD *)(v6 + 4);
        if ( v18 )
        {
          v19 = (__int16 *)(v6 + 6);
          do
          {
            *v17 = v18;
            ++v17;
            v18 = *v19;
            ++v19;
          }
          while ( v18 );
        }
        v20 = *(unsigned __int16 *)(v6 + 2);
        v21 = *(_BYTE *)(v6 + v20);
        v6 += v20;
      }
      while ( (v21 & 0x7F) == 4 );
    }
    *v17 = 0;
    v22 = sub_D97B(0i64, v8, v15, (__int64)&v25);
    sub_136C5(v15);
  }
  if ( v22 < 0 )
    return v22;
LABEL_22:
  v22 = sub_DAB5((__int64)&v25, &v31);
  if ( v22 >= 0 && v31 )
  {
    v23 = (char *)sub_1364F(v31);
    if ( v23 )
    {
      v15 = (__int64)v23;
      v22 = sub_DBA9(&v25, (unsigned __int64 *)&v31, v23);
      goto LABEL_26;
    }
    sub_DE03(&v25);
    return -9223372036854775799i64;
  }
LABEL_26:
  sub_DE03(&v25);
  if ( v22 < 0 )
  {
    if ( v15 )
      sub_136C5(v15);
  }
  else
  {
    *a5 = v31;
    *a6 = v15;
  }
  return v22;
}

//----- (000000000000D97B) ----------------------------------------------------
__int64 __fastcall sub_D97B(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // r15
  char *v5; // rdi
  __int64 v6; // rbx
  __int64 v7; // rax
  unsigned __int64 v8; // r14
  signed __int64 v9; // r12
  __int64 v10; // rsi
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 v13; // rsi
  __int64 v14; // rbx
  __int64 v16; // [rsp+28h] [rbp-38h]

  v4 = (_QWORD *)a4;
  v5 = (char *)a3;
  v6 = a1;
  v16 = -6148914691236517206i64;
  if ( a1 )
  {
    sub_1A2B6(1, (__int64)"[EB|#LD:OLFS] (%E)\n", a3, a4);
    sub_F1B0(v4, 48i64);
    *v4 = v6;
    if ( v5 )
    {
      v7 = sub_23741(v5);
      v8 = 2 * v7 + 2;
      v9 = 2 * v7 + 6;
      v10 = 2 * v7 + 10;
      v11 = sub_1364F(v10);
      sub_F1B0(v11, v10);
      *(_WORD *)v11 = 1028;
      *(_WORD *)(v11 + 2) = v9;
      sub_1B950(v5, (char *)(v11 + 4), v8);
      *(_DWORD *)(v11 + *(unsigned __int16 *)(v11 + 2)) = (_DWORD)&byte_4FF7F;
    }
    else
    {
      v11 = 0i64;
    }
    v4[2] = v11;
  }
  else
  {
    v12 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64, signed __int64, _QWORD))(a2 + 8))(
            a2,
            &v16,
            a3,
            1i64,
            0i64);
    if ( v12 < 0 )
    {
      v14 = v12;
      sub_1A2B6(1, (__int64)"[EB|`LD:OFS] %r @ OPEN (%E)\n", v12, (__int64)v5);
      return v14;
    }
    v13 = v16;
    sub_F1B0(v4, 48i64);
    v4[1] = v13;
  }
  return 0i64;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 4FF7F: using guessed type char byte_4FF7F;

//----- (000000000000DAB5) ----------------------------------------------------
signed __int64 __fastcall sub_DAB5(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rsi
  __int64 (__fastcall **v3)(_QWORD, _QWORD, _QWORD, signed __int64, _QWORD); // rax
  __int64 v4; // rdx
  __int64 v5; // rax
  __int64 *v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // r9
  __int64 v10; // rcx
  signed __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // [rsp+30h] [rbp-20h]

  v2 = a2;
  v13 = -6148914691236517206i64;
  v3 = *(__int64 (__fastcall ***)(_QWORD, _QWORD, _QWORD, signed __int64, _QWORD))a1;
  if ( *(_QWORD *)a1 )
  {
    v4 = *(_QWORD *)(a1 + 40);
    if ( v4 )
    {
      if ( v2 )
        *v2 = v4;
      return 0i64;
    }
    *(_QWORD *)(a1 + 40) = 0i64;
    v6 = (__int64 *)(a1 + 40);
    v7 = (*v3)(v3, *(_QWORD *)(a1 + 16), 0i64, a1 + 40, 0i64);
    if ( v7 != -9223372036854775803i64 )
    {
      sub_1A2B6(1, (__int64)"[EB|`LD:GSS] %r @ S.FIO.LF\n", v7, v8);
      return v7;
    }
    if ( !v2 )
      return 0i64;
    v5 = *v6;
    goto LABEL_11;
  }
  if ( *(_QWORD *)(a1 + 24) )
  {
    if ( a2 )
    {
      v5 = *(_QWORD *)(a1 + 40);
LABEL_11:
      *v2 = v5;
      return 0i64;
    }
  }
  else
  {
    v7 = -9223372036854775806i64;
    v10 = *(_QWORD *)(a1 + 8);
    if ( !v10 )
      return v7;
    v11 = sub_D693(v10, &v13);
    if ( v11 < 0 )
      return v11;
    v12 = v13;
    if ( !v13 )
      return -9223372036854775799i64;
    if ( v2 )
      *v2 = *(_QWORD *)(v13 + 8);
    sub_136C5(v12);
  }
  return 0i64;
}

//----- (000000000000DBA9) ----------------------------------------------------
signed __int64 __fastcall sub_DBA9(_QWORD *a1, unsigned __int64 *a2, char *a3)
{
  char *v3; // r15
  unsigned __int64 *v4; // r14
  _QWORD *v5; // r13
  unsigned __int64 v6; // rdi
  signed __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rbx
  __int64 v10; // rax
  unsigned __int64 v11; // rbx
  __int64 v12; // rcx
  __int64 v13; // rax
  unsigned __int64 v14; // rsi
  __int64 v15; // rsi
  __int64 v16; // rcx
  signed __int64 v17; // rax
  __int64 v18; // rax
  unsigned __int64 v19; // rbx
  __int64 v20; // rcx
  signed __int64 v21; // rax
  __int64 v23; // rax
  __int64 v24; // [rsp+30h] [rbp-40h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *a2;
  v24 = -6148914691236517206i64;
  if ( !*a1 )
  {
    v12 = a1[3];
    if ( v12 )
    {
      v13 = v5[4];
      v14 = v5[5] - v13;
      v24 = v14;
      if ( v6 <= v14 )
        v14 = v6;
      if ( v14 )
      {
        sub_1B950((char *)(v13 + v12), a3, v14);
        v5[4] += v14;
      }
      *v4 = v14;
      return 0i64;
    }
    v16 = v5[1];
    if ( !v16 )
      return -9223372036854775806i64;
    if ( v6 )
    {
      v17 = 0x100000i64;
      if ( v6 <= 0x100000 )
        v17 = v6;
      v24 = v17;
      v15 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v16 + 32))(v16, &v24);
      v18 = v24;
      if ( v24 )
      {
        v19 = 0i64;
        do
        {
          v19 += v18;
          if ( v15 < 0 )
            break;
          v6 -= v18;
          if ( !v6 )
            break;
          v3 += v18;
          v20 = v5[1];
          v21 = 0x100000i64;
          if ( v6 <= 0x100000 )
            v21 = v6;
          v24 = v21;
          v15 = (*(__int64 (__fastcall **)(__int64, __int64 *, char *))(v20 + 32))(v20, &v24, v3);
          v18 = v24;
        }
        while ( v24 );
        goto LABEL_43;
      }
    }
    else
    {
      v15 = 0i64;
    }
    v19 = 0i64;
LABEL_43:
    *v4 = v19;
    return v15;
  }
  v7 = sub_DAB5((__int64)a1, &v24);
  if ( v7 >= 0 )
  {
    v8 = v5[3];
    if ( v8 )
    {
      v9 = v24;
      v10 = v5[4];
      goto LABEL_5;
    }
    v10 = v5[4];
    v9 = v24;
    if ( v10 || v6 != v24 )
    {
LABEL_5:
      v11 = v9 - v10;
      v24 = v11;
      if ( v6 <= v11 )
        v11 = v6;
      if ( v11 )
      {
        if ( !v8 )
        {
          v24 = v5[5];
          v23 = sub_1364F(v24 + 4096);
          v5[3] = v23;
          if ( !v3 )
            return -9223372036854775799i64;
          v15 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64 *, __int64))*v5)(*v5, v5[2], 0i64, &v24, v23);
          if ( v24 != v5[5] )
            sub_9CE0((__int64)"[EB|#STOP|`LD:RS] 'SZ %qd != %qd\n");
          v8 = v5[3];
          if ( v15 < 0 )
          {
            sub_136C5(v8);
            v5[3] = 0i64;
            return v15;
          }
        }
        sub_1B950((char *)(v5[4] + v8), v3, v11);
        v5[4] += v11;
        *v4 = v11;
      }
      else
      {
        *v4 = 0i64;
      }
      return 0i64;
    }
    v7 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, unsigned __int64 *, char *))*v5)(*v5, v5[2], 0i64, v4, v3);
  }
  return v7;
}

//----- (000000000000DE03) ----------------------------------------------------
__int64 __fastcall sub_DE03(_QWORD *a1)
{
  _QWORD *v1; // rsi
  __int64 result; // rax
  __int64 v3; // rcx
  __int64 v4; // rcx

  v1 = a1;
  result = 0i64;
  a1[5] = 0i64;
  a1[4] = 0i64;
  v3 = a1[2];
  if ( v3 )
  {
    result = sub_136C5(v3);
    v4 = v1[3];
    if ( v4 )
      result = sub_136C5(v4);
  }
  else if ( !v1[3] )
  {
    result = (*(__int64 (**)(void))(v1[1] + 16i64))();
  }
  return result;
}

//----- (000000000000DE57) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_DE57(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 *v3; // r15
  __int64 v4; // r14
  __int64 v5; // rbx
  __int64 v6; // r9
  const char *v7; // rdi
  __int64 v8; // rcx
  int v9; // eax
  __int64 v10; // r8
  char v11; // r13
  __int64 v12; // r9
  __int64 v13; // rsi
  __int64 v14; // rax
  __int64 v15; // r9
  const char *v16; // rdx
  const __int16 *v17; // rsi
  __int64 v18; // r9
  __int64 v19; // r9
  __int64 v20; // r9
  signed __int64 v21; // rax
  char v23; // [rsp+30h] [rbp-870h]
  __int64 v24; // [rsp+830h] [rbp-70h]
  __int64 v25; // [rsp+838h] [rbp-68h]
  __int64 v26; // [rsp+840h] [rbp-60h]
  __int64 v27; // [rsp+848h] [rbp-58h]
  __int64 v28; // [rsp+850h] [rbp-50h]
  __int64 v29; // [rsp+858h] [rbp-48h]
  __int64 v30; // [rsp+860h] [rbp-40h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  LOBYTE(a2) = -86;
  sub_F180(&v23, a2, 0x800ui64);
  sub_F1B0(&v23, 2048i64);
  if ( byte_96AD0 )
  {
    v7 = "S";
    sub_1A2B6(1, (__int64)"[EB|`LD:LKC] PM -> (%S)\n", (__int64)"S", v6);
    if ( byte_96AD0 )
      goto LABEL_24;
  }
  else
  {
    v7 = "S";
  }
  if ( qword_96B68 )
  {
    sub_1A2B6(1, (__int64)"[EB|`LD:LKC] CFG -> (%E)\n", qword_96B68, v6);
    v8 = qword_96B68;
LABEL_32:
    v13 = sub_E217(v8, v5, v4, v3);
    goto LABEL_34;
  }
  v9 = qword_96AA8;
  if ( _bittest(&v9, 0x18u) )
  {
    v7 = "S";
    sub_1A2B6(1, (__int64)"[EB|`LD:LKC] TB -> (%S)\n", (__int64)"S", v6);
    v9 = qword_96AA8;
  }
  if ( _bittest(&v9, 0x15u) )
  {
    v7 = "S";
    sub_1A2B6(1, (__int64)"[EB|`LD:LKC] SB -> (%S)\n", (__int64)"S", v6);
    v11 = 0;
    goto LABEL_19;
  }
  v10 = qword_96B88;
  v11 = 1;
  if ( !qword_96B88 )
    goto LABEL_19;
  if ( v9 & 4 )
  {
    if ( !sub_10E81(qword_96B88) )
      goto LABEL_19;
    v10 = qword_96B88;
  }
  sub_1A2B6(1, (__int64)"[EB|`LD:LKC] NV -> (%E)\n", v10, v6);
  v24 = -6148914691236517206i64;
  v25 = -6148914691236517206i64;
  v26 = -6148914691236517206i64;
  v27 = -6148914691236517206i64;
  v28 = -6148914691236517206i64;
  v29 = -6148914691236517206i64;
  sub_D642(v5, qword_96B88, (__int64)&v24, v12);
  v30 = sub_E89C(&v24, v3);
  if ( qword_96B60 )
    sub_136C5(qword_96B60);
  v13 = 0i64;
  qword_96B60 = (__int64)sub_FB02(qword_96B88, 0);
  sub_DE03(&v24);
  if ( v30 )
  {
LABEL_19:
    if ( qword_96AA8 & 4 )
    {
      if ( v11 )
      {
        sub_1A2B6(1, (__int64)"[EB|`LD:LKC] DF -> (%S)\n", (__int64)"x", v6);
        v14 = sub_E217((__int64)"x", v5, v4, v3);
        if ( v14 )
        {
          sub_1A2B6(1, (__int64)"[EB|`LD:LKC] %r @ LD:LKCFFP %S\n", v14, (__int64)"x");
          v16 = "[EB|`LD:LKC] DF -> (%S)\n";
          v17 = L"x86_64\\kernelcache";
          goto LABEL_31;
        }
        goto LABEL_33;
      }
      sub_1A2B6(1, (__int64)"[EB|`LD:LKC] 'BMN+SB\n", v10, v6);
      sub_15A8();
    }
LABEL_24:
    if ( !(qword_96AA8 & 0x20000)
      || (sub_22ED4((__int64)&v23, 1024i64, (__int64)"%", v7),
          sub_1A2B6(1, (__int64)"[EB|`LD:LKC] BM:R -> (%S)\n", (__int64)&v23, v18),
          sub_E217((__int64)&v23, v5, v4, v3)) )
    {
      if ( !qword_96AC0
        || (sub_22ED4((__int64)&v23, 1024i64, (__int64)L"%S.%S", v7, qword_96AC0),
            sub_1A2B6(1, (__int64)"[EB|`LD:LKC] SFX -> (%S)\n", (__int64)&v23, v19),
            sub_E217((__int64)&v23, v5, v4, v3)) )
      {
        sub_22ED4((__int64)&v23, 1024i64, (__int64)L"%S.development", v7);
        sub_1A2B6(1, (__int64)"[EB|`LD:LKC] BPDK -> (%S)\n", (__int64)&v23, v20);
        v21 = sub_E217((__int64)&v23, v5, v4, v3);
        if ( v21 )
        {
          v13 = v21;
          if ( qword_96AA8 & 0x20000 )
            goto LABEL_34;
          v17 = (const __int16 *)&v23;
          sub_22ED4((__int64)&v23, 1024i64, (__int64)"%", v7);
          v16 = "[EB|`LD:LKC] BPDK,!R -> (%S)\n";
LABEL_31:
          sub_1A2B6(1, (__int64)v16, (__int64)v17, v15);
          v8 = (__int64)v17;
          goto LABEL_32;
        }
      }
    }
LABEL_33:
    v13 = 0i64;
  }
LABEL_34:
  sub_1A2B6(1, (__int64)"[EB|`LD:LKC] } %r\n", v13, v6);
  return v13;
}
// DFDB: write access to const memory at 96B60 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 40C9C: using guessed type __int16 aX8664Kernelcac[19];
// 40CC8: using guessed type __int16 aSS[6];
// 40CD4: using guessed type __int16 aSDevelopment[15];
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AC0: using guessed type __int64 qword_96AC0;
// 96AD0: using guessed type char byte_96AD0;
// 96B60: using guessed type __int64 qword_96B60;
// 96B68: using guessed type __int64 qword_96B68;
// 96B88: using guessed type __int64 qword_96B88;

//----- (000000000000E217) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_E217(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 *v4; // r14
  __int64 v5; // rbx
  __int16 *v6; // r15
  int v7; // eax
  signed __int64 v8; // rax
  __int64 v9; // rdi
  __int64 v10; // r12
  __int64 v11; // rax
  __int64 v12; // r9
  const char *v13; // rdx
  __int64 v14; // rsi
  __int64 v15; // rdi
  __int64 v16; // r8
  __int64 v17; // r9
  signed __int64 v18; // rdi
  __int64 v19; // rax
  _WORD *v20; // rax
  __int64 v22; // [rsp+30h] [rbp-70h]
  __int64 v23; // [rsp+38h] [rbp-68h]
  __int64 v24; // [rsp+40h] [rbp-60h]
  __int64 v25; // [rsp+48h] [rbp-58h]
  __int64 v26; // [rsp+50h] [rbp-50h]
  __int64 v27; // [rsp+58h] [rbp-48h]
  __int64 v28; // [rsp+60h] [rbp-40h]
  __int64 v29; // [rsp+68h] [rbp-38h]

  v4 = a4;
  v5 = a3;
  v6 = (__int16 *)a1;
  v22 = -6148914691236517206i64;
  v23 = -6148914691236517206i64;
  v24 = -6148914691236517206i64;
  v25 = -6148914691236517206i64;
  v26 = -6148914691236517206i64;
  v27 = -6148914691236517206i64;
  v28 = 0i64;
  v29 = -6148914691236517206i64;
  v7 = qword_96AA8;
  if ( _bittest(&v7, 0x15u) )
  {
    v8 = sub_D739(0i64, a3, a1, 0i64, &v28, &v29);
    if ( v8 >= 0 )
    {
      v9 = v29;
      v10 = v28;
      sub_F1B0(&v22, 48i64);
      v25 = v9;
      v26 = 0i64;
      v27 = v10;
      v11 = sub_1202((__int64)v6, v5, v9, v10);
      if ( !v11 )
        goto LABEL_12;
      v13 = "[EB|`LD:LKCFFP] %r @ SB:SBVK\n";
LABEL_11:
      sub_1A2B6(1, (__int64)v13, v11, v12);
      sub_5ABA(1);
      goto LABEL_12;
    }
    return v8;
  }
  if ( _bittest(&v7, 0x18u) )
  {
    v8 = sub_D739(0i64, a3, a1, 0i64, &v28, &v29);
    if ( v8 >= 0 )
    {
      v14 = v29;
      v15 = v28;
      sub_F1B0(&v22, 48i64);
      v25 = v14;
      v26 = 0i64;
      v27 = v15;
      v11 = sub_118F1(v14, v15, v16, v17);
      if ( !v11 )
        goto LABEL_12;
      v13 = "[EB|`LD:LKCFFP] %r @ TB:TBVK\n";
      goto LABEL_11;
    }
    return v8;
  }
  v8 = sub_D97B(a2, a3, a1, (__int64)&v22);
  if ( v8 < 0 )
    return v8;
LABEL_12:
  v18 = sub_E89C(&v22, v4);
  if ( v18 >= 0 )
  {
    if ( qword_96B60 )
      sub_136C5(qword_96B60);
    v19 = sub_23741(v6);
    v20 = (_WORD *)sub_1364F(2 * v19 + 2);
    qword_96B60 = (__int64)v20;
    if ( v20 )
      sub_2370D(v20, v6);
  }
  sub_DE03(&v22);
  return v18;
}
// E3C6: write access to const memory at 96B60 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 96AA8: using guessed type __int64 qword_96AA8;
// 96B60: using guessed type __int64 qword_96B60;

//----- (000000000000E3FD) ----------------------------------------------------
__int64 __fastcall sub_E3FD(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 v5; // rax
  signed __int64 v6; // rax
  char *v7; // rdi
  __int64 v9; // [rsp+28h] [rbp-48h]
  __int64 v10; // [rsp+30h] [rbp-40h]
  __int64 v11; // [rsp+38h] [rbp-38h]
  __int64 v12; // [rsp+40h] [rbp-30h]
  __int64 v13; // [rsp+48h] [rbp-28h]
  __int64 v14; // [rsp+50h] [rbp-20h]
  __int64 v15; // [rsp+58h] [rbp-18h]

  v15 = -6148914691236517206i64;
  v9 = -6148914691236517206i64;
  v10 = -6148914691236517206i64;
  v11 = -6148914691236517206i64;
  v12 = -6148914691236517206i64;
  v13 = -6148914691236517206i64;
  v14 = -6148914691236517206i64;
  if ( qword_96B80 || qword_96B78 )
  {
    if ( a1 )
    {
      if ( qword_96B80 )
      {
        sub_D642(a1, qword_96B80, (__int64)&v9, a4);
LABEL_8:
        v6 = sub_E523(&v9, &v15, 0i64);
        if ( v6 < 0 )
        {
          v4 = v6;
        }
        else
        {
          v7 = (char *)sub_17500(&v15, 0i64);
          if ( !v7 )
            sub_9CE0((__int64)"[EB|#STOP|`LD:LRD] ! @ MM:AKM %qd @ 'TS\n", v15);
          v4 = sub_DBA9(&v9, (unsigned __int64 *)&v15, v7);
          if ( v4 >= 0 )
            sub_9B19("RAMDisk", (unsigned int)v7, v15);
        }
        sub_DE03(&v9);
        goto LABEL_16;
      }
      v4 = -9223372036854775805i64;
    }
    else
    {
      v5 = sub_D97B(0i64, a2, qword_96B78, (__int64)&v9);
      if ( v5 >= 0 )
        goto LABEL_8;
      v4 = v5;
    }
LABEL_16:
    sub_1A2B6(1, (__int64)"[EB|`LD:LRD] } %r\n", v4, a4);
    return v4;
  }
  return 0i64;
}
// 96B78: using guessed type __int64 qword_96B78;
// 96B80: using guessed type __int64 qword_96B80;

//----- (000000000000E523) ----------------------------------------------------
signed __int64 __fastcall sub_E523(_QWORD *a1, __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v3; // r14
  __int64 *v4; // r15
  _QWORD *v5; // rsi
  signed __int64 v6; // rax
  signed __int64 v7; // rbx
  _QWORD *v8; // rdi
  signed __int64 v9; // r15
  signed __int64 v10; // r13
  __int64 v11; // r14
  unsigned __int32 v12; // er12
  unsigned __int64 i; // rsi
  unsigned __int32 v14; // eax
  int v15; // ebx
  __int64 v17; // [rsp+28h] [rbp-A8h]
  __int64 v18; // [rsp+30h] [rbp-A0h]
  __int64 v19; // [rsp+38h] [rbp-98h]
  int v20; // [rsp+40h] [rbp-90h]
  __int64 v21; // [rsp+48h] [rbp-88h]
  __int64 v22; // [rsp+50h] [rbp-80h]
  __int64 v23; // [rsp+58h] [rbp-78h]
  unsigned __int64 *v24; // [rsp+60h] [rbp-70h]
  __int64 *v25; // [rsp+68h] [rbp-68h]
  unsigned __int64 v26; // [rsp+70h] [rbp-60h]
  unsigned __int64 v27; // [rsp+78h] [rbp-58h]
  unsigned __int64 v28; // [rsp+80h] [rbp-50h]
  int v29; // [rsp+88h] [rbp-48h]
  unsigned int v30; // [rsp+90h] [rbp-40h]
  int v31; // [rsp+94h] [rbp-3Ch]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v21 = -6148914691236517206i64;
  v22 = -6148914691236517206i64;
  v28 = 0i64;
  v27 = 0i64;
  v29 = 0;
  v26 = 8i64;
  v6 = sub_DBA9(a1, &v26, (char *)&v22);
  if ( v6 < 0 )
    goto LABEL_39;
  v7 = -9223372036854775807i64;
  if ( v26 < 8 )
    return v7;
  if ( (_DWORD)v22 == -1095041334 )
  {
    v8 = v5;
    v24 = v3;
    v25 = v4;
    v9 = _byteswap_ulong(HIDWORD(v22));
    v10 = 0i64;
    v23 = 1i64;
    goto LABEL_7;
  }
  if ( (_DWORD)v22 == -889275714 )
  {
    v8 = v5;
    v24 = v3;
    v25 = v4;
    v9 = HIDWORD(v22);
    v23 = 0i64;
    v10 = 0i64;
LABEL_7:
    v11 = 0i64;
    v12 = 0;
    v30 = 0;
    v31 = 0;
    goto LABEL_8;
  }
  v17 = -6148914691236517206i64;
  v18 = -6148914691236517206i64;
  v19 = -6148914691236517206i64;
  v20 = -1431655766;
  v6 = sub_F11F((__int64)v5, 0i64);
  if ( v6 < 0 )
    goto LABEL_39;
  v26 = 28i64;
  v6 = sub_DBA9(v5, &v26, (char *)&v17);
  if ( v6 < 0 )
    goto LABEL_39;
  if ( v26 < 0x1C )
    return v7;
  v6 = sub_F11F((__int64)v5, 0i64);
  if ( v6 < 0 )
    goto LABEL_39;
  v6 = sub_DAB5((__int64)v5, &v21);
  if ( v6 < 0 )
    goto LABEL_39;
  v8 = v5;
  v24 = v3;
  v25 = v4;
  if ( (unsigned int)(v17 + 17958194) < 2 )
  {
    v31 = v21;
    v12 = HIDWORD(v17);
    v30 = v18;
    v9 = 1i64;
    v11 = 0i64;
  }
  else
  {
    v9 = 0i64;
    if ( (_DWORD)v17 == -822415874 )
    {
      v11 = 0i64;
      goto LABEL_44;
    }
    v11 = 0i64;
    v12 = 0;
    v30 = 0;
    v31 = 0;
    if ( (_DWORD)v17 != -805638658 )
    {
      v9 = 0i64;
      v11 = v21;
LABEL_44:
      v12 = 0;
      v30 = 0;
      v31 = 0;
      goto LABEL_45;
    }
  }
LABEL_45:
  v23 = 0i64;
  v10 = v9;
LABEL_8:
  for ( i = 0i64; v9; --v9 )
  {
    if ( v10 && v9 == 1 )
    {
      v27 = __PAIR__(v30, v12);
      LODWORD(v28) = 0;
      HIDWORD(v28) = v31;
      v29 = 0;
      v14 = v12;
    }
    else
    {
      v26 = 20i64;
      v6 = sub_DBA9(v8, &v26, (char *)&v27);
      if ( v6 < 0 )
        goto LABEL_39;
      if ( v26 < 0x14 )
        return -9223372036854775807i64;
      v14 = v27;
      if ( v23 )
      {
        v14 = _byteswap_ulong(v27);
        v27 = __PAIR__(_byteswap_ulong(HIDWORD(v27)), v14);
        v28 = _byteswap_uint64(__PAIR__(v28, HIDWORD(v28)));
      }
    }
    if ( v14 == 16777223 )
    {
      v15 = HIDWORD(v27);
      if ( HIDWORD(v27) == 3 && v11 == 0 )
      {
        i = (unsigned int)v28;
        v11 = HIDWORD(v28);
      }
      if ( v15 == (unsigned int)sub_9E7F() )
      {
        i = (unsigned int)v28;
        v11 = HIDWORD(v28);
      }
    }
  }
  v7 = -9223372036854775807i64;
  if ( v11 )
  {
    if ( !i || (v6 = sub_F11F((__int64)v8, i), v6 >= 0) )
    {
      if ( v24 )
        *v24 = i;
      if ( v25 )
        *v25 = v11;
      return 0i64;
    }
LABEL_39:
    v7 = v6;
  }
  return v7;
}

//----- (000000000000E83F) ----------------------------------------------------
signed __int64 sub_E83F()
{
  __int64 *v0; // rbx
  unsigned __int64 v1; // rsi
  char *v2; // r14
  __int64 v3; // rdi
  int v4; // eax

  v0 = &qword_92318;
  v1 = 0i64;
  v2 = sub_98E2();
  while ( 1 )
  {
    v3 = *(v0 - 1);
    v4 = sub_189FE((_BYTE *)*(v0 - 1));
    if ( !(unsigned int)sub_18A43((__int64)v2, v3, v4) )
      break;
    ++v1;
    v0 += 2;
    if ( v1 > 4 )
      return 3i64;
  }
  return *(unsigned int *)v0;
}
// 92318: using guessed type __int64 qword_92318;

//----- (000000000000E89C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_E89C(_QWORD *a1, __int64 *a2)
{
  __int64 *v2; // r13
  _QWORD *v3; // r14
  signed __int64 v4; // rax
  signed __int64 v5; // rsi
  int v7; // eax
  __int64 v8; // rax
  char *v9; // r15
  signed __int64 v10; // rbx
  __int64 v11; // rax
  unsigned __int8 *v12; // r12
  unsigned __int64 v13; // rax
  signed __int64 v14; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  int v17; // eax
  char *v18; // rdi
  unsigned __int64 v19; // rbx
  int v20; // er9
  __int64 v21; // r10
  int v22; // ebx
  int v23; // eax
  __int64 v24; // r11
  __int64 v25; // rdi
  __int64 v26; // rcx
  __int64 v27; // r12
  __int64 v28; // rax
  __int64 v29; // rax
  unsigned __int64 v30; // rcx
  unsigned __int64 v31; // r12
  unsigned __int64 v32; // rdi
  unsigned __int64 v33; // rax
  char *v34; // rbx
  signed __int64 v35; // rax
  __int64 v36; // rcx
  signed __int64 v37; // rax
  signed __int64 v38; // rdx
  __int64 v39; // rdi
  unsigned __int64 v43; // rdx
  __int64 v44; // rcx
  __int64 v45; // r12
  _DWORD *v46; // rax
  _DWORD *v47; // r12
  __int64 i; // rax
  __int64 v49; // r12
  __int64 v50; // rdi
  __int64 v51; // rax
  unsigned __int64 v52; // rax
  unsigned __int64 v53; // rcx
  __int64 v54; // r12
  __int64 v55; // rdi
  __int64 v56; // rax
  __int64 v57; // r9
  int v58; // [rsp+20h] [rbp-250h]
  int v59; // [rsp+24h] [rbp-24Ch]
  unsigned int v60; // [rsp+28h] [rbp-248h]
  unsigned int v61; // [rsp+2Ch] [rbp-244h]
  unsigned int v62; // [rsp+30h] [rbp-240h]
  int v63; // [rsp+34h] [rbp-23Ch]
  __int64 v64; // [rsp+1A0h] [rbp-D0h]
  __int64 v65; // [rsp+1A8h] [rbp-C8h]
  __int64 v66; // [rsp+1B0h] [rbp-C0h]
  __int64 v67; // [rsp+1B8h] [rbp-B8h]
  unsigned __int8 *v68; // [rsp+1C0h] [rbp-B0h]
  char *v69; // [rsp+1C8h] [rbp-A8h]
  __int64 v70; // [rsp+1D0h] [rbp-A0h]
  __int64 v71; // [rsp+1D8h] [rbp-98h]
  __int64 v72; // [rsp+1E0h] [rbp-90h]
  __int64 v73; // [rsp+1E8h] [rbp-88h]
  unsigned __int64 v74; // [rsp+1F0h] [rbp-80h]
  __int64 v75; // [rsp+1F8h] [rbp-78h]
  __int64 v76; // [rsp+200h] [rbp-70h]
  unsigned __int64 v77; // [rsp+208h] [rbp-68h]
  unsigned __int64 v78; // [rsp+210h] [rbp-60h]
  __int64 v79; // [rsp+218h] [rbp-58h]
  int v80; // [rsp+224h] [rbp-4Ch]
  unsigned __int64 v81; // [rsp+228h] [rbp-48h]
  int v82; // [rsp+234h] [rbp-3Ch]

  v2 = a2;
  v3 = a1;
  v64 = -6148914691236517206i64;
  v65 = -6148914691236517206i64;
  v81 = -6148914691236517206i64;
  sub_1B930((char *)&v58, (char *)qword_8ECC0, 0x180ui64);
  v4 = sub_E523(v3, &v64, (unsigned __int64 *)&v65);
  if ( v4 < 0 )
    return v4;
  v81 = 384i64;
  v4 = sub_DBA9(v3, &v81, (char *)&v58);
  if ( v4 < 0 )
    return v4;
  v5 = -9223372036854775807i64;
  if ( v81 < 0x180 )
    return -9223372036854775794i64;
  if ( v58 != 1886220131 )
  {
    v9 = 0i64;
    sub_F11F((__int64)v3, 0i64);
    v12 = 0i64;
    goto LABEL_21;
  }
  if ( !v63 )
  {
    v7 = qword_96AA8;
    if ( _bittest(&v7, 0xEu) )
    {
      qword_96AB8 = 0i64;
      qword_96AA8 &= 0xFFFFFFFFFFFFBFFFui64;
    }
  }
  if ( v59 != 1936947820 && v59 != 1853258348 )
    return -9223372036854775805i64;
  v81 = _byteswap_ulong(v62);
  v8 = sub_1364F(v81);
  if ( !v8 )
    return -9223372036854775799i64;
  v9 = (char *)v8;
  sub_1905F((__int64)"Start ReadKernelCache");
  v10 = sub_DBA9(v3, &v81, v9);
  sub_1905F((__int64)"End ReadKernelCache");
  if ( v10 < 0 )
  {
    v12 = 0i64;
    v5 = v10;
    goto LABEL_47;
  }
  if ( v81 != _byteswap_ulong(v62) )
  {
    v5 = -9223372036854775794i64;
LABEL_34:
    v12 = 0i64;
    goto LABEL_47;
  }
  v81 = _byteswap_ulong(v61);
  v11 = sub_1364F(v81);
  if ( !v11 )
  {
    v5 = -9223372036854775799i64;
    goto LABEL_34;
  }
  v12 = (unsigned __int8 *)v11;
  sub_1905F((__int64)"Start UncompressKernelCache");
  if ( v59 == 1853258348 )
  {
    v13 = sub_22C00((__int64)v12, v81, v9, _byteswap_ulong(v62));
    goto LABEL_51;
  }
  if ( v59 == 1936947820 )
  {
    v13 = (unsigned __int64)sub_116D9(v12, v9, _byteswap_ulong(v62));
LABEL_51:
    v81 = v13;
  }
  sub_1905F((__int64)"End UncompressKernelCache");
  if ( v81 != _byteswap_ulong(v61) )
  {
    v5 = -9223372036854775801i64;
    goto LABEL_47;
  }
  sub_1905F((__int64)"Start CalculateAdler32");
  dword_96B70 = sub_4E7F(v12, v81);
  sub_1905F((__int64)"End CalculateAdler32");
  if ( _byteswap_ulong(v60) != dword_96B70 )
  {
    v5 = -9223372036854775781i64;
    goto LABEL_47;
  }
  sub_DE03(v3);
  v19 = v81;
  sub_F1B0(v3, 48i64);
  v3[3] = v12;
  v3[4] = 0i64;
  v3[5] = v19;
LABEL_21:
  sub_1905F((__int64)"Start LoadKernelFromStream");
  v78 = -6148914691236517206i64;
  v66 = -6148914691236517206i64;
  v67 = 0i64;
  v70 = -6148914691236517206i64;
  v71 = -6148914691236517206i64;
  v72 = -6148914691236517206i64;
  v73 = -6148914691236517206i64;
  v14 = sub_E523(v3, &v67, (unsigned __int64 *)&v66);
  if ( v14 < 0 )
    goto LABEL_45;
  if ( !v67 )
  {
    v5 = -9223372036854775794i64;
    goto LABEL_46;
  }
  v78 = 28i64;
  v14 = sub_DBA9(v3, &v78, (char *)&v70);
  if ( v14 < 0 )
    goto LABEL_45;
  if ( v78 < 0x1C )
    goto LABEL_46;
  if ( (_DWORD)v70 == -17958193 )
  {
    v78 = 4i64;
    v14 = sub_DBA9(v3, &v78, (char *)&v73 + 4);
    if ( v14 >= 0 )
    {
      if ( v78 < 4 )
        goto LABEL_46;
      goto LABEL_37;
    }
LABEL_45:
    v5 = v14;
    goto LABEL_46;
  }
  if ( (_DWORD)v70 != -17958194 )
    goto LABEL_46;
  sub_1A2B6(1, (__int64)"ERROR: Booting from 32-bit kernelcache is not supported. Exiting.\n", v15, v16);
  sub_5202(-9223372036854775805i64);
LABEL_37:
  v17 = qword_96AA8;
  if ( _bittest(&v17, 0xEu) && !(v73 & 0x200000) )
  {
    qword_96AB8 = 0i64;
    qword_96AA8 &= 0xFFFFFFFFFFFFBFFFui64;
  }
  v78 = HIDWORD(v72);
  v18 = (char *)sub_1364F(HIDWORD(v72));
  if ( !v18 )
    sub_9CE0((__int64)"[EB|#STOP|`LD:LKFS] ! @ M:BMA %qd @ 'RLOCMD\n", v78);
  if ( sub_DBA9(v3, &v78, v18) < 0 || v78 < HIDWORD(v72) )
  {
    sub_136C5((__int64)v18);
    goto LABEL_46;
  }
  v20 = v72;
  v68 = v12;
  v69 = v18;
  if ( (signed int)v72 <= 0 )
  {
LABEL_119:
    v45 = 0i64;
    goto LABEL_122;
  }
  v21 = (__int64)v18;
  v22 = 0;
  v82 = v72;
  while ( 1 )
  {
    v23 = *(_DWORD *)v21;
    v24 = *(unsigned int *)(v21 + 4);
    if ( *(_DWORD *)v21 > 10 )
    {
      if ( v23 == 11 )
      {
        if ( qword_96AA8 & 0x4000 && *(_DWORD *)(v21 + 76) )
          goto LABEL_121;
      }
      else if ( v23 == 25 )
      {
        v29 = *(_QWORD *)(v21 + 24);
        v74 = *(_QWORD *)(v21 + 24);
        v30 = *(_QWORD *)(v21 + 32);
        v75 = v30;
        v31 = *(_QWORD *)(v21 + 40) + v66;
        v32 = *(_QWORD *)(v21 + 48);
        v76 = *(_QWORD *)(v21 + 48);
        if ( v30 )
        {
          if ( v32 > v30 )
          {
            v76 = v30;
            v32 = v30;
          }
          v77 = v24;
          v79 = v21;
          v80 = v22;
          if ( qword_96AA8 & 0x4000 )
            v74 = qword_96AB8 + v29;
          v33 = sub_17500(&v75, &v74);
          if ( !v33 )
          {
            v45 = -9223372036854775799i64;
            goto LABEL_92;
          }
          v34 = (char *)v33;
          v35 = sub_F11F((__int64)v3, v31);
          if ( v35 < 0 )
            goto LABEL_91;
          if ( v32 )
          {
            v35 = sub_DBA9(v3, (unsigned __int64 *)&v76, v34);
            if ( v35 >= 0 )
            {
              v36 = v76;
              goto LABEL_94;
            }
LABEL_91:
            v45 = v35;
LABEL_92:
            v43 = 0i64;
            v44 = 0i64;
          }
          else
          {
            v36 = 0i64;
LABEL_94:
            if ( v75 != v36 )
              (*(void (__fastcall **)(char *, __int64, _QWORD))(qword_96CD8 + 360))(&v34[v36], v75 - v36, 0i64);
            if ( qword_96AA8 & 0x4000 )
            {
              if ( *(_BYTE *)(v79 + 60) & 2 )
                qword_93BC8 = (__int64)v34;
              if ( !(unsigned int)sub_18A1A((char *)(v79 + 8), "__LINKEDIT") )
              {
                qword_93BD0 = (__int64)v34;
                dword_93BD8 = *(_DWORD *)(v79 + 40);
              }
              if ( !(unsigned int)sub_18A1A((char *)(v79 + 8), "__TEXT") )
              {
                v46 = sub_30C0((__int64)v34);
                if ( v46 )
                {
                  v47 = v46;
                  do
                  {
                    *((_QWORD *)v47 + 3) += qword_96AB8;
                    for ( i = sub_3144((__int64)v47); i; i = sub_3160((__int64)v47, i) )
                      *(_QWORD *)(i + 32) += qword_96AB8;
                    v47 = sub_30F0((__int64)v34, (signed __int64)v47);
                  }
                  while ( v47 );
                }
              }
            }
            v43 = v74;
            v44 = v75;
            v45 = 0i64;
          }
          v20 = v82;
          v22 = v80;
          v21 = v79;
          v24 = v77;
        }
        else
        {
          v43 = -1i64;
          v44 = 0i64;
          v45 = 0i64;
        }
        if ( v44 && v45 >= 0 )
        {
          if ( v2[3] - 1 >= v43 )
          {
            v2[3] = v43;
            v79 = v44;
            v49 = v21;
            v50 = v24;
            v77 = v43;
            v51 = sub_17602(v43);
            v43 = v77;
            v44 = v79;
            v24 = v50;
            v21 = v49;
            v20 = v82;
            *v2 = v51;
          }
          v52 = v2[4];
          v53 = v43 + v44;
          if ( !v52 || v52 < v53 )
          {
            v2[4] = v53;
            v54 = v21;
            v55 = v24;
            v56 = sub_17602(v53);
            v24 = v55;
            v21 = v54;
            v20 = v82;
            v2[1] = v56;
          }
        }
        else if ( v45 )
        {
          goto LABEL_122;
        }
        goto LABEL_118;
      }
      goto LABEL_118;
    }
    if ( v23 == 2 )
    {
      if ( qword_96AA8 & 0x4000 && *(_DWORD *)(v21 + 12) )
      {
        v37 = 16i64 * *(unsigned int *)(v21 + 12);
        v38 = *(unsigned int *)(v21 + 8) + 8i64;
        v39 = 0i64;
        do
        {
          if ( *(_BYTE *)(v38 + v39 - 4) <= 0x1Fu )
            *(_QWORD *)(v38 + v39) += qword_96AB8;
          v39 += 16i64;
        }
        while ( v37 != v39 );
      }
      goto LABEL_118;
    }
    if ( v23 == 5 )
      break;
LABEL_118:
    v21 += v24;
    if ( ++v22 >= v20 )
      goto LABEL_119;
  }
  if ( *(_DWORD *)(v21 + 8) == 4 )
  {
    v25 = *(unsigned int *)(v21 + 4);
    v26 = *(_QWORD *)(v21 + 144) + (qword_96AB8 & (qword_96AA8 << 49 >> 63));
    v2[5] = v26;
    v27 = v21;
    v28 = sub_17602(v26);
    v21 = v27;
    v2[2] = v28;
    v20 = v82;
    v24 = v25;
    goto LABEL_118;
  }
  v5 = -9223372036854775805i64;
LABEL_121:
  v45 = v5;
LABEL_122:
  sub_136C5((__int64)v69);
  sub_1A2B6(1, (__int64)"[EB|`LD:LKFS] } %r\n", v45, v57);
  v5 = v45;
  v12 = v68;
LABEL_46:
  sub_1905F((__int64)"End LoadKernelFromStream");
  if ( v9 )
LABEL_47:
    sub_136C5((__int64)v9);
  if ( v12 )
    sub_136C5((__int64)v12);
  return v5;
}
// E97F: write access to const memory at 96AB8 has been detected
// E990: write access to const memory at 96AA8 has been detected
// EBBD: write access to const memory at 96AB8 has been detected
// EBCE: write access to const memory at 96AA8 has been detected
// ECAB: write access to const memory at 96B70 has been detected
// EFA0: write access to const memory at 93BC8 has been detected
// EFC9: write access to const memory at 93BD0 has been detected
// EFD3: write access to const memory at 93BD8 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 8ECC0: using guessed type __int64 qword_8ECC0[48];
// 93BC8: using guessed type __int64 qword_93BC8;
// 93BD0: using guessed type __int64 qword_93BD0;
// 93BD8: using guessed type int dword_93BD8;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AB8: using guessed type __int64 qword_96AB8;
// 96B70: using guessed type int dword_96B70;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000F11F) ----------------------------------------------------
signed __int64 __fastcall sub_F11F(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // rcx
  signed __int64 result; // rax
  unsigned __int64 v6; // [rsp+28h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  v6 = -6148914691236517206i64;
  v4 = *(_QWORD *)(a1 + 8);
  if ( v4 )
    return (*(__int64 (**)(void))(v4 + 56))();
  result = sub_DAB5(v3, &v6);
  if ( result >= 0 )
  {
    if ( v6 >= v2 )
    {
      *(_QWORD *)(v3 + 32) = v2;
      result = 0i64;
    }
    else
    {
      result = -9223372036854775806i64;
    }
  }
  return result;
}

//----- (000000000000F180) ----------------------------------------------------
__int64 __fastcall sub_F180(char *a1, int a2, unsigned __int64 a3)
{
  int v3; // eax
  __int16 v4; // dx
  __int64 v5; // rax
  __int64 v6; // r8

  v3 = a2;
  BYTE1(v3) = a2;
  v4 = v3;
  v5 = (unsigned int)(v3 << 16);
  LOWORD(v5) = v4;
  sub_F1B3((unsigned int)v5 | (unsigned __int64)(v5 << 32), a3, a1);
  return v6;
}

//----- (000000000000F1B3) ----------------------------------------------------
unsigned __int64 __usercall sub_F1B3@<rax>(unsigned __int64 result@<rax>, unsigned __int64 a2@<rdx>, char *a3@<rcx>)
{
  memset64(a3, result, a2 >> 3);
  memset(&a3[8 * (a2 >> 3)], result, a2 & 7);
  return result;
}

//----- (000000000000F1CC) ----------------------------------------------------
signed __int64 __fastcall sub_F1CC(char *a1, _BYTE *a2, __int64 *a3, char **a4)
{
  char *i; // r15
  unsigned __int8 v5; // al
  _BYTE *v6; // r14
  signed __int64 v7; // rdx
  signed __int64 v8; // r12
  __int64 v9; // rdi
  __int64 v10; // rbx
  char v11; // al
  _BYTE *v12; // rsi
  signed __int64 v13; // rcx
  char *v14; // r13
  int v15; // eax
  unsigned __int64 v16; // rax
  char v17; // al
  _BYTE *v19; // [rsp+28h] [rbp-58h]
  char **v20; // [rsp+30h] [rbp-50h]
  __int64 *v21; // [rsp+38h] [rbp-48h]
  signed __int64 v22; // [rsp+40h] [rbp-40h]

  v20 = a4;
  v21 = a3;
  v22 = -9223372036854775794i64;
  if ( a1 )
  {
    i = a1;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a2;
      v7 = 2305843013508670977i64;
      v8 = 4294977024i64;
      v19 = v6;
      do
      {
        v9 = (__int64)(i + 1);
        while ( v5 <= 0x22u )
        {
          if ( !_bittest64(&v8, v5) )
          {
            if ( v5 == 34i64 )
            {
              v10 = v9;
              do
                v11 = *(_BYTE *)v10++;
              while ( v11 != 34 && v11 );
              v12 = (_BYTE *)(v10 + ~v9);
              v5 = *(_BYTE *)v10;
              goto LABEL_18;
            }
            break;
          }
          v5 = *(_BYTE *)v9++;
        }
        v10 = --v9;
        while ( v5 > 0x3Du || !_bittest64(&v7, v5) )
          v5 = *(_BYTE *)(v10++ + 1);
        v12 = (_BYTE *)(v10 - v9);
LABEL_18:
        if ( v5 <= 0x20u && (v13 = 4294977025i64, _bittest64(&v13, v5)) )
        {
          v14 = 0i64;
          i = (char *)v10;
        }
        else
        {
          LOBYTE(v16) = *(_BYTE *)(v10 + 1);
          if ( (_BYTE)v16 == 34 )
          {
            v10 += 2i64;
            i = (char *)v10;
            do
              v17 = *i++;
            while ( v17 != 34 && v17 );
            v14 = &i[~v10];
          }
          else
          {
            for ( i = (char *)++v10; ; ++i )
            {
              v16 = (unsigned __int8)v16;
              if ( (unsigned __int8)v16 <= 0x3Du )
              {
                if ( _bittest64(&v7, v16) )
                  break;
              }
              LOBYTE(v16) = i[1];
            }
            v14 = &i[-v10];
          }
        }
        if ( v12 == (_BYTE *)(signed int)sub_189FE(v6) )
        {
          v15 = sub_18D2F((__int64)v6, v9, (int)v12);
          v7 = 2305843013508670977i64;
          if ( !v15 )
          {
            *v21 = v10;
            *v20 = v14;
            v22 = 0i64;
          }
        }
        else
        {
          v7 = 2305843013508670977i64;
        }
        v5 = *i;
        v6 = v19;
      }
      while ( *i );
    }
  }
  return v22;
}

//----- (000000000000F364) ----------------------------------------------------
signed __int64 __fastcall sub_F364(char *a1, _BYTE *a2, __int64 *a3, char **a4)
{
  char **v4; // rsi
  __int64 *v5; // rdi
  _BYTE *v6; // rbx
  __int64 v7; // rax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  if ( !sub_F1CC(a1, a2, a3, a4) )
    return 0i64;
  v7 = sub_124B2(0i64, v6);
  if ( v7 )
  {
    *v5 = *(_QWORD *)(v7 + 8);
    *v4 = (char *)(signed int)sub_189FE(*(_BYTE **)(v7 + 8));
    return 0i64;
  }
  return -9223372036854775794i64;
}

//----- (000000000000F3C2) ----------------------------------------------------
signed __int64 __fastcall sub_F3C2(__int64 a1, _BYTE *a2, _QWORD *a3)
{
  _QWORD *v3; // rdi
  signed __int64 v4; // rsi
  __int64 v5; // rax

  v3 = a3;
  v4 = -9223372036854775794i64;
  v5 = sub_124B2(0i64, a2);
  if ( v5 && *(_DWORD *)v5 == 4 )
  {
    *v3 = *(_QWORD *)(v5 + 16);
    v4 = 0i64;
  }
  return v4;
}

//----- (000000000000F403) ----------------------------------------------------
unsigned __int8 *__fastcall sub_F403(__int64 a1, __int64 a2, unsigned __int8 *a3, __int64 a4)
{
  unsigned __int8 *v4; // rsi
  unsigned __int8 *v5; // rdi
  _BYTE *v6; // r12
  __int64 v7; // r14
  __int64 v8; // r9
  __int64 v9; // r9
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // r9
  unsigned __int8 *v13; // rbx
  signed __int64 v14; // r13
  unsigned __int8 *v15; // r8
  unsigned __int64 v16; // rax
  __int64 v17; // r8
  signed __int64 v18; // r12
  unsigned __int8 i; // al
  char v20; // cl
  unsigned __int64 v21; // rdx
  __int64 v22; // r15
  unsigned __int8 v23; // al
  int j; // er15
  char v25; // cl
  unsigned __int64 v26; // rdx
  __int64 v27; // rbx
  unsigned __int8 *v28; // rdi
  unsigned __int8 v29; // al
  int v30; // eax
  __int64 v31; // rcx
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v35; // [rsp+30h] [rbp-70h]
  __int64 v36; // [rsp+38h] [rbp-68h]
  __int64 v37; // [rsp+40h] [rbp-60h]
  int v38; // [rsp+48h] [rbp-58h]
  char v39; // [rsp+4Ch] [rbp-54h]
  __int64 v40; // [rsp+58h] [rbp-48h]
  unsigned __int8 *v41; // [rsp+60h] [rbp-40h]

  v4 = (unsigned __int8 *)a4;
  v5 = a3;
  v6 = (_BYTE *)a2;
  v7 = a1;
  sub_1A2B6(1, (__int64)"[EB|#MBA:CL] (%e)\n", a2, a4);
  sub_1A2B6(1, (__int64)"[EB|#MBA:NV] (%e)\n", (__int64)v5, v8);
  sub_1A2B6(1, (__int64)"[EB|#MBA:KF] (%e)\n", (__int64)v4, v9);
  if ( v6 )
    v10 = (signed int)sub_189FE(v6);
  else
    v10 = 0i64;
  if ( v5 )
    v10 += (signed int)sub_189FE(v5);
  if ( v4 )
    v10 += (signed int)sub_189FE(v4);
  v11 = sub_1364F(v10 + 64);
  v13 = (unsigned __int8 *)v11;
  if ( v11 )
  {
    v14 = 4294977024i64;
    v15 = (unsigned __int8 *)v11;
    if ( v6 )
    {
      while ( 1 )
      {
        v16 = (unsigned __int8)*(++v6 - 1);
        if ( v16 > 0x20 )
          break;
        if ( !_bittest64(&v14, v16) )
        {
          if ( !*(v6 - 1) )
          {
            v15 = v13;
            goto LABEL_17;
          }
          break;
        }
      }
      v17 = 0i64;
      do
      {
        v13[v17] = v16;
        LOBYTE(v16) = v6[v17++];
      }
      while ( (_BYTE)v16 );
      v15 = &v13[v17];
    }
LABEL_17:
    *v15 = 0;
    v18 = 4294977025i64;
    v41 = v13;
    v40 = v7;
    if ( v5 )
    {
      for ( i = *v5; i; v5 += v22 )
      {
        while ( i <= 0x20u && _bittest64(&v14, i) )
          i = (v5++)[1];
        v20 = 0;
        v21 = 0i64;
        v22 = 0i64;
        while ( i > 0x20u || !_bittest64(&v18, i) )
        {
          if ( i == 61 )
            v20 = 1;
          v21 += (unsigned __int8)v20 < 1u;
          i = v5[v22++ + 1];
        }
        v15 = sub_F798(v40, v41, v15, (__int64)v5, v21, v22);
        i = v5[v22];
      }
    }
    if ( v4 )
    {
      v23 = *v4;
      for ( j = v40; v23; v4 += v27 )
      {
        while ( v23 <= 0x20u && _bittest64(&v14, v23) )
          v23 = (v4++)[1];
        v25 = 0;
        v26 = 0i64;
        v27 = 0i64;
        while ( v23 > 0x20u || !_bittest64(&v18, v23) )
        {
          if ( v23 == 61 )
            v25 = 1;
          v26 += (unsigned __int8)v25 < 1u;
          v23 = v4[v27++ + 1];
        }
        v15 = sub_F798(v40, v41, v15, (__int64)v4, v26, v27);
        v23 = v4[v27];
      }
    }
    else
    {
      j = v40;
    }
    if ( j & 1 )
    {
      v13 = v41;
      v15 = sub_F798(j, v41, v15, (__int64)"-x", 2ui64, 2i64);
    }
    else
    {
      v13 = v41;
    }
    if ( j & 0x10 )
      v15 = sub_F798(j, v13, v15, (__int64)"-s", 2ui64, 2i64);
    if ( j & 2 )
      v15 = sub_F798(j, v13, v15, (__int64)"-v", 2ui64, 2i64);
    if ( _bittest(&j, 0xAu) )
      v15 = sub_F798(j, v13, v15, (__int64)"srv=1", 5ui64, 5i64);
    if ( j & 0x1200000 )
    {
      v28 = v15;
      v29 = sub_11805();
      v35 = -6148914691236517206i64;
      v36 = -6148914691236517206i64;
      v37 = -6148914691236517206i64;
      v38 = -1431655766;
      v39 = -86;
      sub_18905((unsigned __int64)&v35, (__int64)"%s=%d", "chunklist-security-epoch", v29);
      v30 = sub_189FE(&v35);
      if ( v28 > v13 )
        *v28++ = 32;
      if ( v30 )
      {
        v31 = v30;
        v32 = 0i64;
        do
        {
          v28[v32] = *((_BYTE *)&v35 + v32);
          ++v32;
        }
        while ( v31 != v32 );
        v28 += v32;
      }
      *v28 = 0;
      if ( !_bittest(&j, 0x19u) )
      {
        if ( v28 > v13 )
          *v28++ = 32;
        v33 = 0i64;
        do
        {
          v28[v33] = aChunklistNoRev[v33];
          ++v33;
        }
        while ( v33 != 22 );
        v28[22] = 0;
      }
    }
    sub_1A2B6(1, (__int64)"[EB|#MBA:OUT] (%e)\n", (__int64)v13, v12);
  }
  return v13;
}

//----- (000000000000F798) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
unsigned __int8 *__fastcall sub_F798(int a1, unsigned __int8 *a2, unsigned __int8 *a3, __int64 a4, unsigned __int64 a5, __int64 a6)
{
  __int64 v6; // r14
  unsigned __int8 *v7; // r13
  unsigned __int8 *v8; // r15
  int v9; // er12
  unsigned __int64 v10; // rdx
  unsigned __int8 v11; // al
  signed __int64 v12; // r8
  signed __int64 v13; // r9
  unsigned __int8 *v14; // rcx
  _BYTE *v15; // rdi
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rax
  char v18; // al
  unsigned __int64 v19; // rsi
  char v20; // al
  const char *v21; // rdx
  unsigned __int64 v22; // rsi
  char v23; // al
  __int64 v24; // rcx

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v10 = a5;
  v11 = *v8;
  if ( *v8 )
  {
    v12 = 2305843013508670977i64;
    v13 = 4294977024i64;
    v14 = v8;
LABEL_3:
    while ( v11 <= 0x20u && _bittest64(&v13, v11) )
      v11 = (v14++)[1];
    v15 = (_BYTE *)v6;
    v16 = a5;
    while ( 1 )
    {
      if ( v11 <= 0x20u )
      {
        if ( _bittest64(&v13, v11) )
          goto LABEL_3;
        if ( !v11 )
          break;
      }
      if ( v15 && *v15 == v11 )
      {
        ++v15;
        ++v14;
        if ( !--v16 )
        {
          v17 = *v14;
          if ( v17 > 0x3D )
          {
            v16 = 0i64;
          }
          else
          {
            v16 = 0i64;
            if ( _bittest64(&v12, v17) )
              return v7;
          }
        }
      }
      else
      {
        ++v14;
        v15 = 0i64;
      }
      v11 = *v14;
    }
  }
  if ( v9 & 1 )
  {
    v18 = sub_11351(v6, a5, off_92370);
    v10 = a5;
    if ( !v18 )
    {
      qword_93BE8 = 1i64;
      v21 = "[EB|#O:NB|%qd] SM -> %s\n";
      goto LABEL_38;
    }
  }
  if ( _bittest(&v9, 0xCu) )
  {
    v19 = v10;
    v20 = sub_11351(v6, v10, &off_923A0);
    v10 = v19;
    if ( v20 )
    {
      qword_93BE8 = 1i64;
      v21 = "[EB|#O:NB|%qd] R -> %s\n";
LABEL_38:
      sub_1A2B6(1, (__int64)v21, 0i64, v6);
      return v7;
    }
  }
  if ( _bittest(&v9, 0x15u) )
  {
    v22 = v10;
    v23 = sub_11351(v6, v10, off_923B0);
    v10 = v22;
    if ( v23 )
    {
      qword_93BE8 = 1i64;
      v21 = "[EB|#O:NB|%qd] SB -> %s\n";
      goto LABEL_38;
    }
  }
  if ( _bittest(&v9, 0x18u) && (unsigned __int8)sub_11351(v6, v10, off_923B0) )
  {
    qword_93BE8 = 1i64;
    v21 = "[EB|#O:NB|%qd] TB -> %s\n";
    goto LABEL_38;
  }
  if ( v7 > v8 )
    *v7++ = 32;
  if ( a6 )
  {
    v24 = 0i64;
    do
    {
      v7[v24] = *(_BYTE *)(v6 + v24);
      ++v24;
    }
    while ( a6 != v24 );
    v7 += v24;
  }
  *v7 = 0;
  return v7;
}
// F88E: write access to const memory at 93BE8 has been detected
// F8CC: write access to const memory at 93BE8 has been detected
// F904: write access to const memory at 93BE8 has been detected
// F952: write access to const memory at 93BE8 has been detected
// 92370: using guessed type char *off_92370[4];
// 923A0: using guessed type char *off_923A0;
// 923B0: using guessed type char *off_923B0[4];
// 93BE8: using guessed type __int64 qword_93BE8;

//----- (000000000000F981) ----------------------------------------------------
__int64 __fastcall sub_F981(__int64 a1, __int16 *a2, char a3)
{
  char v3; // r14
  __int16 *v4; // r12
  __int64 v5; // rbx
  signed __int64 v6; // rsi
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // r15
  __int64 v10; // rdi
  _WORD *v11; // rsi
  _WORD *v12; // r13
  char v13; // al
  __int16 v14; // bx
  __int16 *v15; // rdi
  _WORD *v16; // rcx
  _WORD *v17; // rdx
  __int16 v18; // bx
  bool v19; // zf
  _WORD *v20; // rcx
  __int16 v21; // dx
  __int16 *v22; // r12
  unsigned __int16 v23; // cx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = sub_23D3E(a1);
  v7 = sub_23741(v4);
  v8 = sub_1364F(v6 + 2 * v7 + 2);
  if ( !v8 )
    return 0i64;
  v9 = v8;
  v10 = 0i64;
  v11 = (_WORD *)v8;
  v12 = 0i64;
  while ( 1 )
  {
    v13 = *(_BYTE *)v5 & 0x7F;
    if ( v13 == 3 )
    {
      if ( *(_BYTE *)(v5 + 1) != 12 )
        goto LABEL_10;
LABEL_9:
      v10 = v5;
      v12 = v11;
      goto LABEL_10;
    }
    if ( v13 != 4 )
      break;
    if ( *(_BYTE *)(v5 + 1) == 4 )
      goto LABEL_9;
LABEL_10:
    sub_1B930((char *)v11, (char *)v5, *(unsigned __int16 *)(v5 + 2));
    v5 += *(unsigned __int16 *)(v5 + 2);
    v11 = (_WORD *)((char *)v11 + (unsigned __int16)v11[1]);
  }
  if ( v13 != 127 || *(_BYTE *)(v5 + 1) != -1 )
    goto LABEL_10;
  if ( !v10 || !v12 )
  {
    sub_136C5(v9);
    return 0i64;
  }
  *v12 = 1028;
  v14 = *(_WORD *)(v10 + 4);
  if ( v14 )
  {
    v15 = (__int16 *)(v10 + 6);
    v16 = 0i64;
    v17 = v12 + 2;
    do
    {
      *v17 = v14;
      v18 = *(v15 - 1);
      if ( v18 == 92 || v18 == 47 )
        v16 = v17;
      ++v17;
      v14 = *v15;
      ++v15;
    }
    while ( v14 );
  }
  else
  {
    v16 = 0i64;
    v17 = v12 + 2;
  }
  v19 = v16 == 0i64;
  v20 = v16 + 1;
  if ( v19 )
    v20 = v12 + 2;
  if ( !v3 )
    v20 = v17;
  v21 = *v4;
  if ( *v4 )
  {
    v22 = v4 + 1;
    do
    {
      *v20 = v21;
      ++v20;
      v21 = *v22;
      ++v22;
    }
    while ( v21 );
  }
  *v20 = 0;
  v23 = (_WORD)v20 - ((_WORD)v12 + 4) + 6;
  v12[1] = v23;
  *(_DWORD *)((char *)v12 + v23) = (_DWORD)&byte_4FF7F;
  return v9;
}
// 4FF7F: using guessed type char byte_4FF7F;

//----- (000000000000FB02) ----------------------------------------------------
char *__fastcall sub_FB02(__int64 a1, char a2)
{
  char v2; // r14
  __int64 v3; // rdi
  unsigned __int16 *v4; // rbx
  unsigned __int16 *v5; // rsi
  __int64 v6; // r12
  char v7; // al
  __int64 v8; // rax
  signed __int64 v9; // r12
  _WORD *v10; // rcx
  unsigned __int16 v11; // dx
  unsigned __int16 *v12; // rdi
  __int64 v13; // rbx
  char *v14; // rax
  char *v15; // rsi
  __int16 v16; // cx
  char *v17; // rdi
  unsigned __int64 v18; // rsi
  char *v19; // rax
  char *v20; // r15
  char *i; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  v5 = 0i64;
  v6 = 0i64;
  while ( 1 )
  {
    v7 = *(_BYTE *)v3 & 0x7F;
    if ( v7 != 4 )
      break;
    if ( *(_BYTE *)(v3 + 1) == 4 )
    {
      if ( !v4 )
        v4 = (unsigned __int16 *)v3;
      v6 += sub_23741((_WORD *)(v3 + 4));
      v5 = (unsigned __int16 *)v3;
      goto LABEL_12;
    }
LABEL_10:
    if ( v4 )
      goto LABEL_14;
    v4 = 0i64;
LABEL_12:
    v3 += *(unsigned __int16 *)(v3 + 2);
  }
  if ( v7 != 127 || *(_BYTE *)(v3 + 1) != -1 )
    goto LABEL_10;
  if ( !v4 )
    return 0i64;
LABEL_14:
  if ( v4 == v5 )
  {
    v13 = (__int64)(v4 + 2);
    v9 = 0i64;
    goto LABEL_24;
  }
  v8 = sub_1364F(2 * v6 + 2);
  if ( !v8 )
    return 0i64;
  v9 = v6 + 1;
  v10 = (_WORD *)v8;
  while ( 1 )
  {
    v11 = v4[2];
    if ( v11 )
    {
      v12 = v4 + 3;
      do
      {
        *v10 = v11;
        ++v10;
        v11 = *v12;
        ++v12;
      }
      while ( v11 );
    }
    if ( v4 == v5 )
      break;
    v4 = (unsigned __int16 *)((char *)v4 + v4[1]);
  }
  *v10 = 0;
  v13 = v8;
LABEL_24:
  v14 = 0i64;
  v15 = (char *)v13;
  while ( 2 )
  {
    v16 = *(_WORD *)v15;
    if ( *(_WORD *)v15 == 47 || v16 == 92 )
    {
      v14 = v15;
      goto LABEL_30;
    }
    if ( v16 )
    {
LABEL_30:
      v15 += 2;
      continue;
    }
    break;
  }
  v17 = v14 + 2;
  if ( !v14 )
    v17 = (char *)v13;
  if ( v2 )
    v17 = (char *)v13;
  v18 = (v15 - v17 + 2) & 0xFFFFFFFFFFFFFFFEui64;
  v19 = (char *)sub_1364F(v18);
  v20 = v19;
  if ( v19 )
  {
    sub_1B930(v19, v17, v18);
    if ( v2 )
    {
      for ( i = v20; ; i += 2 )
      {
        if ( *(_WORD *)i == 47 )
        {
          *(_WORD *)i = 92;
        }
        else if ( !*(_WORD *)i )
        {
          break;
        }
      }
    }
  }
  if ( v9 )
    sub_136C5(v13);
  return v20;
}

//----- (000000000000FC87) ----------------------------------------------------
__int64 __fastcall sub_FC87(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 v5; // rsi
  __int64 v7; // rax
  __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // [rsp+38h] [rbp-88h]
  int v15; // [rsp+40h] [rbp-80h]
  __int64 v16; // [rsp+44h] [rbp-7Ch]
  __int64 v17; // [rsp+50h] [rbp-70h]
  unsigned __int64 v18; // [rsp+58h] [rbp-68h]
  __int64 v19; // [rsp+60h] [rbp-60h]
  __int64 v20; // [rsp+68h] [rbp-58h]
  __int64 v21; // [rsp+70h] [rbp-50h]
  int v22; // [rsp+7Ch] [rbp-44h]
  int v23; // [rsp+80h] [rbp-40h]
  char v24; // [rsp+87h] [rbp-39h]

  v14 = -6148914691236517206i64;
  v15 = -1431655766;
  v16 = -6148914691236517206i64;
  v19 = -6148914691236517206i64;
  v22 = -1431655766;
  v24 = -86;
  v17 = -6148914691236517206i64;
  v23 = -1431655766;
  v20 = -6148914691236517206i64;
  v21 = -6148914691236517206i64;
  v18 = -6148914691236517206i64;
  LODWORD(v4) = 0;
  sub_C2C4(1, 0, a3, a4);
  (*(void (__fastcall **)(signed __int64, int *, _QWORD, unsigned __int64 *, __int64 *))(qword_96CD8 + 312))(
    2i64,
    &dword_92824,
    0i64,
    &v18,
    &v21);
  if ( v18 )
  {
    v5 = 0i64;
    while ( (*(__int64 (__fastcall **)(_QWORD, int *, __int64 *))(qword_96CD8 + 152))(
              *(_QWORD *)(v21 + 8 * v5),
              &dword_92824,
              &v20) < 0
         || (*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD, __int64 *, char *, int *, int *, __int64))(v20 + 16))(
              v20,
              qword_923D8,
              0i64,
              &v17,
              &v24,
              &v22,
              &v23,
              v14) < 0 )
    {
      if ( ++v5 >= v18 )
        goto LABEL_6;
    }
    v7 = sub_23D7F(*(_QWORD *)(v21 + 8 * v5));
    if ( v7 )
    {
      v8 = v7;
      LODWORD(v14) = 1312260;
      (*(void (__fastcall **)(char *, __int64 *, signed __int64))(qword_96CD8 + 352))(
        (char *)&v14 + 4,
        qword_923D8,
        16i64);
      v9 = sub_23E90(v8, (__int64)&v14);
      v10 = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD, __int64 *))(qword_96CD8 + 200))(
              0i64,
              qword_96A90,
              v9,
              0i64,
              0i64,
              &v19);
      if ( v10 >= 0 )
      {
        sub_1A2B6(1, (__int64)"[EB|#APUI+]\n", v11, v12);
        v4 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(qword_96CD8 + 208))(v19, 0i64, 0i64);
        sub_1A2B6(1, (__int64)"[EB|#APUI-] %r\n", v4, v13);
        LOBYTE(v4) = v4 >= 0;
        return (unsigned int)v4;
      }
      sub_1A2B6(1, (__int64)"[EB|`OPT:VFP] %r @ BS.LIMG APUI\n", v10, v12);
    }
LABEL_6:
    LODWORD(v4) = 0;
  }
  return (unsigned int)v4;
}
// 923D8: using guessed type __int64 qword_923D8[3];
// 92824: using guessed type int dword_92824;
// 96A90: using guessed type __int64 qword_96A90;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000000FE80) ----------------------------------------------------
char sub_FE80()
{
  __int64 v0; // rbx
  char result; // al
  __int64 v2; // rbx
  int v3; // [rsp+34h] [rbp-2Ch]
  __int64 v4; // [rsp+38h] [rbp-28h]
  __int16 v5; // [rsp+42h] [rbp-1Eh]
  int v6; // [rsp+44h] [rbp-1Ch]

  v3 = -1431655766;
  v4 = 4i64;
  v6 = -1431655766;
  v0 = (*(__int64 (__fastcall **)(const char *, int *))(qword_96CE0 + 72))("P", &dword_91FF4);
  sub_1A2B6(1, (__int64)"[EB|`OPT:BPWU] %r @ GV %g:%S\n", v0, (__int64)&dword_91FF4);
  if ( v0 < 0 || (result = 1, v6 & 1) )
  {
    v5 = -21846;
    v4 = 2i64;
    v2 = (*(__int64 (__fastcall **)(const char *, int *, int *))(qword_96CE0 + 72))("B", &dword_92004, &v6);
    sub_1A2B6(1, (__int64)"[EB|`OPT:BPWU] %r @ GV %g:%S\n", v2, (__int64)&dword_92004);
    if ( v2 < 0 || v6 & 1 || (result = 1, v5) )
      result = 0;
  }
  return result;
}
// 91FF4: using guessed type int dword_91FF4;
// 92004: using guessed type int dword_92004;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000000FF72) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_FF72()
{
  __int64 v0; // r8
  __int64 v1; // r9
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rsi
  char v5; // r10
  __int64 v6; // r9
  char v7; // r12
  __int64 v8; // r8
  char v9; // r13
  char v10; // r14
  char v11; // r15
  unsigned __int64 v12; // rbx
  signed int v13; // ecx
  int v14; // edi
  unsigned int v15; // edi
  char v16; // bl
  char v18; // bl
  char v19; // di
  __int64 v20; // [rsp+20h] [rbp-A0h]
  __int64 v21; // [rsp+28h] [rbp-98h]
  __int64 v22; // [rsp+30h] [rbp-90h]
  __int64 v23; // [rsp+38h] [rbp-88h]
  __int64 v24; // [rsp+40h] [rbp-80h]
  __int64 v25; // [rsp+48h] [rbp-78h]
  __int64 v26; // [rsp+50h] [rbp-70h]
  __int64 v27; // [rsp+58h] [rbp-68h]
  __int64 v28; // [rsp+68h] [rbp-58h]
  unsigned __int64 v29; // [rsp+70h] [rbp-50h]
  __int64 v30; // [rsp+78h] [rbp-48h]
  __int16 v31; // [rsp+86h] [rbp-3Ah]

  v28 = -6148914691236517206i64;
  v30 = -6148914691236517206i64;
  if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD))(qword_96CD8 + 320))(qword_92C30, 0i64) >= 0 )
  {
    v20 = 0i64;
    (*(void (__fastcall **)(__int64, __int64 *))(v28 + 32))(v28, &v20);
    if ( v20 )
    {
      sub_1A2B6(1, (__int64)"[EB|#SM]\n", v0, v1);
      LOBYTE(qword_96AA8) = qword_96AA8 | 0x40;
    }
  }
  if ( qword_96AA8 & 0x2000 )
    return 0i64;
  v2 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92BC0, 0i64, &v30);
  if ( v2 < 0 )
  {
    v4 = v2;
    sub_1A2B6(1, (__int64)"[EB|`OPT:PK] %r @ LocP %g\n", v2, (__int64)qword_92BC0);
    v30 = 0i64;
  }
  else
  {
    v31 = -21846;
    v27 = -6148914691236517206i64;
    v26 = -6148914691236517206i64;
    v25 = -6148914691236517206i64;
    v24 = -6148914691236517206i64;
    v23 = -6148914691236517206i64;
    v22 = -6148914691236517206i64;
    v21 = -6148914691236517206i64;
    v20 = -6148914691236517206i64;
    v29 = 32i64;
    v3 = (*(__int64 (__cdecl **)(__int64, __int16 *, unsigned __int64 *, __int64 *, signed __int64, signed __int64, signed __int64, signed __int64))(v30 + 8))(
           v30,
           &v31,
           &v29,
           &v20,
           -6148914691236517206i64,
           -6148914691236517206i64,
           -6148914691236517206i64,
           -6148914691236517206i64);
    v4 = v3;
    if ( v3 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`OPT:PK] %r @ %g.GKM\n", v3, (__int64)qword_92BC0);
    }
    else
    {
      if ( v29 )
      {
        v5 = 0;
        v6 = 0i64;
        v7 = 0;
        v8 = 0i64;
        v9 = 0;
        v10 = 0;
        v11 = 0;
        v12 = 0i64;
        do
        {
          v13 = *((signed __int16 *)&v20 + v12);
          v14 = *((unsigned __int16 *)&v20 + v12);
          if ( v13 <= 28692 )
          {
            if ( v14 == 28678 )
            {
              v7 = 1;
            }
            else if ( v14 == 28686 )
            {
              LOBYTE(v6) = 1;
            }
          }
          else
          {
            switch ( (_WORD)v13 )
            {
              case 0x7015:
                LOBYTE(v8) = 1;
                break;
              case 0x7016:
                v10 = 1;
                break;
              case 0x7017:
              case 0x7018:
              case 0x701A:
                break;
              case 0x7019:
                v11 = 1;
                break;
              case 0x701B:
                v9 = 1;
                break;
              default:
                if ( v14 == 28717 )
                  v5 = 1;
                break;
            }
          }
          ++v12;
        }
        while ( v12 < v29 );
      }
      else
      {
        v11 = 0;
        v10 = 0;
        v9 = 0;
        v8 = 0i64;
        v7 = 0;
        v6 = 0i64;
        v5 = 0;
      }
      if ( v31 & 0x88 && !(v31 & 0xFF77) && (_BYTE)v8 && v29 == 1 )
      {
        v15 = v6;
        v16 = v5;
        sub_1A2B6(1, (__int64)"[EB|#KP:CmdR]\n", v8, v6);
        v5 = v16;
        v6 = v15;
        BYTE1(qword_96AA8) |= 8u;
      }
      if ( qword_96AA8 & 0x40 )
      {
        sub_1A2B6(1, (__int64)"[EB|#PK:SKIP]\n", v8, v6);
      }
      else if ( !(v31 & 0x22) || v31 & 0xFFDD )
      {
        if ( v31 & 0x88 )
        {
          v18 = v5;
          v19 = v6;
          if ( v11 )
          {
            sub_1A2B6(1, (__int64)"[EB|#KP:CmdV]\n", v8, v6);
            LOBYTE(qword_96AA8) = qword_96AA8 | 2;
            sub_1A6EF(1u);
          }
          if ( v10 )
          {
            if ( v18 )
            {
              if ( (unsigned int)sub_1B98C() )
              {
                sub_1A2B6(1, (__int64)"[EB|#KP:CmdS_]\n", v8, v6);
                dword_92024 = 0;
              }
            }
            else
            {
              sub_1A2B6(1, (__int64)"[EB|#KP:CmdS]\n", v8, v6);
              LOBYTE(qword_96AA8) = qword_96AA8 | 0x10;
            }
          }
          if ( v9 )
          {
            sub_1A2B6(1, (__int64)"[EB|#KP:CmdX]\n", v8, v6);
            BYTE1(qword_96AA8) |= 4u;
          }
          if ( v7 && v18 )
          {
            sub_1A2B6(1, (__int64)"[EB|#KP:CmdC_]\n", v8, v6);
            byte_91FF0 = 0;
          }
          if ( v19 )
          {
            sub_1A2B6(1, (__int64)"[EB|#KP:CmdK]\n", v8, v6);
            BYTE2(qword_96AA8) |= 2u;
          }
        }
      }
      else
      {
        qword_96AA8 |= 1ui64;
        sub_1A2B6(1, (__int64)"[EB|#KP:Shift]\n", v8, v6);
        dword_92024 = 0;
      }
    }
  }
  return v4;
}
// FFE4: write access to const memory at 96AA8 has been detected
// 101A1: write access to const memory at 96AA9 has been detected
// 101C7: write access to const memory at 96AA8 has been detected
// 101DF: write access to const memory at 92024 has been detected
// 10234: write access to const memory at 96AA8 has been detected
// 1026B: write access to const memory at 92024 has been detected
// 10288: write access to const memory at 96AA8 has been detected
// 102A5: write access to const memory at 96AA9 has been detected
// 102C6: write access to const memory at 91FF0 has been detected
// 102E7: write access to const memory at 96AAA has been detected
// 91FF0: using guessed type char byte_91FF0;
// 92024: using guessed type int dword_92024;
// 92BC0: using guessed type __int64 qword_92BC0[2];
// 92C30: using guessed type __int64 qword_92C30[2];
// 96AA0: using guessed type __int64 qword_96AA0;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000010310) ----------------------------------------------------
__int64 __fastcall sub_10310(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 *a5)
{
  _QWORD *v5; // r14
  __int16 *v6; // rdi
  __int64 v7; // r15
  __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rsi
  __int64 v12; // r8
  __int64 v13; // r9
  signed __int64 v14; // rax

  v5 = (_QWORD *)a4;
  v6 = (__int16 *)a3;
  v7 = a2;
  v8 = a1;
  sub_1A2B6(1, (__int64)"[EB|`OPT:LXF] 'LF (%E)\n", a3, a4);
  if ( v8 )
  {
    v9 = sub_F981(*(_QWORD *)(qword_96A98 + 32), v6, 1);
    if ( v9 )
    {
      v10 = v9;
      v11 = sub_D739(v8, 0i64, 0i64, v9, v5, a5);
      sub_136C5(v10);
      goto LABEL_7;
    }
    v14 = sub_D739(v8, v7, (__int64)v6, 0i64, v5, a5);
  }
  else
  {
    v14 = sub_D739(0i64, v7, (__int64)v6, 0i64, v5, a5);
  }
  v11 = v14;
LABEL_7:
  if ( v11 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`OPT:LXF] %r @ 'LF\n", v11, v13);
  }
  else if ( *v5 )
  {
    v11 = 0i64;
  }
  else
  {
    sub_1A2B6(1, (__int64)"[EB|`OPT:LXF] ! @ 'LF\n", v12, v13);
    v11 = -9223372036854775794i64;
  }
  return v11;
}
// 96A98: using guessed type __int64 qword_96A98;

//----- (000000000001040A) ----------------------------------------------------
signed __int64 __fastcall sub_1040A(__int64 a1, _BYTE *a2)
{
  _BYTE *v2; // rdi
  _BYTE *v3; // r15
  __int64 v4; // rax
  signed __int64 v5; // r14
  __int64 v6; // rsi
  char *v7; // rax
  __int64 v8; // rbx
  __int64 v9; // rax
  __int64 v10; // r9
  __int64 v11; // rax
  __int64 v12; // r9
  __int64 v13; // rsi
  _DWORD *v14; // rax
  __int64 v15; // r9
  __int64 v16; // rbx
  unsigned int v17; // eax
  unsigned __int64 v18; // r12
  __int64 v19; // rsi
  __int64 v20; // rax
  __int64 v21; // r13
  _DWORD *v22; // rax
  __int64 v23; // r9
  __int64 v24; // rbx
  unsigned int v25; // eax
  unsigned __int64 v26; // rdi
  __int64 v27; // rsi
  __int64 v28; // rax
  __int64 v30; // [rsp+30h] [rbp-50h]
  __int64 v31; // [rsp+38h] [rbp-48h]
  __int64 v32; // [rsp+40h] [rbp-40h]

  v2 = a2;
  v3 = (_BYTE *)a1;
  v30 = 0i64;
  v31 = 0i64;
  v32 = 0i64;
  if ( a1 && !(unsigned int)sub_18A43(a1, (__int64)"VMM", 3) )
    return 0i64;
  v4 = sub_F981(*(_QWORD *)(qword_96A98 + 32), (__int16 *)"P", 1);
  v5 = -9223372036854775805i64;
  if ( v4 )
  {
    v6 = v4;
    v7 = sub_FB02(v4, 1);
    if ( v7 )
      v8 = sub_10310(qword_96AE0, qword_96AE8, (__int64)v7, (__int64)&v30, &v31);
    else
      v8 = -9223372036854775794i64;
    sub_136C5(v6);
  }
  else
  {
    v8 = sub_10310(qword_96AE0, qword_96AE8, (__int64)"P", (__int64)&v30, &v31);
  }
  if ( v8 < 0 )
  {
    v9 = sub_10310(qword_96AE0, qword_96AE8, (__int64)"S", (__int64)&v30, &v31);
    if ( v9 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`OPT:PCC] %r @ 'LF PS\n", v9, v10);
      return 0i64;
    }
  }
  v11 = sub_12DC6(v31, &v32);
  if ( v11 )
  {
    v13 = v11;
    sub_1A2B6(1, (__int64)"[EB|`OPT:PCC] %r @ X:XPF\n", v11, v12);
    v32 = 0i64;
    return v13;
  }
  v14 = (_DWORD *)sub_124B2(v32, "SupportedFeatures");
  if ( v14 && (v16 = (__int64)v14, *v14 == 9) )
  {
    v17 = sub_12D6F((__int64)v14);
    if ( v17 )
    {
      v18 = v17;
      v19 = 0i64;
      while ( 1 )
      {
        v20 = sub_12D9A(v16, v19);
        if ( v20 )
        {
          v21 = v20;
          if ( *(_DWORD *)v20 == 3 )
          {
            if ( !(unsigned int)sub_18A1A(*(char **)(v20 + 8), "BootVTdEnabled") )
            {
              *v2 |= 1u;
              goto LABEL_28;
            }
            if ( !(unsigned int)sub_18A1A(*(char **)(v21 + 8), "InterruptRemapping") )
              break;
          }
        }
        if ( ++v19 >= v18 )
          goto LABEL_28;
      }
      *v2 |= 2u;
    }
LABEL_28:
    sub_12C84(v16);
  }
  else
  {
    sub_1A2B6(1, (__int64)"[EB|`OPT:PCC] ! @ X:XGP %s\n", (__int64)"SupportedFeatures", v15);
  }
  v22 = (_DWORD *)sub_124B2(v32, "SupportedBoardIds");
  if ( !v22 || (v24 = (__int64)v22, *v22 != 9) )
  {
    sub_1A2B6(1, (__int64)"[EB|`OPT:PCC] ! @ X:XGP %s\n", (__int64)"SupportedBoardIds", v23);
    return -9223372036854775794i64;
  }
  v25 = sub_12D6F((__int64)v22);
  if ( v25 )
  {
    v26 = v25;
    v27 = 0i64;
    while ( 1 )
    {
      v28 = sub_12D9A(v24, v27);
      if ( v28 )
      {
        if ( *(_DWORD *)v28 == 3 && !(unsigned int)sub_18A1A(*(char **)(v28 + 8), v3) )
          break;
      }
      if ( ++v27 >= v26 )
        return v5;
    }
    return 0i64;
  }
  return v5;
}
// 96A98: using guessed type __int64 qword_96A98;
// 96AE0: using guessed type __int64 qword_96AE0;
// 96AE8: using guessed type __int64 qword_96AE8;

//----- (00000000000106AA) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_106AA(__int64 a1, __int64 a2, _WORD *a3, char **a4)
{
  char **v4; // r15
  _WORD *v5; // rdi
  __int64 v6; // r13
  _WORD *v7; // rax
  signed __int64 v8; // rsi
  unsigned __int64 v9; // rdx
  signed __int64 v10; // r12
  __int64 v11; // rax
  int v12; // ebx
  signed __int64 v13; // rsi
  char *v14; // rax
  char *v15; // r14
  char v16; // al
  __int16 v17; // cx
  __int64 v18; // rax
  __int64 v19; // r13
  __int64 v20; // rax
  unsigned __int8 *v21; // rcx
  __int64 v22; // rax
  __int64 v23; // rdi
  __int64 v24; // rax
  __int64 v25; // rsi
  __int64 v26; // rax
  _WORD *v27; // rbx
  __int16 *v28; // rdi
  __int64 v29; // rax
  __int64 v30; // r12
  __int64 v31; // rsi
  char *v32; // rax
  _WORD *v33; // r12
  __int64 v34; // rbx
  bool v35; // sf
  unsigned __int8 *v36; // rax
  _WORD *v37; // rcx
  _WORD *v38; // rsi
  unsigned __int64 v39; // rbx
  bool v40; // cf
  signed __int64 v41; // rbx
  __int16 v42; // dx
  unsigned __int8 *v43; // rax
  _WORD *v44; // rax
  __int16 *v45; // rax
  signed __int64 v46; // rax
  char v47; // cl
  int v48; // eax
  unsigned __int8 *v49; // rdi
  int v50; // esi
  int v51; // ecx
  __int64 v52; // r9
  unsigned __int16 *v53; // rax
  __int64 v54; // r8
  _WORD *v56; // rdi
  signed __int16 v57; // bx
  const __int16 *v58; // rdx
  __int64 v59; // [rsp+30h] [rbp-90h]
  unsigned __int8 *v60; // [rsp+38h] [rbp-88h]
  __int64 v61; // [rsp+48h] [rbp-78h]
  __int64 v62; // [rsp+50h] [rbp-70h]
  __int16 v63; // [rsp+58h] [rbp-68h]
  int v64; // [rsp+5Ch] [rbp-64h]
  __int64 v65; // [rsp+60h] [rbp-60h]
  __int64 v66; // [rsp+68h] [rbp-58h]
  int v67; // [rsp+74h] [rbp-4Ch]
  unsigned __int8 *v68; // [rsp+78h] [rbp-48h]
  unsigned __int64 v69; // [rsp+80h] [rbp-40h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v68 = 0i64;
  v66 = 0i64;
  v69 = 0i64;
  v67 = -1431655766;
  v65 = 0i64;
  v7 = a3 + 1;
  v8 = 4294977024i64;
  while ( 1 )
  {
    v9 = (unsigned __int16)*(v7 - 1);
    if ( v9 > 0x20 || !_bittest64(&v8, v9) )
      break;
    ++v7;
  }
  v59 = a1;
  if ( (unsigned __int16)((v9 & 0xFFDF) - 65) >= 0x1Au && (_WORD)v9 != 47 && (_WORD)v9 != 92 )
    goto LABEL_17;
  while ( 1 )
  {
    v9 = (unsigned __int16)v9;
    if ( (unsigned __int16)v9 > 0x3Du )
      goto LABEL_11;
    if ( _bittest64(&v8, v9) )
      goto LABEL_16;
    if ( !v9 )
      break;
    if ( v9 == 61 )
      goto LABEL_17;
LABEL_11:
    LOWORD(v9) = *v7;
    ++v7;
  }
  --v7;
LABEL_16:
  v5 = v7;
LABEL_17:
  v10 = -9223372036854775799i64;
  v11 = sub_23741(v5);
  v12 = v11;
  v13 = 3 * v11 + 1;
  v69 = 3 * v11 + 1;
  v14 = (char *)sub_1364F(v13);
  if ( !v14 )
    return v10;
  v15 = v14;
  sub_7035((signed __int64)v5, v12, v14, v13, 1);
  if ( !sub_F1CC(v15, "-x", (__int64 *)&v68, (char **)&v69) )
    LOBYTE(qword_96AA8) = qword_96AA8 | 1;
  v16 = sub_10E81(qword_96AD8);
  v17 = qword_96AA8;
  if ( v16 )
  {
    v17 = qword_96AA8 | 4;
    qword_96AA8 |= 4ui64;
  }
  if ( !(v17 & 0x2004) )
  {
    v62 = -6148914691236517206i64;
    v63 = -21846;
    v66 = 10i64;
    v18 = (*(__int64 (__fastcall **)(const char *, __int64 *, int *))(qword_96CE0 + 72))("r", qword_92360, &v67);
    if ( !v18 || v18 == -9223372036854775803i64 )
      qword_96AA8 = qword_96AA8 & 0xFFFFFFFFFFFFF7EEui64 | 0x800;
  }
  v61 = v6;
  v19 = 0i64;
  v66 = 0i64;
  v20 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, int *))(qword_96CE0 + 72))(
          L"boot-args",
          qword_92360,
          &v67);
  v21 = 0i64;
  if ( v20 != -9223372036854775803i64 )
  {
LABEL_31:
    v60 = v21;
    v23 = 0i64;
    v62 = 0i64;
    v64 = -1431655766;
    if ( (*(__int64 (__fastcall **)(const __int16 *, __int64 *))(qword_96CE0 + 72))(
           L"efi-boot-kernelcache-data",
           qword_92360) == -9223372036854775803i64 )
    {
      v24 = sub_1364F(v62);
      if ( v24 )
      {
        v25 = v24;
        v23 = 0i64;
        if ( (*(__int64 (__fastcall **)(const __int16 *, __int64 *, int *, __int64 *, __int64))(qword_96CE0 + 72))(
               L"efi-boot-kernelcache-data",
               qword_92360,
               &v64,
               &v62,
               v24) >= 0 )
          v23 = v25;
      }
      else
      {
        v23 = 0i64;
      }
    }
    qword_96B88 = v23;
    v26 = sub_1364F(2048i64);
    if ( !v26 )
      return v10;
    v27 = (_WORD *)v26;
    sub_F1B0(v26, 2048i64);
    v28 = L"com.apple.Boot.plist";
    v29 = sub_F981(*(_QWORD *)(qword_96A98 + 32), L"com.apple.Boot.plist", 1);
    v30 = v59;
    if ( v29 )
    {
      v31 = v29;
      v32 = sub_FB02(v29, 1);
      if ( v32 )
      {
        v33 = v27;
        v34 = sub_10EBB(v59, v61, (__int64)v32, &v65);
        sub_136C5(v31);
        v35 = v34 < 0;
        v27 = v33;
        v30 = v59;
        if ( !v35 )
          goto LABEL_53;
      }
      else
      {
        sub_136C5(v31);
      }
    }
    if ( sub_F1CC(v15, "config", (__int64 *)&v68, (char **)&v69) )
    {
      if ( !v30 )
        v28 = L"Library\\Preferences\\SystemConfiguration\\com.apple.Boot.plist";
      sub_2370D(v27, v28);
    }
    else
    {
      v36 = v68;
      v37 = v27;
      if ( !v30 )
      {
        v37 = v27;
        if ( *v68 != 47 && *v68 != 92 )
        {
          v56 = v27;
          v37 = v27 + 1;
          v57 = 76;
          v58 = L"ibrary\\Preferences\\SystemConfiguration";
          do
          {
            *(v37 - 1) = v57;
            v57 = *v58;
            ++v58;
            ++v37;
          }
          while ( v57 );
          *(v37 - 1) = 92;
          v27 = v56;
        }
      }
      v38 = v27;
      v39 = v69;
      v40 = v69-- < 1;
      if ( !v40 )
      {
        v41 = v39 - 2;
        do
        {
          v42 = (char)*v36++;
          *v37 = v42;
          ++v37;
          v69 = v41--;
        }
        while ( v41 != -2 );
      }
      sub_2370D(v37, (__int16 *)".");
      v27 = v38;
    }
    sub_10EBB(v30, v61, (__int64)v27, &v65);
LABEL_53:
    v43 = sub_F403(qword_96AA8, (__int64)v15, v60, v65);
    *v4 = (char *)v43;
    if ( !sub_F364((char *)v43, "Kernel Cache", (__int64 *)&v68, (char **)&v69) )
    {
      v44 = sub_7226(v68, v69);
      qword_96B68 = (__int64)v44;
      while ( 1 )
      {
        if ( *v44 == 47 )
        {
          *v44 = 92;
        }
        else if ( !*v44 )
        {
          break;
        }
        ++v44;
      }
    }
    if ( !sub_F364(*v4, "RAM Disk", (__int64 *)&v68, (char **)&v69) )
    {
      v45 = sub_7226(v68, v69);
      qword_96B78 = (__int64)v45;
      if ( v30 )
        qword_96B80 = sub_F981(*(_QWORD *)(qword_96A98 + 32), v45, 1);
    }
    sub_136C5((__int64)v15);
    if ( !sub_F1CC(*v4, "-v", (__int64 *)&v68, (char **)&v69) )
    {
      LOBYTE(qword_96AA8) = qword_96AA8 | 2;
      sub_1A6EF(1u);
    }
    if ( !sub_F1CC(*v4, "-x", (__int64 *)&v68, (char **)&v69) )
      LOBYTE(qword_96AA8) = qword_96AA8 | 1;
    if ( !sub_F1CC(*v4, "-s", (__int64 *)&v68, (char **)&v69) )
      LOBYTE(qword_96AA8) = qword_96AA8 | 0x10;
    if ( !sub_F1CC(*v4, "-no_compat_check", (__int64 *)&v68, (char **)&v69) )
      byte_91FF0 = 0;
    if ( !sub_F1CC(*v4, "-no_panic_dialog", (__int64 *)&v68, (char **)&v69) )
      byte_91FF1 = 0;
    v46 = sub_F1CC(*v4, "debug", (__int64 *)&v68, (char **)&v69);
    v47 = qword_96AA8;
    if ( !v46 )
    {
      v47 = qword_96AA8 | 0x80;
      qword_96AA8 |= 0x80ui64;
    }
    if ( v47 & 1 )
    {
      sub_1000(0xFu);
    }
    else
    {
      if ( sub_F364(*v4, "slide", (__int64 *)&v68, (char **)&v69) || !(unsigned int)sub_1B98C() || !v69 )
        goto LABEL_84;
      v48 = sub_18AE1((char *)v68);
      if ( v48 )
      {
        if ( (unsigned int)(v48 - 1) <= 0xFE )
        {
          qword_96AB8 = sub_10F72(v48);
          dword_92024 = 2;
        }
LABEL_84:
        if ( !sub_F364(*v4, "cpu_subtype", (__int64 *)&v68, (char **)&v69) )
        {
          v49 = v68;
          v50 = v69;
          if ( !(unsigned int)sub_18A43((__int64)v68, (__int64)"x86_64", v69) )
          {
            v51 = 3;
            goto LABEL_89;
          }
          if ( !(unsigned int)sub_18A43((__int64)v49, (__int64)"x86_64h", v50) )
          {
            v51 = 8;
LABEL_89:
            sub_9E8B(v51);
            goto LABEL_90;
          }
        }
LABEL_90:
        if ( qword_96AA8 & 0x1005 )
          qword_96AA8 |= 0x20000ui64;
        if ( !sub_F364(*v4, "kcsuffix", (__int64 *)&v68, (char **)&v69) )
        {
          if ( !v69 || (v53 = sub_7226(v68, v69), (qword_96AC0 = (__int64)v53) == 0) || !v69 || !sub_2378A(v53, "r") )
            BYTE2(qword_96AA8) |= 2u;
        }
        v54 = qword_96AA8;
        if ( qword_96AA8 & 0x10 )
        {
          sub_1000(0x13u);
          LOBYTE(qword_96AA8) = qword_96AA8 | 2;
          sub_1A6EF(1u);
          v54 = qword_96AA8;
        }
        sub_1A2B6(1, (__int64)"[EB|#OPT:BM] 0x%qx\n", v54, v52);
        if ( v19 )
          sub_136C5(v19);
        sub_136C5((__int64)v27);
        return 0i64;
      }
    }
    dword_92024 = 0;
    goto LABEL_84;
  }
  v22 = sub_1364F(++v66);
  if ( v22 )
  {
    v19 = v22;
    if ( (*(__int64 (__fastcall **)(const __int16 *, __int64 *, int *, __int64 *, __int64))(qword_96CE0 + 72))(
           L"boot-args",
           qword_92360,
           &v67,
           &v66,
           v22) < 0 )
    {
      v21 = 0i64;
    }
    else
    {
      *(_BYTE *)(v19 + v66) = 0;
      v21 = (unsigned __int8 *)v19;
    }
    goto LABEL_31;
  }
  return v10;
}
// 107BC: write access to const memory at 96AA8 has been detected
// 107DE: write access to const memory at 96AA8 has been detected
// 10858: write access to const memory at 96AA8 has been detected
// 10974: write access to const memory at 96B88 has been detected
// 10B0A: write access to const memory at 96B68 has been detected
// 10B54: write access to const memory at 96B78 has been detected
// 10B76: write access to const memory at 96B80 has been detected
// 10BA1: write access to const memory at 96AA8 has been detected
// 10BCE: write access to const memory at 96AA8 has been detected
// 10BF1: write access to const memory at 96AA8 has been detected
// 10C14: write access to const memory at 91FF0 has been detected
// 10C37: write access to const memory at 91FF1 has been detected
// 10C68: write access to const memory at 96AA8 has been detected
// 10CCA: write access to const memory at 96AB8 has been detected
// 10CD1: write access to const memory at 92024 has been detected
// 10CE4: write access to const memory at 92024 has been detected
// 10D62: write access to const memory at 96AA8 has been detected
// 10D97: write access to const memory at 96AC0 has been detected
// 10DC0: write access to const memory at 96AAA has been detected
// 10DDB: write access to const memory at 96AA8 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 40DE4: using guessed type __int16 aBootArgs_0[10];
// 40DF8: using guessed type __int16 aEfiBootKernelc[26];
// 40E2C: using guessed type __int16 aComAppleBootPl[21];
// 40E58: using guessed type __int16 aIbraryPreferen[39];
// 40EB4: using guessed type __int16 aLibraryPrefere[61];
// 91FF0: using guessed type char byte_91FF0;
// 91FF1: using guessed type char byte_91FF1;
// 92024: using guessed type int dword_92024;
// 92360: using guessed type __int64 qword_92360[2];
// 96A98: using guessed type __int64 qword_96A98;
// 96AA0: using guessed type __int64 qword_96AA0;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AB8: using guessed type __int64 qword_96AB8;
// 96AC0: using guessed type __int64 qword_96AC0;
// 96AD8: using guessed type __int64 qword_96AD8;
// 96B68: using guessed type __int64 qword_96B68;
// 96B78: using guessed type __int64 qword_96B78;
// 96B80: using guessed type __int64 qword_96B80;
// 96B88: using guessed type __int64 qword_96B88;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000010E81) ----------------------------------------------------
char __fastcall sub_10E81(__int64 a1)
{
  char v1; // al

  while ( 1 )
  {
    v1 = *(_BYTE *)a1 & 0x7F;
    if ( v1 == 3 )
      break;
    if ( v1 == 127 && *(_BYTE *)(a1 + 1) == -1 )
      return 0;
LABEL_6:
    a1 += *(unsigned __int16 *)(a1 + 2);
  }
  if ( *(_BYTE *)(a1 + 1) != 11 )
    goto LABEL_6;
  return 1;
}

//----- (0000000000010EBB) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_10EBB(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // r9
  __int64 v8; // rdi
  __int64 v9; // rax
  __int64 v10; // r9
  __int64 v11; // rdi
  __int64 v13; // [rsp+30h] [rbp-20h]
  __int64 v14; // [rsp+38h] [rbp-18h]

  v4 = a4;
  v13 = 0i64;
  v14 = 0i64;
  v5 = sub_10310(a1, a2, a3, (__int64)&v13, &v14);
  if ( v5 < 0 )
    return v5;
  v6 = sub_12DC6(v14, &qword_93BE0);
  if ( v6 )
  {
    v8 = v6;
    sub_1A2B6(1, (__int64)"[EB|`OPT:LCF] %r @ X:XPF\n", v6, v7);
    qword_93BE0 = 0i64;
  }
  else
  {
    if ( !(qword_96AA8 & 1) )
    {
      v9 = sub_124B2(0i64, "Kernel Flags");
      if ( v9 )
      {
        v11 = v9;
        sub_1A2B6(1, (__int64)"[EB:#KF] (%e)\n", *(_QWORD *)(v9 + 8), v10);
        *v4 = *(_QWORD *)(v11 + 8);
      }
    }
    v8 = 0i64;
  }
  return v8;
}
// 10F13: write access to const memory at 93BE0 has been detected
// 93BE0: using guessed type __int64 qword_93BE0;
// 96AA8: using guessed type __int64 qword_96AA8;

//----- (0000000000010F72) ----------------------------------------------------
__int64 __fastcall sub_10F72(unsigned __int8 a1)
{
  int v1; // er8
  __int64 result; // rax
  unsigned int v8; // edx
  int v9; // ecx
  int v10; // er8

  v1 = a1;
  if ( (a1 & 0x80u) != 0 )
  {
    _RAX = 1i64;
    __asm { cpuid }
    v8 = ((unsigned int)_RAX >> 8) & 0xF;
    if ( v8 == 15 )
      v8 = (unsigned __int8)((unsigned int)_RAX >> 20) + 15;
    v9 = (unsigned __int8)_RAX >> 4;
    if ( v8 == 15 || v8 == 6 )
      v9 |= ((unsigned int)_RAX >> 12) & 0xF0;
    v10 = v1 << 21;
    LODWORD(result) = v10 + 270532608;
    if ( v8 ^ 6 | (v9 | 0x10) ^ 0x3A )
      LODWORD(result) = v10;
  }
  else
  {
    LODWORD(result) = a1 << 21;
  }
  return (unsigned int)result;
}

//----- (0000000000011012) ----------------------------------------------------
__int64 __fastcall sub_11012(_BYTE *a1)
{
  __int64 v1; // rax
  __int64 result; // rax

  v1 = sub_124B2(0i64, a1);
  if ( v1 )
    result = *(_QWORD *)(v1 + 8);
  else
    result = 0i64;
  return result;
}

//----- (000000000001103F) ----------------------------------------------------
__int64 __fastcall sub_1103F(_BYTE *a1)
{
  char **v1; // rax
  __int64 result; // rax

  v1 = (char **)sub_124B2(0i64, a1);
  if ( v1 )
    result = sub_12F48(v1);
  else
    result = 0i64;
  return result;
}

//----- (0000000000011070) ----------------------------------------------------
bool __fastcall sub_11070(char *a1, _BYTE *a2)
{
  _BYTE *v2; // rsi
  char *v3; // rdi
  char v5; // [rsp+27h] [rbp-19h]

  v2 = a2;
  v3 = a1;
  v5 = 0;
  if ( (unsigned int)sub_189FE(a1) != 36 )
    return 0;
  *v2 = sub_111CF(v3, &v5);
  v2[1] = sub_111CF(v3 + 2, &v5);
  v2[2] = sub_111CF(v3 + 4, &v5);
  v2[3] = sub_111CF(v3 + 6, &v5);
  if ( v3[8] != 45 )
    return 0;
  v2[4] = sub_111CF(v3 + 9, &v5);
  v2[5] = sub_111CF(v3 + 11, &v5);
  if ( v3[13] != 45 )
    return 0;
  v2[6] = sub_111CF(v3 + 14, &v5);
  v2[7] = sub_111CF(v3 + 16, &v5);
  if ( v3[18] != 45 )
    return 0;
  v2[8] = sub_111CF(v3 + 19, &v5);
  v2[9] = sub_111CF(v3 + 21, &v5);
  if ( v3[23] != 45 )
    return 0;
  v2[10] = sub_111CF(v3 + 24, &v5);
  v2[11] = sub_111CF(v3 + 26, &v5);
  v2[12] = sub_111CF(v3 + 28, &v5);
  v2[13] = sub_111CF(v3 + 30, &v5);
  v2[14] = sub_111CF(v3 + 32, &v5);
  v2[15] = sub_111CF(v3 + 34, &v5);
  return v5 == 0;
}

//----- (00000000000111CF) ----------------------------------------------------
__int64 __fastcall sub_111CF(char *a1, _BYTE *a2)
{
  int v2; // eax
  int v3; // eax
  __int64 result; // rax
  int v5; // er9
  int v6; // er8

  v2 = *a1;
  if ( (unsigned __int8)(*a1 - 48) > 9u )
  {
    if ( (unsigned __int8)(v2 - 97) > 5u )
    {
      if ( (unsigned __int8)(v2 - 65) > 5u )
      {
        *a2 = 1;
        v3 = 0;
      }
      else
      {
        v3 = v2 - 55;
      }
    }
    else
    {
      v3 = v2 - 87;
    }
  }
  else
  {
    v3 = v2 - 48;
  }
  result = (unsigned int)(16 * v3);
  v5 = (unsigned __int8)a1[1];
  if ( (unsigned __int8)(v5 - 48) <= 9u )
    return (unsigned int)result | (v5 + 208);
  if ( (unsigned __int8)(v5 - 97) <= 5u )
  {
    v6 = (char)v5 + 169;
    return (unsigned int)result | v6;
  }
  if ( (unsigned __int8)(v5 - 65) <= 5u )
  {
    v6 = (char)v5 + 201;
    return (unsigned int)result | v6;
  }
  *a2 = 1;
  return result;
}

//----- (000000000001125C) ----------------------------------------------------
__int64 sub_1125C()
{
  char v5; // cf
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rax
  unsigned __int64 v9; // [rsp+30h] [rbp-10h]

  v9 = -6148914691236517206i64;
  _RAX = 1i64;
  __asm { cpuid }
  v5 = _bittest((const signed int *)&_RCX, 0x1Eu);
  if ( v5 && (unsigned int)sub_21A60(v5, &v9) )
  {
    LOBYTE(v6) = v9;
  }
  else
  {
    v7 = sub_18D72();
    v6 = v7 ^ (v7 >> 8);
    v9 = v7 ^ (v7 >> 8);
  }
  return sub_10F72(v6);
}

//----- (00000000000112D5) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_112D5(char a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    dword_92024 = 0;
    qword_96AB8 = 0i64;
    result = qword_96AA8 & 0xFFFFFFFFFFFFBFFFui64;
  }
  else
  {
    qword_96AB8 = sub_1125C();
    result = qword_96AA8 | 0x4000;
  }
  qword_96AA8 = result;
  return result;
}
// 112E1: write access to const memory at 92024 has been detected
// 112EB: write access to const memory at 96AB8 has been detected
// 11303: write access to const memory at 96AA8 has been detected
// 11324: write access to const memory at 96AB8 has been detected
// 92024: using guessed type int dword_92024;
// 96AA0: using guessed type __int64 qword_96AA0;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AB8: using guessed type __int64 qword_96AB8;

//----- (0000000000011351) ----------------------------------------------------
signed int __fastcall sub_11351(__int64 a1, unsigned __int64 a2, _BYTE **a3)
{
  __int64 v3; // rbx
  _BYTE *v4; // rcx
  unsigned __int64 v5; // rdi
  _BYTE **v6; // rsi
  int v7; // er8

  v3 = a1;
  v4 = *a3;
  if ( !*a3 )
    return 0;
  v5 = a2;
  v6 = a3 + 1;
  while ( 1 )
  {
    v7 = sub_189FE(v4);
    if ( v7 <= v5 && !(unsigned int)sub_18A43(v3, (__int64)*(v6 - 1), v7) )
      break;
    v4 = *v6;
    ++v6;
    if ( !v4 )
      return 0;
  }
  return 1;
}

//----- (00000000000113A9) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_113A9()
{
  const __int16 *v0; // rsi
  __int64 result; // rax
  char v2; // bl
  __int64 v3; // rdi
  __int64 v11; // [rsp+30h] [rbp-30h]
  __int64 v12; // [rsp+38h] [rbp-28h]
  __int64 v13; // [rsp+40h] [rbp-20h]

  v11 = -6148914691236517206i64;
  v12 = -6148914691236517206i64;
  v13 = 0i64;
  v0 = (const __int16 *)"b";
  result = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("b", qword_92360, 0i64);
  v2 = 1;
  if ( result != -9223372036854775803i64 )
  {
    v2 = 0;
    v13 = 0i64;
    v0 = L"bootercfg";
    result = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
               L"bootercfg",
               qword_92360,
               0i64);
    if ( result != -9223372036854775803i64 )
      v0 = 0i64;
  }
  if ( v0 )
  {
    result = v13 - 1;
    if ( (unsigned __int64)(v13 - 1) <= 0x1FF )
    {
      result = sub_1364F(v13 + 1);
      if ( result )
      {
        v3 = result;
        result = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD, __int64 *, __int64))(qword_96CE0 + 72))(
                   v0,
                   qword_92360,
                   0i64,
                   &v13,
                   result);
        if ( result >= 0 )
        {
          *(_BYTE *)(v3 + v13) = 0;
          qword_93BF8 = (__int64)v0;
          qword_93BF0 = v3;
          result = v13;
          qword_93C00 = v13;
        }
      }
    }
  }
  if ( v2 )
    result = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
               "b",
               qword_92360,
               0i64,
               0i64,
               0i64);
  return result;
}
// 11488: write access to const memory at 93BF8 has been detected
// 1148F: write access to const memory at 93BF0 has been detected
// 1149A: write access to const memory at 93C00 has been detected
// 40F5C: using guessed type __int16 aBootercfg[10];
// 92360: using guessed type __int64 qword_92360[2];
// 93BF0: using guessed type __int64 qword_93BF0;
// 93BF8: using guessed type __int64 qword_93BF8;
// 93C00: using guessed type __int64 qword_93C00;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000011577) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
unsigned __int64 sub_11577()
{
  unsigned __int64 result; // rax
  char *v1; // rcx
  char **v2; // rdi
  unsigned __int64 v3; // rsi
  char **v4; // rbx
  __int64 v5; // r12
  __int64 *v6; // rcx
  __int64 v7; // r8
  __int64 v8; // ST38_8
  __int64 v9; // ST28_8
  __int64 v10; // rdx
  char *v11; // r9

  result = (unsigned __int64)sub_1A36C((__int64)"[EB|#CONFIG:SRC] <default>\n");
  v1 = "boot-save-log";
  if ( "boot-save-log" )
  {
    v2 = &off_92468;
    v3 = 0i64;
    do
    {
      result = sub_23811(v1);
      if ( result > v3 )
        v3 = result;
      v1 = *v2;
      v2 += 5;
    }
    while ( v1 );
    if ( "boot-save-log" )
    {
      v4 = &off_92468;
      v5 = 0i64;
      do
      {
        result = *((unsigned int *)v4 - 5);
        if ( (_DWORD)result != 2 || !*((_BYTE *)v4 - 24) )
        {
          v6 = (__int64 *)*(v4 - 1);
          if ( v6 )
            v7 = *v6;
          *((_BYTE *)v4 - 24);
          v8 = (__int64)*(v4 - 2);
          v9 = (__int64)*(v4 - 4);
          v10 = v5++;
          result = (unsigned __int64)sub_1A36C(
                                       (__int64)"[EB|#CONFIG|% 2d] %*s : 0x%016qX (0x%016qX %c 0x%016qX)%s\n",
                                       v10,
                                       v3);
        }
        v11 = *v4;
        v4 += 5;
      }
      while ( v11 );
    }
  }
  return result;
}
// 115D1: write access to const memory at 93BF0 has been detected
// 115D8: write access to const memory at 93C00 has been detected
// 92468: using guessed type char *off_92468;
// 93BF0: using guessed type __int64 qword_93BF0;
// 93BF8: using guessed type __int64 qword_93BF8;
// 93C00: using guessed type __int64 qword_93C00;

//----- (00000000000116D9) ----------------------------------------------------
_BYTE *__fastcall sub_116D9(_BYTE *a1, char *a2, __int64 a3)
{
  __int64 v3; // rax
  unsigned __int64 v4; // r8
  signed __int64 v5; // r11
  unsigned __int64 v6; // r10
  _BYTE *v7; // rax
  __int64 v8; // r10
  unsigned __int64 v9; // rdi
  signed __int64 v10; // rsi
  char v11; // bl
  char v12; // bl

  a3 = (unsigned int)a3;
  v3 = 0i64;
  do
    *((_BYTE *)qword_93C10 + v3++) = 32;
  while ( v3 != 4078 );
  v4 = (unsigned __int64)&a2[a3];
  v5 = 4078i64;
  v6 = 0i64;
  v7 = a1;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( _bittest((const signed int *)&v6, 9u) )
      {
        v6 >>= 1;
      }
      else
      {
        if ( (unsigned __int64)a2 >= v4 )
          return (_BYTE *)(v7 - a1);
        v8 = (unsigned __int8)*a2++;
        v6 = v8 | 0xFF00;
      }
      if ( !(v6 & 1) )
        break;
      if ( (unsigned __int64)a2 >= v4 )
        return (_BYTE *)(v7 - a1);
      v12 = *a2++;
      *v7++ = v12;
      *((_BYTE *)qword_93C10 + v5) = v12;
      v5 = ((_WORD)v5 + 1) & 0xFFF;
    }
    if ( (unsigned __int64)a2 >= v4 || (unsigned __int64)(a2 + 1) >= v4 )
      break;
    v9 = (unsigned __int8)*a2 | (unsigned __int64)(16 * (unsigned __int8)a2[1] & 0xF00);
    v10 = (a2[1] & 0xF) + 3i64;
    do
    {
      v11 = *((_BYTE *)qword_93C10 + (v9 & 0xFFF));
      *v7++ = v11;
      *((_BYTE *)qword_93C10 + v5) = v11;
      v5 = ((_WORD)v5 + 1) & 0xFFF;
      ++v9;
      --v10;
    }
    while ( v10 );
    a2 += 2;
  }
  return (_BYTE *)(v7 - a1);
}
// 93C10: using guessed type __int64 qword_93C10[126];

//----- (00000000000117B5) ----------------------------------------------------
bool sub_117B5()
{
  __int64 v1; // [rsp+28h] [rbp-18h]
  int v2; // [rsp+30h] [rbp-10h]
  char v3; // [rsp+37h] [rbp-9h]

  v2 = -1431655766;
  v3 = 0;
  v1 = 1i64;
  (*(void (__fastcall **)(const __int16 *, __int64 *))(qword_96CE0 + 72))(L"InternalUseOnlyUnit", qword_91F20);
  return v3 == 1;
}
// 40F70: using guessed type __int16 aInternaluseonl[20];
// 91F20: using guessed type __int64[2];
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000011805) ----------------------------------------------------
__int64 sub_11805()
{
  unsigned int v0; // esi
  __int64 v1; // rax
  __int64 v3; // [rsp+28h] [rbp-28h]
  int v4; // [rsp+30h] [rbp-20h]
  unsigned __int8 v5; // [rsp+37h] [rbp-19h]

  v4 = -1431655766;
  v3 = -6148914691236517206i64;
  v5 = -86;
  v0 = 0;
  if ( byte_94C28 == 1 )
  {
    v3 = 1i64;
    v1 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, int *, __int64 *, unsigned __int8 *))(qword_96CE0 + 72))(
           L"SecurityEpoch",
           qword_91F20,
           &v4,
           &v3,
           &v5);
    if ( !(v1 | v3 ^ 1) )
      v0 = v5;
  }
  return v0;
}
// 40F98: using guessed type __int16 aSecurityepoch[14];
// 91F20: using guessed type __int64 qword_91F20[2];
// 94C28: using guessed type char byte_94C28;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000011882) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __usercall sub_11882@<rax>(unsigned int a1@<esi>)
{
  __int64 v1; // rcx

  v1 = qword_94C30;
  if ( !qword_94C30 )
  {
    a1 = 0;
    if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92648, 0i64, &qword_94C30) < 0 )
      return a1;
    v1 = qword_94C30;
  }
  (*(void (__fastcall **)(__int64, char *))(v1 + 16))(v1, &byte_94C38);
  LOBYTE(a1) = byte_94C38;
  if ( byte_94C38 )
  {
    if ( byte_94C38 == -126 )
      byte_94C28 = 1;
    LOBYTE(a1) = 1;
  }
  return a1;
}
// 118DE: write access to const memory at 94C28 has been detected
// 92648: using guessed type __int64 qword_92648[3];
// 94C28: using guessed type char byte_94C28;
// 94C30: using guessed type __int64 qword_94C30;
// 94C38: using guessed type char byte_94C38;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000118F1) ----------------------------------------------------
signed __int64 __fastcall sub_118F1(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 v5; // rdi
  __int64 v6; // rcx
  signed __int64 result; // rax

  v4 = a2;
  v5 = a1;
  v6 = qword_94C30;
  if ( !qword_94C30 )
  {
    result = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(
               qword_92648,
               0i64,
               &qword_94C30);
    if ( result < 0 )
      return result;
    v6 = qword_94C30;
  }
  LOBYTE(a4) = 1;
  return ((*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(v6 + 48))(v6, v5, v4, a4) >> 63) & 0x800000000000001Aui64;
}
// 92648: using guessed type __int64 qword_92648[3];
// 94C30: using guessed type __int64 qword_94C30;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000001195E) ----------------------------------------------------
signed __int64 __fastcall sub_1195E(_QWORD *a1)
{
  signed __int64 result; // rax

  a1[2] = 0i64;
  *a1 = -1167088121787636991i64;
  result = 1167088121787636990i64;
  a1[1] = 1167088121787636990i64;
  return result;
}

//----- (0000000000011987) ----------------------------------------------------
char *__fastcall sub_11987(int *a1, char *a2, unsigned int a3)
{
  unsigned int v3; // esi
  char *v4; // r15
  int *v5; // rbx
  unsigned int v6; // ecx
  int v7; // eax
  __int64 v8; // rdi
  unsigned int v9; // er12
  unsigned int v10; // edi

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = a1[4];
  v7 = v5[5];
  v8 = (v6 >> 3) & 0x3F;
  v5[4] = v6 + 8 * a3;
  if ( __CFADD__(v6, 8 * a3) )
    v5[5] = ++v7;
  v5[5] = v7 + (a3 >> 29);
  v9 = 64 - v8;
  if ( 64 - (signed int)v8 <= a3 )
  {
    sub_1B930((char *)v5 + v8 + 24, a2, v9);
    sub_11A4F(v5, (__int64)(v5 + 6));
    v10 = v8 ^ 0x7F;
    if ( v10 < v3 )
    {
      do
      {
        sub_11A4F(v5, (__int64)&v4[v10 - 63]);
        v10 += 64;
      }
      while ( v10 < v3 );
      v9 = v10 - 63;
    }
    v8 = 0i64;
  }
  else
  {
    v9 = 0;
  }
  return sub_1B930((char *)v5 + v8 + 24, &v4[v9], v3 - v9);
}

//----- (0000000000011A4F) ----------------------------------------------------
__int64 __fastcall sub_11A4F(int *a1, __int64 a2)
{
  int v2; // er8
  __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 v5; // rbx
  __int64 v6; // rax
  int v7; // er8
  int v8; // ebx
  int v9; // edx
  int v10; // esi
  int v11; // edi
  int v12; // eax
  int v13; // ecx
  int v14; // er9
  int v15; // ebx
  int v16; // er11
  int v17; // er8
  int v18; // ecx
  int v19; // esi
  int v20; // eax
  int v21; // er9
  int v22; // er15
  int v23; // er10
  int v24; // ebx
  int v25; // eax
  int v26; // er11
  int v27; // er13
  int v28; // er15
  int v29; // er14
  int v30; // er10
  int v31; // er13
  int v32; // er15
  int v33; // er11
  int v34; // ebx
  int v35; // er13
  int v36; // er15
  int v37; // er14
  int v38; // er10
  int v39; // er13
  int v40; // eax
  int v41; // er15
  int v42; // er14
  int v43; // ebx
  int v44; // er11
  int v45; // ebx
  int v46; // edi
  int v47; // er15
  int v48; // er10
  int v49; // ebx
  int v50; // er14
  int v51; // er11
  int v52; // edi
  int v53; // ebx
  int v54; // er14
  int v55; // er10
  int v56; // edi
  int v57; // ebx
  int v58; // er15
  int v59; // er10
  int v60; // edi
  int v61; // er14
  int v62; // er15
  int v63; // er10
  int v64; // er11
  int v65; // eax
  int v66; // er8
  int v67; // er10
  int v68; // er11
  int v69; // eax
  int v70; // er8
  int v71; // er9
  int v72; // er10
  int v73; // eax
  int v74; // edi
  int v75; // ebx
  int v76; // ecx
  int v77; // eax
  int *v78; // rsi
  __int64 v80; // [rsp+20h] [rbp-F0h]
  __int64 v81; // [rsp+28h] [rbp-E8h]
  __int64 v82; // [rsp+30h] [rbp-E0h]
  __int64 v83; // [rsp+38h] [rbp-D8h]
  __int64 v84; // [rsp+40h] [rbp-D0h]
  __int64 v85; // [rsp+48h] [rbp-C8h]
  __int64 v86; // [rsp+50h] [rbp-C0h]
  __int64 v87; // [rsp+58h] [rbp-B8h]
  int *v88; // [rsp+60h] [rbp-B0h]
  __int64 v89; // [rsp+68h] [rbp-A8h]
  __int64 v90; // [rsp+70h] [rbp-A0h]
  __int64 v91; // [rsp+78h] [rbp-98h]
  __int64 v92; // [rsp+80h] [rbp-90h]
  __int64 v93; // [rsp+88h] [rbp-88h]
  __int64 v94; // [rsp+90h] [rbp-80h]
  __int64 v95; // [rsp+98h] [rbp-78h]
  int v96; // [rsp+A0h] [rbp-70h]
  int v97; // [rsp+A4h] [rbp-6Ch]
  int v98; // [rsp+A8h] [rbp-68h]
  int v99; // [rsp+ACh] [rbp-64h]
  __int64 v100; // [rsp+B0h] [rbp-60h]
  int v101; // [rsp+B8h] [rbp-58h]
  int v102; // [rsp+BCh] [rbp-54h]
  int v103; // [rsp+C0h] [rbp-50h]
  int v104; // [rsp+C4h] [rbp-4Ch]
  int v105; // [rsp+C8h] [rbp-48h]
  int v106; // [rsp+CCh] [rbp-44h]
  int v107; // [rsp+D0h] [rbp-40h]
  int v108; // [rsp+D4h] [rbp-3Ch]

  v2 = *a1;
  v3 = (unsigned int)a1[1];
  v4 = (unsigned int)a1[2];
  v88 = a1;
  v5 = (unsigned int)a1[3];
  v87 = -6148914691236517206i64;
  v86 = -6148914691236517206i64;
  v85 = -6148914691236517206i64;
  v84 = -6148914691236517206i64;
  v83 = -6148914691236517206i64;
  v82 = -6148914691236517206i64;
  v81 = -6148914691236517206i64;
  v80 = -6148914691236517206i64;
  v6 = 0i64;
  do
  {
    *((_DWORD *)&v80 + v6) = *(_DWORD *)(a2 + 4 * v6);
    ++v6;
  }
  while ( v6 != 16 );
  v93 = (unsigned int)v80;
  v100 = HIDWORD(v80);
  v89 = v5;
  v96 = v2;
  v7 = v3 + __ROL4__(v80 + v2 + (v3 & v4 | v5 & ~(_DWORD)v3) - 680876936, 7);
  v90 = v4;
  v8 = v7 + __ROL4__((v3 & v7 | v4 & ~v7) + v5 + HIDWORD(v80) - 389564586, 12);
  v9 = v3;
  v91 = v3;
  v92 = (unsigned int)v81;
  v10 = v8 + __ROL4__((v7 & v8 | v3 & ~v8) + v4 + v81 + 606105819, 17);
  v94 = HIDWORD(v81);
  v11 = v10 + __ROL4__((v8 & v10 | v7 & ~v10) + v9 + HIDWORD(v81) - 1044525330, 22);
  v105 = v82;
  v12 = v11
      + __ROL4__(
          (v10 & (v10 + __ROL4__((v8 & v10 | v7 & ~v10) + v9 + HIDWORD(v81) - 1044525330, 22)) | v8 & ~(v10 + __ROL4__((v8 & v10 | v7 & ~v10) + v9 + HIDWORD(v81) - 1044525330, 22)))
        + v82
        + v7
        - 176418897,
          7);
  v13 = v11 & (v11
             + __ROL4__(
                 (v10 & (v10 + __ROL4__((v8 & v10 | v7 & ~v10) + v9 + HIDWORD(v81) - 1044525330, 22)) | v8 & ~(v10 + __ROL4__((v8 & v10 | v7 & ~v10) + v9 + HIDWORD(v81) - 1044525330, 22)))
               + v82
               + v7
               - 176418897,
                 7)) | v10 & ~v12;
  v95 = HIDWORD(v82);
  v14 = v12 + __ROL4__(v13 + HIDWORD(v82) + v8 + 1200080426, 12);
  v15 = v12 & (v12 + __ROL4__(v13 + HIDWORD(v82) + v8 + 1200080426, 12)) | v11 & ~v14;
  v102 = v83;
  v16 = v14 + __ROL4__(v15 + v83 + v10 - 1473231341, 17);
  v97 = HIDWORD(v83);
  v17 = v16
      + __ROL4__(
          (v14 & (v14 + __ROL4__(v15 + v83 + v10 - 1473231341, 17)) | v12 & ~(v14
                                                                            + __ROL4__(v15 + v83 + v10 - 1473231341, 17)))
        + HIDWORD(v83)
        + v11
        - 45705983,
          22);
  v106 = v84;
  v18 = v17
      + __ROL4__(
          (v16 & (v16
                + __ROL4__(
                    (v14 & (v14 + __ROL4__(v15 + v83 + v10 - 1473231341, 17)) | v12 & ~(v14
                                                                                      + __ROL4__(
                                                                                          v15 + v83 + v10 - 1473231341,
                                                                                          17)))
                  + HIDWORD(v83)
                  + v11
                  - 45705983,
                    22)) | v14 & ~(v16
                                 + __ROL4__(
                                     (v14 & (v14 + __ROL4__(v15 + v83 + v10 - 1473231341, 17)) | v12 & ~(v14 + __ROL4__(v15 + v83 + v10 - 1473231341, 17)))
                                   + HIDWORD(v83)
                                   + v11
                                   - 45705983,
                                     22)))
        + v84
        + v12
        + 1770035416,
          7);
  v19 = v17 & (v17
             + __ROL4__(
                 (v16 & (v16
                       + __ROL4__(
                           (v14 & (v14 + __ROL4__(v15 + v83 + v10 - 1473231341, 17)) | v12 & ~(v14
                                                                                             + __ROL4__(
                                                                                                 v15
                                                                                               + v83
                                                                                               + v10
                                                                                               - 1473231341,
                                                                                                 17)))
                         + HIDWORD(v83)
                         + v11
                         - 45705983,
                           22)) | v14 & ~(v16
                                        + __ROL4__(
                                            (v14 & (v14 + __ROL4__(v15 + v83 + v10 - 1473231341, 17)) | v12 & ~(v14 + __ROL4__(v15 + v83 + v10 - 1473231341, 17)))
                                          + HIDWORD(v83)
                                          + v11
                                          - 45705983,
                                            22)))
               + v84
               + v12
               + 1770035416,
                 7)) | v16 & ~v18;
  v108 = HIDWORD(v84);
  v20 = v18 + __ROL4__(v19 + HIDWORD(v84) + v14 - 1958414417, 12);
  v103 = v85;
  v21 = v20
      + __ROL4__(
          (v18 & (v18 + __ROL4__(v19 + HIDWORD(v84) + v14 - 1958414417, 12)) | v17 & ~(v18
                                                                                     + __ROL4__(
                                                                                         v19
                                                                                       + HIDWORD(v84)
                                                                                       + v14
                                                                                       - 1958414417,
                                                                                         12)))
        + v85
        + v16
        - 42063,
          17);
  v101 = HIDWORD(v85);
  v22 = v21 + __ROL4__((v20 & v21 | v18 & ~v21) + HIDWORD(v85) + v17 - 1990404162, 22);
  v104 = v86;
  v23 = v22
      + __ROL4__(
          (v21 & (v21 + __ROL4__((v20 & v21 | v18 & ~v21) + HIDWORD(v85) + v17 - 1990404162, 22)) | v20 & ~(v21 + __ROL4__((v20 & v21 | v18 & ~v21) + HIDWORD(v85) + v17 - 1990404162, 22)))
        + v86
        + v18
        + 1804603682,
          7);
  v107 = HIDWORD(v86);
  v24 = v23
      + __ROL4__(
          (v22 & (v22
                + __ROL4__(
                    (v21 & (v21 + __ROL4__((v20 & v21 | v18 & ~v21) + HIDWORD(v85) + v17 - 1990404162, 22)) | v20 & ~(v21 + __ROL4__((v20 & v21 | v18 & ~v21) + HIDWORD(v85) + v17 - 1990404162, 22)))
                  + v86
                  + v18
                  + 1804603682,
                    7)) | v21 & ~v23)
        + HIDWORD(v86)
        + v20
        - 40341101,
          12);
  v25 = v24 + __ROL4__((v23 & v24 | ~v24 & v22) + v87 + v21 - 1502002290, 17);
  v26 = ~(v24 + __ROL4__((v23 & v24 | ~v24 & v22) + v87 + v21 - 1502002290, 17));
  v98 = HIDWORD(v87);
  v27 = v25
      + __ROL4__(
          HIDWORD(v87)
        + v22
        + (v24 & (v24 + __ROL4__((v23 & v24 | ~v24 & v22) + v87 + v21 - 1502002290, 17)) | v26 & v23)
        + 1236535329,
          22);
  v28 = v27 + __ROL4__((v24 & v27 | v25 & ~v24) + HIDWORD(v80) + v23 - 165796510, 5);
  v29 = v28
      + __ROL4__(
          (v25 & (v27 + __ROL4__((v24 & v27 | v25 & ~v24) + HIDWORD(v80) + v23 - 165796510, 5)) | v27 & v26)
        + v83
        + v24
        - 1069501632,
          9);
  v30 = v29
      + __ROL4__(
          (v27 & (v28
                + __ROL4__(
                    (v25 & (v27 + __ROL4__((v24 & v27 | v25 & ~v24) + HIDWORD(v80) + v23 - 165796510, 5)) | v27 & v26)
                  + v83
                  + v24
                  - 1069501632,
                    9)) | v28 & ~v27)
        + HIDWORD(v85)
        + v25
        + 643717713,
          14);
  v31 = v30 + __ROL4__((v28 & v30 | v29 & ~v28) + v80 + v27 - 373897302, 20);
  v32 = v31 + __ROL4__((v29 & v31 | v30 & ~v29) + HIDWORD(v82) + v28 - 701558691, 5);
  v33 = v32 + __ROL4__((v30 & v32 | v31 & ~v30) + v85 + v29 + 38016083, 9);
  v34 = v33
      + __ROL4__(
          (v31 & (v32 + __ROL4__((v30 & v32 | v31 & ~v30) + v85 + v29 + 38016083, 9)) | v32 & ~v31)
        + HIDWORD(v87)
        + v30
        - 660478335,
          14);
  v35 = v34
      + __ROL4__(
          (v32 & (v33
                + __ROL4__(
                    (v31 & (v32 + __ROL4__((v30 & v32 | v31 & ~v30) + v85 + v29 + 38016083, 9)) | v32 & ~v31)
                  + HIDWORD(v87)
                  + v30
                  - 660478335,
                    14)) | v33 & ~v32)
        + v82
        + v31
        - 405537848,
          20);
  v36 = v35 + __ROL4__((v33 & v35 | v34 & ~v33) + HIDWORD(v84) + v32 + 568446438, 5);
  v99 = v87;
  v37 = v36 + __ROL4__((v34 & v36 | v35 & ~v34) + v87 + v33 - 1019803690, 9);
  v38 = v37
      + __ROL4__(
          (v35 & (v36 + __ROL4__((v34 & v36 | v35 & ~v34) + v87 + v33 - 1019803690, 9)) | v36 & ~v35)
        + HIDWORD(v81)
        + v34
        - 187363961,
          14);
  v39 = v38
      + __ROL4__(
          (v36 & (v37
                + __ROL4__(
                    (v35 & (v36 + __ROL4__((v34 & v36 | v35 & ~v34) + v87 + v33 - 1019803690, 9)) | v36 & ~v35)
                  + HIDWORD(v81)
                  + v34
                  - 187363961,
                    14)) | v37 & ~v36)
        + v84
        + v35
        + 1163531501,
          20);
  v40 = v39 + __ROL4__((v37 & v39 | v38 & ~v37) + HIDWORD(v86) + v36 - 1444681467, 5);
  v41 = v40
      + __ROL4__(
          (v38 & (v39 + __ROL4__((v37 & v39 | v38 & ~v37) + HIDWORD(v86) + v36 - 1444681467, 5)) | v39 & ~v38)
        + v81
        + v37
        - 51403784,
          9);
  v42 = v41 + __ROL4__((v39 & v41 | v40 & ~v39) + HIDWORD(v83) + v38 + 1735328473, 14);
  v43 = v40 & (v41 + __ROL4__((v39 & v41 | v40 & ~v39) + HIDWORD(v83) + v38 + 1735328473, 14));
  v44 = v42 + __ROL4__((v43 | v41 & ~v40) + v86 + v39 - 1926607734, 20);
  v45 = v42 ^ (v42 + __ROL4__((v43 | v41 & ~v40) + v86 + v39 - 1926607734, 20));
  v46 = v44 + __ROL4__((v41 ^ v45) + HIDWORD(v82) + v40 - 378558, 4);
  v47 = v46 + __ROL4__((v46 ^ v45) + v84 + v41 - 2022574463, 11);
  v48 = v47 + __ROL4__((v47 ^ v44 ^ v46) + HIDWORD(v85) + v42 + 1839030562, 16);
  v49 = v48 + __ROL4__((v48 ^ v46 ^ v47) + v87 + v44 - 35309556, 23);
  v50 = v49
      + __ROL4__(
          (v49 ^ v47 ^ (v47 + __ROL4__((v47 ^ v44 ^ v46) + HIDWORD(v85) + v42 + 1839030562, 16)))
        + HIDWORD(v80)
        + v46
        - 1530992060,
          4);
  v51 = v50
      + __ROL4__(
          (v50 ^ v48 ^ (v48 + __ROL4__((v48 ^ v46 ^ v47) + v87 + v44 - 35309556, 23))) + v82 + v47 + 1272893353,
          11);
  v52 = v51 + __ROL4__((v51 ^ v49 ^ v50) + HIDWORD(v83) + v48 - 155497632, 16);
  v53 = v52 + __ROL4__((v52 ^ v50 ^ v51) + v85 + v49 - 1094730640, 23);
  v54 = v53 + __ROL4__((v53 ^ v51 ^ v52) + HIDWORD(v86) + v50 + 681279174, 4);
  v55 = v54 + __ROL4__((v54 ^ v52 ^ v53) + v80 + v51 - 358537222, 11);
  v56 = v55 + __ROL4__((v55 ^ v53 ^ v54) + HIDWORD(v81) + v52 - 722521979, 16);
  v57 = v56 + __ROL4__((v56 ^ v54 ^ v55) + v83 + v53 + 76029189, 23);
  v58 = v57 + __ROL4__((v57 ^ v55 ^ v56) + HIDWORD(v84) + v54 - 640364487, 4);
  v59 = v58 + __ROL4__((v58 ^ v56 ^ v57) + v86 + v55 - 421815835, 11);
  v60 = v59 + __ROL4__((v59 ^ v57 ^ v58) + HIDWORD(v87) + v56 + 530742520, 16);
  v61 = v60 + __ROL4__((v60 ^ v58 ^ v59) + v81 + v57 - 995338651, 23);
  v62 = v61 + __ROL4__((v60 ^ (v61 | ~v59)) + v80 + v58 - 198630844, 6);
  v63 = v62 + __ROL4__((v61 ^ (v62 | ~v60)) + HIDWORD(v83) + v59 + 1126891415, 10);
  v64 = v63 + __ROL4__((v62 ^ (v63 | ~v61)) + v87 + v60 - 1416354905, 15);
  v65 = v64 + __ROL4__((v63 ^ (v64 | ~v62)) + HIDWORD(v82) + v61 - 57434055, 21);
  v66 = v65 + __ROL4__((v64 ^ (v65 | ~v63)) + v86 + v62 + 1700485571, 6);
  v67 = v66 + __ROL4__((v65 ^ (v66 | ~v64)) + HIDWORD(v81) + v63 - 1894986606, 10);
  v68 = v67 + __ROL4__((v66 ^ (v67 | ~v65)) + v85 + v64 - 1051523, 15);
  v69 = v68 + __ROL4__((v67 ^ (v68 | ~v66)) + HIDWORD(v80) + v65 - 2054922799, 21);
  v70 = v69 + __ROL4__((v68 ^ (v69 | ~v67)) + v84 + v66 + 1873313359, 6);
  v71 = v70 + __ROL4__((v69 ^ (v70 | ~v68)) + HIDWORD(v87) + v67 - 30611744, 10);
  v72 = v71 + __ROL4__((v70 ^ (v71 | ~v69)) + v83 + v68 - 1560198380, 15);
  v73 = v72 + __ROL4__((v71 ^ (v72 | ~v70)) + HIDWORD(v86) + v69 + 1309151649, 21);
  v74 = v73 + __ROL4__((v72 ^ (v73 | ~v71)) + v82 + v70 - 145523070, 6);
  v75 = v74 + __ROL4__((v73 ^ (v74 | ~v72)) + HIDWORD(v85) + v71 - 1120210379, 10);
  v76 = v75 + __ROL4__((v74 ^ (v75 | ~v73)) + v81 + v72 + 718787259, 15);
  v77 = (v75 ^ (v76 | ~v74)) + HIDWORD(v84) + v73 - 343485551;
  v78 = v88;
  *v88 = v96 + v74;
  v78[1] = __ROL4__(v77, 21) + v76 + v91;
  v78[2] = v90 + v76;
  v78[3] = v89 + v75;
  return sub_F180((char *)&v80, 0, 0x40ui64);
}

//----- (00000000000123E7) ----------------------------------------------------
char *__fastcall sub_123E7(int *a1)
{
  int *v1; // rsi
  __int64 v2; // rax
  __int64 v4; // [rsp+20h] [rbp-10h]

  v1 = a1;
  v4 = -6148914691236517206i64;
  v2 = 0i64;
  do
  {
    *((_DWORD *)&v4 + v2) = a1[v2 + 4];
    ++v2;
  }
  while ( v2 != 2 );
  sub_11987(
    a1,
    (char *)qword_92660,
    (((((unsigned int)a1[4] >> 3) & 0x3F) > 0x37) << 6) - (((unsigned int)a1[4] >> 3) & 0x3F) + 56);
  return sub_11987(v1, (char *)&v4, 8u);
}
// 92660: using guessed type __int64 qword_92660[8];

//----- (000000000001245A) ----------------------------------------------------
__int64 __fastcall sub_1245A(__int64 a1, int *a2)
{
  char *v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // rax

  v2 = (char *)a2;
  v3 = a1;
  sub_123E7(a2);
  v4 = 0i64;
  do
  {
    *(_BYTE *)(v3 + 4 * v4) = v2[4 * v4];
    *(_BYTE *)(v3 + 4 * v4 + 1) = v2[4 * v4 + 1];
    *(_BYTE *)(v3 + 4 * v4 + 2) = v2[4 * v4 + 2];
    *(_BYTE *)(v3 + 4 * v4 + 3) = v2[4 * v4 + 3];
    ++v4;
  }
  while ( v4 != 4 );
  return sub_F180(v2, 0, 0x58ui64);
}

//----- (00000000000124B2) ----------------------------------------------------
__int64 __fastcall sub_124B2(__int64 a1, _BYTE *a2)
{
  _QWORD *v2; // rbx
  _BYTE *v3; // rdi
  __int64 v4; // r14
  char *v5; // rcx
  _QWORD *v6; // rsi

  if ( !a1 )
    return 0i64;
  if ( *(_DWORD *)a1 != 1 )
    return 0i64;
  v2 = *(_QWORD **)(a1 + 40);
  if ( !v2 )
    return 0i64;
  v3 = a2;
  v4 = 0i64;
  while ( 1 )
  {
    v5 = (char *)v2[1];
    v6 = (_QWORD *)v2[6];
    if ( v5 )
    {
      if ( !(unsigned int)sub_18A1A(v5, v3) )
        break;
    }
    v2 = v6;
    if ( !v6 )
      return v4;
  }
  return v2[5];
}

//----- (0000000000012512) ----------------------------------------------------
signed __int64 __fastcall sub_12512(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // r14
  __int64 v3; // rbx
  signed __int64 v4; // r15
  signed __int64 v5; // rax
  signed __int64 v6; // rdi
  __int64 v7; // rsi
  _DWORD *v9; // [rsp+28h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  v4 = -9223372036854775794i64;
  v9 = (_DWORD *)-6148914691236517206i64;
  v5 = sub_125A2(a1, (__int64 *)&v9);
  if ( v5 == -1 )
    return v4;
  v6 = v5;
  v7 = 0i64;
  while ( !v9 )
  {
LABEL_6:
    v7 += v6;
    v6 = sub_125A2(v3 + v7, (__int64 *)&v9);
    if ( v6 == -1 )
      return v4;
  }
  if ( *v9 != 9 )
  {
    sub_12C84((__int64)v9);
    goto LABEL_6;
  }
  if ( v6 >= 0 )
  {
    *v2 = v9;
    v4 = 0i64;
  }
  return v4;
}

//----- (00000000000125A2) ----------------------------------------------------
signed __int64 __fastcall sub_125A2(__int64 a1, __int64 *a2)
{
  __int64 *v2; // r13
  __int64 v3; // rbx
  __int64 i; // rax
  char v5; // cl
  __int64 v6; // rsi
  char v7; // cl
  char *v8; // rdi
  int v9; // eax
  __int64 v10; // r14
  signed __int64 v11; // rdi
  _BYTE *v12; // rdi
  signed __int64 v13; // rax
  signed __int64 v14; // r12
  __int64 v15; // rax
  char v16; // cl
  __int64 v18; // rcx
  __int64 *v19; // rdx
  int v20; // er8
  __int64 v21; // r9
  char *v22; // rdi
  signed __int64 v23; // rax
  signed __int64 v24; // r14
  __int64 v25; // rax
  __int64 v26; // r15
  __int64 v27; // rax
  __int64 v28; // rbx
  signed __int64 v29; // rax
  char *v30; // rbx
  signed __int64 v31; // rax
  __int64 v32; // rax
  signed __int64 v33; // rax
  signed int v34; // ecx
  _BYTE *v35; // rdi
  signed __int64 v36; // rax
  char v37; // cl
  signed __int64 v38; // rax
  char *v39; // rax
  char v40; // dl
  int v41; // er15
  unsigned __int64 v42; // r8
  signed int v43; // er14
  __int64 v44; // rdi
  char *v45; // r11
  __int64 v46; // rdx
  int v47; // edi
  int v48; // edx
  int v49; // ecx
  signed __int64 v50; // r11
  char *v51; // rax
  char *v52; // ST38_8
  signed __int64 v53; // rax
  __int64 v54; // rax
  _BYTE *v55; // rbx
  signed __int64 v56; // r9
  __int64 v57; // rdi
  __int64 v58; // rax
  signed __int64 v59; // rdx
  __int64 v60; // rax
  char *v61; // rdi
  unsigned __int64 v62; // rbx
  _BYTE *v63; // rbx
  signed __int64 v64; // r9
  __int64 v65; // rdi
  signed __int64 v66; // [rsp+30h] [rbp-70h]
  unsigned __int64 v67; // [rsp+40h] [rbp-60h]
  __int64 v68; // [rsp+48h] [rbp-58h]
  unsigned __int64 v69; // [rsp+50h] [rbp-50h]
  char *v70; // [rsp+58h] [rbp-48h]
  int v71; // [rsp+60h] [rbp-40h]
  int v72; // [rsp+64h] [rbp-3Ch]

  v2 = a2;
  v3 = a1;
  for ( i = 0i64; ; ++i )
  {
    v5 = *(_BYTE *)(v3 + i);
    if ( !v5 )
      return -1i64;
    if ( v5 == 60 )
      break;
  }
  v6 = i;
  do
  {
    v7 = *(_BYTE *)(v3 + v6 + 1);
    if ( !v7 )
      return -1i64;
    ++v6;
  }
  while ( v7 != 62 );
  v8 = (char *)(v3 + i + 1);
  *(_BYTE *)(v3 + v6) = 0;
  if ( !(unsigned int)sub_18A43((__int64)v8, (__int64)"plist ", 6) )
  {
    v11 = 0i64;
    return v11 + v6 + 1;
  }
  if ( !(unsigned int)sub_18A1A(v8, "dict") )
  {
    v18 = v3 + v6 + 1;
    v19 = v2;
    v20 = 1;
LABEL_29:
    v21 = 0i64;
    goto LABEL_31;
  }
  if ( !(unsigned int)sub_18A1A(v8, "dict/") )
  {
    v18 = v3 + v6 + 1;
    v21 = 1i64;
    v19 = v2;
    v20 = 1;
    goto LABEL_31;
  }
  if ( !(unsigned int)sub_18A1A(v8, "key") )
  {
    v22 = (char *)(v3 + v6 + 1);
    v68 = -6148914691236517206i64;
    v23 = sub_132DD((__int64)v22, "key");
    v14 = -1i64;
    if ( v23 != -1 )
    {
      v24 = v23;
      sub_1335D((char *)(v3 + v6 + 1));
      v25 = sub_125A2(v6 + v24 + v3 + 1, &v68);
      if ( v25 != -1 )
      {
        v26 = v25;
        v27 = sub_13260();
        if ( v27 )
        {
          v28 = v27;
          v29 = sub_1349D(v22);
          *(_DWORD *)v28 = 2;
          *(_QWORD *)(v28 + 8) = v29;
          *(_QWORD *)(v28 + 16) = 0i64;
          *(_QWORD *)(v28 + 24) = 0i64;
          *(_QWORD *)(v28 + 32) = 0i64;
          *(_QWORD *)(v28 + 40) = v68;
          *(_QWORD *)(v28 + 48) = 0i64;
          *v2 = v28;
          v14 = v24 + v26;
        }
        else
        {
          sub_12C84(v68);
        }
      }
    }
    goto LABEL_32;
  }
  if ( !(unsigned int)sub_18A1A(v8, "string") )
  {
    v30 = (char *)(v6 + v3 + 1);
    v31 = sub_132DD((__int64)v30, "string");
    if ( v31 == -1 )
      return -1i64;
    v11 = v31;
    sub_1335D(v30);
    v32 = sub_13260();
    if ( !v32 )
      return -1i64;
    v10 = v32;
    v33 = sub_1349D(v30);
    v34 = 3;
    goto LABEL_86;
  }
  if ( !(unsigned int)sub_18A1A(v8, "integer") )
  {
    v35 = (_BYTE *)(v3 + v6 + 1);
    v36 = sub_132DD((__int64)v35, "integer");
    if ( v36 != -1 )
    {
      v14 = v36;
      v15 = sub_13260();
      if ( v15 )
      {
        while ( 1 )
        {
          v37 = *v35;
          if ( *v35 != 32 && v37 != 9 )
            break;
          ++v35;
        }
        v55 = v35 + 1;
        if ( v37 != 45 )
          v55 = v35;
        v56 = 0i64;
        while ( 1 )
        {
          v57 = (char)*v55;
          if ( (*v55 | 0x20) == 32 )
            break;
          if ( (unsigned __int8)(v57 - 48) > 9u )
          {
            v56 = 0i64;
            break;
          }
          v56 = v57 + 10 * v56 - 48;
          ++v55;
        }
        v59 = -v56;
        if ( v37 != 45 )
          v59 = v56;
        *(_DWORD *)v15 = 4;
        goto LABEL_82;
      }
    }
    return -1i64;
  }
  if ( !(unsigned int)sub_18A1A(v8, "data") )
  {
    v38 = sub_132DD(v3 + v6 + 1, "data");
    if ( v38 == -1 )
      return -1i64;
    v14 = v38;
    v39 = (char *)sub_1364F(4096i64);
    v40 = *(_BYTE *)(v3 + v6 + 1);
    v41 = 0;
    if ( v40 )
    {
      v69 = 0i64;
      v42 = 0i64;
      v71 = 0;
      v72 = 0;
      v43 = 0;
      while ( 1 )
      {
        v44 = v41++;
        v45 = (char *)(v3 + v6 + v44 + 2);
        while ( 1 )
        {
          v46 = v40 & 0x7F;
          v47 = v43 + 1;
          v43 = 0;
          if ( (_BYTE)v46 == 61 )
            v43 = v47;
          v48 = *((char *)qword_8EFC0 + v46);
          if ( v48 >= 0 )
            break;
          v40 = *v45;
          ++v41;
          ++v45;
          if ( !v40 )
            goto LABEL_89;
        }
        v49 = v48 + (v72 << 6);
        ++v71;
        v72 = v48 + (v72 << 6);
        if ( !(v71 & 3) )
        {
          v50 = v42 + 2;
          if ( v69 <= v42 + 2 )
          {
            v66 = v42 + 2;
            v67 = v42;
            v70 = v39;
            v69 += 4096i64;
            v51 = (char *)sub_1364F(v69);
            if ( !v51 )
            {
              sub_136C5((__int64)v70);
              return -1i64;
            }
            v52 = v51;
            sub_1B930(v51, v70, v67);
            sub_136C5((__int64)v70);
            v42 = v67;
            v39 = v52;
            v49 = v72;
            v50 = v66;
          }
          v39[v42] = BYTE2(v49);
          if ( v43 > 1 )
          {
            v43 = v47;
            ++v42;
          }
          else
          {
            v39[v42 + 1] = BYTE1(v49);
            if ( v43 == 1 )
            {
              v43 = 1;
              v42 = v50;
            }
            else
            {
              v39[v42 + 2] = v49;
              v42 += 3i64;
            }
          }
        }
        v40 = *(_BYTE *)(v6 + v3 + v41 + 1);
        if ( !v40 )
          goto LABEL_89;
      }
    }
    v42 = 0i64;
LABEL_89:
    if ( v39 )
    {
      v61 = v39;
      v62 = v42;
      v15 = sub_13260();
      if ( v15 )
      {
        *(_DWORD *)v15 = 5;
        *(_QWORD *)(v15 + 8) = 0i64;
        *(_QWORD *)(v15 + 16) = 0i64;
        *(_QWORD *)(v15 + 24) = v61;
        *(_QWORD *)(v15 + 32) = v62;
        goto LABEL_92;
      }
    }
    return -1i64;
  }
  if ( !(unsigned int)sub_18A1A(v8, "date") )
  {
    v53 = sub_132DD(v3 + v6 + 1, "date");
    if ( v53 == -1 )
      return -1i64;
    v11 = v53;
    v54 = sub_13260();
    if ( !v54 )
      return -1i64;
    v10 = v54;
    v34 = 6;
    v33 = 0i64;
    goto LABEL_86;
  }
  if ( !(unsigned int)sub_18A1A(v8, "false/") )
  {
    v58 = sub_13260();
    if ( !v58 )
      return -1i64;
    v10 = v58;
    v34 = 7;
LABEL_85:
    v33 = 0i64;
    v11 = 0i64;
LABEL_86:
    *(_DWORD *)v10 = v34;
    *(_QWORD *)(v10 + 8) = v33;
    *(_QWORD *)(v10 + 16) = 0i64;
    *(_QWORD *)(v10 + 24) = 0i64;
    *(_QWORD *)(v10 + 32) = 0i64;
    *(_QWORD *)(v10 + 40) = 0i64;
    *(_QWORD *)(v10 + 48) = 0i64;
LABEL_87:
    *v2 = v10;
    return v11 + v6 + 1;
  }
  if ( !(unsigned int)sub_18A1A(v8, "true/") )
  {
    v60 = sub_13260();
    if ( !v60 )
      return -1i64;
    v10 = v60;
    v34 = 8;
    goto LABEL_85;
  }
  if ( !(unsigned int)sub_18A1A(v8, "array") )
  {
    v18 = v3 + v6 + 1;
    v19 = v2;
    v20 = 9;
    goto LABEL_29;
  }
  if ( (unsigned int)sub_18A1A(v8, "array/") )
  {
    v9 = sub_18A1A(v8, "real");
    v10 = 0i64;
    v11 = 0i64;
    if ( !v9 )
    {
      v12 = (_BYTE *)(v3 + v6 + 1);
      v13 = sub_132DD((__int64)v12, "real");
      if ( v13 != -1 )
      {
        v14 = v13;
        v15 = sub_13260();
        if ( v15 )
        {
          while ( 1 )
          {
            v16 = *v12;
            if ( *v12 != 32 && v16 != 9 )
              break;
            ++v12;
          }
          v63 = v12 + 1;
          if ( v16 != 45 )
            v63 = v12;
          v64 = 0i64;
          while ( 1 )
          {
            v65 = (char)*v63;
            if ( (*v63 | 0x20) == 32 )
              break;
            if ( (unsigned __int8)(v65 - 48) > 9u )
            {
              v64 = 0i64;
              break;
            }
            v64 = v65 + 10 * v64 - 48;
            ++v63;
          }
          v59 = -v64;
          if ( v16 != 45 )
            v59 = v64;
          *(_DWORD *)v15 = 10;
LABEL_82:
          *(_QWORD *)(v15 + 8) = 0i64;
          *(_QWORD *)(v15 + 16) = v59;
          *(_QWORD *)(v15 + 24) = 0i64;
          *(_QWORD *)(v15 + 32) = 0i64;
LABEL_92:
          *(_QWORD *)(v15 + 40) = 0i64;
          *(_QWORD *)(v15 + 48) = 0i64;
          *v2 = v15;
          goto LABEL_32;
        }
      }
      return -1i64;
    }
    goto LABEL_87;
  }
  v18 = v3 + v6 + 1;
  v21 = 1i64;
  v19 = v2;
  v20 = 9;
LABEL_31:
  v14 = sub_12E56(v18, v19, v20, v21);
LABEL_32:
  if ( v14 == -1 )
    return -1i64;
  return v14 + v6 + 1;
}
// 8EFC0: using guessed type __int64 qword_8EFC0[16];

//----- (0000000000012C84) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_12C84(__int64 a1)
{
  __int64 v1; // rsi
  int v2; // eax
  _BYTE *v3; // r14
  __int64 v4; // rdi
  __int64 v5; // rbx
  bool v6; // zf
  __int64 *v7; // rax
  __int64 v8; // rcx

  if ( a1 )
  {
    v1 = a1;
    v2 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 == 3 )
    {
      v3 = *(_BYTE **)(a1 + 8);
      if ( v3 )
      {
        v4 = qword_94C48;
        if ( qword_94C48 )
        {
          if ( (unsigned int)sub_18A1A((char *)(qword_94C48 + 16), *(_BYTE **)(a1 + 8)) )
          {
            while ( 1 )
            {
              v5 = v4;
              v4 = *(_QWORD *)(v4 + 8);
              if ( !v4 )
                break;
              if ( !(unsigned int)sub_18A1A((char *)(v4 + 16), v3) )
                goto LABEL_10;
            }
          }
          else
          {
            v5 = 0i64;
LABEL_10:
            v6 = (*(_QWORD *)v4)-- == 1i64;
            if ( v6 )
            {
              v7 = (__int64 *)(v5 + 8);
              if ( !v5 )
                v7 = &qword_94C48;
              *v7 = *(_QWORD *)(v4 + 8);
              sub_136C5(v4);
            }
          }
        }
      }
      v2 = *(_DWORD *)v1;
    }
    if ( v2 == 5 )
    {
      v8 = *(_QWORD *)(v1 + 24);
      if ( v8 )
        sub_136C5(v8);
    }
    sub_12C84(*(_QWORD *)(v1 + 40));
    sub_12C84(*(_QWORD *)(v1 + 48));
    *(_DWORD *)v1 = 0;
    *(_QWORD *)(v1 + 8) = 0i64;
    *(_QWORD *)(v1 + 16) = 0i64;
    *(_QWORD *)(v1 + 24) = 0i64;
    *(_QWORD *)(v1 + 32) = 0i64;
    *(_QWORD *)(v1 + 40) = 0i64;
    *(_QWORD *)(v1 + 48) = qword_94C40;
    qword_94C40 = v1;
  }
}
// 12D5D: write access to const memory at 94C40 has been detected
// 94C40: using guessed type __int64 qword_94C40;
// 94C48: using guessed type __int64 qword_94C48;

//----- (0000000000012D6F) ----------------------------------------------------
__int64 __fastcall sub_12D6F(__int64 a1)
{
  __int64 v1; // rcx
  __int64 result; // rax

  if ( !a1 )
    return 0i64;
  if ( *(_DWORD *)a1 != 9 )
    return 0i64;
  v1 = *(_QWORD *)(a1 + 40);
  if ( !v1 )
    return 0i64;
  result = 0i64;
  do
  {
    ++result;
    v1 = *(_QWORD *)(v1 + 48);
  }
  while ( v1 );
  return result;
}

//----- (0000000000012D9A) ----------------------------------------------------
__int64 __fastcall sub_12D9A(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  signed __int64 v3; // rdx

  if ( !a1 )
    return 0i64;
  if ( *(_DWORD *)a1 != 9 )
    return 0i64;
  result = *(_QWORD *)(a1 + 40);
  if ( !result )
    return 0i64;
  v3 = a2 + 1;
  while ( --v3 )
  {
    result = *(_QWORD *)(result + 48);
    if ( !result )
      return 0i64;
  }
  return result;
}

//----- (0000000000012DC6) ----------------------------------------------------
signed __int64 __fastcall sub_12DC6(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // r14
  __int64 v3; // rbx
  signed __int64 v4; // r15
  signed __int64 v5; // rax
  signed __int64 v6; // rdi
  __int64 v7; // rsi
  _DWORD *v9; // [rsp+28h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  v4 = -9223372036854775794i64;
  v9 = (_DWORD *)-6148914691236517206i64;
  v5 = sub_125A2(a1, (__int64 *)&v9);
  if ( v5 == -1 )
    return v4;
  v6 = v5;
  v7 = 0i64;
  while ( !v9 )
  {
LABEL_6:
    v7 += v6;
    v6 = sub_125A2(v3 + v7, (__int64 *)&v9);
    if ( v6 == -1 )
      return v4;
  }
  if ( *v9 != 1 )
  {
    sub_12C84((__int64)v9);
    goto LABEL_6;
  }
  if ( v6 >= 0 )
  {
    *v2 = v9;
    v4 = 0i64;
  }
  return v4;
}

//----- (0000000000012E56) ----------------------------------------------------
signed __int64 __fastcall sub_12E56(__int64 a1, __int64 *a2, int a3, __int64 a4)
{
  int v4; // er15
  __int64 *v5; // rsi
  __int64 v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // r13
  signed __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rsi
  __int64 v13; // r14
  __int64 v14; // rcx
  __int64 *v16; // [rsp+28h] [rbp-48h]
  __int64 v17; // [rsp+30h] [rbp-40h]

  v4 = a3;
  v5 = a2;
  v17 = -6148914691236517206i64;
  v6 = 0i64;
  v7 = 0i64;
  if ( !a4 )
  {
    v9 = a1;
    v10 = sub_125A2(a1, &v17);
    if ( v10 == -1 )
    {
      v13 = 0i64;
LABEL_13:
      v14 = v13;
      goto LABEL_14;
    }
    v16 = v5;
    v7 = 0i64;
    v11 = 0i64;
    v6 = 0i64;
    while ( 1 )
    {
      v6 += v10;
      v12 = v17;
      if ( !v17 )
        break;
      v13 = v17;
      if ( v7 )
      {
        *(_QWORD *)(v11 + 48) = v17;
        v13 = v7;
      }
      v10 = sub_125A2(v6 + v9, &v17);
      v7 = v13;
      v11 = v12;
      if ( v10 == -1 )
        goto LABEL_13;
    }
    v5 = v16;
  }
  v8 = sub_13260();
  v17 = v8;
  if ( !v8 )
  {
    v14 = v7;
LABEL_14:
    sub_12C84(v14);
    return -1i64;
  }
  *(_DWORD *)v8 = v4;
  *(_QWORD *)(v8 + 8) = 0i64;
  *(_QWORD *)(v8 + 16) = 0i64;
  *(_QWORD *)(v8 + 24) = 0i64;
  *(_QWORD *)(v8 + 32) = 0i64;
  *(_QWORD *)(v8 + 40) = v7;
  *(_QWORD *)(v8 + 48) = 0i64;
  *v5 = v8;
  return v6;
}

//----- (0000000000012F48) ----------------------------------------------------
__int64 __fastcall sub_12F48(char **a1)
{
  __int128 v2; // [rsp+30h] [rbp-20h]
  __int64 v3; // [rsp+40h] [rbp-10h]

  v2 = 0ui64;
  v3 = 0i64;
  sub_12F82(a1, (char **)&v2, (unsigned __int64 *)&v2 + 1, &v3, 0);
  return v2;
}

//----- (0000000000012F82) ----------------------------------------------------
char *__fastcall sub_12F82(char **a1, char **a2, unsigned __int64 *a3, __int64 *a4, signed int a5)
{
  char *result; // rax
  char **v6; // rsi
  __int64 *v7; // r14
  unsigned __int64 *v8; // r13
  char **v9; // rbx
  unsigned __int64 v10; // rax
  const char *v11; // rdi
  int v12; // eax
  unsigned int v13; // ecx
  char v14; // di
  char *v15; // r15
  __int64 v16; // rax
  __int64 v17; // rdi
  bool v18; // zf
  __int64 v19; // [rsp+30h] [rbp-90h]
  __int64 v20; // [rsp+38h] [rbp-88h]
  __int64 v21; // [rsp+40h] [rbp-80h]
  __int64 v22; // [rsp+48h] [rbp-78h]
  __int64 v23; // [rsp+50h] [rbp-70h]
  __int64 v24; // [rsp+58h] [rbp-68h]
  __int64 v25; // [rsp+60h] [rbp-60h]
  __int64 v26; // [rsp+68h] [rbp-58h]
  const char *v27; // [rsp+78h] [rbp-48h]
  int v28; // [rsp+84h] [rbp-3Ch]

  result = (char *)-6148914691236517206i64;
  v26 = -6148914691236517206i64;
  v25 = -6148914691236517206i64;
  v24 = -6148914691236517206i64;
  v23 = -6148914691236517206i64;
  v22 = -6148914691236517206i64;
  v21 = -6148914691236517206i64;
  v20 = -6148914691236517206i64;
  v19 = -6148914691236517206i64;
  if ( a5 <= 16 )
  {
    v6 = a1;
    if ( a1 )
    {
      v7 = a4;
      v8 = a3;
      v9 = a2;
      v28 = a5 + 1;
      do
      {
        v10 = *(signed int *)v6;
        v11 = "unknown";
        if ( v10 <= 0xA )
          v11 = off_91580[v10];
        sub_18905((unsigned __int64)&v19, (__int64)"<%s", v11);
        sub_13536(v9, v8, v7, (char *)&v19, 0);
        v12 = *(_DWORD *)v6;
        v13 = *(_DWORD *)v6 & 0xFFFFFFFE;
        v27 = v11;
        if ( v13 == 2 )
        {
          sub_13536(v9, v8, v7, ">", 0);
          sub_13536(v9, v8, v7, v6[1], 1);
          v12 = *(_DWORD *)v6;
          v14 = 1;
        }
        else
        {
          v14 = 0;
        }
        if ( v12 == 4 )
        {
          v14 = 1;
          sub_13536(v9, v8, v7, ">", 0);
          sub_18905((unsigned __int64)&v19, (__int64)"%ld", v6[2]);
          sub_13536(v9, v8, v7, (char *)&v19, 0);
          v12 = *(_DWORD *)v6;
        }
        if ( v12 == 5 )
        {
          sub_13536(v9, v8, v7, " format=\"hex\">", 0);
          v14 = 1;
          if ( v6[4] )
          {
            v15 = 0i64;
            do
            {
              sub_18905((unsigned __int64)&v19, (__int64)"%02x", (unsigned __int8)v15[(_QWORD)v6[3]]);
              sub_13536(v9, v8, v7, (char *)&v19, 0);
              v16 = (unsigned __int8)v15++ & 3;
              if ( v16 == 3 && v15 != v6[4] )
                sub_13536(v9, v8, v7, " ", 0);
            }
            while ( v15 < v6[4] );
          }
        }
        if ( v6[5] )
        {
          if ( !v14 )
            sub_13536(v9, v8, v7, ">", 0);
          v17 = (__int64)v27;
          if ( *(_DWORD *)v6 != 2 )
          {
            sub_12F82((unsigned __int64)v6[5]);
LABEL_26:
            sub_18905((unsigned __int64)&v19, (__int64)"</%s>", v17);
            result = sub_13536(v9, v8, v7, (char *)&v19, 0);
            goto LABEL_27;
          }
          sub_18905((unsigned __int64)&v19, (__int64)"</%s>", v27);
          sub_13536(v9, v8, v7, (char *)&v19, 0);
          result = (char *)sub_12F82((unsigned __int64)v6[5]);
        }
        else
        {
          v18 = v14 == 0;
          v17 = (__int64)v27;
          if ( !v18 )
            goto LABEL_26;
          result = sub_13536(v9, v8, v7, "/>", 0);
        }
LABEL_27:
        v6 = (char **)v6[6];
      }
      while ( v6 );
    }
  }
  return result;
}
// 91580: using guessed type char *off_91580[11];

//----- (0000000000013260) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13260()
{
  __int64 result; // rax
  __int64 v1; // rdx

  result = qword_94C40;
  if ( qword_94C40 )
    goto LABEL_6;
  result = sub_1364F((__int64)&loc_38000);
  if ( result )
  {
    v1 = 0i64;
    do
    {
      *(_DWORD *)(result + v1) = 0;
      *(_QWORD *)(result + v1 + 8) = 0i64;
      *(_QWORD *)(result + v1 + 40) = 0i64;
      *(_QWORD *)(result + v1 + 48) = result + 56 + v1;
      v1 += 56i64;
    }
    while ( v1 != 229376 );
    *(_QWORD *)(result + 229368) = 0i64;
    qword_94C40 = result;
LABEL_6:
    qword_94C40 = *(_QWORD *)(result + 48);
    return result;
  }
  return 0i64;
}
// 132C1: write access to const memory at 94C40 has been detected
// 132CC: write access to const memory at 94C40 has been detected
// 94C40: using guessed type __int64 qword_94C40;

//----- (00000000000132DD) ----------------------------------------------------
signed __int64 __fastcall sub_132DD(__int64 a1, _BYTE *a2)
{
  _BYTE *v2; // r14
  __int64 v3; // rbx
  signed __int64 v4; // r15
  __int64 v5; // rsi
  char *v6; // rdi
  __int64 v7; // rax
  char v8; // cl
  char v9; // al

  v2 = a2;
  v3 = a1;
  v4 = a1 + 2;
  v5 = 0i64;
LABEL_2:
  v6 = (char *)(v4 + v5++);
  v7 = 0i64;
  while ( 1 )
  {
    v8 = *(v6 - 2);
    if ( !v8 )
      return -1i64;
    if ( v8 == 60 )
    {
      while ( 1 )
      {
        v9 = *(_BYTE *)(v3 + v5);
        if ( !v9 )
          return -1i64;
        ++v5;
        if ( v9 == 62 )
        {
          *(_BYTE *)(v3 + v5 - 1) = 0;
          if ( *(v6 - 1) == 47 && !(unsigned int)sub_18A1A(v6, v2) )
          {
            *(v6 - 2) = 0;
            return v5;
          }
          goto LABEL_2;
        }
      }
    }
    ++v7;
    ++v6;
    ++v5;
  }
}

//----- (000000000001335D) ----------------------------------------------------
char __fastcall sub_1335D(char *a1)
{
  char *v1; // rsi
  signed __int64 v2; // rax
  char v3; // cl
  signed __int64 v4; // r15
  char *v5; // rdi
  char v6; // dl
  signed __int64 v7; // rbx
  char *v8; // r14
  char v9; // dl
  unsigned __int8 v10; // cl
  char v11; // cl
  signed __int64 v12; // rbx
  const char **v13; // r13
  const char *v14; // rdx
  __int64 v15; // r14
  char *v16; // r15

  v1 = a1;
  LODWORD(v2) = (unsigned __int64)sub_189FE(a1) + 1;
  if ( (_DWORD)v2 )
  {
    v3 = *v1;
    if ( *v1 )
    {
      v4 = (signed int)v2;
      while ( 1 )
      {
        if ( v3 == 38 )
        {
          v5 = v1 + 1;
          do
          {
            LOBYTE(v2) = *v5;
            v6 = (*v5 == 59) ^ (*v5 != 0);
            ++v5;
          }
          while ( v6 );
          if ( (_BYTE)v2 == 59 )
          {
            v7 = v5 - v1;
            v8 = v1 + 1;
            if ( v1[1] == 35 )
            {
              if ( v7 != 3 )
              {
                v2 = 3i64;
                v9 = 0;
                while ( 1 )
                {
                  v10 = v1[v2 - 1] - 48;
                  if ( v10 > 9u )
                    goto LABEL_24;
                  v11 = 10 * v9 + v10;
                  ++v2;
                  v9 = v11;
                  if ( v7 == v2 )
                    goto LABEL_20;
                }
              }
              v11 = 0;
LABEL_20:
              *v1 = v11;
            }
            else
            {
              v12 = v7 - 2;
              v13 = (const char **)&off_91508;
              v14 = "amp";
              while ( 1 )
              {
                if ( *(v13 - 2) == (const char *)v12 )
                {
                  LODWORD(v2) = sub_18A43((__int64)(v1 + 1), (__int64)v14, v12);
                  if ( !(_DWORD)v2 )
                    break;
                }
                v14 = *v13;
                v13 += 3;
                if ( !v14 )
                  goto LABEL_24;
              }
              v15 = (signed int)sub_189FE(*(v13 - 1));
              LOBYTE(v2) = sub_18A90((__int64)v1, (__int64)*(v13 - 1), v15);
              if ( !(_DWORD)v15 )
                goto LABEL_24;
              v8 = &v1[v15];
            }
            v16 = &v1[v4];
            LOBYTE(v2) = (unsigned __int64)sub_1B930(v8, v5, v16 - v5);
            v4 = v16 - v8;
            v1 = v8 - 1;
          }
        }
LABEL_24:
        if ( --v4 )
        {
          v3 = (v1++)[1];
          if ( v3 )
            continue;
        }
        return v2;
      }
    }
  }
  return v2;
}
// 91508: using guessed type char *off_91508;

//----- (000000000001349D) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_1349D(char *a1)
{
  char *v1; // rdi
  __int64 i; // rsi
  __int64 v3; // rbx

  v1 = a1;
  for ( i = qword_94C48; i; i = *(_QWORD *)(i + 8) )
  {
    if ( !(unsigned int)sub_18A1A((char *)(i + 16), v1) )
      goto LABEL_8;
  }
  v3 = (signed int)sub_189FE(v1) + 17i64;
  i = sub_1364F(v3);
  if ( !i )
    sub_9CE0((__int64)"[EB|#STOP|`X:NS] ! @ B:BMA %qd @ 'S\n", v3);
  *(_QWORD *)i = 0i64;
  sub_18A75((char *)(i + 16), v1);
  *(_QWORD *)(i + 8) = qword_94C48;
  qword_94C48 = i;
LABEL_8:
  ++*(_QWORD *)i;
  return i + 16;
}
// 1351C: write access to const memory at 94C48 has been detected
// 94C48: using guessed type __int64 qword_94C48;

//----- (0000000000013536) ----------------------------------------------------
char *__fastcall sub_13536(char **a1, unsigned __int64 *a2, __int64 *a3, char *a4, char a5)
{
  char *v5; // rsi
  __int64 *v6; // r14
  unsigned __int64 *v7; // rdi
  char **v8; // r15
  char *result; // rax
  unsigned __int64 v10; // rcx
  const char *v11; // r13
  __int64 v12; // rcx
  char *v13; // rbx
  char v14; // cl
  int v15; // edx
  signed __int64 v16; // rcx
  bool v17; // zf

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  result = &(*a1)[*a3];
  v10 = *a2;
  v11 = 0i64;
  while ( 1 )
  {
    if ( !v10 || v10 >= (unsigned __int64)result )
    {
      v12 = *v6 + 4096;
      *v6 = v12;
      result = (char *)sub_1364F(v12);
      if ( !result )
        return result;
      v13 = result;
      sub_1B950(*v8, result, *v7 - (_QWORD)*v8);
      sub_136C5((__int64)*v8);
      *v7 = (unsigned __int64)&v13[*v7 - (_QWORD)*v8];
      *v8 = v13;
      result = &v13[*v6];
    }
    if ( v11 || !a5 )
      break;
    v14 = *v5;
    v15 = *v5;
    if ( v15 == 38 )
    {
      v11 = "&amp;";
    }
    else
    {
      v11 = "&lt;";
      if ( v15 != 60 )
      {
        if ( v15 != 62 )
          goto LABEL_14;
        v11 = "&gt;";
      }
    }
LABEL_17:
    *(_BYTE *)*v7 = *v11;
    v16 = (signed __int64)(v5 + 1);
    v17 = (v11++)[1] == 0;
    if ( !v17 )
      v16 = (signed __int64)v5;
    if ( v17 )
      v11 = 0i64;
    v5 = (char *)v16;
LABEL_22:
    v10 = *v7 + 1;
    *v7 = v10;
  }
  if ( v11 )
    goto LABEL_17;
  v14 = *v5;
LABEL_14:
  *(_BYTE *)*v7 = v14;
  if ( *v5 )
  {
    ++v5;
    v11 = 0i64;
    goto LABEL_22;
  }
  return result;
}

//----- (000000000001364F) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_1364F(__int64 a1)
{
  __int64 v1; // rsi
  _QWORD *v2; // rax

  v1 = sub_24103(a1);
  v2 = (_QWORD *)sub_138C6();
  *v2 = v1;
  v2[2] = 0i64;
  v2[1] = 0i64;
  v2[3] = qword_94C50;
  qword_94C50 = (__int64)v2;
  return v1;
}
// 1367D: write access to const memory at 94C50 has been detected
// 94C50: using guessed type __int64 qword_94C50;

//----- (000000000001368E) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_QWORD *__fastcall sub_1368E(__int64 a1)
{
  __int64 v1; // rsi
  _QWORD *result; // rax

  v1 = a1;
  result = (_QWORD *)sub_138C6();
  *result = v1;
  result[2] = 0i64;
  result[1] = 0i64;
  result[3] = qword_94C50;
  qword_94C50 = (__int64)result;
  return result;
}
// 136B7: write access to const memory at 94C50 has been detected
// 94C50: using guessed type __int64 qword_94C50;

//----- (00000000000136C5) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_136C5(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rsi
  __int64 v3; // r8
  __int64 v4; // r9
  _QWORD *v5; // rax
  __int64 v6; // rcx
  __int64 v7; // rdx
  __int64 *v8; // rcx

  v1 = a1;
  v2 = (*(__int64 (**)(void))(qword_96CD8 + 72))();
  if ( v2 >= 0 )
  {
    v5 = (_QWORD *)qword_94C50;
    if ( !qword_94C50 )
    {
LABEL_8:
      sub_1A2B6(1, (__int64)"[EB|`M:BMF] UK\n", v3, v4);
      return v2;
    }
    if ( *(_QWORD *)qword_94C50 != v1 )
    {
      v6 = qword_94C50;
      while ( 1 )
      {
        v5 = *(_QWORD **)(v6 + 24);
        if ( !v5 )
          goto LABEL_8;
        v7 = v6;
        v6 = *(_QWORD *)(v6 + 24);
        if ( *v5 == v1 )
          goto LABEL_10;
      }
    }
    v7 = 0i64;
LABEL_10:
    v8 = (__int64 *)(v7 + 24);
    if ( !v7 )
      v8 = &qword_94C50;
    *v8 = v5[3];
    v5[3] = qword_94C60;
    qword_94C60 = (__int64)v5;
  }
  return v2;
}
// 13747: write access to const memory at 94C60 has been detected
// 94C50: using guessed type __int64 qword_94C50;
// 94C60: using guessed type __int64 qword_94C60;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000013759) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13759(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 *v4; // rbx
  __int64 v5; // rsi
  __int64 v6; // rdi
  __int64 v7; // rbx
  _QWORD *v8; // rax

  v4 = a4;
  v5 = a3;
  v6 = (*(__int64 (__fastcall **)(__int64, __int64))(qword_96CD8 + 40))(a1, a2);
  if ( v6 >= 0 )
  {
    v7 = *v4;
    v8 = (_QWORD *)sub_138C6();
    *v8 = 0i64;
    v8[2] = v7;
    v8[1] = v5;
    v8[3] = qword_94C50;
    qword_94C50 = (__int64)v8;
  }
  return v6;
}
// 1379E: write access to const memory at 94C50 has been detected
// 94C50: using guessed type __int64 qword_94C50;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000137B1) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_137B1(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rsi
  __int64 v5; // r9
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 *v9; // rcx

  v2 = a2;
  v3 = a1;
  v4 = (*(__int64 (**)(void))(qword_96CD8 + 48))();
  if ( v4 < 0 )
    return v4;
  v6 = qword_94C50;
  if ( !qword_94C50 )
  {
LABEL_11:
    sub_1A2B6(1, (__int64)"[EB|`M:BFP] UK (%qd)\n", v2, v5);
    return v4;
  }
  if ( *(_QWORD *)(qword_94C50 + 16) != v3 )
  {
    v8 = qword_94C50;
    while ( 1 )
    {
      v6 = *(_QWORD *)(v8 + 24);
      if ( !v6 )
        goto LABEL_11;
      v7 = v8;
      v8 = *(_QWORD *)(v8 + 24);
      if ( *(_QWORD *)(v6 + 16) == v3 )
        goto LABEL_8;
    }
  }
  v7 = 0i64;
LABEL_8:
  v9 = (__int64 *)(v7 + 24);
  if ( !v7 )
    v9 = &qword_94C50;
  *v9 = *(_QWORD *)(v6 + 24);
  *(_QWORD *)(v6 + 24) = qword_94C60;
  qword_94C60 = v6;
  return v4;
}
// 13826: write access to const memory at 94C60 has been detected
// 94C50: using guessed type __int64 qword_94C50;
// 94C60: using guessed type __int64 qword_94C60;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000001384F) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_1384F()
{
  _QWORD *i; // rsi
  __int64 *v1; // rsi
  __int64 v2; // rcx
  __int64 result; // rax

  for ( i = (_QWORD *)qword_94C50; i; i = (_QWORD *)i[3] )
  {
    if ( *i )
      (*(void (**)(void))(qword_96CD8 + 72))();
    else
      (*(void (__fastcall **)(_QWORD, _QWORD))(qword_96CD8 + 48))(i[2], i[1]);
  }
  v1 = (__int64 *)qword_94C58;
  while ( v1 )
  {
    v2 = *v1;
    v1 = (__int64 *)v1[3];
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v2);
  }
  result = 0i64;
  qword_94C50 = 0i64;
  qword_94C58 = (unsigned __int8)qword_94C50;
  qword_94C60 = (unsigned __int8)qword_94C50;
  return result;
}
// 138AA: write access to const memory at 94C50 has been detected
// 138B1: write access to const memory at 94C58 has been detected
// 138B8: write access to const memory at 94C60 has been detected
// 94C50: using guessed type __int64 qword_94C50;
// 94C58: using guessed type __int64 qword_94C58;
// 94C60: using guessed type __int64 qword_94C60;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000138C6) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 sub_138C6()
{
  signed __int64 result; // rax
  __int64 v1; // rcx
  _QWORD *v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rdx

  result = qword_94C60;
  if ( qword_94C60 )
  {
    v1 = *(_QWORD *)(qword_94C60 + 24);
  }
  else
  {
    v2 = (_QWORD *)sub_24103(4096i64);
    if ( !v2 )
      sub_9CE0((__int64)"[EB|#STOP|`M:GT] ! ELAP\n");
    v3 = qword_94C60;
    v4 = 0i64;
    do
    {
      v1 = v3;
      v3 = (__int64)&v2[v4];
      v2[v4 + 3] = v1;
      v4 += 4i64;
    }
    while ( v4 != 508 );
    result = (signed __int64)(v2 + 504);
    qword_94C60 = (__int64)(v2 + 504);
    v2[508] = v2;
    v2[510] = 0i64;
    v2[509] = 0i64;
    v2[511] = qword_94C58;
    qword_94C58 = (__int64)(v2 + 508);
  }
  qword_94C60 = v1;
  *(_QWORD *)(result + 24) = 0i64;
  return result;
}
// 1392A: write access to const memory at 94C60 has been detected
// 13954: write access to const memory at 94C58 has been detected
// 1395B: write access to const memory at 94C60 has been detected
// 94C58: using guessed type __int64 qword_94C58;
// 94C60: using guessed type __int64 qword_94C60;

//----- (0000000000013980) ----------------------------------------------------
__int64 __usercall sub_13980@<rax>(char a1@<cf>, _QWORD *a2@<rcx>)
{
  signed int v2; // edx

  v2 = 10;
  do
  {
    __asm { rdseed  rax }
    if ( a1 )
      break;
    _mm_pause();
    --v2;
  }
  while ( v2 );
  *a2 = _RAX;
  return (unsigned int)a1;
}

//----- (000000000001399B) ----------------------------------------------------
__int64 __fastcall sub_1399B(_DWORD *a1, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5, int a6, unsigned int a7, char a8, char a9, __int64 a10)
{
  _DWORD *v10; // r14
  unsigned int v11; // ecx
  __int64 v12; // rdi
  unsigned int v13; // ebx
  __int64 v14; // r8
  int v15; // er15
  __int64 v16; // rdx
  __int64 v18; // r13
  __int64 v19; // r15
  __int64 v20; // r14
  __int64 v21; // r8
  __int64 v22; // rax
  unsigned int *v23; // r9
  unsigned __int64 v24; // rcx
  int v25; // er10
  unsigned int v26; // er11
  __int16 v27; // bx
  __int16 v28; // r12
  unsigned int v29; // esi
  unsigned int v30; // er10
  unsigned int v31; // eax
  int v32; // er8
  int v33; // edx
  unsigned int v34; // edx
  int v35; // esi
  __int16 v36; // di
  __int16 v37; // r12
  __int16 v38; // bx
  __int16 v39; // dx
  __int16 v40; // ax
  __int16 v41; // bx
  __int16 v42; // dx
  __int64 v43; // rax
  signed __int64 v44; // r12
  _WORD *v45; // rsi
  __int64 v46; // rcx
  __int64 v47; // rdx
  int v48; // er13
  __int64 v49; // r11
  __int64 v50; // r9
  unsigned int *v51; // rsi
  int v52; // ebx
  unsigned int v53; // eax
  unsigned int v54; // er8
  unsigned int v55; // ebx
  __int128 v56; // [rsp+20h] [rbp-B0h]
  _DWORD *v57; // [rsp+30h] [rbp-A0h]
  __int64 v58; // [rsp+38h] [rbp-98h]
  int v59; // [rsp+44h] [rbp-8Ch]
  unsigned int v60; // [rsp+48h] [rbp-88h]
  unsigned int v61; // [rsp+4Ch] [rbp-84h]
  __int64 v62; // [rsp+50h] [rbp-80h]
  __int64 v63; // [rsp+58h] [rbp-78h]
  _DWORD *v64; // [rsp+60h] [rbp-70h]
  unsigned __int64 v65; // [rsp+68h] [rbp-68h]
  __int64 v66; // [rsp+70h] [rbp-60h]
  _DWORD *v67; // [rsp+78h] [rbp-58h]
  unsigned int v68; // [rsp+84h] [rbp-4Ch]
  __int64 v69; // [rsp+88h] [rbp-48h]
  __int64 v70; // [rsp+90h] [rbp-40h]

  v66 = a3;
  v10 = a1;
  v11 = *a1;
  if ( v11 <= a2 || v10[1] != (_DWORD)a4 )
    goto LABEL_9;
  LODWORD(v12) = 0;
  if ( a6 != 4 || v10[2] != a5 )
    return (unsigned int)v12;
  v13 = a2;
  v14 = a4;
  v15 = v10[3];
  if ( v15 != 32 && v15 != 30 )
    goto LABEL_9;
  v16 = a7;
  if ( !a8 )
  {
    v63 = a7;
    v67 = v10;
    v65 = (unsigned int)a4;
    v58 = 4i64 * (unsigned int)a4;
    v70 = a4;
    v62 = sub_1364F(4i64 * (unsigned int)a4);
    v70 = (unsigned int)(v70 + 2);
    v12 = sub_1364F(2 * v70);
    v18 = sub_1364F(2 * v70);
    v19 = sub_1364F(2 * v70);
    v20 = sub_1364F(2 * v70);
    v64 = (_DWORD *)v12;
    sub_F1B0(v12, 2 * v70);
    sub_F1B0(v18, 2 * v70);
    sub_F1B0(v19, 2 * v70);
    sub_F1B0(v20, 2 * v70);
    v21 = v70;
    v60 = a5 + 2;
    if ( a5 == -2 )
    {
LABEL_33:
      sub_136C5(v20);
      sub_136C5(v19);
      sub_136C5(v18);
      sub_136C5((__int64)v64);
      sub_136C5(v62);
      LOBYTE(v12) = 1;
      return (unsigned int)v12;
    }
    v63 = (unsigned int)v63 >> 2;
    v59 = v67[3];
    v57 = &v67[a5 * v13 + 21];
    v61 = a5 - 1;
    LODWORD(v69) = 0;
    while ( !(_DWORD)v21 )
    {
LABEL_30:
      if ( (unsigned int)v69 >= 2 )
      {
        (*(void (__fastcall **)(__int64, __int64, __int64))(qword_96CD8 + 352))(v66, v62, v58);
        v21 = v70;
        v66 += 4 * v63;
      }
      LODWORD(v69) = v69 + 1;
      if ( (_DWORD)v69 == v60 )
        goto LABEL_33;
    }
    v22 = v61;
    if ( (unsigned int)v69 < a5 )
      v22 = (unsigned int)v69;
    v23 = (_DWORD *)((char *)v67 + (unsigned int)v57[v22]);
    v68 = -1431655766;
    v24 = 0i64;
    v25 = 0;
    v26 = -1431655766;
    v27 = 0;
    v28 = 0;
    LOWORD(v12) = 0;
    v29 = 0;
    while ( 1 )
    {
      if ( v24 < v65 )
      {
        if ( !v25 )
        {
          v30 = *v23;
          ++v23;
          v68 = v30 & 0xFF000000;
          v25 = (v30 & 0xFFFFFF) - 1;
          goto LABEL_22;
        }
        --v25;
        if ( !v68 )
        {
          v68 = 0;
LABEL_22:
          v31 = *v23;
          if ( v59 == 30 )
          {
            v32 = 13933 * (unsigned __int8)(v31 >> 2) + 46871 * (unsigned __int8)(v31 >> 12);
            v33 = 4732 * (unsigned __int8)(v31 >> 22);
          }
          else
          {
            v32 = 13933 * BYTE2(v31);
            v33 = 46871 * BYTE1(v31) + 4732 * (unsigned __int8)v31;
          }
          v34 = v32 + v33;
          v21 = v70;
          ++v23;
          v26 = (19661 * (v34 >> 16) + 6750208) >> 16;
          goto LABEL_26;
        }
      }
LABEL_26:
      v35 = v26 + v29;
      v36 = v35 + v12;
      v37 = v36 + v28;
      v38 = v37 + v27;
      v39 = v38 + *((_WORD *)v64 + v24);
      *((_WORD *)v64 + v24) = v38;
      v40 = v39 + *(_WORD *)(v18 + 2 * v24);
      *(_WORD *)(v18 + 2 * v24) = v39;
      v41 = v40 + *(_WORD *)(v19 + 2 * v24);
      *(_WORD *)(v19 + 2 * v24) = v40;
      v42 = *(_WORD *)(v20 + 2 * v24);
      *(_WORD *)(v20 + 2 * v24) = v41;
      if ( (unsigned int)v69 >= 2 && v24 >= 2 )
        *(_DWORD *)(v62 + 4 * v24 - 8) = ((unsigned __int16)(v42 + v41 + 128) >> 8) | ((unsigned __int8)((unsigned __int16)(v42 + v41 + 128) >> 8) << 8) | ((unsigned __int8)((unsigned __int16)(v42 + v41 + 128) >> 8) << 16);
      ++v24;
      v27 = v37;
      v28 = v36;
      LODWORD(v12) = v35;
      v29 = v26;
      if ( v21 == v24 )
        goto LABEL_30;
    }
  }
  if ( a7 & 0xF )
  {
LABEL_9:
    LODWORD(v12) = 0;
    return (unsigned int)v12;
  }
  if ( a9 )
  {
    v12 = a4;
    v43 = (*(__int64 (__fastcall **)(signed __int64))(qword_96CD8 + 24))(31i64);
    v14 = v12;
    v65 = v43;
    v11 = *v10;
    v15 = v10[3];
  }
  else
  {
    v65 = 0i64;
  }
  v56 = xmmword_8F040;
  v44 = (signed __int64)&v10[a5 * v11 + 21];
  v67 = v10;
  if ( a10 )
  {
    LODWORD(v12) = v13;
    v45 = (_WORD *)(a10 + 4096);
    v46 = 0i64;
    do
    {
      v47 = (unsigned int)v46 / 0x3FF;
      *(v45 - 2048) = *(unsigned __int8 *)(v44 + v47) | (unsigned __int16)(*(unsigned __int8 *)(v44 + v47) << 8);
      *(v45 - 1024) = *(unsigned __int8 *)(v44 + v47 + 256) | (unsigned __int16)(*(unsigned __int8 *)(v44 + v47 + 256) << 8);
      v16 = *(unsigned __int8 *)(v44 + v47 + 512) | ((unsigned int)*(unsigned __int8 *)(v44 + v47 + 512) << 8);
      *v45 = v16;
      v46 += 255i64;
      ++v45;
    }
    while ( v46 != 261120 );
    v44 = 0i64;
  }
  if ( a5 )
  {
    v64 = &v67[a5 * v13 + 21];
    v69 = a5;
    v48 = -(signed int)v14;
    v49 = 0i64;
    while ( 1 )
    {
      v50 = v14;
      if ( (_DWORD)v14 )
        break;
LABEL_57:
      v66 += 16i64 * (a7 >> 4);
      ++v49;
      v14 = v50;
      if ( v49 == v69 )
        goto LABEL_58;
    }
    v51 = (_DWORD *)((char *)v67 + (unsigned int)v64[v49]);
    LODWORD(v12) = -1431655766;
    v52 = 0;
    v53 = -1431655766;
    v54 = 0;
    while ( v52 )
    {
      --v52;
      if ( !(_DWORD)v12 )
      {
        LODWORD(v12) = 0;
LABEL_49:
        v53 = *v51;
        if ( v15 == 30 )
          v53 = (unsigned __int8)(v53 >> 22) | (v53 >> 4) & 0xFF00 | (v53 << 14) & 0xFF0000;
        ++v51;
        if ( v44 )
          v53 = (*(unsigned __int8 *)(v44 + BYTE2(v53)) << 16) | (*(unsigned __int8 *)(v44 + BYTE1(v53) + 256) << 8) | *(unsigned __int8 *)(v44 + (unsigned __int8)v53 + 512);
      }
      v16 = v54 & 3;
      *((_DWORD *)&v56 + v16) = v53;
      if ( v54 + v48 == -1 || (_DWORD)v16 == 3 )
      {
        v16 = v66;
        *(_OWORD *)(v66 + 16i64 * (v54 >> 2)) = v56;
      }
      if ( !(++v54 + v48) )
        goto LABEL_57;
    }
    v55 = *v51;
    ++v51;
    LODWORD(v12) = v55 & 0xFF000000;
    v52 = (v55 & 0xFFFFFF) - 1;
    goto LABEL_49;
  }
LABEL_58:
  LOBYTE(v12) = 1;
  if ( a9 )
    (*(void (__fastcall **)(unsigned __int64, __int64, __int64))(qword_96CD8 + 32))(v65, v16, v14);
  return (unsigned int)v12;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 8F040: using guessed type __int128 xmmword_8F040;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000013F31) ----------------------------------------------------
__int64 sub_13F31()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  unsigned __int64 v2; // r15
  __int64 v3; // r14
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // r12
  __int64 v8; // rax
  __int64 v9; // r9
  __int64 v10; // rsi
  __int64 v11; // rax
  __int64 v12; // r9
  char *v13; // r13
  __int64 v14; // rax
  int v15; // eax
  __int64 v16; // rdi
  unsigned __int64 v17; // rcx
  __int64 v18; // rax
  __int64 v19; // rdi
  __int64 v20; // rcx
  unsigned int v21; // eax
  unsigned int v22; // edx
  bool v23; // cf
  int v24; // edx
  unsigned __int64 v25; // rdi
  char *v26; // rdx
  void (__fastcall *v27)(const __int16 *, __int64 *, signed __int64, _QWORD, const char *); // rdi
  int v28; // eax
  __int64 v30; // rsi
  __int64 v31; // rdi
  __int64 v32; // rcx
  char *v33; // r13
  __int64 v34; // rax
  unsigned __int64 v35; // r13
  __int64 v36; // rax
  char *v37; // rdi
  const __int16 *v38; // [rsp+28h] [rbp-B8h]
  __int64 v39; // [rsp+38h] [rbp-A8h]
  unsigned __int64 v40; // [rsp+40h] [rbp-A0h]
  __int64 v41; // [rsp+48h] [rbp-98h]
  __int64 v42; // [rsp+50h] [rbp-90h]
  __int64 v43; // [rsp+58h] [rbp-88h]
  __int64 v44; // [rsp+60h] [rbp-80h]
  char *v45; // [rsp+68h] [rbp-78h]
  __int64 v46; // [rsp+70h] [rbp-70h]
  __int64 v47; // [rsp+78h] [rbp-68h]
  __int64 v48; // [rsp+80h] [rbp-60h]
  int v49; // [rsp+8Ch] [rbp-54h]
  __int64 v50; // [rsp+90h] [rbp-50h]
  __int64 v51; // [rsp+98h] [rbp-48h]
  unsigned int v52; // [rsp+A4h] [rbp-3Ch]

  v40 = -6148914691236517206i64;
  v41 = -6148914691236517206i64;
  v42 = -6148914691236517206i64;
  v39 = 24i64;
  v47 = 0i64;
  v43 = -6148914691236517206i64;
  if ( qword_96AA8 & 0x100000 )
    return 0i64;
  v0 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD, __int64 *, unsigned __int64 *))(qword_96CE0 + 72))(
         L"Persistent-memory-note",
         qword_92360,
         0i64,
         &v39,
         &v40);
  v1 = -9223372036854775806i64;
  if ( v0 < 0 || v39 != 24 )
  {
    v38 = L"Persistent-memory-note";
    sub_1A2B6(1, (__int64)"[EB|`H:CPM] %r, (%qd, %d) @ GV %S\n", v0, v39);
  }
  else
  {
    v2 = v40;
    if ( v40 )
    {
      v3 = v42;
      if ( v42 )
      {
        v4 = sub_14446(&v43, &v47, 0i64, 0i64);
        if ( v4 < 0 )
        {
          v30 = v4;
          sub_1A2B6(1, (__int64)"[EB|`H:CPM] %r @ H:OID\n", v4, v6);
          v1 = v30;
        }
        else
        {
          v7 = v47;
          if ( v47 )
          {
            sub_136C5(v43);
            v52 = **(_DWORD **)(qword_96BA8 + 8);
            v8 = sub_1364F(512i64);
            if ( v8 )
            {
              v10 = v8;
              sub_F1B0(v8, 512i64);
              v11 = sub_1364F(0x2000i64);
              if ( v11 )
              {
                v50 = v11;
                v13 = (char *)((v11 + 4095) & 0xFFFFFFFFFFFFF000ui64);
                v44 = qword_96B90;
                v14 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, signed __int64, char *))(qword_96B90 + 8))(
                        qword_96B90,
                        v52,
                        v7,
                        512i64,
                        v13);
                if ( v14 < 0 )
                {
                  v31 = v14;
                  sub_1A2B6(1, (__int64)"[EB|`H:CPM] %r @ %g.RD 'HDR\n", v14, (__int64)qword_92AA0);
                  v1 = v31;
                }
                else
                {
                  v45 = v13;
                  sub_1B950(v13, (char *)v10, 0x200ui64);
                  sub_1A2B6(
                    1,
                    (__int64)"[EB|`H:CPM] SIG: 0x%x, BSZ: %d\n",
                    *(unsigned int *)(v10 + 88),
                    *(unsigned int *)(v10 + 472));
                  v15 = *(_DWORD *)(v10 + 88);
                  if ( v15 != 1936289125 )
                  {
                    v16 = 0i64;
                    if ( v15 != -236929379 )
                      goto LABEL_32;
                  }
                  v17 = *(unsigned int *)(v10 + 476);
                  v16 = 0i64;
                  if ( v17 > 0x1020 )
                    goto LABEL_32;
                  v18 = sub_1364F(v17);
                  if ( v18 )
                  {
                    v19 = v18;
                    sub_F1B0(v18, *(unsigned int *)(v10 + 476));
                    sub_1B950((char *)(v10 + 480), (char *)v19, 0x20ui64);
                    v20 = *(unsigned int *)(v10 + 472);
                    v21 = *(_DWORD *)(v10 + 476);
                    v22 = *(_DWORD *)(v10 + 476) >> 4;
                    v23 = v22 < 1;
                    v24 = v22 - 1;
                    if ( v23 )
                      v24 = 0;
                    v51 = v19;
                    v25 = *(_QWORD *)(v19 + 8) - v20;
                    v48 = v7 + v20;
                    v47 = v7 + v20;
                    v49 = v24;
                    if ( v24 )
                    {
                      v26 = v45;
                      if ( v25 )
                      {
                        v46 = v51;
                      }
                      else
                      {
                        v46 = v51 + 16;
                        --v49;
                        v48 = *(_QWORD *)(v51 + 16);
                        v47 = v48;
                        v25 = *(_QWORD *)(v51 + 24);
                      }
                    }
                    else
                    {
                      v46 = v51;
                      v26 = v45;
                    }
                    if ( v21 < 0x21 )
                    {
                      while ( 1 )
                      {
LABEL_41:
                        v35 = v25;
                        if ( v25 > v2 )
                          v35 = v2;
                        if ( v35 )
                        {
                          v36 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, unsigned __int64, __int64))(v44 + 16))(
                                  v44,
                                  v52,
                                  v48,
                                  v35,
                                  v3);
                          v26 = v45;
                          if ( v36 < 0 )
                            break;
                        }
                        v25 -= v35;
                        if ( !v25 )
                        {
                          if ( !v49 )
                            goto LABEL_49;
                          --v49;
                          v48 = *(_QWORD *)(v46 + 16);
                          v25 = *(_QWORD *)(v46 + 24);
                          v46 += 16i64;
                        }
                        v2 -= v35;
                        v3 += v35;
                        if ( !v2 )
                        {
LABEL_49:
                          v47 = v48;
                          *(_DWORD *)(v10 + 88) = -52560675;
                          v37 = v26;
                          sub_1B950((char *)v10, v26, 0x200ui64);
                          v1 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, signed __int64, char *))(v44 + 16))(
                                 v44,
                                 v52,
                                 v7,
                                 512i64,
                                 v37);
                          goto LABEL_51;
                        }
                      }
                      v1 = v36;
                      v47 = v48;
LABEL_51:
                      v32 = v50;
                      v16 = v51;
                      goto LABEL_33;
                    }
                    v33 = v26;
                    v34 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, signed __int64, char *))(v44 + 8))(
                            v44,
                            v52,
                            v48,
                            4096i64,
                            v26);
                    if ( v34 >= 0 )
                    {
                      sub_1B950(v33, (char *)(v51 + 32), *(unsigned int *)(v10 + 476) - 32i64);
                      v26 = v33;
                      goto LABEL_41;
                    }
                    v1 = v34;
                    v16 = v51;
LABEL_32:
                    v32 = v50;
LABEL_33:
                    sub_136C5(v32);
                    sub_136C5(v10);
                    if ( v16 )
                      sub_136C5(v16);
                    goto LABEL_22;
                  }
                  v1 = -9223372036854775787i64;
                }
                v16 = 0i64;
                goto LABEL_32;
              }
              sub_1A2B6(1, (__int64)"[EB|`H:CPM] ! @ M:BMA %d @ 'TMP\n", 0x2000i64, v12);
              sub_136C5(v10);
            }
            else
            {
              sub_1A2B6(1, (__int64)"[EB|`H:CPM] ! @ M:BMA %d @ 'HDR\n", 512i64, v9);
            }
            v1 = -9223372036854775787i64;
          }
          else
          {
            sub_1A2B6(1, (__int64)"[EB|`H:CPM] ! @ 'START\n", v5, v6);
          }
        }
      }
    }
  }
LABEL_22:
  (*(void (__fastcall **)(const char *, __int64 *, _QWORD, _QWORD, _QWORD, const __int16 *))(qword_96CE0 + 88))(
    "b",
    qword_92360,
    0i64,
    0i64,
    0i64,
    v38);
  if ( v1 >= 0 )
  {
    v27 = *(void (__fastcall **)(const __int16 *, __int64 *, signed __int64, _QWORD, const char *))(qword_96CE0 + 88);
    v28 = sub_189FE("sleepimage");
    v27(L"Persistent-memory-note", qword_92360, 7i64, v28, "sleepimage");
  }
  return v1;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 40FB4: using guessed type __int16 aPersistentMemo[23];
// 92360: using guessed type __int64 qword_92360[2];
// 92AA0: using guessed type __int64 qword_92AA0[2];
// 96AA8: using guessed type __int64 qword_96AA8;
// 96B90: using guessed type __int64 qword_96B90;
// 96BA8: using guessed type __int64 qword_96BA8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000014446) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_14446(__int64 *a1, signed __int64 *a2, _BYTE *a3, char *a4)
{
  signed __int64 *v4; // rbx
  __int64 *v5; // r12
  signed __int64 v6; // rsi
  __int64 v7; // rdi
  __int64 v8; // r14
  __int64 v9; // r9
  __int64 v10; // rax
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 i; // rcx
  char v14; // al
  __int64 v15; // rdx
  int v16; // er8
  __int64 v17; // rdx
  int v18; // er8
  signed __int64 *v19; // r14
  _BYTE *v20; // rax
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rbx
  __int64 v24; // rsi
  __int64 v25; // r9
  char v26; // si
  __int64 v27; // rbx
  __int64 v28; // r8
  __int64 v29; // r9
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 v33; // rax
  __int64 v34; // rax
  __int64 v35; // rax
  __int64 v36; // [rsp+28h] [rbp-78h]
  __int64 v37; // [rsp+30h] [rbp-70h]
  _BYTE *v38; // [rsp+38h] [rbp-68h]
  __int64 v39; // [rsp+40h] [rbp-60h]
  _BYTE *v40; // [rsp+48h] [rbp-58h]
  __int64 v41; // [rsp+50h] [rbp-50h]
  char *v42; // [rsp+58h] [rbp-48h]
  __int64 v43; // [rsp+60h] [rbp-40h]

  v42 = a4;
  v38 = a3;
  v4 = a2;
  v5 = a1;
  v6 = -9223372036854775794i64;
  v7 = 0i64;
  v43 = 0i64;
  v37 = -9034400514174975832i64;
  v36 = 5457143572451254544i64;
  v41 = -6148914691236517206i64;
  v40 = (_BYTE *)-6148914691236517206i64;
  v39 = 0i64;
  v8 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, __int64 *, _QWORD, signed __int64, signed __int64))(qword_96CE0 + 72))(
         "b",
         &v36,
         0i64,
         &v39,
         0i64,
         5457143572451254544i64,
         -9034400514174975832i64);
  v9 = v39;
  if ( v8 == -9223372036854775803i64 && v39 )
  {
    v10 = sub_1364F(v39);
    if ( !v10 )
    {
      sub_1A2B6(1, (__int64)"[EB|`H:OID] ! @ M:BMA %qd @ GV %S\n", v39, (__int64)"b");
      v15 = 0i64;
      v16 = 33;
      goto LABEL_22;
    }
    v7 = v10;
    v8 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, __int64 *, __int64))(qword_96CE0 + 72))(
           "b",
           &v36,
           0i64,
           &v39,
           v10);
    v9 = v39;
    v6 = -9223372036854775794i64;
  }
  if ( v8 < 0 || !v9 )
  {
    sub_1A2B6(1, (__int64)"[EB|`H:OID] %r, %qd @ GV %S\n", v8, v9);
    v15 = v8;
    v16 = 34;
LABEL_22:
    sub_2724(0, v15, v16);
    return -9223372036854775787i64;
  }
  *v5 = v7;
  sub_1A2B6(1, (__int64)"[EB|#H:BI] (%.*b)\n", v9, v7);
  for ( i = v7; ; i += *(unsigned __int16 *)(i + 2) )
  {
    v14 = *(_BYTE *)i & 0x7F;
    if ( v14 == 4 )
      break;
    if ( v14 == 127 && *(_BYTE *)(i + 1) == -1 )
    {
      sub_1A2B6(1, (__int64)"[EB|`H:OID] ! @ H:FDPT\n", v11, v12);
      v17 = 0i64;
      v18 = 35;
LABEL_32:
      sub_2724(0, v17, v18);
      return v6;
    }
LABEL_13:
    ;
  }
  if ( *(_BYTE *)(i + 1) != 4 )
    goto LABEL_13;
  v19 = v4;
  v20 = sub_71CF((_WORD *)(i + 4));
  if ( !v20 )
  {
    sub_1A2B6(1, (__int64)"[EB|`H:OID] ! @ BST:U8U16\n", v21, v22);
    v17 = 0i64;
    v18 = 36;
    goto LABEL_32;
  }
  v23 = (__int64)v20;
  *v19 = sub_18B20((signed __int64)v20, (signed __int64 *)&v40, 16i64);
  if ( v38 && v40 && *v40 == 58 && (v24 = (__int64)v38, sub_11070(v40 + 1, v38)) )
  {
    sub_1A2B6(1, (__int64)"[EB|#H:VKU] %g\n", v24, v25);
    v26 = 1;
  }
  else
  {
    v26 = 0;
  }
  if ( v42 )
    *v42 = v26;
  sub_136C5(v23);
  if ( *v19 )
  {
    v41 = v7;
    if ( v26
      && (v27 = (*(__int64 (__fastcall **)(__int64 *, __int64 *, __int64 *))(qword_96CD8 + 184))(
                  qword_92A70,
                  &v41,
                  &v43),
          sub_1A2B6(1, (__int64)"[EB|`H:OID] %r @ LocDP %g\n", v27, (__int64)qword_92A70),
          v27 >= 0)
      && (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(v43, qword_92A70, &qword_96BA8) >= 0 )
    {
      BYTE2(qword_96AA8) |= 0x10u;
      sub_1A2B6(1, (__int64)"[EB|#H:BIOC]\n", v28, v29);
    }
    else
    {
      v41 = v7;
      if ( (*(__int64 (__fastcall **)(__int64 *, __int64 *, __int64 *))(qword_96CD8 + 184))(qword_92A60, &v41, &v43) < 0 )
      {
        v41 = v7;
        v35 = sub_C2C4(1, 1, v31, v32);
        if ( v35 < 0
          || (v35 = (*(__int64 (__fastcall **)(__int64 *, __int64 *, __int64 *))(qword_96CD8 + 184))(
                      qword_92A60,
                      &v41,
                      &v43),
              v35 < 0) )
        {
          v6 = v35;
          sub_1A2B6(1, (__int64)"[EB|`H:OID] %r @ LocDP %g\n", v35, (__int64)qword_92A60);
          v17 = v6;
          v18 = 38;
          goto LABEL_32;
        }
      }
      v33 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(
              v43,
              qword_92AA0,
              &qword_96B90);
      if ( v33 < 0 )
      {
        v6 = v33;
        sub_1A2B6(1, (__int64)"[EB|`H:OID] %r @ HdlP %g\n", v33, (__int64)qword_92A60);
        v17 = v6;
        v18 = 39;
        goto LABEL_32;
      }
      v34 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(
              v43,
              qword_92A60,
              &qword_96BA8);
      if ( v34 < 0 )
      {
        v6 = v34;
        v17 = v34;
        v18 = 40;
        goto LABEL_32;
      }
    }
    v6 = 0i64;
  }
  else
  {
    sub_2724(0, 0i64, 37);
    v6 = -9223372036854775794i64;
  }
  return v6;
}
// 146F4: write access to const memory at 96AAA has been detected
// 92A60: using guessed type __int64 qword_92A60[2];
// 92A70: using guessed type __int64 qword_92A70[2];
// 92AA0: using guessed type __int64 qword_92AA0[2];
// 96AA8: using guessed type __int64 qword_96AA8;
// 96B90: using guessed type __int64 qword_96B90;
// 96BA8: using guessed type __int64 qword_96BA8;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001487D) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_1487D()
{
  __int64 v0; // rax
  unsigned int v1; // esi
  __int64 v2; // rax
  __int64 v3; // r9
  __int64 v5; // [rsp+28h] [rbp-18h]

  dword_926A0 = 1;
  v5 = 0i64;
  v0 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
         L"boot-signature",
         qword_92360,
         0i64);
  if ( v0 != -9223372036854775803i64 )
  {
    sub_1A2B6(1, (__int64)"[EB|`H:IS] %r @ GV %S\n", v0, (__int64)L"boot-signature");
    dword_926A0 = 0;
  }
  v1 = 0;
  v5 = 0i64;
  v2 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("b", qword_92360, 0i64);
  if ( v2 == -9223372036854775803i64 )
  {
    v1 = -1;
  }
  else
  {
    sub_1A2B6(1, (__int64)"[EB|`H:IS] %r @ GV %S\n", v2, (__int64)"b");
    dword_926A0 = 0;
  }
  sub_1A2B6(1, (__int64)"[EB|#H:IS] %d\n", v1, v3);
  return 0;
}
// 148AE: write access to const memory at 926A0 has been detected
// 14901: write access to const memory at 926A0 has been detected
// 1495C: write access to const memory at 926A0 has been detected
// 40FF8: using guessed type __int16 aBootSignature_0[15];
// 92360: using guessed type __int64 qword_92360[2];
// 926A0: using guessed type int dword_926A0;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001498C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __usercall sub_1498C@<rax>(_BYTE *a1@<rcx>, __int64 a2@<r9>, __m128 *a3@<xmm0>, __m128i *a4@<xmm1>, __m128i *a5@<xmm2>, __m128i *a6@<xmm6>, __m128i *a7@<xmm7>)
{
  _BYTE *v7; // r14
  __int64 v8; // r8
  __int64 v9; // r9
  char v10; // r12
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // rbx
  unsigned __int64 v15; // rdi
  int v16; // er13
  __int64 v17; // rax
  __int64 v18; // rbx
  int v19; // eax
  int v20; // eax
  __int64 *v21; // rdx
  __int64 v22; // rax
  __int64 v23; // r9
  __int64 v24; // r8
  __int64 v25; // r14
  __int64 v26; // r8
  __int64 v27; // r9
  char v28; // al
  __int64 *v29; // rsi
  __int64 v30; // rax
  const char *v31; // rdx
  __int64 v32; // rax
  char *v33; // rsi
  __int64 v34; // rax
  __int64 v35; // r8
  __int64 v36; // rcx
  __int64 v37; // rax
  char v38; // cl
  __int64 v39; // r8
  __int64 (__fastcall *v40)(__int64, signed __int64, __int64, __int64); // rax
  __int64 v41; // r9
  unsigned __int64 v42; // rax
  bool v43; // cf
  __int64 v44; // rcx
  signed __int64 v45; // rdx
  __int64 v46; // r8
  __int64 v47; // rax
  __int64 v48; // r8
  __int64 v49; // r8
  __int64 v50; // rax
  __int64 v51; // r9
  signed __int64 v52; // rax
  char v53; // cl
  char v54; // si
  __int64 v55; // r9
  __int64 v57; // [rsp+40h] [rbp-A0h]
  unsigned __int64 v58; // [rsp+48h] [rbp-98h]
  __int64 v59; // [rsp+50h] [rbp-90h]
  __int64 v60; // [rsp+58h] [rbp-88h]
  __int64 v61; // [rsp+60h] [rbp-80h]
  __int64 v62; // [rsp+68h] [rbp-78h]
  __int64 v63; // [rsp+70h] [rbp-70h]
  __int64 v64; // [rsp+78h] [rbp-68h]
  __int64 v65; // [rsp+80h] [rbp-60h]
  __int64 v66; // [rsp+88h] [rbp-58h]
  __int64 v67; // [rsp+98h] [rbp-48h]
  char v68; // [rsp+A7h] [rbp-39h]

  v7 = a1;
  v60 = 0i64;
  v67 = 0i64;
  v62 = -9034400514174975832i64;
  v61 = 5457143572451254544i64;
  v59 = 0i64;
  v57 = -6148914691236517206i64;
  v68 = 0;
  sub_1A2B6(1, (__int64)"[EB|`H:CHK] BM: 0x%016qx\n", qword_96AA8, a2);
  if ( qword_96AA8 & 1 )
  {
    sub_1A2B6(1, (__int64)"[EB|`H:CHK] 'SAFE\n", v8, v9);
    LODWORD(v15) = 0;
    sub_2724(0, 0i64, 32);
  }
  else
  {
    v10 = 0;
    if ( (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, __int64 *, _QWORD))(qword_96CE0 + 72))(
           "b",
           &v61,
           0i64,
           &v67,
           0i64) == -9223372036854775803i64
      && v67 )
    {
      sub_1A2B6(1, (__int64)"[EB|`H:CHK] 'BI\n", v11, v12);
      v10 = 1;
    }
    v67 = 20i64;
    v13 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
            L"boot-signature",
            &v61,
            0i64);
    v14 = v13;
    if ( v13 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`H:CHK] %r @ GV %S\n", v13, (__int64)L"boot-signature");
      LODWORD(v15) = 0;
      sub_2724(0, v14, 23);
      if ( v10 )
      {
        LODWORD(v15) = 0;
        sub_2724(32, 0i64, 0);
        v24 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
                "b",
                qword_92360,
                0i64,
                0i64,
                0i64);
LABEL_23:
        sub_1A2B6(1, (__int64)"[EB|`H:CHK] %r @ SV- %S\n", v24, (__int64)"b");
        goto LABEL_88;
      }
    }
    else
    {
      v15 = (unsigned __int64)L"boot-signature";
      v16 = 0;
      (*(void (__fastcall **)(const __int16 *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
        L"boot-signature",
        &v61,
        0i64,
        0i64,
        0i64);
      sub_1A2B6(1, (__int64)"[EB|`H:CHK] %r @ SV- %S\n", v14, (__int64)L"boot-signature");
      v67 = 16i64;
      v17 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("b", &v61, 0i64);
      v18 = v17;
      if ( v17 >= 0 )
      {
        (*(void (__fastcall **)(const char *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
          "b",
          &v61,
          0i64,
          0i64,
          0i64);
        sub_1A2B6(1, (__int64)"[EB|`H:CHK] %r @ SV- %S\n", v18, (__int64)"b");
        qword_96BB0 = 5575295297i64;
        sub_2724(16, v18, 0);
        LOWORD(v63) = -21846;
        *(_DWORD *)((char *)&v63 + 2) = -1431655766;
        HIWORD(v63) = -21846;
        v64 = -6148914691236517206i64;
        if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD))(qword_96CE0 + 24))(&v63, 0i64) >= 0 )
        {
          v19 = -1;
          if ( (unsigned __int16)v63 >= 0x7B3u )
          {
            v20 = 0;
            LODWORD(v15) = 1970;
            do
            {
              v20 += ((v15 & 3) < 1) + 365;
              LODWORD(v15) = v15 + 1;
            }
            while ( (unsigned __int16)v63 != (_DWORD)v15 );
            v19 = v20 - 1;
          }
          v21 = qword_8F060;
          if ( !(v63 & 3) )
            v21 = qword_8F0A0;
          v16 = 86400 * (*((_DWORD *)v21 + BYTE2(v63) - 1) + v19 + BYTE3(v63))
              + BYTE6(v63)
              + 60 * BYTE5(v63)
              + 3600 * BYTE4(v63);
        }
        dword_96BDC = v16;
        v22 = sub_14446(&v60, &qword_96BE0, v7, &v68);
        if ( v22 < 0 )
        {
          v25 = v22;
          sub_1A2B6(1, (__int64)"[EB|`H:CHK] %r @ H:OID\n", v22, v23);
          v28 = 1;
LABEL_82:
          v38 = v68;
LABEL_83:
          if ( v38 )
          {
            sub_1A2B6(1, (__int64)"[EB|#H:FND]\n", v26, v27);
            LOBYTE(v15) = 1;
            return (unsigned int)v15;
          }
          if ( !v28 )
          {
            sub_1A2B6(1, (__int64)"[EB|#H:BOOT.1]\n", v26, v27);
            v25 = sub_152FD(
                    qword_96B90,
                    qword_96BA8,
                    qword_96B98,
                    qword_96BE0,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7,
                    (unsigned int *)qword_96BF0,
                    qword_96BE8,
                    0);
            sub_1A2B6(1, (__int64)"[EB|`H:CHK] %r @ H:HB\n", v25, v55);
          }
          LODWORD(v15) = 0;
          sub_2724(32, v25, 0);
LABEL_88:
          sub_52BA(0, 4u);
          return (unsigned int)v15;
        }
        if ( qword_96AA8 & 0x100000 )
        {
          qword_96BE8 = 64i64;
          qword_96BF0 = sub_1364F(64i64);
        }
        else
        {
          qword_96BE8 = 16i64;
          qword_96BF0 = sub_1364F(16i64);
          sub_1B950((char *)&dword_96BCC, (char *)qword_96BF0, qword_96BE8);
        }
        v57 = v60;
        v29 = qword_92C00;
        if ( !_bittest((const signed __int32 *)&qword_96AA8, 0x14u) )
          v29 = qword_92BF0;
        v30 = (*(__int64 (__fastcall **)(__int64 *, __int64 *, __int64 *))(qword_96CD8 + 184))(v29, &v57, &v59);
        if ( v30 < 0 )
        {
          v31 = "[EB|`H:CHK] %r @ LocDP %g\n";
        }
        else
        {
          v30 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(v59, v29, &qword_96B98);
          if ( v30 >= 0 )
          {
LABEL_33:
            v67 = 0i64;
            v15 = 3500i64;
            if ( (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
                   L"boot-gfx-delay",
                   &v61,
                   0i64) == -9223372036854775803i64 )
            {
              if ( v67 )
              {
                v32 = sub_1364F(v67);
                v33 = (char *)v32;
                v60 = v32;
                v34 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD, __int64 *, __int64))(qword_96CE0 + 72))(
                        L"boot-gfx-delay",
                        &v61,
                        0i64,
                        &v67,
                        v32);
                if ( v33 )
                {
                  if ( v34 >= 0 )
                    v15 = (signed int)sub_18AE1(v33);
                }
              }
            }
            if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(
                   qword_92C40,
                   0i64,
                   &qword_96BA0) < 0 )
            {
              qword_96BA0 = 0i64;
              v67 = (unsigned __int8)qword_96BA0;
            }
            else
            {
              v67 = 0i64;
              if ( qword_96BA0 )
              {
                if ( (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, __int64 *, _QWORD))(qword_96CE0 + 72))(
                       "b",
                       &v61,
                       0i64,
                       &v67,
                       0i64) == -9223372036854775803i64 )
                {
                  LOWORD(v63) = -21846;
                  LOBYTE(v35) = 2;
                  if ( (*(__int64 (__fastcall **)(__int64, signed __int64, __int64))(qword_96BA0 + 8))(
                         qword_96BA0,
                         1129076555i64,
                         v35) >= 0 )
                    dword_94C68 = 10 * (BYTE1(v63) | ((unsigned __int8)v63 << 8));
                }
              }
            }
            v36 = qword_96AF8;
            if ( !qword_96AF8 )
            {
              v25 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(
                      qword_92D00,
                      0i64,
                      &qword_96AF8);
              if ( v25 < 0 )
              {
                qword_96AF8 = 0i64;
                goto LABEL_52;
              }
              v36 = qword_96AF8;
              if ( !qword_96AF8 )
                goto LABEL_52;
            }
            v63 = -6148914691236517206i64;
            v58 = -6148914691236517206i64;
            v37 = (*(__int64 (__fastcall **)(__int64, _QWORD))(v36 + 48))(v36, 0i64);
            v25 = v37;
            if ( v15 && v37 >= 0 )
            {
              v15 *= 1000000000000i64;
              qword_94C70 = sub_23CAD(v15, v58, 0i64);
            }
LABEL_52:
            qword_94C78 = sub_18D72();
            v28 = 0;
            v38 = v68;
            if ( !qword_96BA0 || !v68 )
              goto LABEL_83;
            v63 = -6148914691236517206i64;
            v64 = -6148914691236517206i64;
            v65 = -6148914691236517206i64;
            v66 = -6148914691236517206i64;
            sub_2724(0, 0i64, 7);
            v40 = *(__int64 (__fastcall **)(__int64, signed __int64, __int64, __int64))(qword_96BA0 + 8);
            if ( qword_96AA8 & 0x100000 )
            {
              LOBYTE(v39) = 32;
              v47 = v40(qword_96BA0, 1212304208i64, v39, qword_96BF0);
              if ( v47 >= 0 )
              {
                sub_F1B0(&v63, 32i64);
                LOBYTE(v48) = 32;
                (*(void (__fastcall **)(__int64, signed __int64, __int64, __int64 *))(qword_96BA0 + 16))(
                  qword_96BA0,
                  1212304208i64,
                  v48,
                  &v63);
                LOBYTE(v49) = 32;
                v50 = (*(__int64 (__fastcall **)(__int64, signed __int64, __int64, __int64))(qword_96BA0 + 8))(
                        qword_96BA0,
                        1212304213i64,
                        v49,
                        qword_96BF0 + 32);
                v25 = v50;
                if ( v50 < 0 )
                  sub_1A2B6(1, (__int64)"[EB|`H:CHK] %r @ HBKU\n", v50, v51);
                v52 = -32i64;
                LODWORD(v15) = 1;
                v53 = 0;
                v54 = 0;
                do
                {
                  if ( *(_QWORD *)(qword_96BF0 + v52 + 32) )
                    v54 = 1;
                  if ( *(_QWORD *)(qword_96BF0 + v52 + 64) )
                    v53 = 1;
                  v52 += 8i64;
                }
                while ( v52 );
                if ( v54 && v53 )
                {
                  v68 = 0;
                  sub_1A2B6(1, (__int64)"[EB|#H:HBKPU]\n", v46, v51);
                }
                v44 = qword_96BA0;
                v45 = 1212304213i64;
                LOBYTE(v46) = 32;
                goto LABEL_78;
              }
              v25 = v47;
            }
            else
            {
              LOBYTE(v39) = 32;
              v25 = v40(qword_96BA0, 1212304208i64, v39, (__int64)&v63);
              if ( v25 >= 0 )
              {
                if ( qword_96BE8 )
                {
                  v42 = 1i64;
                  do
                  {
                    *(_BYTE *)(qword_96BF0 + v42 - 1) ^= *((_BYTE *)&v62 + v42 + 7);
                    if ( *((_BYTE *)&v62 + v42 + 7) )
                      v68 = 0;
                    if ( v42 > 0x1F )
                      break;
                    v43 = v42++ < qword_96BE8;
                  }
                  while ( v43 );
                }
                if ( !v68 )
                  sub_1A2B6(1, (__int64)"[EB|#H:HBKP]\n", v25, v41);
                v15 = (unsigned __int64)&v63;
                sub_F1B0(&v63, 32i64);
                v44 = qword_96BA0;
                v45 = 1212304208i64;
                LOBYTE(v46) = 32;
LABEL_78:
                (*(void (__fastcall **)(__int64, signed __int64, __int64, __int64 *))(v44 + 16))(v44, v45, v46, &v63);
LABEL_81:
                v28 = 0;
                goto LABEL_82;
              }
            }
            sub_1A2B6(1, (__int64)"[EB|`H:CHK] %r @ HBKP\n", v25, v41);
            goto LABEL_81;
          }
          v31 = "[EB|`H:CHK] %r @ HdlP %g\n";
        }
        sub_1A2B6(1, (__int64)v31, v30, (__int64)v29);
        qword_96B98 = 0i64;
        goto LABEL_33;
      }
      sub_1A2B6(1, (__int64)"[EB|`H:CHK] %r @ GV %S\n", v17, (__int64)"b");
      LODWORD(v15) = 0;
      sub_2724(0, v18, 24);
      if ( v10 )
      {
        LODWORD(v15) = 0;
        sub_2724(32, 0i64, 0);
        (*(void (__fastcall **)(const char *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
          "b",
          qword_92360,
          0i64,
          0i64,
          0i64);
        v24 = v18;
        goto LABEL_23;
      }
    }
  }
  return (unsigned int)v15;
}
// 14B5E: write access to const memory at 96BB0 has been detected
// 14C1A: write access to const memory at 96BDC has been detected
// 14C51: write access to const memory at 96BE8 has been detected
// 14C66: write access to const memory at 96BF0 has been detected
// 14DDA: write access to const memory at 96BE8 has been detected
// 14DEF: write access to const memory at 96BF0 has been detected
// 14E8A: write access to const memory at 96B98 has been detected
// 14FA1: write access to const memory at 94C68 has been detected
// 14FAB: write access to const memory at 96BA0 has been detected
// 15005: write access to const memory at 94C70 has been detected
// 15041: write access to const memory at 96AF8 has been detected
// 15051: write access to const memory at 94C78 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 40FF8: using guessed type __int16 aBootSignature_0[15];
// 41034: using guessed type __int16 aBootGfxDelay[15];
// 8F060: using guessed type __int64 qword_8F060[8];
// 8F0A0: using guessed type __int64 qword_8F0A0[8];
// 92360: using guessed type __int64 qword_92360[2];
// 92BF0: using guessed type __int64[2];
// 92C00: using guessed type __int64 qword_92C00[2];
// 92C40: using guessed type __int64 qword_92C40[2];
// 92D00: using guessed type __int64 qword_92D00[2];
// 94C68: using guessed type int dword_94C68;
// 94C70: using guessed type __int64 qword_94C70;
// 94C78: using guessed type __int64 qword_94C78;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AF8: using guessed type __int64 qword_96AF8;
// 96B90: using guessed type __int64 qword_96B90;
// 96B98: using guessed type __int64 qword_96B98;
// 96BA0: using guessed type __int64 qword_96BA0;
// 96BA8: using guessed type __int64 qword_96BA8;
// 96BB0: using guessed type __int64 qword_96BB0;
// 96BCC: using guessed type int dword_96BCC;
// 96BDC: using guessed type int dword_96BDC;
// 96BE0: using guessed type __int64 qword_96BE0;
// 96BE8: using guessed type __int64 qword_96BE8;
// 96BF0: using guessed type __int64 qword_96BF0;
// 96BF8: using guessed type int dword_96BF8;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (00000000000152FD) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __usercall sub_152FD@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, unsigned __int64 a4@<r9>, __m128 a5@<xmm0>, __m128i *a6@<xmm1>, __m128i *a7@<xmm2>, __m128i *a8@<xmm6>, __m128i *a9@<xmm7>, unsigned int *a10, __int64 a11, unsigned __int8 a12)
{
  unsigned __int64 v12; // r12
  __int64 v13; // rdi
  unsigned __int8 v14; // r14
  unsigned __int64 v15; // r15
  int v16; // edx
  __int64 v17; // r9
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // r8
  __int64 v21; // r9
  signed __int64 v22; // rax
  _DWORD *v23; // rax
  __int64 v24; // rsi
  __int64 v25; // r9
  unsigned __int64 v26; // r13
  __int64 v27; // r8
  __int64 v28; // rcx
  int v29; // eax
  __int64 v30; // rbx
  __int64 v31; // rax
  __int64 v32; // r9
  signed __int64 v33; // r12
  __int64 v34; // rax
  __int64 v35; // rsi
  __int64 v36; // rax
  signed int v37; // eax
  __int64 v38; // rax
  __int64 v39; // rcx
  signed __int64 v40; // rdi
  __int64 v41; // r8
  __int64 v42; // r9
  __int64 v43; // rax
  __int64 v44; // r9
  __int64 v45; // r12
  __int64 v46; // r8
  __int64 v47; // r8
  __int64 v48; // r9
  unsigned int v49; // esi
  signed int v50; // er14
  int v51; // esi
  const char *v52; // rdx
  __int64 v53; // r8
  __int64 v54; // r9
  unsigned int v55; // eax
  int v56; // er13
  __int64 v57; // r14
  int v58; // eax
  unsigned __int64 v59; // r12
  __int64 v60; // rsi
  __int64 v61; // rbx
  __int64 v62; // rax
  int v63; // esi
  int v64; // ebx
  char *v65; // rcx
  int v66; // er14
  int v67; // ebx
  _BYTE *v68; // rax
  __int64 v69; // r13
  char *v70; // rsi
  signed __int64 v71; // rsi
  bool v72; // zf
  __int64 v73; // r8
  __int64 v74; // r9
  __int64 v75; // r12
  __int64 v76; // rbx
  __int64 v77; // r8
  __int64 v78; // r9
  unsigned __int64 v79; // rdi
  bool v80; // cl
  int v81; // er10
  int v82; // er13
  unsigned __int64 v83; // r14
  unsigned __int64 v84; // rax
  char *v85; // r12
  bool v86; // r13
  __int64 v87; // rsi
  int v88; // ebx
  __int64 v89; // rax
  unsigned __int64 v90; // rcx
  __int64 (__fastcall **v91)(_QWORD, _QWORD, unsigned __int64, unsigned __int64, unsigned __int64, unsigned int *, __int64, __int64); // rsi
  unsigned __int64 v92; // rbx
  __int64 v93; // rdi
  unsigned __int64 v94; // rax
  __int64 v95; // r9
  __int64 v96; // rax
  unsigned __int64 v97; // rax
  __int64 v98; // rsi
  int v99; // ebx
  int v100; // er12
  unsigned __int64 v101; // r13
  unsigned __int64 v102; // r14
  char *v103; // r14
  __int64 v104; // rsi
  unsigned __int64 v105; // r14
  __int64 v106; // r8
  __int64 v107; // rcx
  unsigned int v108; // er9
  __int64 v109; // rdx
  char *v110; // r14
  __int64 v111; // rsi
  unsigned __int8 v112; // bl
  __int64 v113; // r8
  __int64 v114; // r9
  __int64 v115; // r9
  char v116; // cl
  __int64 v117; // rbx
  char v118; // al
  __int64 v119; // rdx
  __int64 v120; // r9
  __int64 v121; // r8
  int v122; // esi
  unsigned int v123; // edi
  unsigned int v124; // ebx
  char v125; // al
  __int64 v126; // rdi
  __int64 v127; // rax
  signed __int64 v128; // rbx
  signed __int64 *v129; // rax
  signed __int64 *v130; // rsi
  __int64 v131; // rsi
  unsigned __int64 v132; // rbx
  __int64 v133; // rcx
  __int64 v134; // rax
  _DWORD *v135; // rbx
  unsigned int *v136; // rsi
  __int64 v137; // rdi
  __int64 v138; // rsi
  int v139; // ecx
  signed __int64 v140; // rdi
  char *v141; // rsi
  int v142; // er15
  unsigned int v143; // edi
  _DWORD *v144; // r13
  __int64 v145; // rcx
  __int64 v146; // r9
  unsigned __int64 v147; // r14
  __int64 v148; // r9
  const char *v149; // rdx
  int v150; // er13
  __int64 v151; // rbx
  __int64 v152; // r15
  unsigned __int64 v153; // rdi
  __int64 v154; // rax
  unsigned int v155; // er14
  __int64 v156; // rcx
  __int64 v157; // r9
  __int64 v158; // r8
  int v159; // eax
  unsigned int v160; // er14
  __int64 v161; // rcx
  __int64 v162; // rdx
  __int64 v163; // rdi
  int v164; // esi
  unsigned __int64 v165; // rax
  unsigned __int64 v166; // rsi
  unsigned __int64 v167; // rsi
  char *v169; // [rsp+20h] [rbp-770h]
  __int64 v170; // [rsp+20h] [rbp-770h]
  __int64 v171; // [rsp+28h] [rbp-768h]
  char v172; // [rsp+40h] [rbp-750h]
  char v173; // [rsp+318h] [rbp-478h]
  char v174; // [rsp+328h] [rbp-468h]
  __int64 v175; // [rsp+510h] [rbp-280h]
  __int64 v176; // [rsp+518h] [rbp-278h]
  __int64 v177; // [rsp+520h] [rbp-270h]
  __int64 v178; // [rsp+528h] [rbp-268h]
  __int64 v179; // [rsp+530h] [rbp-260h]
  __int64 v180; // [rsp+538h] [rbp-258h]
  __int64 v181; // [rsp+540h] [rbp-250h]
  unsigned __int64 v182; // [rsp+548h] [rbp-248h]
  __int64 v183; // [rsp+550h] [rbp-240h]
  __int64 v184; // [rsp+558h] [rbp-238h]
  __int64 v185; // [rsp+560h] [rbp-230h]
  __int64 v186; // [rsp+568h] [rbp-228h]
  __int64 v187; // [rsp+570h] [rbp-220h]
  __int64 v188; // [rsp+578h] [rbp-218h]
  __int64 v189; // [rsp+580h] [rbp-210h]
  __int64 v190; // [rsp+588h] [rbp-208h]
  __int64 v191; // [rsp+590h] [rbp-200h]
  __int64 v192; // [rsp+598h] [rbp-1F8h]
  __int64 v193; // [rsp+5A0h] [rbp-1F0h]
  __int64 v194; // [rsp+5A8h] [rbp-1E8h]
  __int64 v195; // [rsp+5B0h] [rbp-1E0h]
  __int64 v196; // [rsp+5B8h] [rbp-1D8h]
  __int64 v197; // [rsp+5C0h] [rbp-1D0h]
  _DWORD *v198; // [rsp+5C8h] [rbp-1C8h]
  __int64 v199; // [rsp+5D0h] [rbp-1C0h]
  __int64 v200; // [rsp+5D8h] [rbp-1B8h]
  __int64 v201; // [rsp+5E0h] [rbp-1B0h]
  unsigned __int64 v202; // [rsp+5E8h] [rbp-1A8h]
  __int64 v203; // [rsp+5F0h] [rbp-1A0h]
  __int64 v204; // [rsp+5F8h] [rbp-198h]
  unsigned __int64 v205; // [rsp+600h] [rbp-190h]
  __int64 v206; // [rsp+608h] [rbp-188h]
  __int64 v207; // [rsp+610h] [rbp-180h]
  unsigned __int64 v208; // [rsp+618h] [rbp-178h]
  __int64 v209; // [rsp+620h] [rbp-170h]
  __int64 v210; // [rsp+628h] [rbp-168h]
  unsigned __int64 v211; // [rsp+630h] [rbp-160h]
  unsigned __int64 v212; // [rsp+638h] [rbp-158h]
  int v213; // [rsp+644h] [rbp-14Ch]
  int v214; // [rsp+648h] [rbp-148h]
  int v215; // [rsp+64Ch] [rbp-144h]
  unsigned __int64 v216; // [rsp+650h] [rbp-140h]
  unsigned __int64 v217; // [rsp+658h] [rbp-138h]
  __int64 v218; // [rsp+660h] [rbp-130h]
  __int64 v219; // [rsp+668h] [rbp-128h]
  __int64 v220; // [rsp+670h] [rbp-120h]
  unsigned __int64 v221; // [rsp+678h] [rbp-118h]
  __int64 v222; // [rsp+680h] [rbp-110h]
  __int64 v223; // [rsp+688h] [rbp-108h]
  __int64 v224; // [rsp+690h] [rbp-100h]
  int v225; // [rsp+698h] [rbp-F8h]
  unsigned int v226; // [rsp+69Ch] [rbp-F4h]
  __int64 v227; // [rsp+6A0h] [rbp-F0h]
  unsigned __int64 v228; // [rsp+6A8h] [rbp-E8h]
  char *v229; // [rsp+6B0h] [rbp-E0h]
  __int64 v230; // [rsp+6B8h] [rbp-D8h]
  _DWORD *v231; // [rsp+6C0h] [rbp-D0h]
  __int64 v232; // [rsp+6C8h] [rbp-C8h]
  unsigned __int64 v233; // [rsp+6D0h] [rbp-C0h]
  __int64 v234; // [rsp+6D8h] [rbp-B8h]
  __int64 v235; // [rsp+6E0h] [rbp-B0h]
  __int64 v236; // [rsp+6E8h] [rbp-A8h]
  char *v237; // [rsp+6F0h] [rbp-A0h]
  char *v238; // [rsp+6F8h] [rbp-98h]
  unsigned __int64 v239; // [rsp+700h] [rbp-90h]
  __int64 v240; // [rsp+708h] [rbp-88h]
  BOOL v241; // [rsp+710h] [rbp-80h]
  unsigned int v242; // [rsp+714h] [rbp-7Ch]
  unsigned __int64 v243; // [rsp+718h] [rbp-78h]
  int v244; // [rsp+720h] [rbp-70h]
  int v245; // [rsp+724h] [rbp-6Ch]
  unsigned __int64 v246; // [rsp+728h] [rbp-68h]
  bool v247; // [rsp+737h] [rbp-59h]
  char *v248; // [rsp+738h] [rbp-58h]
  __int64 v249; // [rsp+740h] [rbp-50h]
  char v250; // [rsp+74Eh] [rbp-42h]
  bool v251; // [rsp+74Fh] [rbp-41h]
  __int64 v252; // [rsp+750h] [rbp-40h]

  v12 = a4;
  v227 = a3;
  v199 = a1;
  v13 = a2;
  v14 = a12;
  v15 = -6148914691236517206i64;
  v252 = -6148914691236517206i64;
  v181 = -6148914691236517206i64;
  v180 = -6148914691236517206i64;
  v179 = -6148914691236517206i64;
  v178 = -6148914691236517206i64;
  v177 = -6148914691236517206i64;
  v176 = -6148914691236517206i64;
  v175 = -6148914691236517206i64;
  LOBYTE(a1) = -86;
  sub_F180(&v172, a1, 0x2D2ui64);
  v212 = 0i64;
  v211 = 0i64;
  v213 = -1;
  v238 = (char *)-6148914691236517206i64;
  v229 = (char *)-6148914691236517206i64;
  v218 = -6148914691236517206i64;
  v239 = -6148914691236517206i64;
  v230 = -6148914691236517206i64;
  v244 = -1431655766;
  v219 = -6148914691236517206i64;
  v220 = -6148914691236517206i64;
  LOBYTE(v16) = -86;
  sub_F180(&v173, v16, 0x1F8ui64);
  v250 = 0;
  v197 = -6148914691236517206i64;
  v248 = sub_98E2();
  sub_1A2B6(1, (__int64)"[EB|#LW] %d\n", a12 != 0, v17);
  sub_2724(0, 0i64, 8);
  v252 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92CE0, 0i64, &v220);
  if ( v252 < 0 || *(_DWORD *)v220 < 2u )
  {
    v236 = 19i64;
    v232 = 0i64;
    v22 = 0i64;
    goto LABEL_7;
  }
  sub_1A2B6(1, (__int64)"[EB|#TB]\n", v18, v19);
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64 *))(v220 + 32))(v220, &v252) && v252 >= 0 )
  {
    v232 = 1i64;
    sub_1A2B6(1, (__int64)"[#TB:NBY]\n", v20, v21);
    v22 = 1i64;
    v236 = 4i64;
LABEL_7:
    v240 = v22;
    goto LABEL_8;
  }
  v236 = 19i64;
  v240 = 0i64;
  v232 = 1i64;
LABEL_8:
  v23 = *(_DWORD **)(v13 + 8i64 * !_bittest((const signed __int32 *)&qword_96AA8, 0x14u));
  LODWORD(v231) = *v23;
  v24 = (unsigned int)v23[3];
  v249 = sub_1364F(v24);
  sub_F1B0(v249, v24);
  v235 = v24;
  v26 = sub_23CAD(v12, v24, (unsigned __int64 *)&v219);
  v27 = v219;
  if ( v219 )
    sub_1A2B6(1, (__int64)"EB|`H:HB] ! @ BSZ, R: %qd\n", v219, v25);
  v28 = (__int64)a10;
  v29 = qword_96AA8;
  if ( _bittest(&v29, 0x14u) )
  {
    if ( ((unsigned int)qword_82000 & (unsigned int)qword_96AA8) == 0x2000i64 )
    {
      sub_1A2B6(1, (__int64)"[EB|`H:HB] ! @ 'APB\n", v27, v25);
      v28 = (__int64)a10;
    }
    v188 = 0i64;
    v187 = 0i64;
    v186 = 0i64;
    v185 = 0i64;
    v184 = 0i64;
    v183 = 0i64;
    v182 = 0i64;
    v204 = -6148914691236517206i64;
    v205 = -6148914691236517206i64;
    v206 = -6148914691236517206i64;
    v190 = 1290301015158498096i64;
    v191 = -379942466776188743i64;
    v189 = -1i64;
    v194 = a11;
    v193 = -1406344122541571929i64;
    v192 = 4865396145490737770i64;
    v195 = 4096i64;
    v196 = v28;
    v34 = (*(__int64 (__fastcall **)(__int64, signed __int64, __int64 *, unsigned __int64 *))(v13 + 24))(
            v13,
            1i64,
            &v189,
            &v182);
    v252 = v34;
    if ( v34 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`H:HB] %r @ %g.SC\n", v34, (__int64)qword_92A70);
      return 97i64;
    }
    v204 = 24i64;
    v205 = v12;
    v35 = v235;
    v206 = v235;
    sub_1A2B6(1, (__int64)"[EB|`H:HB] %g.SC -> RI: 0x%qx\n", (__int64)qword_92A70, v182);
    v30 = v249;
    v36 = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned __int64, _QWORD, __int64, __int64, unsigned __int64 *, __int64 *))(v13 + 40))(
            v13,
            (unsigned int)v231,
            v26,
            0i64,
            v35,
            v249,
            &v182,
            &v204);
    v252 = v36;
    if ( v36 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`H:HB] %r @ %g.RE\n", v36, (__int64)qword_92A70);
      return 98i64;
    }
    v14 = a12;
  }
  else
  {
    v30 = v249;
    v31 = (*(__int64 (__fastcall **)(__int64, _QWORD, unsigned __int64, __int64, __int64))(v13 + 24))(
            v13,
            (unsigned int)v231,
            v26,
            v235,
            v249);
    v252 = v31;
    if ( v31 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`H:HB] %r @ %g.RB\n", v31, (__int64)qword_92A60);
      return 99i64;
    }
  }
  sub_1A2B6(1, (__int64)"[EB|#H:SIG] 0x%X\n", *(unsigned int *)(v30 + 88), v32);
  v37 = *(_DWORD *)(v30 + 88);
  if ( v37 <= 1936289124 )
  {
    if ( v37 == -236929379 )
      return 117i64;
    if ( v37 == -52560675 )
      return 118i64;
    return 119i64;
  }
  if ( v37 != 1936289125 )
  {
    v33 = 116i64;
    if ( v37 == 2054847098 )
      return v33;
    return 119i64;
  }
  v38 = sub_74E9("FACP");
  if ( v38 )
  {
    if ( *(_BYTE *)(v38 + 8) >= 3u && (v39 = *(_QWORD *)(v38 + 132)) != 0
      || (v39 = *(unsigned int *)(v38 + 36), *(_DWORD *)(v38 + 36)) )
    {
      v33 = 102i64;
      if ( *(_QWORD *)(v30 + 128) != *(_DWORD *)(v39 + 8) )
        return v33;
    }
  }
  v40 = 0i64;
  sub_2724(0, 0i64, 10);
  if ( !qword_96BA0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`H:HB] ! @ 'SIO\n", v41, v42);
    v50 = 100;
    v51 = 0;
LABEL_45:
    v45 = 0i64;
    goto LABEL_59;
  }
  LOWORD(v189) = -21846;
  LOBYTE(v41) = 1;
  v43 = (*(__int64 (__fastcall **)(__int64, signed __int64, __int64))(qword_96BA0 + 8))(qword_96BA0, 1297307506i64, v41);
  v252 = v43;
  if ( v43 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`H:HB] %r @ MSWr\n", v43, v44);
    v50 = 100;
    v51 = 0;
    v40 = 0i64;
    goto LABEL_45;
  }
  v45 = (unsigned __int8)v189;
  sub_1A2B6(1, (__int64)"[EB|#H:MSWr] 0x%x\n", (unsigned __int8)v189, v44);
  LOBYTE(v46) = 2;
  v252 = (*(__int64 (__fastcall **)(__int64, signed __int64, __int64, __int64 *))(qword_96BA0 + 8))(
           qword_96BA0,
           1297305683i64,
           v46,
           &v189);
  if ( v252 < 0 )
  {
    v49 = 100;
    goto LABEL_47;
  }
  v49 = BYTE1(v189);
  sub_1A2B6(1, (__int64)"[EB|#H:MSPS] 0x%x\n", BYTE1(v189), v48);
  if ( v49 >= 4 )
  {
LABEL_47:
    v52 = "[EB|#H:FWK.1]\n";
LABEL_48:
    sub_1A2B6(1, (__int64)v52, v47, v48);
    v40 = 0i64;
    goto LABEL_49;
  }
  if ( (char)v45 <= 111 )
  {
    if ( (_BYTE)v45 == 25 )
      goto LABEL_90;
    if ( (_BYTE)v45 != 33 )
      goto LABEL_98;
    goto LABEL_89;
  }
  switch ( (_BYTE)v45 )
  {
    case 0x70:
LABEL_90:
      v52 = "[EB|#H:LID]\n";
      goto LABEL_48;
    case 0x74:
LABEL_89:
      sub_1A2B6(1, (__int64)"[EB|#H:DKWK.1]\n", v47, v48);
      v40 = 8 * (unsigned int)(v14 == 0);
      goto LABEL_49;
    case 0x72:
      goto LABEL_90;
  }
LABEL_98:
  v40 = 0i64;
  if ( !v14 )
  {
    LOBYTE(v47) = 1;
    v252 = (*(__int64 (__fastcall **)(__int64, signed __int64, __int64, __int64 *))(qword_96BA0 + 8))(
             qword_96BA0,
             1297303127i64,
             v47,
             &v189);
    if ( v252 < 0 )
    {
      v50 = 3;
      if ( (unsigned __int8)v49 > 2u )
        goto LABEL_50;
      v149 = "[EB|#H:DKWK.3]\n";
    }
    else
    {
      if ( (_BYTE)v189 == 1 )
      {
        sub_1A2B6(1, (__int64)"[EB|#H:FWK.2]\n", v73, v74);
        goto LABEL_49;
      }
      v149 = "[EB|#H:DKWK.2]\n";
    }
    sub_1A2B6(1, (__int64)v149, v73, v74);
    v40 = 8i64;
  }
LABEL_49:
  v50 = v49;
LABEL_50:
  v197 = 1i64;
  v252 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
           L"next-wake-type",
           qword_92360,
           0i64);
  if ( v252 >= 0 && v250 == 1 )
  {
    sub_1A2B6(1, (__int64)"[EB|#H:FWK.3]\n", v53, v54);
LABEL_58:
    LOBYTE(v182) = 0;
    LOBYTE(v53) = 1;
    v252 = (*(__int64 (__fastcall **)(__int64, signed __int64, __int64))(qword_96BA0 + 16))(
             qword_96BA0,
             1464554576i64,
             v53);
    v51 = 0;
    v40 = 0i64;
    goto LABEL_59;
  }
  if ( !(_DWORD)v40 )
    goto LABEL_58;
  v51 = 0;
  if ( !(unsigned int)sub_E83F() )
  {
    LOBYTE(v51) = (unsigned int)sub_18A1A("MacPro6,1", v248) != 0;
    v55 = 0;
    if ( !(_BYTE)v51 )
      v55 = v40;
    v40 = v55;
  }
LABEL_59:
  if ( *(_DWORD *)(v30 + 112) )
    sub_18D87((char *)*(unsigned int *)(v30 + 112), *(unsigned int *)(v30 + 116));
  else
    sub_19006();
  sub_1905F((__int64)"Start");
  sub_2724(0, 0i64, 9);
  v223 = *(_QWORD *)(v30 + 8);
  v56 = *(_DWORD *)(v30 + 32);
  v252 = sub_1738E(&v239, (__int64 *)&v238, (__int64)&v218, (__int64)&v230, (__int64)&v244);
  if ( v252 < 0 )
    return 103i64;
  v229 = &v238[v239];
  v252 = sub_1775B(v238, (unsigned __int64 *)&v229, v230);
  if ( v252 < 0 )
    return 104i64;
  v242 = v50;
  v214 = v51;
  v57 = v229 - v238;
  v238 = 0i64;
  v239 = 0i64;
  sub_2724(0, 0i64, 11);
  v182 = -6148914691236517206i64;
  v182 = sub_23C84(*(unsigned int *)(v30 + 16), 12);
  v252 = sub_13759(2i64, 2i64, *(unsigned int *)(v30 + 32), (__int64 *)&v182);
  if ( v252 < 0 )
    return 105i64;
  v182 = sub_23C84(*(unsigned int *)(v30 + 96), 12);
  v252 = sub_13759(2i64, 2i64, *(unsigned int *)(v30 + 100), (__int64 *)&v182);
  if ( v252 < 0 )
    return 106i64;
  v182 = 0i64;
  v58 = sub_23C9F((v223 + 4095) & 0xFFFFFFFFFFFFF000ui64, 12);
  v252 = sub_13759(0i64, 2i64, (unsigned int)(v58 + 1), (__int64 *)&v182);
  if ( v252 < 0 )
    return 107i64;
  v233 = v57;
  v209 = v45;
  v59 = v182;
  v60 = v249;
  v200 = *(_QWORD *)(v249 + 464);
  v61 = *(unsigned int *)(v249 + 472);
  sub_1B950((char *)v249, (char *)v182, 0x200ui64);
  sub_136C5(v60);
  v221 = *(_QWORD *)(v59 + 488);
  v62 = *(_QWORD *)(v59 + 480);
  v249 = v61;
  v222 = v61 + v62;
  if ( (unsigned int)dword_96BDC < *(_DWORD *)(v59 + 180) )
    dword_96BDC = 0;
  v202 = *(_QWORD *)(v59 + 8) + 0x100000i64;
  v63 = *(_DWORD *)(v59 + 136);
  v64 = *(_DWORD *)(v59 + 176);
  v65 = 0i64;
  if ( v64 & 4 )
    v65 = &v172;
  if ( (_BYTE)v240 )
    v65 = &v172;
  v66 = *(_DWORD *)(v59 + 136);
  v67 = ((_BYTE)v240 == 0) & ((unsigned __int8)(v64 & 2) >> 1);
  v237 = v65;
  v226 = v67;
  v225 = v40 & 0xFFFFFFF8;
  LODWORD(v171) = ((unsigned int)v40 & 0xFFFFFFF8) >> 3;
  v241 = v63 != 0;
  v68 = sub_1A2B6(1, (__int64)"[EB|#H:HBOPT] SU %d, RP %d, CP %d, DW %d\n", v65 != 0i64, v63 != 0);
  if ( !(_BYTE)v67 )
    qword_94C70 = 0i64;
  v69 = (unsigned int)(v56 << 12);
  v70 = v248;
  if ( v248 )
  {
    if ( !(unsigned int)sub_18A1A("MacBookAir4,1", v248)
      || (LODWORD(v68) = sub_18A1A("MacBookAir4,2", v70), !(_DWORD)v68) )
    {
      if ( !sub_7B52(0x10000000) )
        qword_94C70 = 0i64;
    }
  }
  v71 = v59 + 512;
  LOBYTE(v68) = qword_94C70 == 0;
  v245 = (signed int)v68;
  if ( v66 )
    v216 = v71 + ((v235 + v69 + (unsigned int)(*(_DWORD *)(v59 + 136) + *(_DWORD *)(v59 + 476)) - 33) & -v235);
  else
    v216 = 0i64;
  v72 = *(_QWORD *)(v59 + 120) == 0i64;
  v246 = v59;
  if ( v72 )
  {
    v248 = 0i64;
    v217 = 0i64;
    v224 = 0i64;
  }
  else
  {
    v33 = 108i64;
    if ( !a10 || !a11 )
      return v33;
    if ( v227 )
    {
      a5 = sub_4067(a11, a10, &v174, a9);
      v224 = 0i64;
    }
    else
    {
      v75 = (*(__int64 (__fastcall **)(signed __int64))(qword_96CD8 + 24))(31i64);
      a5 = sub_4067(a11, a10, &v174, a9);
      v224 = v75;
      (*(void (__fastcall **)(__int64))(qword_96CD8 + 32))(v75);
    }
    v59 = v246;
    sub_1B950((char *)qword_8F050, &v173, 0x10ui64);
    v248 = (char *)(v71 - v249 + *(_QWORD *)(v59 + 120));
    v217 = *(_QWORD *)(v59 + 456) + v71 - v249;
  }
  v210 = v69;
  if ( !a12 )
    goto LABEL_109;
  if ( qword_96AA8 & 0x80000 )
    goto LABEL_108;
  if ( sub_1BE84() == 1 )
  {
    dword_96BFC = 2;
LABEL_108:
    dword_94C80 = 1;
  }
LABEL_109:
  v234 = v40;
  v233 *= 2i64;
  v76 = v223 - v249;
  v221 -= v249;
  v247 = v237 == 0i64;
  sub_2724(0, 0i64, 13);
  sub_1A2B6(1, (__int64)"[EB|#H:RDST]\n", v77, v78);
  sub_1A6EF(7u);
  sub_1905F((__int64)"Start hibernate read");
  v79 = v71;
  v203 = (unsigned int)v236;
  v201 = v235 - 1;
  v251 = v227 == 0;
  v208 = v59 + 480;
  v210 += v59 + 480;
  v80 = 1;
  v223 = v76;
  v207 = 0i64;
  v81 = 0;
  v82 = 0;
  v83 = 0i64;
  LODWORD(v249) = 0;
  v84 = (unsigned __int64)v248;
  while ( 1 )
  {
    v85 = (char *)v84;
    if ( !(v76 | v84) )
    {
      v110 = (char *)v76;
      v112 = a12;
      v111 = v246;
      goto LABEL_188;
    }
    if ( (_BYTE)v81 )
    {
      if ( (_BYTE)v82
        || (v86 = v80,
            v87 = v76,
            v88 = v81,
            v89 = (*(__int64 (**)(void))(v227 + 8))(),
            v81 = v88,
            v76 = v87,
            (v252 = v89) == 0) )
      {
        v76 -= v15;
        if ( !(_BYTE)v241 )
          v83 = v203 * (v15 + v207) / v202;
        v207 += v15;
        v222 += v15;
        v221 -= v15;
        v79 += v15;
        v80 = v76 != 0;
        v81 = 0;
      }
      else
      {
        v80 = v86;
      }
      v82 = 0;
    }
    else
    {
      v81 = 0;
    }
    if ( !v80 )
      goto LABEL_139;
    v248 = (char *)v76;
    v228 = v83;
    v90 = v221;
    v91 = (__int64 (__fastcall **)(_QWORD, _QWORD, unsigned __int64, unsigned __int64, unsigned __int64, unsigned int *, __int64, __int64))v227;
    if ( !v221 )
    {
      v222 = *(_QWORD *)(v208 + 16);
      v90 = *(_QWORD *)(v208 + 24);
      v208 += 16i64;
    }
    v15 = (unsigned __int64)v248;
    if ( v90 < (unsigned __int64)v248 )
      v15 = v90;
    if ( v216 > v79 && v15 > v216 - v79 )
      v15 = v216 - v79;
    if ( v15 >= 0x100000 )
      v15 = 0x100000i64;
    v221 = v90;
    if ( v227 )
    {
      v92 = v79;
      v219 = 0i64;
      v93 = v222 + v200;
      v94 = sub_23CAD(v222 + v200, v235, (unsigned __int64 *)&v219);
      if ( v219 | v201 & v15 )
      {
        v112 = a12;
        v96 = -9223372036854775786i64;
        v252 = -9223372036854775786i64;
        goto LABEL_186;
      }
      v96 = (*v91)(v91, (unsigned int)v231, v94, v15, v92, a10, a11, v93);
      v252 = v96;
      if ( v96 < 0 )
      {
        v112 = a12;
LABEL_186:
        v111 = v246;
        v110 = v248;
        sub_1A2B6(1, (__int64)"[EB|`H:HB] %r @ ?.RD\n", v96, v95);
        goto LABEL_188;
      }
      goto LABEL_135;
    }
    v92 = v79;
    v252 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, unsigned __int64))(v199 + 8))(
             v199,
             (unsigned int)v231,
             v222,
             v15);
    LOBYTE(v82) = 1;
    if ( v252 < 0 )
      break;
LABEL_135:
    LOBYTE(v81) = 1;
    if ( !(_BYTE)v245 && qword_94C70 )
    {
      v97 = sub_18D72();
      LOBYTE(v81) = 1;
      LOBYTE(v97) = v97 > qword_94C70;
      v245 = v97;
    }
    v79 = v92;
    v83 = v228;
    v76 = (__int64)v248;
LABEL_139:
    if ( !v247 && (_DWORD)v83 != (_DWORD)v249 )
    {
      v98 = v76;
      v99 = v81;
      sub_CDB1((__int64)v237, (unsigned int)v249);
      v81 = v99;
      v76 = v98;
      LODWORD(v249) = v83;
    }
    v84 = (unsigned __int64)v85;
    v80 = 0;
    if ( v85 && v79 > (unsigned __int64)v85 )
    {
      v248 = (char *)v76;
      v100 = v81;
      v215 = v82;
      v228 = v83;
      v101 = v84;
      v102 = v217;
      v243 = v79;
      if ( v79 < v217 )
        v102 = v79;
      v103 = (char *)(v102 - v84);
      if ( v103 >= (char *)&loc_1FFFD + 3 )
        v103 = (char *)&loc_1FFFD + 3;
      v189 = -6148914691236517206i64;
      v190 = -6148914691236517206i64;
      sub_1B950(&v173, (char *)&v189, 0x10ui64);
      sub_1B950(&v103[v101 - 16], &v173, 0x10ui64);
      v104 = v227;
      if ( !v227 )
        v224 = (*(__int64 (__fastcall **)(signed __int64))(qword_96CD8 + 24))(31i64);
      v169 = &v174;
      sub_194E0((__m128i *)a5.m128_u64[0], a6, a7, a8, a9);
      if ( !v104 )
        (*(void (__fastcall **)(__int64))(qword_96CD8 + 32))(v224);
      v105 = (unsigned __int64)&v103[v101];
      if ( !(_BYTE)v245 )
      {
        v245 = 0;
        v79 = v243;
        v81 = v100;
        goto LABEL_181;
      }
      v79 = v243;
      v81 = v100;
      if ( (_BYTE)v241 )
      {
        if ( v105 < v216 )
          goto LABEL_181;
        v106 = *(unsigned int *)(v246 + 140);
        v107 = v210 + *(unsigned int *)(v246 + 476);
        v108 = *(_DWORD *)(v106 + v107 + 16);
        dword_96BF8 = *(_DWORD *)(v106 + v107 + 16);
        if ( a12 )
        {
          if ( dword_94C80 )
          {
            if ( !(qword_96AA8 & 0x80000) )
            {
              dword_96BFC = 2;
              v109 = 0i64;
              goto LABEL_177;
            }
            dword_96BFC = 3;
          }
          else
          {
            dword_96BFC = 4;
          }
          v109 = 1i64;
LABEL_177:
          if ( !v225 )
          {
            LOBYTE(v171) = v251;
            LOBYTE(v169) = a12;
            sub_C4E0(v106 + v107, v109, (__int64)v237, v226, (__int64)v169, v171, (__int64 *)&v211);
            goto LABEL_179;
          }
          goto LABEL_180;
        }
        v109 = 1i64;
        if ( (_BYTE)v240 )
          goto LABEL_177;
        if ( (_DWORD)v232 )
        {
          if ( v242 > 3 )
            goto LABEL_176;
        }
        else if ( v242 >= 4 && qword_96AA8 & 0x100000 )
        {
          goto LABEL_176;
        }
        if ( v108 )
        {
          if ( dword_96BDC - 1 < v108 )
          {
            dword_96BFC = 2;
            goto LABEL_174;
          }
          dword_96BFC = 3;
        }
        else
        {
          dword_96BFC = 1;
LABEL_174:
          v109 = 0i64;
        }
LABEL_176:
        v79 = v243;
        v81 = v100;
        goto LABEL_177;
      }
      if ( !v225 )
      {
        sub_2724(0, 0i64, 12);
        LOBYTE(v171) = v251;
        LOBYTE(v169) = a12;
        sub_C4E0(0i64, 0i64, (__int64)v237, v226, (__int64)v169, v171, (__int64 *)&v211);
LABEL_179:
        v81 = v100;
        v79 = v243;
      }
LABEL_180:
      qword_94C70 = 0i64;
      v241 = 0;
      v245 = 0;
LABEL_181:
      v80 = 0;
      v84 = 0i64;
      if ( v105 != v217 )
        v84 = v105;
      v83 = v228;
      v82 = v215;
      v76 = (__int64)v248;
    }
  }
  v112 = a12;
  v111 = v246;
  v110 = v248;
LABEL_188:
  sub_1905F(
    (__int64)"End hibernate read (bytes 0x%qx, encrypted 0x%qx)",
    v223,
    *(_QWORD *)(v111 + 456) - *(_QWORD *)(v111 + 120));
  sub_1A6EF(8u);
  sub_1A2B6(1, (__int64)"[EB|#H:RDEND]\n", v113, v114);
  v116 = v240;
  if ( (_BYTE)v240 )
  {
LABEL_189:
    if ( !dword_94C80 )
    {
      dword_96BFC = 3 - ((v112 < 1u) - 1);
      sub_1A2B6(1, (__int64)"[EB|#H:LKST] %d\n", 3 - ((unsigned int)(v112 < 1u) - 1), v115);
      v116 = v240;
    }
  }
  else if ( (_DWORD)v232 )
  {
    if ( v242 >= 4 )
      goto LABEL_189;
  }
  else if ( v242 >= 4 && qword_96AA8 & 0x100000 )
  {
    goto LABEL_189;
  }
  v33 = 115i64;
  if ( !v110 )
  {
    v117 = a11;
    if ( v116 )
    {
      sub_1905F((__int64)"Start Check M8 boot");
      v118 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v220 + 32))(v220, &v252);
      v121 = v252;
      if ( !v118 && v252 >= 0 )
      {
        v122 = 190 - 10 * v236;
        v123 = 190 - 10 * v236;
        do
        {
          (*(void (__fastcall **)(signed __int64, __int64, __int64))(qword_96CD8 + 248))(10000i64, v119, v121);
          v124 = v236 + v123 / 0x2328;
          if ( v124 <= 0x11 && v237 && v124 != (_DWORD)v249 )
          {
            sub_CDB1((__int64)v237, (unsigned int)v249);
            LODWORD(v249) = v124;
          }
          v125 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v220 + 32))(v220, &v252);
          v121 = v252;
          if ( v125 )
            break;
          v123 += v122;
        }
        while ( v252 >= 0 );
      }
      if ( v121 < 0 )
        sub_1A2B6(1, (__int64)"[EB|`H:HB] %r @ %g.CKB\n", v121, (__int64)qword_92CE0);
      else
        sub_1A2B6(1, (__int64)"[EB|#H:TBRDY]\n", v121, v120);
      v117 = a11;
      if ( v237 )
        sub_CDB1((__int64)v237, 17i64);
      sub_1905F((__int64)"End Check M8 boot");
    }
    sub_192A2();
    v126 = 0i64;
    v189 = 0i64;
    v204 = 0i64;
    v127 = qword_96AA8;
    if ( _bittest((const signed int *)&v127, 9u) )
    {
      sub_1E2B5();
      sub_1E360(0i64, (unsigned __int64 *)&v204);
      v126 = v204 + 8;
      v127 = qword_96AA8;
    }
    v128 = (v127 << 43 >> 63) & (v117 + 8);
    sub_1A2B6(1, (__int64)"[EB|`H:HB] LKST: %d, FDUM: %d\n", (unsigned int)dword_96BFC, (unsigned int)dword_94C80);
    v129 = (signed __int64 *)sub_A398();
    if ( v129 )
    {
      v130 = v129;
      sub_9EC7(v129, "IOScreenLockState", 4ui64, (char *)&dword_96BFC, 0);
      sub_9EC7(v130, "IOFDEUserMatched", 4ui64, (char *)&dword_94C80, 0);
    }
    sub_A211(0i64, &v189);
    v182 = 0i64;
    v131 = ((v189 + v128 + v233 + v126 + 808) >> 12) + 1;
    v252 = sub_13759(0i64, 2i64, v131, (__int64 *)&v182);
    if ( v252 < 0 )
      return 109i64;
    v132 = v182;
    v133 = v246;
    *(_DWORD *)(v246 + 160) = v182 >> 12;
    *(_DWORD *)(v133 + 164) = v131;
    *(_QWORD *)v132 = 3231567511553i64;
    sub_F1B0(&v175, 56i64);
    sub_CAE6((__int64)&v175, &v213);
    v134 = v181;
    *(_QWORD *)(v132 + 8) = v181;
    *(_DWORD *)(v132 + 20) = HIDWORD(v175);
    *(_QWORD *)(v132 + 24) = v176;
    *(_DWORD *)(v132 + 32) = v177;
    *(_DWORD *)(v132 + 16) = v213;
    if ( v134 )
    {
      v234 &= 7u;
      if ( v237 )
        sub_1B950(v237, (char *)(v132 + 36), 0x2D2ui64);
    }
    else
    {
      v234 = (unsigned int)v234 | 8;
    }
    *(_QWORD *)(v132 + 760) = 70471581698i64;
    sub_1B950(&v173, (char *)(v132 + 768), 0x10ui64);
    sub_F1B0(&v173, 8i64);
    if ( qword_96AA8 & 0x100000 )
    {
      *(_DWORD *)(v132 + 784) = 1752104967;
      *(_DWORD *)(v132 + 788) = a11;
      v136 = a10;
      sub_1B930((char *)(v132 + 792), (char *)a10, a11);
      v135 = (_DWORD *)(*(unsigned int *)(v132 + 788) + v132 + 792);
    }
    else
    {
      v135 = (_DWORD *)(v132 + 784);
      v136 = a10;
    }
    if ( v136 && a11 )
      sub_F1B0(v136, a11);
    if ( qword_96AA8 & 0x200 )
    {
      *v135 = 1752104966;
      v137 = (unsigned int)v204;
      v135[1] = v204;
      v198 = v135 + 2;
      v135 = (_DWORD *)((char *)v135 + v137 + 8);
      sub_1E360((unsigned __int64 *)&v198, (unsigned __int64 *)&v204);
    }
    *v135 = 1752104964;
    v138 = (unsigned int)v189;
    v135[1] = v189;
    v198 = v135 + 2;
    sub_A211(&v198, &v189);
    *(_DWORD *)((char *)v135 + v138 + 8) = 1752104963;
    *(_DWORD *)(v246 + 420) = 0;
    if ( byte_96B49 )
    {
      sub_1905F((__int64)"Start ExitBootServicesWa");
      LOBYTE(v139) = 1;
      sub_5DCF(v139);
      sub_1905F((__int64)"End ExitBootServicesWa");
    }
    sub_2724(0, 0i64, 14);
    sub_1A6EF(0xAu);
    v252 = sub_1738E(&v239, (__int64 *)&v238, (__int64)&v218, (__int64)&v230, (__int64)&v244);
    v140 = 110i64;
    if ( v252 >= 0 )
    {
      v231 = (_DWORD *)((char *)v135 + v138 + 8);
      v141 = (char *)v135 + v138 + 16;
      v142 = v209 + 21248;
      v143 = 2;
      v144 = (_DWORD *)v246;
      while ( 1 )
      {
        v229 = &v238[v239];
        v252 = sub_1775B(v238, (unsigned __int64 *)&v229, v230);
        if ( v252 < 0 )
        {
          v140 = 111i64;
          goto LABEL_258;
        }
        v239 = v229 - v238;
        if ( v229 - v238 > v233 )
        {
          v140 = 112i64;
          goto LABEL_258;
        }
        sub_1B930(v141, v238, v229 - v238);
        v145 = v234;
        if ( (_BYTE)v214 )
          v145 = (unsigned int)v234 | 8;
        v233 = v239;
        v144[38] = v142;
        v146 = (unsigned int)v145 | v144[44];
        v144[44] = v146;
        v144[108] = (unsigned __int64)qword_94C78 >> 8;
        v144[109] = dword_94C68;
        v144[110] = v211 >> 8;
        v144[111] = v212 >> 8;
        v234 = v145;
        sub_1A2B6(1, (__int64)"[EB|#H:HD] WR: 0x%x, OPT: 0x%x, GOPT: 0x%x\n", v209, v146);
        v147 = sub_18D72();
        sub_1905F((__int64)"Start ExitBootServices");
        v252 = (*(__int64 (__fastcall **)(__int64, __int64))(qword_96CD8 + 232))(qword_96A90, v218);
        sub_1905F((__int64)"End ExitBootServices");
        v144[105] += (sub_18D72() - v147) >> 8;
        if ( v252 != -9223372036854775806i64 )
          break;
        if ( v143 - 1 > 4 )
          goto LABEL_257;
        sub_1A2B6(1, (__int64)"[EB|`H:HB] %r @ ExitBS, %d\n", -9223372036854775806i64, v143);
        v252 = sub_1738E(&v239, (__int64 *)&v238, (__int64)&v218, (__int64)&v230, (__int64)&v244);
        ++v143;
        if ( v252 < 0 )
        {
          v140 = 110i64;
          goto LABEL_258;
        }
      }
      if ( v252 < 0 )
      {
LABEL_257:
        v140 = 113i64;
        sub_1A2B6(1, (__int64)"[EB|`H:HB] %r @ ExitBS\n", 113i64, v148);
        goto LABEL_258;
      }
      sub_1A6EF(0xBu);
      v150 = 0;
      qword_96CD8 = 0i64;
      sub_2724(4, v252, 15);
      v235 = sub_18D72();
      sub_1905F((__int64)"Start FinalizeMemoryMap");
      v151 = v246;
      v152 = sub_23C84(*(unsigned int *)(v246 + 96), 12);
      v153 = v152 + sub_23C84(*(unsigned int *)(v151 + 100), 12);
      v154 = sub_23C84(*(_QWORD *)(v151 + 104), 12);
      v155 = v233;
      v229 = &v141[v233];
      LODWORD(v170) = v244;
      v252 = sub_178DE((unsigned __int64)v141, &v141[v233], 0i64, v230, v170, v152, v153, v154);
      *(_DWORD *)(v151 + 168) = qword_96CD0 - v152;
      v156 = (__int64)v231;
      v231[1] = v155;
      *(_QWORD *)(v156 + v155 + 8) = 1752104960i64;
      qword_96CE0 = 0i64;
      qword_96CD8 = 0i64;
      if ( *(_DWORD *)(v151 + 168) )
      {
        sub_1905F((__int64)"End FinalizeMemoryMap");
        *(_DWORD *)(v151 + 424) = (sub_18D72() - v235) >> 8;
        *(_DWORD *)(v151 + 448) = (sub_18D72() - qword_94C78) >> 8;
        v158 = *(unsigned int *)(v151 + 32);
        v159 = *(_DWORD *)(v151 + 16) << 12;
        v160 = v159 + *(_DWORD *)(v151 + 36);
        if ( *(_DWORD *)(v151 + 32) )
        {
          v161 = v246 + *(unsigned int *)(v246 + 476) + 480;
          v162 = (unsigned int)(*(_DWORD *)(v151 + 16) << 12);
          v157 = *(_QWORD *)(v246 + 24);
          v163 = 0i64;
          v150 = 0;
          do
          {
            v164 = *(_DWORD *)(v161 + 4i64 * (((_WORD)v163 + (_WORD)v157) & 0x3FF));
            v165 = 0i64;
            do
            {
              *(_DWORD *)(v162 + v165) = *(_DWORD *)(v161 + v165);
              *(_DWORD *)(v162 + v165 + 4) = *(_DWORD *)(v161 + v165 + 4);
              *(_DWORD *)(v162 + v165 + 8) = *(_DWORD *)(v161 + v165 + 8);
              *(_DWORD *)(v162 + v165 + 12) = *(_DWORD *)(v161 + v165 + 12);
              *(_DWORD *)(v162 + v165 + 16) = *(_DWORD *)(v161 + v165 + 16);
              *(_DWORD *)(v162 + v165 + 20) = *(_DWORD *)(v161 + v165 + 20);
              *(_DWORD *)(v162 + v165 + 24) = *(_DWORD *)(v161 + v165 + 24);
              *(_DWORD *)(v162 + v165 + 28) = *(_DWORD *)(v161 + v165 + 28);
              v165 += 32i64;
            }
            while ( v165 < 0x1000 );
            v150 += v164;
            ++v163;
            v162 += v165;
            v161 += v165;
          }
          while ( v163 != v158 );
        }
        v166 = v246;
        *(_DWORD *)(v246 + 64) = v150;
        sub_1A2B6(1, (__int64)"[EB|#H:WK]\n", v158, v157);
        sub_1905F((__int64)"End");
        _disable();
        v167 = sub_23C9F(v166, 12);
        sub_2724(4, 0i64, 16);
        qword_96AC8(v167, v160);
        sub_9CE0((__int64)"[EB|#STOP|`H:HB] Kernel entry failed\n");
        sub_5202(-9223372036854775787i64);
        return v33;
      }
      v140 = 114i64;
    }
LABEL_258:
    v33 = v140;
  }
  return v33;
}
// 15BFA: write access to const memory at 96BDC has been detected
// 15CA2: write access to const memory at 94C70 has been detected
// 15CF2: write access to const memory at 94C70 has been detected
// 15F37: write access to const memory at 96BFC has been detected
// 15F41: write access to const memory at 94C80 has been detected
// 1639D: write access to const memory at 96BF8 has been detected
// 163C2: write access to const memory at 96BFC has been detected
// 16445: write access to const memory at 96BFC has been detected
// 16451: write access to const memory at 96BFC has been detected
// 1648B: write access to const memory at 96BFC has been detected
// 16497: write access to const memory at 96BFC has been detected
// 164A5: write access to const memory at 96BFC has been detected
// 164F3: write access to const memory at 94C70 has been detected
// 165DE: write access to const memory at 96BFC has been detected
// 16D43: write access to const memory at 96CD8 has been detected
// 16E0E: write access to const memory at 96CE0 has been detected
// 16E15: write access to const memory at 96CD8 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 410A0: using guessed type __int16 aNextWakeType[15];
// 82000: using guessed type __int64 qword_82000[512];
// 8F050: using guessed type __int64 qword_8F050[2];
// 92360: using guessed type __int64 qword_92360[2];
// 92A60: using guessed type __int64 qword_92A60[2];
// 92A70: using guessed type __int64 qword_92A70[2];
// 92CE0: using guessed type __int64 qword_92CE0[2];
// 94C68: using guessed type int dword_94C68;
// 94C70: using guessed type __int64 qword_94C70;
// 94C78: using guessed type __int64 qword_94C78;
// 94C80: using guessed type int dword_94C80;
// 96A90: using guessed type __int64 qword_96A90;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AC8: using guessed type __int64 (__fastcall *qword_96AC8)(_QWORD, _QWORD);
// 96B49: using guessed type char byte_96B49;
// 96BA0: using guessed type __int64 qword_96BA0;
// 96BDC: using guessed type int dword_96BDC;
// 96BF8: using guessed type int dword_96BF8;
// 96BFC: using guessed type int dword_96BFC;
// 96CD0: using guessed type __int64 qword_96CD0;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000016FB7) ----------------------------------------------------
signed __int64 __fastcall sub_16FB7(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // r9
  __int64 v10; // rsi
  const char *v11; // rdx
  __int64 *v12; // r9
  __int64 v14; // [rsp+28h] [rbp-28h]
  __int64 v15; // [rsp+30h] [rbp-20h]
  __int64 v16; // [rsp+38h] [rbp-18h]

  v15 = -9034400514174975832i64;
  v14 = 5457143572451254544i64;
  v16 = -6148914691236517206i64;
  if ( !qword_96BE8 )
    return 0i64;
  sub_1A2B6(1, (__int64)"[EB|#H:RPRM]\n", a3, a4);
  v4 = (*(__int64 (__fastcall **)(const char *, __int64 *, signed __int64, signed __int64, __int64 *, __int64, __int64))(qword_96CE0 + 88))(
         "I",
         &v14,
         1i64,
         44i64,
         &qword_96BB0,
         v14,
         v15);
  if ( v4 < 0 )
  {
    v10 = v4;
    v11 = "[EB|`H:RPRM] %r @ SV %S\n";
    v12 = (__int64 *)"I";
LABEL_13:
    sub_1A2B6(1, (__int64)v11, v10, (__int64)v12);
    return v10;
  }
  if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92C10, 0i64, &v16) >= 0 )
  {
    v5 = (*(__int64 (__fastcall **)(__int64, __int64 *, signed __int64, signed __int64))(v16 + 16))(
           v16,
           &qword_96BB0,
           44i64,
           128i64);
    if ( v5 < 0 )
    {
      v10 = v5;
      v11 = "[EB|`H:RPRM] %r @ %g.W\n";
      v12 = qword_92C10;
      goto LABEL_13;
    }
  }
  v6 = sub_23DB4(qword_96AD8, *(_QWORD *)(qword_96A98 + 32));
  if ( !v6 )
    return -9223372036854775799i64;
  v7 = v6;
  v8 = sub_1BEDE(0x82u, &word_4109E, v6, *(_DWORD *)(qword_96A98 + 48), *(_QWORD *)(qword_96A98 + 56));
  v10 = v8;
  if ( v8 < 0 )
    sub_1A2B6(1, (__int64)"[EB|`H:RPRM] %r @ CS:SBN\n", v8, v9);
  (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v7);
  return v10;
}
// 4109E: using guessed type __int16 word_4109E;
// 92C10: using guessed type __int64 qword_92C10[2];
// 96A98: using guessed type __int64 qword_96A98;
// 96AD8: using guessed type __int64 qword_96AD8;
// 96BB0: using guessed type __int64 qword_96BB0;
// 96BE8: using guessed type __int64 qword_96BE8;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000017139) ----------------------------------------------------
__int64 __usercall sub_17139@<rax>(unsigned __int64 a1@<rdx>, unsigned int *a2@<rcx>, __m128 *a3@<xmm0>, __m128i *a4@<xmm1>, __m128i *a5@<xmm2>, __m128i *a6@<xmm6>, __m128i *a7@<xmm7>)
{
  unsigned __int64 v7; // rdi
  unsigned int *v8; // rsi
  __int64 v9; // rbx
  __int64 v10; // r9
  unsigned __int64 v11; // rax
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r9

  v7 = a1;
  v8 = a2;
  v9 = 0i64;
  sub_2724(0, 0i64, 17);
  sub_1A2B6(1, (__int64)"[EB|`H:FFH] 'IN %d, %qd\n", v8 != 0i64, v7);
  sub_1A2B6(1, (__int64)"[EB|`H:FFH] 'GNKS %qd\n", qword_96BE8, v10);
  if ( v8 )
  {
    if ( qword_96AA8 & 0x100000 )
    {
LABEL_12:
      sub_2724(0, 0i64, 18);
      sub_1A2B6(1, (__int64)"[EB|#H:BOOT.2]\n", v12, v13);
      v9 = sub_152FD(
             qword_96B90,
             qword_96BA8,
             qword_96B98,
             qword_96BE0,
             a3,
             a4,
             a5,
             a6,
             a7,
             v8,
             v7,
             ((unsigned __int64)qword_96AA8 >> 22) & 1);
      sub_1A2B6(1, (__int64)"[EB|`H:FFH] %r @ H:HB\n", v9, v14);
      goto LABEL_13;
    }
    if ( qword_96BE8 < v7 )
    {
      v7 = qword_96BE8;
      goto LABEL_7;
    }
    if ( qword_96BE8 <= v7 )
    {
LABEL_7:
      if ( v7 )
      {
        v11 = 0i64;
        do
        {
          *((_BYTE *)v8 + v11) ^= *(_BYTE *)(qword_96BF0 + v11);
          ++v11;
        }
        while ( v11 < v7 );
      }
      else
      {
        v7 = 0i64;
      }
      goto LABEL_12;
    }
    v9 = 0i64;
  }
LABEL_13:
  sub_2724(32, v9, 0);
  return sub_52BA(0, 4u);
}
// 96AA8: using guessed type __int64 qword_96AA8;
// 96B90: using guessed type __int64 qword_96B90;
// 96B98: using guessed type __int64 qword_96B98;
// 96BA8: using guessed type __int64 qword_96BA8;
// 96BE0: using guessed type __int64 qword_96BE0;
// 96BE8: using guessed type __int64 qword_96BE8;
// 96BF0: using guessed type __int64 qword_96BF0;

//----- (0000000000017276) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_17276()
{
  __int64 v0; // rsi
  __int64 v1; // rdi
  unsigned __int64 v2; // rdx
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // r9
  __int64 v6; // rbx
  __int64 v7; // rdi
  __int128 v9; // [rsp+28h] [rbp-48h]
  __int64 v10; // [rsp+38h] [rbp-38h]
  int v11; // [rsp+44h] [rbp-2Ch]
  __int64 v12; // [rsp+48h] [rbp-28h]
  __int64 v13; // [rsp+50h] [rbp-20h]

  v9 = 0xAAAAAAAAAAAAAAAAui64;
  v10 = -6148914691236517206i64;
  v12 = -6148914691236517206i64;
  v11 = -1431655766;
  v13 = qword_96AB8 + 0x100000;
  sub_1738E((unsigned __int64 *)&v9, (__int64 *)&v9 + 1, (__int64)&v10, (__int64)&v12, (__int64)&v11);
  v0 = *((_QWORD *)&v9 + 1);
  if ( *((_QWORD *)&v9 + 1) >= *((_QWORD *)&v9 + 1) + (_QWORD)v9 )
  {
    v1 = 0i64;
  }
  else
  {
    v1 = 0i64;
    v2 = *((_QWORD *)&v9 + 1);
    do
    {
      if ( *(_DWORD *)v2 && *(_QWORD *)(v2 + 32) < 0 )
        v1 += *(unsigned int *)(v2 + 24);
      v2 += v12;
    }
    while ( v2 < *((_QWORD *)&v9 + 1) + (_QWORD)v9 );
  }
  v3 = v1 + 49433;
  v4 = sub_13759(2i64, 2i64, v3, &v13);
  v6 = v4;
  if ( v4 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`MM:AKMR] %r @ M:BAP %qd\n", v4, v3);
  }
  else
  {
    v7 = v3 << 12;
    sub_1A2B6(1, (__int64)"[EB|#KMR] %qd\n", v7, v5);
    qword_94C88 = v13;
    qword_94C90 = qword_94C88 + v7;
  }
  if ( v0 )
    sub_136C5(v0);
  return v6;
}
// 1734B: write access to const memory at 94C88 has been detected
// 17355: write access to const memory at 94C90 has been detected
// 94C88: using guessed type __int64 qword_94C88;
// 94C90: using guessed type __int64 qword_94C90;
// 96AB8: using guessed type __int64 qword_96AB8;

//----- (000000000001738E) ----------------------------------------------------
__int64 __fastcall sub_1738E(unsigned __int64 *a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r13
  __int64 v6; // rdi
  __int64 v7; // rbx
  unsigned int v8; // er12
  unsigned __int64 v9; // r14
  __int64 v10; // r15
  __int64 v11; // rax
  __int64 v12; // r13
  __int64 v13; // rax
  __int64 v15; // [rsp+28h] [rbp-58h]
  unsigned __int64 *v16; // [rsp+30h] [rbp-50h]
  __int64 *v17; // [rsp+38h] [rbp-48h]
  unsigned __int64 v18; // [rsp+40h] [rbp-40h]

  v5 = a4;
  v6 = a3;
  v16 = a1;
  v7 = a5;
  v8 = 0;
  v18 = 0i64;
  v17 = a2;
  *a2 = 0i64;
  v9 = 0i64;
  v15 = a3;
  while ( 1 )
  {
    v18 = 0i64;
    v10 = v5;
    v11 = (*(__int64 (__fastcall **)(unsigned __int64 *, _QWORD, __int64, __int64, __int64))(qword_96CD8 + 56))(
            &v18,
            0i64,
            v6,
            v5,
            v7);
    if ( v11 != -9223372036854775803i64 )
      sub_9CE0((__int64)"[EB|#STOP|`MM:GBMM] %r @ BS.GMM (%d)\n", v11, v8);
    if ( v18 > v9 )
    {
      v12 = v18 + 512;
      if ( *v17 )
        sub_136C5(*v17);
      v13 = sub_1364F(v12);
      *v17 = v13;
      if ( !v13 )
        sub_9CE0((__int64)"[EB|#STOP|`MM:GBMM] ! @ M:BMA %qd @ 'MM\n", v12);
      v9 = v12;
    }
    v18 = v9;
    v7 = a5;
    v6 = v15;
    v5 = v10;
    if ( !(*(__int64 (__fastcall **)(unsigned __int64 *, __int64, __int64, __int64, __int64))(qword_96CD8 + 56))(
            &v18,
            *v17,
            v15,
            v10,
            a5) )
      break;
    if ( ++v8 >= 4 )
    {
      if ( v8 == 4 )
        sub_9CE0((__int64)"[EB|#STOP|`MM:GBMM] ! @ 'MAX (%d)\n", 4i64);
      break;
    }
  }
  *v16 = v18;
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000174C9) ----------------------------------------------------
__int64 __fastcall sub_174C9(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, _QWORD *a5, _QWORD *a6)
{
  *a5 = 0i64;
  *a6 = 0i64;
  while ( a1 < a2 )
  {
    if ( *(_DWORD *)a1 )
    {
      if ( *(_QWORD *)(a1 + 32) < 0 )
      {
        ++*a5;
        *a6 += *(unsigned int *)(a1 + 24);
      }
    }
    a1 += a3;
  }
  return 0i64;
}

//----- (0000000000017500) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
unsigned __int64 __fastcall sub_17500(__int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 v2; // rdi
  unsigned __int64 *v3; // r14
  __int64 *v4; // rsi
  __int64 v5; // rbx
  unsigned __int64 v6; // r15
  __int64 v7; // rax
  __int64 v8; // r9
  __int64 v9; // rbx
  unsigned __int64 v10; // rbx

  v2 = 0i64;
  if ( a1 && qword_96CD8 )
  {
    v3 = a2;
    v4 = a1;
    v5 = ((unsigned __int64)*a1 >> 12) - (((*a1 & 0xFFFui64) < 1) - 1i64);
    if ( !a2 )
      return 0i64;
    v6 = *a2;
    if ( !*a2 )
      return 0i64;
    v2 = v6 & 0x3FFFFFFF;
    v7 = sub_17610(1, v2, v5);
    if ( v7 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`MM:AKM] %r @ MM:MKP\n", v7, v8);
      return 0i64;
    }
    v9 = v5 << 12;
    *v4 = v9;
    if ( v6 < 0xFFFFFFFFFFFFFFFFui64 )
      qword_926B0 = v6;
    if ( qword_94C98 < v6 + v9 )
      qword_94C98 = v6 + v9;
    if ( v2 < 0xFFFFFFFFFFFFFFFFui64 )
      qword_926B8 = v6 & 0x3FFFFFFF;
    v10 = v2 + v9;
    if ( qword_94CA0 < v10 )
      qword_94CA0 = v10;
    if ( v3 )
      *v3 = v6;
  }
  return v2;
}
// 17594: write access to const memory at 926B0 has been detected
// 175A8: write access to const memory at 94C98 has been detected
// 175B8: write access to const memory at 926B8 has been detected
// 175CB: write access to const memory at 94CA0 has been detected
// 926B0: using guessed type __int64 qword_926B0;
// 926B8: using guessed type __int64 qword_926B8;
// 94C98: using guessed type __int64 qword_94C98;
// 94CA0: using guessed type __int64 qword_94CA0;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000017602) ----------------------------------------------------
__int64 __fastcall sub_17602(int a1)
{
  return a1 & 0x3FFFFFFF;
}

//----- (0000000000017610) ----------------------------------------------------
__int64 __fastcall sub_17610(char a1, unsigned __int64 a2, __int64 a3)
{
  __int64 result; // rax
  unsigned __int64 v4; // r10
  unsigned __int64 v5; // [rsp+28h] [rbp-8h]

  v5 = a2;
  if ( !a3 )
    return 0i64;
  if ( qword_94C88 && qword_94C90 )
  {
    if ( qword_94C88 > a2 && a2 + (a3 << 12) > qword_94C90 )
      return -9223372036854775806i64;
    if ( a2 + (a3 << 12) > qword_94C88 && qword_94C90 > a2 )
    {
      if ( qword_94C88 <= a2 && a2 + (a3 << 12) <= qword_94C90 )
        return 0i64;
      v4 = qword_94C88 - a2;
      if ( qword_94C88 <= a2 )
        v4 = a2 + (a3 << 12) - qword_94C90;
      if ( qword_94C88 <= a2 )
        a2 = qword_94C90;
      a3 = (v4 >> 12) - (((v4 & 0xFFF) < 1) - 1i64);
      v5 = a2;
    }
  }
  if ( a1 )
    result = sub_13759(2i64, 2i64, a3, (__int64 *)&v5);
  else
    result = sub_137B1(a2, a3);
  return result;
}
// 94C88: using guessed type __int64 qword_94C88;
// 94C90: using guessed type __int64 qword_94C90;

//----- (00000000000176C6) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_176C6(unsigned __int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  __int64 v4; // r8
  __int64 result; // rax

  v3 = a3;
  v4 = (a3 >> 12) - (((a3 & 0xFFF) < 1) - 1i64);
  result = a1;
  if ( v3 + a1 == qword_94CA0 && v3 + a2 == qword_94C98 && qword_96CD8 )
  {
    result = sub_17610(0, a1, v4);
    if ( result < 0 )
    {
      result = sub_9CE0((__int64)"[EB|`MM:DKM] %r @ M:MKP\n", result);
    }
    else
    {
      qword_94C98 -= v3;
      qword_94CA0 -= v3;
    }
  }
  return result;
}
// 1771B: write access to const memory at 94C98 has been detected
// 17722: write access to const memory at 94CA0 has been detected
// 94C98: using guessed type __int64 qword_94C98;
// 94CA0: using guessed type __int64 qword_94CA0;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000017741) ----------------------------------------------------
__int64 __fastcall sub_17741(_QWORD *a1, _QWORD *a2)
{
  __int64 result; // rax

  *a1 = -1i64;
  result = qword_94CA0;
  *a2 = qword_94CA0;
  return result;
}
// 94CA0: using guessed type __int64 qword_94CA0;

//----- (000000000001775B) ----------------------------------------------------
__int64 __fastcall sub_1775B(_QWORD *a1, unsigned __int64 *a2, __int64 a3)
{
  _QWORD *v3; // r9
  unsigned __int64 v4; // rcx
  _QWORD *v5; // rax

  v3 = a1;
  v4 = *a2;
  if ( *a2 > (unsigned __int64)v3 )
  {
    v5 = v3;
    do
    {
      if ( *(_DWORD *)v5 && v5[4] < 0 )
      {
        if ( v5 != v3 )
        {
          qmemcpy(v3, v5, 0x28ui64);
          v4 = *a2;
        }
        v3 = (_QWORD *)((char *)v3 + a3);
      }
      v5 = (_QWORD *)((char *)v5 + a3);
    }
    while ( v4 > (unsigned __int64)v5 );
  }
  *a2 = (unsigned __int64)v3;
  return 0i64;
}

//----- (00000000000177A5) ----------------------------------------------------
char *__fastcall sub_177A5(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rsi
  char *v4; // r12
  __int64 v5; // rax
  char *result; // rax
  char *v7; // r13
  __int64 v8; // rax
  char *v9; // rbx
  char *v10; // rdi
  char *v11; // r14
  __int64 v12; // rax
  __int64 v13; // [rsp+0h] [rbp-60h]
  unsigned __int64 v14; // [rsp+8h] [rbp-58h]
  __int64 v15; // [rsp+10h] [rbp-50h]
  unsigned __int128 v16; // [rsp+18h] [rbp-48h]
  __int64 v17; // [rsp+28h] [rbp-38h]

  v3 = a3;
  v16 = __PAIR__(a1, a2);
  v14 = (a3 + 15) & 0xFFFFFFFFFFFFFFF0ui64;
  v4 = (char *)&v13 - v14;
  if ( a3 )
  {
    v5 = 0i64;
    do
      v4[v5++] = -86;
    while ( a3 != v5 );
  }
  result = (char *)*((_QWORD *)&v16 + 1);
  if ( *((_QWORD *)&v16 + 1) < (unsigned __int64)v16 )
  {
    v15 = -(signed __int64)a3;
    v7 = (char *)*((_QWORD *)&v16 + 1);
    do
    {
      sub_1B930(v4, v7, v3);
      v8 = (__int64)&v7[v15];
      v9 = v7;
      if ( (unsigned __int64)&v7[v15] >= *((_QWORD *)&v16 + 1) )
      {
        v10 = v7;
        while ( 1 )
        {
          v9 = (char *)v8;
          if ( *(_QWORD *)(v8 + 8) <= *((_QWORD *)v4 + 1) )
            break;
          v11 = (char *)&v17 - v14;
          if ( v3 )
          {
            v12 = 0i64;
            do
              v11[v12++] = -86;
            while ( v3 != v12 );
          }
          sub_1B930(v11, v9, v3);
          sub_1B930(v9, v10, v3);
          sub_1B930(v10, v11, v3);
          v8 = (__int64)&v9[v15];
          v10 = v9;
          if ( (unsigned __int64)&v9[v15] < *((_QWORD *)&v16 + 1) )
            goto LABEL_15;
        }
        v9 = v10;
      }
LABEL_15:
      result = sub_1B930(v9, v4, v3);
      v7 += v3;
    }
    while ( (unsigned __int64)v7 < (unsigned __int64)v16 );
  }
  return result;
}

//----- (00000000000178DE) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_178DE(unsigned __int64 a1, char *a2, char **a3, unsigned __int64 a4, __int64 a5, unsigned __int64 a6, unsigned __int64 a7, __int64 a8)
{
  unsigned __int64 v8; // r13
  char *v9; // r12
  unsigned __int64 v10; // r15
  __int64 v11; // rbx
  __int64 v12; // r11
  __int64 v13; // rdx
  __int64 v14; // rdx
  __int64 v15; // rax
  unsigned __int64 v16; // rdi
  char *v17; // rcx
  signed __int64 v18; // rdx
  __int64 v19; // rsi
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rdi
  unsigned __int64 v24; // rdx
  bool v25; // cf
  __int64 v26; // rdx
  unsigned __int64 v27; // rcx
  unsigned __int64 v28; // r10
  unsigned __int64 v29; // rsi
  unsigned __int64 v30; // r9
  _QWORD *v31; // rdi
  unsigned __int64 v32; // rbx
  char **v33; // r8
  int v34; // er14
  __int64 v35; // rbx
  unsigned __int64 v36; // rax
  unsigned __int64 v37; // r9
  unsigned __int64 v38; // rsi
  unsigned __int64 v39; // rcx
  unsigned __int64 v40; // rdi
  unsigned __int64 v41; // rax
  signed __int64 v42; // r12
  char *v43; // rax
  __int64 v44; // rcx
  unsigned __int64 v45; // rdi
  unsigned __int64 v46; // r12
  _QWORD *v47; // rax
  __int64 v48; // rdx
  __int64 v50; // [rsp+20h] [rbp-50h]
  unsigned __int64 v51; // [rsp+28h] [rbp-48h]
  char **v52; // [rsp+30h] [rbp-40h]

  v8 = a4;
  v52 = a3;
  v9 = a2;
  v10 = a1;
  if ( a1 >= (unsigned __int64)a2 )
  {
LABEL_13:
    *(_QWORD *)(qword_96CD0 + 88) = 0i64;
    *(_DWORD *)(qword_96CD0 + 16) = 0;
    *(_DWORD *)(qword_96CD0 + 16) = sub_17CD4(0, qword_96CD0, *(_DWORD *)(qword_96CD0 + 12));
  }
  else
  {
    v11 = a8;
    v12 = 0i64;
    do
    {
      v13 = *(_QWORD *)(a1 + 32);
      if ( *(_DWORD *)a1 )
      {
        if ( v13 < 0 )
        {
          if ( ((unsigned int)v11 & 0x3FFFFFFF) < a6 )
            return -9223372036854775791i64;
          v14 = v11 + (*(_QWORD *)(a1 + 24) << 12);
          if ( (((_DWORD)v11 + (*(_DWORD *)(a1 + 24) << 12)) & 0x3FFFFFFFu) > a7 )
            return -9223372036854775791i64;
          v12 += (unsigned int)*(_QWORD *)(a1 + 24);
          *(_QWORD *)(a1 + 16) = v11;
          v11 = v14;
        }
      }
      else
      {
        *(_QWORD *)(a1 + 32) = v13 & 0x7FFFFFFFFFFFFFFFi64;
      }
      a1 += a4;
    }
    while ( a1 < (unsigned __int64)v9 );
    if ( !v12 )
      goto LABEL_13;
    v15 = (*(__int64 (__fastcall **)(char *, unsigned __int64, _QWORD, unsigned __int64))(qword_96CE0 + 56))(
            &v9[-v10],
            a4,
            (unsigned int)a5,
            v10);
    if ( v15 < 0 )
      sub_9CE0((__int64)"[EB|#STOP|`MM:FMM] %r @ RT.SVAM\n", v15);
  }
  if ( v10 < (unsigned __int64)v9 )
  {
    v16 = v10;
    do
    {
      if ( (unsigned int)(*(_DWORD *)v16 - 5) <= 1 )
      {
        v17 = *(char **)(v16 + 8);
        v18 = *(_QWORD *)(v16 + 16) & 0x3FFFFFFFi64;
        if ( (char *)v18 != v17 )
        {
          v19 = *(_QWORD *)(v16 + 24) << 12;
          sub_1B950(v17, (char *)(*(_QWORD *)(v16 + 16) & 0x3FFFFFFFi64), *(_QWORD *)(v16 + 24) << 12);
          sub_F1B0(*(_QWORD *)(v16 + 8), v19);
        }
      }
      v16 += v8;
    }
    while ( v16 < (unsigned __int64)v9 );
    if ( v10 < (unsigned __int64)v9 )
    {
      v20 = v10;
      do
      {
        if ( (unsigned int)(*(_DWORD *)v20 - 5) <= 1 )
        {
          v21 = *(_QWORD *)(v20 + 8);
          if ( qword_96CD0 >= v21
            && (unsigned __int64)qword_96CD0 < *(_QWORD *)(v20 + 8) + (*(_QWORD *)(v20 + 24) << 12) )
          {
            qword_96CD0 = (*(_DWORD *)(v20 + 16) + (_DWORD)qword_96CD0 - (_DWORD)v21) & 0x3FFFFFFF;
          }
        }
        v20 += v8;
      }
      while ( v20 < (unsigned __int64)v9 );
      if ( v10 < (unsigned __int64)v9 )
      {
        v22 = v10;
        do
        {
          if ( (unsigned int)(*(_DWORD *)v22 - 5) <= 1 )
          {
            v23 = *(_QWORD *)(v22 + 8);
            v24 = *(_QWORD *)(qword_96CD0 + 112);
            v25 = v24 < v23;
            v26 = v24 - v23;
            if ( !v25 && *(_QWORD *)(qword_96CD0 + 112) < *(_QWORD *)(v22 + 8) + (*(_QWORD *)(v22 + 24) << 12) )
              *(_QWORD *)(qword_96CD0 + 112) = *(_QWORD *)(v22 + 16) + v26;
          }
          v22 += v8;
        }
        while ( v22 < (unsigned __int64)v9 );
        v27 = v10;
        do
        {
          if ( (unsigned int)(*(_DWORD *)v27 - 5) <= 1 )
          {
            v28 = *(_QWORD *)(qword_96CD0 + 104);
            if ( v28 )
            {
              v29 = *(_QWORD *)(v27 + 8);
              v30 = v29 + (*(_QWORD *)(v27 + 24) << 12);
              v31 = (_QWORD *)((*(_QWORD *)(qword_96CD0 + 112) & 0x3FFFFFFFi64) + 16);
              v32 = 0i64;
              do
              {
                if ( *v31 >= v29 && *v31 < v30 )
                  *v31 = *(_QWORD *)(v27 + 16) + *v31 - v29;
                ++v32;
                v31 += 3;
              }
              while ( v32 < v28 );
            }
          }
          v27 += v8;
        }
        while ( v27 < (unsigned __int64)v9 );
        v51 = v10;
        v33 = v52;
        do
        {
          v34 = *(_DWORD *)v10;
          if ( (unsigned int)(*(_DWORD *)v10 - 5) <= 1 )
          {
            v35 = *(_QWORD *)(v10 + 16);
            v36 = *(_QWORD *)(v10 + 16) & 0x3FFFFFFFi64;
            if ( v36 != *(_QWORD *)(v10 + 8) )
            {
              if ( v33 )
              {
                v37 = *(_QWORD *)(v10 + 24);
                *(_QWORD *)(v10 + 32) &= 0x7FFFFFFFFFFFFFFFui64;
                *(_DWORD *)v10 = 7;
                *(_QWORD *)(v10 + 16) = 0i64;
                if ( (unsigned __int64)v9 <= v51 )
                {
LABEL_52:
                  sub_9CE0((__int64)"[EB|#STOP|`MM:FMM] %r @ MM:CMMSR\n", -9223372036854775794i64, v33, v37, v50);
                  v33 = v52;
                  v38 = 0i64;
                }
                else
                {
                  v38 = v51;
                  while ( 1 )
                  {
                    v39 = *(_QWORD *)(v38 + 8);
                    if ( v36 >= v39 )
                    {
                      v40 = *(_QWORD *)(v38 + 24);
                      if ( *(_QWORD *)(v38 + 8) + (*(_QWORD *)(v38 + 24) << 12) > v36 )
                        break;
                    }
                    v38 += v8;
                    if ( (unsigned __int64)v9 <= v38 )
                      goto LABEL_52;
                  }
                  v25 = v36 < v39;
                  v41 = v36 - v39;
                  if ( !v25 && v41 != 0 )
                  {
                    v50 = v37;
                    v42 = (v41 >> 12) - (((v41 & 0xFFF) < 1) - 1i64);
                    sub_1B930(*v33, (char *)v38, v8);
                    v33 = v52;
                    v43 = *v52;
                    *((_QWORD *)v43 + 3) = v42;
                    *v52 = &v43[v8];
                    *(_QWORD *)(v38 + 8) += v42 << 12;
                    v44 = *(_QWORD *)(v38 + 16);
                    if ( v44 )
                      *(_QWORD *)(v38 + 16) += v42 << 12;
                    v40 = *(_QWORD *)(v38 + 24) - v42;
                    *(_QWORD *)(v38 + 24) = v40;
                    v37 = v50;
                  }
                  v25 = v40 < v37;
                  v45 = v40 - v37;
                  if ( !v25 && v45 != 0 )
                  {
                    v46 = v37;
                    sub_1B930(*v33, (char *)v38, v8);
                    v33 = v52;
                    v47 = *v52;
                    v47[3] = v45;
                    v47[1] += v46 << 12;
                    v48 = v47[2];
                    if ( v48 )
                      v47[2] += v46 << 12;
                    *v52 = (char *)v47 + v8;
                    *(_QWORD *)(v38 + 24) = v46;
                  }
                }
                *(_QWORD *)(v38 + 16) = v35;
                *(_QWORD *)(v38 + 32) |= 0x8000000000000000ui64;
                *(_DWORD *)v38 = v34;
                v9 = *v33;
              }
              else
              {
                *(_QWORD *)(v10 + 8) = v36;
              }
            }
          }
          v10 += v8;
        }
        while ( (unsigned __int64)v9 > v10 );
      }
    }
  }
  return 0i64;
}
// 17A6C: write access to const memory at 96CD0 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 96CD0: using guessed type __int64 qword_96CD0;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000017CD4) ----------------------------------------------------
__int64 __fastcall sub_17CD4(int a1, __int64 a2, int a3)
{
  unsigned int v3; // eax
  __int64 v4; // rcx

  v3 = ~a1;
  if ( a3 )
  {
    v4 = 0i64;
    do
      v3 = *((_DWORD *)qword_8F100 + (*(unsigned __int8 *)(a2 + v4++) ^ (unsigned int)(unsigned __int8)v3)) ^ (v3 >> 8);
    while ( a3 != (_DWORD)v4 );
  }
  return ~v3;
}
// 8F100: using guessed type __int64 qword_8F100[128];

//----- (0000000000017D0C) ----------------------------------------------------
void __fastcall sub_17D0C(int a1, __int64 a2)
{
  __int64 v2; // rax

  if ( a1 == 1 )
  {
    v2 = 0i64;
    do
      *(_BYTE *)(a2 + v2++) = -1;
    while ( v2 != 8 );
  }
}

//----- (0000000000017D26) ----------------------------------------------------
void __fastcall sub_17D26(int a1, __int64 a2, __int64 a3, unsigned int *a4)
{
  unsigned int v4; // eax
  __int64 v5; // rcx

  if ( a1 == 1 )
  {
    v4 = *a4;
    if ( a3 )
    {
      v5 = 0i64;
      do
        v4 = *((_DWORD *)qword_8F500 + (*(unsigned __int8 *)(a2 + v5++) ^ (unsigned int)(unsigned __int8)v4)) ^ (v4 >> 8);
      while ( a3 != v5 );
    }
    *a4 = v4;
  }
}
// 8F500: using guessed type __int64 qword_8F500[128];

//----- (0000000000017D61) ----------------------------------------------------
unsigned __int16 __fastcall sub_17D61(unsigned __int16 a1, __int64 a2, int a3)
{
  unsigned __int16 result; // ax
  __int64 v4; // rcx

  result = a1;
  if ( a3 )
  {
    v4 = 0i64;
    do
      result = *((_WORD *)qword_8F900 + (*(unsigned __int8 *)(a2 + v4++) ^ (unsigned __int64)(unsigned __int8)result)) ^ (result >> 8);
    while ( a3 != (_DWORD)v4 );
  }
  return result;
}
// 8F900: using guessed type __int64 qword_8F900[64];

//----- (0000000000017D9C) ----------------------------------------------------
void __fastcall sub_17D9C(__int64 a1, void (__fastcall *a2)(signed __int64, __int64), __int64 a3, unsigned __int64 **a4)
{
  __int64 v4; // r15
  void (__fastcall *v5)(signed __int64, __int64); // rbx
  __int64 v6; // rsi
  signed __int64 v7; // rcx
  signed __int64 v8; // r8
  unsigned int v9; // er14
  int v10; // er13
  int v11; // er12
  signed int v12; // ecx
  unsigned __int64 *v13; // rcx
  int v14; // ecx
  signed int v15; // eax
  int v16; // edx
  signed int v17; // edi
  char **v18; // rax
  unsigned __int64 *v19; // rax
  unsigned __int64 v20; // rdi
  __int64 v21; // r14
  int v22; // er12
  unsigned __int64 *v23; // rax
  unsigned __int64 *v24; // rax
  unsigned int *v25; // rdi
  int v26; // er13
  unsigned __int64 *v27; // rax
  unsigned __int64 v28; // r14
  char v29; // al
  __int64 v30; // rdi
  unsigned __int8 **v31; // rax
  unsigned __int8 *v32; // rdi
  int v33; // er13
  unsigned __int64 *v34; // rcx
  unsigned __int64 *v35; // rax
  unsigned __int64 v36; // rcx
  unsigned __int64 *v37; // rax
  char v38; // al
  signed __int64 v39; // rdi
  int v40; // er13
  char v41; // al
  signed __int64 v42; // rdi
  char v43; // al
  signed __int64 v44; // rdi
  signed int v45; // [rsp+4Ch] [rbp-44h]
  unsigned __int64 **v46; // [rsp+50h] [rbp-40h]

  v46 = a4;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  v45 = 0;
LABEL_2:
  while ( 1 )
  {
    v7 = (unsigned int)*(char *)(++v6 - 1);
    if ( !*(_BYTE *)(v6 - 1) )
      break;
    if ( *(_BYTE *)(v6 - 1) != 37 )
      goto LABEL_4;
    v8 = 0i64;
    v9 = 0;
    v10 = 0;
    v11 = 0;
LABEL_6:
    ++v6;
    while ( 1 )
    {
      v12 = *(char *)(v6 - 1);
      if ( (unsigned int)(v12 - 49) < 9 )
        goto LABEL_8;
      if ( v12 > 67 )
        break;
      if ( v12 <= 47 )
      {
        if ( v12 == 32 )
        {
          v15 = 1;
          goto LABEL_29;
        }
        if ( v12 != 42 )
        {
          if ( v12 != 46 )
            goto LABEL_2;
          v15 = 4;
          goto LABEL_29;
        }
        v13 = *v46;
        ++*v46;
        v14 = *(_DWORD *)v13;
        if ( !(v9 & 4) )
          v10 = v14;
        if ( v9 & 4 )
          v11 = v14;
        goto LABEL_6;
      }
      if ( v12 != 48 )
        goto LABEL_2;
      if ( !(v9 & 4 | v10) )
      {
        v10 = 0;
        v15 = 2;
LABEL_29:
        v9 |= v15;
        goto LABEL_6;
      }
LABEL_8:
      if ( !(v9 & 4) )
      {
        v10 = v12 + 10 * v10 - 48;
        goto LABEL_6;
      }
      v11 = v12 + 10 * v11 - 48;
      ++v6;
    }
    switch ( v12 )
    {
      case 79:
      case 111:
        v16 = 8;
        goto LABEL_70;
      case 80:
        v9 |= 0x10u;
        goto LABEL_36;
      case 81:
      case 82:
      case 84:
      case 85:
      case 86:
      case 87:
      case 89:
      case 90:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 97:
      case 102:
      case 104:
      case 105:
      case 106:
      case 107:
      case 109:
      case 110:
      case 117:
      case 118:
      case 119:
        continue;
      case 83:
        LOBYTE(v9) = v9 | 8;
        goto LABEL_38;
      case 88:
        v9 |= 0x10u;
        goto LABEL_42;
      case 98:
        v19 = *v46;
        ++*v46;
        v20 = *v19;
        if ( *v19 )
        {
          if ( v11 <= 0 )
          {
            v22 = 0;
          }
          else
          {
            v21 = 0i64;
            do
              sub_18630(*(unsigned __int8 *)(v20 + v21++), 16, 2i64, 2, 0, v5, v4);
            while ( v11 != (_DWORD)v21 );
            v22 = 2 * v11;
          }
          if ( v22 < v10 )
          {
            v40 = v10 - v22;
            do
            {
              v5(32i64, v4);
              --v40;
            }
            while ( v40 );
          }
        }
        else
        {
          sub_18734("<null buffer>", v9 & 5, v10, v11, v5, v4);
        }
        continue;
      case 99:
        v23 = *v46;
        ++*v46;
        v7 = *(unsigned int *)v23;
        break;
      case 100:
        v16 = 10;
        goto LABEL_70;
      case 101:
        goto LABEL_33;
      case 103:
        v24 = *v46;
        ++*v46;
        v25 = (unsigned int *)*v24;
        if ( *v24 )
        {
          sub_18630(*v25, 16, 18i64, 8, 0, v5, v4);
          v5(45i64, v4);
          sub_18630(*((unsigned __int16 *)v25 + 2), 16, 18i64, 4, 0, v5, v4);
          v5(45i64, v4);
          sub_18630(*((unsigned __int16 *)v25 + 3), 16, 18i64, 4, 0, v5, v4);
          v5(45i64, v4);
          sub_18630(*((unsigned __int8 *)v25 + 8), 16, 18i64, 2, 0, v5, v4);
          sub_18630(*((unsigned __int8 *)v25 + 9), 16, 18i64, 2, 0, v5, v4);
          v5(45i64, v4);
          sub_18630(*((unsigned __int8 *)v25 + 10), 16, 18i64, 2, 0, v5, v4);
          sub_18630(*((unsigned __int8 *)v25 + 11), 16, 18i64, 2, 0, v5, v4);
          sub_18630(*((unsigned __int8 *)v25 + 12), 16, 18i64, 2, 0, v5, v4);
          sub_18630(*((unsigned __int8 *)v25 + 13), 16, 18i64, 2, 0, v5, v4);
          sub_18630(*((unsigned __int8 *)v25 + 14), 16, 18i64, 2, 0, v5, v4);
          sub_18630(*((unsigned __int8 *)v25 + 15), 16, 18i64, 2, 0, v5, v4);
          if ( v10 >= 37 )
          {
            v26 = v10 - 36;
            do
            {
              v5(32i64, v4);
              --v26;
            }
            while ( v26 );
          }
        }
        else
        {
          sub_18734("<null guid>", v9 & 5, v10, v11, v5, v4);
        }
        continue;
      case 108:
        v8 = 1i64;
        goto LABEL_6;
      case 112:
LABEL_36:
        v17 = 2;
        v45 = 1;
        goto LABEL_44;
      case 113:
        v8 = 2i64;
        goto LABEL_6;
      case 114:
        v27 = *v46;
        ++*v46;
        v28 = *v27;
        if ( !*v27 )
        {
          v38 = 79;
          v39 = 1i64;
          do
          {
            ((void (__fastcall *)(_QWORD, __int64, signed __int64))v5)((unsigned int)v38, v4, v8);
            v38 = aOk0[v39++];
          }
          while ( v39 != 6 );
          continue;
        }
        if ( (*v27 & 0x8000000000000000ui64) != 0i64 )
        {
          v41 = 69;
          v42 = 1i64;
          do
          {
            ((void (__fastcall *)(_QWORD, __int64, signed __int64))v5)((unsigned int)v41, v4, v8);
            v41 = aErr[v42++];
          }
          while ( v42 != 4 );
          v28 &= 0x7FFFFFFFFFFFFFFFui64;
        }
        else
        {
          v29 = 87;
          v30 = 0i64;
          do
          {
            ((void (__fastcall *)(_QWORD, __int64, signed __int64))v5)((unsigned int)v29, v4, v8);
            v29 = aWarn[v30++ + 1];
          }
          while ( v30 != 4 );
        }
        v43 = 40;
        v44 = 1i64;
        do
        {
          v5((unsigned int)v43, v4);
          v43 = a0x[v44++];
        }
        while ( v44 != 4 );
        sub_18630(v28, 16, 16i64, 0, 0, v5, v4);
        v7 = 41i64;
        break;
      case 115:
        goto LABEL_38;
      case 116:
        v31 = (unsigned __int8 **)*v46;
        ++*v46;
        v32 = *v31;
        if ( *v31 )
        {
          sub_18630(*(unsigned __int16 *)v32, 10, 2i64, 4, 0, v5, v4);
          v5(45i64, v4);
          sub_18630(v32[2], 10, 2i64, 2, 0, v5, v4);
          v5(45i64, v4);
          sub_18630(v32[3], 10, 2i64, 2, 0, v5, v4);
          v5(84i64, v4);
          sub_18630(v32[4], 10, 2i64, 2, 0, v5, v4);
          v5(58i64, v4);
          sub_18630(v32[5], 10, 2i64, 2, 0, v5, v4);
          v5(58i64, v4);
          sub_18630(v32[6], 10, 2i64, 2, 0, v5, v4);
          if ( v10 >= 20 )
          {
            v33 = v10 - 19;
            do
            {
              v5(32i64, v4);
              --v33;
            }
            while ( v33 );
          }
        }
        else
        {
          sub_18734("<null time>", v9 & 5, v10, v11, v5, v4);
        }
        continue;
      case 120:
LABEL_42:
        if ( v45 )
        {
          v17 = v8;
LABEL_44:
          ((void (__fastcall *)(signed __int64, __int64, signed __int64))v5)(48i64, v4, v8);
          v5(120i64, v4);
          v16 = 16;
          LODWORD(v8) = v17;
        }
        else
        {
          v16 = 16;
          v45 = 0;
        }
LABEL_70:
        if ( (_DWORD)v8 == 2 )
        {
          v35 = *v46;
          ++*v46;
          v36 = *v35;
        }
        else
        {
          v37 = *v46;
          ++*v46;
          v36 = *v37;
          if ( (_DWORD)v8 != 1 )
            v36 = (unsigned int)v36;
        }
        sub_18630(v36, v16, v9, v10, v11, v5, v4);
        continue;
      default:
        if ( (unsigned int)off_18588 == 68 )
        {
          if ( sub_AE6A )
          {
            v34 = *v46;
            ++*v46;
            sub_AE6A((_BYTE *)*v34, v10, v5, v4);
          }
        }
        else if ( (unsigned int)off_18588 == 69 )
        {
          LOBYTE(v9) = v9 | 8;
LABEL_33:
          LOBYTE(v9) = v9 | 0x40;
LABEL_38:
          v18 = (char **)*v46;
          ++*v46;
          if ( *v18 )
            sub_18734(*v18, v9, v10, v11, v5, v4);
          else
            sub_18734("<null string>", v9 & 0xF7, v10, v11, v5, v4);
        }
        continue;
    }
LABEL_4:
    v5(v7, v4);
  }
}
// 18588: using guessed type void *__ptr32 off_18588[42];

//----- (0000000000018630) ----------------------------------------------------
__int64 __fastcall sub_18630(unsigned __int64 a1, int a2, __int64 a3, int a4, signed int a5, void (__fastcall *a6)(signed __int64, __int64), __int64 a7)
{
  int v7; // er13
  signed int v8; // esi
  bool v9; // r11
  unsigned __int64 v10; // rbx
  __int64 v11; // rdi
  bool v12; // cf
  int v13; // er14
  int v14; // eax
  __int64 v15; // rbx
  unsigned int v16; // ebx
  int v17; // er13
  __int64 result; // rax
  unsigned __int8 v19; // of
  char v20; // [rsp+1Fh] [rbp-61h]
  __int64 v21; // [rsp+20h] [rbp-60h]
  __int64 v22; // [rsp+28h] [rbp-58h]
  __int64 v23; // [rsp+30h] [rbp-50h]
  __int64 v24; // [rsp+38h] [rbp-48h]

  v7 = a4;
  v8 = a5;
  v21 = -6148914691236517206i64;
  v22 = -6148914691236517206i64;
  v23 = -6148914691236517206i64;
  v24 = -6148914691236517206i64;
  v9 = a2 == 10 && (a1 & 0x80000000) != 0i64;
  v10 = (unsigned int)-(signed int)a1;
  if ( !v9 )
    v10 = a1;
  v11 = 0i64;
  do
  {
    *((_BYTE *)&v21 + v11++) = a0123456789abcd[(a3 & 0x10) + v10 % a2];
    v12 = v10 < a2;
    v10 /= (unsigned __int64)a2;
  }
  while ( !v12 );
  v13 = v11;
  if ( a5 >= (signed int)v11 )
    v13 = a5;
  v14 = v13;
  if ( v9 )
  {
    v15 = a3;
    a6(45i64, a7);
    a3 = v15;
    v14 = v13 + 1;
  }
  if ( v14 < v7 )
  {
    v16 = 8 * (a3 & 2) + 32;
    v17 = v7 - v14;
    do
    {
      a6(v16, a7);
      --v17;
    }
    while ( v17 );
  }
  if ( v13 != (_DWORD)v11 )
  {
    do
    {
      ((void (__fastcall *)(signed __int64, __int64, __int64))a6)(48i64, a7, a3);
      --v8;
    }
    while ( (_DWORD)v11 != v8 );
  }
  do
  {
    result = ((__int64 (__fastcall *)(_QWORD, __int64, __int64))a6)((unsigned int)*(&v20 + v11), a7, a3);
    v19 = __OFSUB__(v11--, 1i64);
  }
  while ( !((unsigned __int8)((v11 < 0) ^ v19) | (v11 == 0)) );
  return result;
}

//----- (0000000000018734) ----------------------------------------------------
__int64 __fastcall sub_18734(char *a1, char a2, int a3, int a4, void (__fastcall *a5)(signed __int64, __int64), __int64 a6)
{
  int v6; // er14
  int v7; // esi
  char v8; // di
  char *v9; // r15
  int v10; // er12
  int v11; // er13
  signed int v12; // ebx
  __int64 result; // rax
  signed __int64 v14; // rcx
  int v15; // esi
  unsigned __int16 *v16; // [rsp+38h] [rbp-48h]
  int v17; // [rsp+44h] [rbp-3Ch]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v10 = a2 & 0x44;
  v17 = 0;
  v16 = (unsigned __int16 *)a1;
  v11 = 0;
  while ( 1 )
  {
    if ( v8 & 4 )
    {
      if ( v17 >= v6 )
        break;
      ++v17;
    }
    if ( v8 & 8 )
    {
      v12 = *v16;
      result = (__int64)(v16 + 1);
      ++v16;
    }
    else
    {
      v12 = *v9++;
    }
    if ( !v12 && v10 != 68 )
      break;
    if ( !(v8 & 0x40) )
      goto LABEL_14;
    if ( (unsigned int)(v12 - 32) > 0x5E )
    {
      a5(92i64, a6);
      if ( v12 > 9 )
      {
        if ( v12 == 10 )
        {
          v14 = 110i64;
        }
        else
        {
          if ( v12 != 13 )
            goto LABEL_25;
          v14 = 114i64;
        }
LABEL_24:
        result = ((__int64 (__fastcall *)(signed __int64, __int64))a5)(v14, a6);
        v11 += 2;
      }
      else
      {
        if ( !v12 )
        {
          v14 = 48i64;
          goto LABEL_24;
        }
        if ( v12 == 9 )
        {
          v14 = 116i64;
          goto LABEL_24;
        }
LABEL_25:
        if ( v8 & 8 )
        {
          ++v11;
          a5(117i64, a6);
          sub_18630(BYTE1(v12), 16, 18i64, 2, 0, a5, a6);
        }
        else
        {
          a5(120i64, a6);
        }
        result = sub_18630((unsigned __int8)v12, 16, 18i64, 2, 0, a5, a6);
        v11 += 3;
      }
    }
    else if ( v12 == 92 )
    {
      a5(92i64, a6);
      result = ((__int64 (__fastcall *)(signed __int64, __int64))a5)(92i64, a6);
      v11 += 2;
    }
    else
    {
LABEL_14:
      result = ((__int64 (__fastcall *)(_QWORD, __int64))a5)((unsigned int)v12, a6);
      ++v11;
    }
  }
  if ( v11 < v7 )
  {
    v15 = v7 - v11;
    do
    {
      result = ((__int64 (__fastcall *)(signed __int64, __int64))a5)(32i64, a6);
      --v15;
    }
    while ( v15 );
  }
  return result;
}

//----- (0000000000018905) ----------------------------------------------------
__int64 sub_18905(unsigned __int64 a1, __int64 a2, ...)
{
  va_list v3; // [rsp+20h] [rbp-30h]
  __int64 v4; // [rsp+28h] [rbp-28h]
  __int64 v5; // [rsp+30h] [rbp-20h]
  __int128 v6; // [rsp+38h] [rbp-18h]
  va_list va; // [rsp+70h] [rbp+20h]

  va_start(va, a2);
  v4 = -6148914691236517206i64;
  v5 = -6148914691236517206i64;
  va_copy(v3, va);
  v6 = a1;
  sub_17D9C(a2, (void (__fastcall *)(signed __int64, __int64))sub_18968, (__int64)&v6, (unsigned __int64 **)&v3);
  *(_BYTE *)v6 = 0;
  return 0i64;
}

//----- (0000000000018968) ----------------------------------------------------
_BYTE *__fastcall sub_18968(char a1, __int64 a2)
{
  _BYTE *v2; // r8
  _BYTE *result; // rax

  v2 = *(_BYTE **)a2;
  result = *(_BYTE **)(a2 + 8);
  if ( result && v2 == result )
  {
    *result = 0;
  }
  else
  {
    result = v2 + 1;
    *(_QWORD *)a2 = v2 + 1;
    *v2 = a1;
  }
  return result;
}

//----- (000000000001898E) ----------------------------------------------------
__int64 __fastcall sub_1898E(_BYTE *a1, int a2, __int64 a3, unsigned __int64 **a4)
{
  int v4; // esi
  _BYTE *v6; // [rsp+20h] [rbp-20h]
  _BYTE *v7; // [rsp+28h] [rbp-18h]

  v4 = (signed int)a1;
  v6 = a1;
  v7 = &a1[a2 - 1];
  sub_17D9C(a3, (void (__fastcall *)(signed __int64, __int64))sub_18968, (__int64)&v6, a4);
  *v6 = 0;
  return (unsigned int)((_DWORD)v6 - v4);
}

//----- (00000000000189D2) ----------------------------------------------------
__int64 __fastcall sub_189D2(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  int v4; // eax
  int v5; // er10

  if ( !a3 )
    return 0i64;
  v3 = 0i64;
  while ( 1 )
  {
    v4 = *(unsigned __int8 *)(a1 + v3);
    v5 = *(unsigned __int8 *)(a2 + v3);
    if ( (_BYTE)v4 != (_BYTE)v5 )
      break;
    if ( a3 == ++v3 )
      return 0i64;
  }
  return (unsigned int)(v4 - v5);
}

//----- (00000000000189FE) ----------------------------------------------------
__int64 __fastcall sub_189FE(_BYTE *a1)
{
  __int64 result; // rax

  if ( !*a1 )
    return 0i64;
  result = 0i64;
  while ( a1[result++ + 1] != 0 )
    ;
  return result;
}

//----- (0000000000018A1A) ----------------------------------------------------
__int64 __fastcall sub_18A1A(char *a1, _BYTE *a2)
{
  char v2; // al
  char *v3; // rcx

  v2 = *a1;
  if ( *a1 )
  {
    v3 = a1 + 1;
    while ( v2 == *a2 )
    {
      ++a2;
      v2 = *v3++;
      if ( !v2 )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v2 = 0;
  }
  return (unsigned int)(v2 - (char)*a2);
}

//----- (0000000000018A43) ----------------------------------------------------
__int64 __fastcall sub_18A43(__int64 a1, __int64 a2, int a3)
{
  __int64 result; // rax
  __int64 v4; // r9
  int v5; // er10

  result = 0i64;
  v4 = 0i64;
  while ( a3 > 0 )
  {
    v5 = *(char *)(a1 + v4);
    if ( *(_BYTE *)(a1 + v4) != *(_BYTE *)(a2 + v4) )
      return (unsigned int)(v5 - *(char *)(a2 + v4));
    --a3;
    ++v4;
    if ( !(_BYTE)v5 )
      return result;
  }
  return result;
}

//----- (0000000000018A75) ----------------------------------------------------
char *__fastcall sub_18A75(char *a1, const char *a2)
{
  char *result; // rax

  result = a1;
  strcpy(a1, a2);
  return result;
}

//----- (0000000000018A90) ----------------------------------------------------
__int64 __fastcall sub_18A90(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // rcx
  char v5; // r9

  result = a1;
  if ( a3 )
  {
    v4 = 0i64;
    do
    {
      v5 = *(_BYTE *)(a2 + v4);
      *(_BYTE *)(result + v4) = v5;
      if ( !v5 )
        break;
      ++v4;
    }
    while ( a3 != v4 );
  }
  return result;
}

//----- (0000000000018AB5) ----------------------------------------------------
__int64 __fastcall sub_18AB5(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // rcx
  char v5; // r9

  result = a1;
  if ( a3 )
  {
    v4 = 0i64;
    while ( 1 )
    {
      v5 = *(_BYTE *)(a2 + v4);
      *(_BYTE *)(result + v4) = v5;
      if ( !v5 )
        break;
      if ( a3 == ++v4 )
      {
        a1 = result + v4;
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    *(_BYTE *)(a1 - 1) = 0;
  }
  return result;
}

//----- (0000000000018AE1) ----------------------------------------------------
__int64 __fastcall sub_18AE1(char *a1)
{
  char v1; // dl
  __int64 result; // rax

  do
  {
    do
      v1 = *(++a1 - 1);
    while ( v1 == 9 );
  }
  while ( v1 == 32 );
  result = 0i64;
  if ( (unsigned __int8)(v1 - 48) <= 9u )
  {
    LODWORD(result) = 0;
    do
    {
      result = (unsigned int)(v1 + 10 * result - 48);
      v1 = *a1++;
    }
    while ( (unsigned __int8)(v1 - 48) < 0xAu );
  }
  return result;
}

//----- (0000000000018B20) ----------------------------------------------------
signed __int64 __fastcall sub_18B20(signed __int64 a1, signed __int64 *a2, __int64 a3)
{
  signed __int64 *v3; // r9
  char *i; // r10
  char v5; // al
  signed int v6; // er11
  signed int v7; // esi
  bool v8; // dl
  signed int v9; // eax
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // r15
  signed __int64 v12; // r10
  signed int v13; // er14
  unsigned __int8 v14; // di
  unsigned __int64 v15; // rsi
  signed int v16; // ebx
  unsigned __int64 v17; // rdi
  signed __int64 result; // rax

  v3 = a2;
  for ( i = (char *)(a1 + 1); ; ++i )
  {
    v5 = *(i - 1);
    if ( v5 > 31 )
      break;
    if ( (unsigned __int8)(v5 - 9) >= 2u )
      goto LABEL_12;
LABEL_6:
    ;
  }
  switch ( v5 )
  {
    case 32:
      goto LABEL_6;
    case 43:
      v6 = 0;
      goto LABEL_11;
    case 45:
      v6 = 1;
LABEL_11:
      v5 = *i++;
      goto LABEL_13;
  }
LABEL_12:
  v6 = 0;
LABEL_13:
  if ( a3 & 0xFFFFFFEF || v5 != 48 )
  {
    v8 = (_DWORD)a3 == 0;
    if ( v5 == 48 )
      goto LABEL_20;
    v7 = v5;
    v9 = 10;
  }
  else
  {
    if ( ((unsigned __int8)*i | 0x20) == 120 )
    {
      v7 = i[1];
      i += 2;
      LODWORD(a3) = 16;
      goto LABEL_23;
    }
    v8 = (_DWORD)a3 == 0;
LABEL_20:
    v9 = 8;
    v7 = 48;
  }
  if ( v8 )
    LODWORD(a3) = v9;
LABEL_23:
  a3 = (unsigned int)a3;
  v10 = 0xFFFFFFFFFFFFFFFFui64 / (unsigned int)a3;
  v11 = 0i64;
  v12 = (signed __int64)(i - 1);
  v13 = 0;
  while ( 2 )
  {
    if ( (unsigned __int8)(v7 - 48) <= 9u )
    {
      LODWORD(v15) = v7 - 48;
LABEL_29:
      if ( (signed int)v15 >= (signed int)a3 )
        goto LABEL_37;
      v16 = -1;
      if ( v11 <= v10 && v13 >= 0 )
      {
        v15 = (signed int)v15;
        if ( v11 == v10 )
        {
          v17 = 0xFFFFFFFFFFFFFFFFui64 / (unsigned int)a3;
          if ( 0xFFFFFFFFFFFFFFFFui64 % (unsigned int)a3 < v15 )
            goto LABEL_36;
        }
        v11 = v15 + a3 * v11;
        v16 = 1;
      }
      v17 = v11;
LABEL_36:
      v7 = *(char *)(v12++ + 1);
      v11 = v17;
      v13 = v16;
      continue;
    }
    break;
  }
  v14 = v7 - 65;
  if ( (unsigned __int8)(v7 - 97) < 0x1Au || v14 <= 0x19u )
  {
    LODWORD(v15) = v7 - 32 * (v14 > 0x19u) - 55;
    goto LABEL_29;
  }
LABEL_37:
  if ( v13 < 0 )
  {
    result = -1i64;
  }
  else
  {
    result = -(signed __int64)v11;
    if ( !v6 )
      result = v11;
  }
  if ( v3 )
  {
    if ( !v13 )
      v12 = a1;
    *v3 = v12;
  }
  return result;
}

//----- (0000000000018C7A) ----------------------------------------------------
_BYTE *__fastcall sub_18C7A(_BYTE *a1, __int64 a2, __int64 a3)
{
  _BYTE *result; // rax
  _BYTE *v4; // r10
  _BYTE *v5; // rcx
  __int64 v6; // r8
  signed __int64 v7; // r9
  char v8; // cl
  signed __int64 v9; // rcx

  result = a1;
  v4 = a1;
  do
    v5 = v4++;
  while ( *v5 );
  if ( a3 )
  {
    v6 = -a3;
    v7 = -1i64;
    do
    {
      v8 = *(_BYTE *)(a2 + v7 + 1);
      if ( !v8 )
        break;
      v4[v7] = v8;
      v9 = v6 + v7++ + 1;
    }
    while ( v9 != -1 );
    v5 = &v4[v7];
  }
  *v5 = 0;
  return result;
}

//----- (0000000000018CC7) ----------------------------------------------------
_BYTE *__fastcall sub_18CC7(_BYTE *a1, char *a2)
{
  _BYTE *result; // rax
  char v3; // r8
  __int64 v4; // r9
  bool v5; // zf
  _BYTE *v6; // r10
  signed __int64 v7; // r9
  __int64 v8; // r11
  __int64 v9; // r10

  result = a1;
  v3 = *a2;
  v4 = 0i64;
  if ( *a2 )
  {
    do
      v5 = a2[v4++ + 1] == 0;
    while ( !v5 );
  }
  do
    v5 = *a1++ == 0;
  while ( !v5 );
  v6 = a1 - 1;
  if ( (_DWORD)v4 && v3 )
  {
    v7 = (signed int)v4 - 1i64;
    v8 = 0i64;
    do
    {
      v9 = v8;
      a1[v8 - 1] = v3;
      if ( v7 == v8 )
        break;
      v3 = a2[v8++ + 1];
    }
    while ( v3 );
    v6 = &a1[v9];
  }
  *v6 = 0;
  return result;
}

//----- (0000000000018D2F) ----------------------------------------------------
__int64 __fastcall sub_18D2F(__int64 a1, __int64 a2, int a3)
{
  __int64 result; // rax
  __int64 v4; // r9
  int v5; // er10

  result = 0i64;
  v4 = 0i64;
  while ( a3 > 0 )
  {
    v5 = *(char *)(a1 + v4);
    if ( (*(_BYTE *)(a1 + v4) ^ *(_BYTE *)(a2 + v4)) & 0xDF )
      return (v5 & 0xFFFFFFDF) - (*(char *)(a2 + v4) & 0xFFFFFFDF);
    --a3;
    ++v4;
    if ( !(_BYTE)v5 )
      return result;
  }
  return result;
}

//----- (0000000000018D72) ----------------------------------------------------
unsigned __int64 sub_18D72()
{
  unsigned __int64 result; // rax

  _mm_lfence();
  result = __rdtsc();
  _mm_lfence();
  return result;
}

//----- (0000000000018D87) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char *__fastcall sub_18D87(char *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r12
  char *v3; // rdi
  unsigned int v4; // er14
  char v5; // si
  char *result; // rax
  unsigned int v7; // eax
  __int64 v8; // rdi
  __int64 v9; // rax
  unsigned __int64 v10; // r8
  __int64 v11; // rcx
  __int64 v12; // [rsp+30h] [rbp-50h]
  __int64 v13; // [rsp+38h] [rbp-48h]
  __int64 v14; // [rsp+40h] [rbp-40h]
  char *v15; // [rsp+48h] [rbp-38h]

  v13 = -9034400514174975832i64;
  v12 = 5457143572451254544i64;
  v14 = 0i64;
  v15 = 0i64;
  if ( a1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = 2;
    v5 = 1;
  }
  else
  {
    v3 = (char *)0xFFFFFFFFi64;
    v2 = 4096i64;
    v4 = 1;
    if ( sub_1487D() )
    {
      v5 = 0;
    }
    else
    {
      result = (char *)(*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, __int64 *, _QWORD))(qword_96CE0 + 72))(
                         "e",
                         &v12,
                         0i64,
                         &v14,
                         0i64);
      if ( result != (char *)-9223372036854775803i64 )
        return result;
      v5 = 0;
      (*(void (__fastcall **)(const char *, __int64 *, signed __int64, _QWORD, _QWORD))(qword_96CE0 + 88))(
        "e",
        &v12,
        7i64,
        0i64,
        0i64);
    }
  }
  v15 = v3;
  byte_94CB0 = v5;
  v7 = sub_23C9F(v2, 12);
  v8 = v7;
  v9 = sub_13759(v4, 9i64, v7, (__int64 *)&v15);
  if ( v9 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`DBG:IDTP] %r @ M:BAP %qd\n", v9, v8);
    result = 0i64;
    qword_94CB8 = 0i64;
    qword_94CC0 = (unsigned __int8)qword_94CB8;
    return result;
  }
  if ( !qword_94CB8 || !qword_94CC8 || (v10 = *(unsigned int *)(qword_94CC8 + 12), v2 < v10) )
  {
    qword_94CB8 = (__int64)v15;
    qword_94CC0 = v2;
    v11 = qword_96AF8;
    if ( qword_96AF8 )
    {
LABEL_12:
      result = (char *)(*(__int64 (__fastcall **)(__int64, _QWORD, __int64 *, __int64 *))(v11 + 48))(
                         v11,
                         0i64,
                         &qword_94CD0,
                         &qword_94CD8);
      if ( (signed __int64)result < 0 )
        return result;
      qword_94CD8 = sub_23CAD(0xE8D4A51000ui64, qword_94CD8, 0i64);
      goto LABEL_22;
    }
    if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92D00, 0i64, &qword_96AF8) < 0 )
    {
      qword_96AF8 = 0i64;
    }
    else
    {
      v11 = qword_96AF8;
      if ( qword_96AF8 )
        goto LABEL_12;
    }
LABEL_22:
    qword_94CC8 = qword_94CB8;
    *(_QWORD *)qword_94CC8 = 8029764669531384162i64;
    *(_QWORD *)(qword_94CB8 + 8) = 0i64;
    *(_QWORD *)(qword_94CB8 + 16) = qword_94CD8;
    result = (char *)sub_23CAD(qword_94CD0, qword_94CD8, 0i64);
    *(_QWORD *)(qword_94CC8 + 24) = result;
    *(_DWORD *)(qword_94CC8 + 12) += 64;
    return result;
  }
  sub_1B930(v15, (char *)qword_94CB8, v10);
  if ( !(byte_94CB0 & 1) )
    sub_19006();
  result = v15;
  qword_94CB8 = (__int64)v15;
  qword_94CC0 = v2;
  qword_94CC8 = qword_94CB8;
  return result;
}
// 18E5B: write access to const memory at 94CB0 has been detected
// 18EB6: write access to const memory at 94CB8 has been detected
// 18EBD: write access to const memory at 94CC0 has been detected
// 18F05: write access to const memory at 94CD8 has been detected
// 18F2A: write access to const memory at 94CB8 has been detected
// 18F31: write access to const memory at 94CC0 has been detected
// 18F89: write access to const memory at 94CB8 has been detected
// 18F90: write access to const memory at 94CC0 has been detected
// 18F97: write access to const memory at 94CC8 has been detected
// 18FA0: write access to const memory at 96AF8 has been detected
// 18FB2: write access to const memory at 94CC8 has been detected
// 92D00: using guessed type __int64 qword_92D00[2];
// 94CB0: using guessed type char byte_94CB0;
// 94CB8: using guessed type __int64 qword_94CB8;
// 94CC0: using guessed type __int64 qword_94CC0;
// 94CC8: using guessed type __int64 qword_94CC8;
// 94CD0: using guessed type __int64 qword_94CD0;
// 94CD8: using guessed type __int64 qword_94CD8;
// 96AF8: using guessed type __int64 qword_96AF8;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000019006) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_19006()
{
  __int64 result; // rax
  unsigned int v1; // eax

  result = 0i64;
  qword_94CB8 = 0i64;
  qword_94CC0 = (unsigned __int8)qword_94CB8;
  qword_94CC8 = (unsigned __int8)qword_94CB8;
  if ( (_BYTE)qword_94CB8 )
  {
    if ( qword_94CC0 )
    {
      v1 = sub_23C9F(qword_94CC0, 12);
      result = sub_137B1(qword_94CB8, v1);
    }
  }
  return result;
}
// 1901F: write access to const memory at 94CB8 has been detected
// 19026: write access to const memory at 94CC0 has been detected
// 1902D: write access to const memory at 94CC8 has been detected
// 94CB0: using guessed type char byte_94CB0;
// 94CB8: using guessed type __int64 qword_94CB8;
// 94CC0: using guessed type __int64 qword_94CC0;
// 94CC8: using guessed type __int64 qword_94CC8;

//----- (000000000001905F) ----------------------------------------------------
_BYTE *sub_1905F(__int64 a1, ...)
{
  _BYTE *result; // rax
  va_list v2; // [rsp+20h] [rbp-20h]
  __int64 v3; // [rsp+28h] [rbp-18h]
  __int64 v4; // [rsp+30h] [rbp-10h]
  va_list va; // [rsp+58h] [rbp+18h]

  va_start(va, a1);
  result = (_BYTE *)a1;
  v2 = (va_list)-6148914691236517206i64;
  v3 = -6148914691236517206i64;
  v4 = -6148914691236517206i64;
  if ( qword_94CB8 )
  {
    va_copy(v2, va);
    result = sub_190B4(1, a1, (unsigned __int64 **)&v2);
  }
  return result;
}
// 94CB8: using guessed type __int64 qword_94CB8;

//----- (00000000000190B4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_BYTE *__fastcall sub_190B4(int a1, __int64 a2, unsigned __int64 **a3)
{
  unsigned __int64 **v3; // rdi
  __int64 v4; // rbx
  int v5; // er14
  unsigned __int64 v6; // r13
  unsigned __int64 v7; // r15
  int v8; // eax
  signed int v9; // edx
  char *v10; // rax
  __int64 v11; // rcx
  unsigned __int64 v12; // rdi
  _BYTE *result; // rax
  __int64 v14; // rax
  unsigned int v15; // eax
  __int64 v16; // r12
  __int64 v17; // rax
  unsigned int v18; // eax
  __int64 v19; // rdx
  __int64 v20; // rcx
  char *v21; // [rsp+20h] [rbp-40h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  _mm_lfence();
  _mm_lfence();
  v6 = __rdtsc();
  if ( qword_94CD8 )
    v7 = sub_23CAD(v6, qword_94CD8, 0i64);
  else
    v7 = -1i64;
  v8 = sub_1898E(qword_94CE0, 256, v4, v3);
  if ( *((_BYTE *)qword_94CE0 + v8 - 1) == 10 )
    *((_BYTE *)qword_94CE0 + v8-- - 1) = 0;
  v9 = v8 + ((v8 + ((unsigned int)((v8 + 8) >> 31) >> 29) + 8) & 0xFFFFFFF8);
  v10 = (char *)qword_94CC8;
  v11 = *(unsigned int *)(qword_94CC8 + 12);
  v12 = v9;
  if ( v11 + v9 + 24 <= (unsigned __int64)qword_94CC0 )
  {
    v19 = qword_94CB8;
    goto LABEL_12;
  }
  result = (_BYTE *)-6148914691236517206i64;
  v21 = (char *)-6148914691236517206i64;
  if ( !byte_94CB0 )
  {
    result = (_BYTE *)qword_96CD8;
    if ( qword_96CD8 )
    {
      v21 = (char *)0xFFFFFFFFi64;
      v14 = sub_23C84(qword_94CC0, 1);
      qword_94CC0 = v14;
      v15 = sub_23C9F(v14, 12);
      v16 = v15;
      v17 = sub_13759(1i64, 9i64, v15, (__int64 *)&v21);
      if ( v17 >= 0 )
      {
        sub_1B930(v21, (char *)qword_94CB8, *(unsigned int *)(qword_94CC8 + 12));
        v18 = sub_23C9F(qword_94CC0, 12);
        sub_137B1(qword_94CB8, v18);
        v10 = v21;
        qword_94CB8 = (__int64)v21;
        qword_94CC8 = qword_94CB8;
        v11 = *(unsigned int *)(qword_94CB8 + 12);
        v19 = qword_94CB8;
LABEL_12:
        *(_DWORD *)(v19 + v11) = v5;
        *(_DWORD *)(v19 + v11 + 4) = v12;
        *(_QWORD *)(v19 + v11 + 8) = v7;
        *(_QWORD *)(v19 + v11 + 16) = v6;
        v20 = (unsigned int)(*((_DWORD *)v10 + 3) + 24);
        *((_DWORD *)v10 + 3) = v20;
        sub_1B930((char *)(v19 + v20), (char *)qword_94CE0, v12);
        result = (_BYTE *)qword_94CC8;
        *((_DWORD *)result + 3) += v12;
        ++*((_DWORD *)result + 2);
        return result;
      }
      result = sub_1A2B6(1, (__int64)"EB|`DBG:TTPI] %r @ M:BAP %qd\n", v17, v16);
    }
  }
  return result;
}
// 191AF: write access to const memory at 94CC0 has been detected
// 19221: write access to const memory at 94CB8 has been detected
// 19228: write access to const memory at 94CC8 has been detected
// 94CB0: using guessed type char byte_94CB0;
// 94CB8: using guessed type __int64 qword_94CB8;
// 94CC0: using guessed type __int64 qword_94CC0;
// 94CC8: using guessed type __int64 qword_94CC8;
// 94CD8: using guessed type __int64 qword_94CD8;
// 94CE0: using guessed type __int64 qword_94CE0[32];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000192A2) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_192A2()
{
  __int64 result; // rax
  __int64 v1; // [rsp+30h] [rbp-30h]
  __int64 v2; // [rsp+38h] [rbp-28h]
  int v3; // [rsp+44h] [rbp-1Ch]

  v3 = -1431655766;
  v2 = -9034400514174975832i64;
  v1 = 5457143572451254544i64;
  result = qword_94CB8;
  if ( qword_94CB8 )
  {
    byte_94CB0 = 1;
    v3 = qword_94CB8;
    (*(void (__fastcall **)(const char *, __int64 *, signed __int64, signed __int64, int *))(qword_96CE0 + 88))(
      "e",
      &v1,
      6i64,
      4i64,
      &v3);
    v3 = qword_94CC0;
    result = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, signed __int64, signed __int64, int *))(qword_96CE0 + 88))(
               L"efiboot-perf-record-data-size",
               &v1,
               6i64,
               4i64,
               &v3);
    if ( qword_96B00 )
    {
      *(_DWORD *)(qword_96B00 + 1112i64) = qword_94CB8;
      result = (unsigned int)qword_94CC0;
      *(_DWORD *)(qword_96B00 + 1116i64) = qword_94CC0;
    }
  }
  return result;
}
// 192E1: write access to const memory at 94CB0 has been detected
// 41118: using guessed type __int16 aEfibootPerfRec[30];
// 94CB0: using guessed type char byte_94CB0;
// 94CB8: using guessed type __int64 qword_94CB8;
// 94CC0: using guessed type __int64 qword_94CC0;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001936A) ----------------------------------------------------
_BYTE *sub_1936A()
{
  _BYTE *result; // rax
  int v9; // esi
  unsigned __int64 v10; // rax
  __int64 v11; // rbx
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rax

  result = (_BYTE *)2863311530i64;
  if ( qword_94CB8 )
  {
    _RAX = 0i64;
    __asm { cpuid }
    if ( (_DWORD)result )
    {
      _RAX = 1i64;
      __asm { cpuid }
      v9 = _RDX;
      if ( (_RCX & 0x80u) != 0i64 )
      {
        v10 = __readmsr(0x198u);
        v11 = (unsigned int)v10;
        v12 = __readmsr(0x199u);
        result = sub_1905F((__int64)"PERF_STS 0x%x, PERF_CTL 0x%x", v11, (unsigned int)v12);
      }
      if ( _bittest(&v9, 0x1Du) )
      {
        v13 = __readmsr(0x19Cu);
        result = sub_1905F((__int64)"THERM_STATUS 0x%x", (unsigned int)v13);
      }
    }
  }
  return result;
}
// 94CB8: using guessed type __int64 qword_94CB8;

//----- (00000000000194E0) ----------------------------------------------------
__int64 __usercall sub_194E0@<rax>(__m128i a1@<xmm0>, __m128i a2@<xmm1>, __m128i a3@<xmm2>, __m128i a4@<xmm6>, __m128i a5@<xmm7>)
{
  int v5; // eax
  __m128i *v6; // rcx
  __m128i *v7; // rbx
  const __m128i *v8; // rdx
  __m128i v9; // xmm7
  signed int v10; // er8
  signed int v11; // er13
  __m128i *v12; // r9
  __m128i *v13; // r14
  __int64 v14; // r15
  __m128i v15; // xmm6
  __m128i v16; // xmm0
  unsigned __int8 v17; // of
  __int128 v19; // [rsp+0h] [rbp-C8h]
  __int128 v20; // [rsp+10h] [rbp-B8h]
  __int128 v21; // [rsp+30h] [rbp-98h]
  __int128 v22; // [rsp+40h] [rbp-88h]
  __int128 v23; // [rsp+50h] [rbp-78h]
  __int64 v24; // [rsp+C0h] [rbp-8h]

  LOBYTE(v5) = sub_9DAB();
  JUMPOUT(v5, 0, sub_1FEC0);
  _mm_store_si128((__m128i *)&v19, a5);
  _mm_store_si128((__m128i *)&v20, a4);
  _mm_store_si128((__m128i *)&v21, a1);
  _mm_store_si128((__m128i *)&v22, a2);
  _mm_store_si128((__m128i *)&v23, a3);
  v7 = v6;
  v9 = _mm_loadu_si128(v8);
  v11 = v10;
  v13 = v12;
  v14 = *(_QWORD *)((unsigned int)&v24 + 48);
  if ( v10 >= 1 )
  {
    do
    {
      v15 = _mm_loadu_si128(v7);
      sub_38CC(v7, (int *)v13->m128i_i64, v14);
      v16 = _mm_xor_si128(_mm_loadu_si128(v13), v9);
      v9 = v15;
      _mm_storeu_si128(v13, v16);
      ++v7;
      ++v13;
      v17 = __OFSUB__(v11--, 1);
    }
    while ( !((unsigned __int8)((v11 < 0) ^ v17) | (v11 == 0)) );
  }
  return 0i64;
}

//----- (000000000001959F) ----------------------------------------------------
signed __int64 __usercall sub_1959F@<rax>(__int64 a1@<rdx>, unsigned int *a2@<rcx>, __int64 a3@<r8>, char *a4@<r9>, __m128i *a5@<xmm1>, __m128i *a6@<xmm2>, __m128i *a7@<xmm6>, __m128i *a8@<xmm7>, unsigned __int64 a9, __int64 a10, unsigned __int64 *a11)
{
  unsigned __int64 v11; // r13
  unsigned int v12; // er15
  signed __int64 result; // rax
  __int64 v14; // r12
  char *v15; // r14
  char *v16; // rdi
  __int64 v17; // rsi
  __int64 v18; // rbx
  __int64 v19; // rax
  int v20; // eax
  unsigned int v21; // er13
  _QWORD *v22; // rdi
  __int64 v23; // r14
  int v24; // edx
  __m128 v25; // xmm0
  unsigned __int8 v26; // of
  char *v27; // rsi
  __int64 v28; // rbx
  __int64 v29; // rdi
  char v30; // [rsp+30h] [rbp-1D0h]
  __int64 v31; // [rsp+130h] [rbp-D0h]
  __int64 v32; // [rsp+138h] [rbp-C8h]
  __int64 v33; // [rsp+140h] [rbp-C0h]
  __int64 v34; // [rsp+148h] [rbp-B8h]
  __int64 v35; // [rsp+150h] [rbp-B0h]
  __int64 v36; // [rsp+158h] [rbp-A8h]
  __int64 v37; // [rsp+160h] [rbp-A0h]
  __int64 v38; // [rsp+168h] [rbp-98h]
  __int64 v39; // [rsp+170h] [rbp-90h]
  __int64 v40; // [rsp+178h] [rbp-88h]
  unsigned int *v41; // [rsp+180h] [rbp-80h]
  __int64 v42; // [rsp+188h] [rbp-78h]
  __int64 v43; // [rsp+190h] [rbp-70h]
  __int64 *v44; // [rsp+198h] [rbp-68h]
  __int64 v45; // [rsp+1A0h] [rbp-60h]
  unsigned __int64 v46; // [rsp+1A8h] [rbp-58h]
  __int64 v47; // [rsp+1B0h] [rbp-50h]
  unsigned int v48; // [rsp+1BCh] [rbp-44h]
  int v49; // [rsp+1C0h] [rbp-40h]
  unsigned int v50; // [rsp+1C4h] [rbp-3Ch]

  v41 = a2;
  v11 = a9 >> 3;
  v12 = (a9 >> 3) - 1;
  v40 = -6148914691236517206i64;
  v39 = -6148914691236517206i64;
  v38 = -6148914691236517206i64;
  v37 = -6148914691236517206i64;
  v36 = -6148914691236517206i64;
  v35 = -6148914691236517206i64;
  v34 = -6148914691236517206i64;
  v33 = -6148914691236517206i64;
  result = 0xFFFFFFFFi64;
  if ( v12 <= 4 )
  {
    v14 = a1;
    if ( !((a1 - 16) & 0xFFFFFFFFFFFFFFEFui64) && a11 && *a11 >= a9 - 8 )
    {
      v15 = a4;
      v45 = a3;
      v46 = a9 - 8;
      sub_1B930((char *)&v33, a4, 8ui64);
      v47 = v12;
      if ( (unsigned int)(a9 >> 3) != 1 )
      {
        v16 = (char *)&v34;
        v17 = 8 * v47;
        v18 = 0i64;
        do
        {
          v18 += 8i64;
          sub_1B930(v16, &v15[v18 & 0xFFFFFFF8], 8ui64);
          v16 += 16;
        }
        while ( v17 != v18 );
      }
      v19 = (unsigned int)(v11 - 2);
      v43 = v19 + 1;
      v42 = (unsigned int)(v11 - 2);
      v44 = &v33 + 2 * v19;
      v50 = 6 * v11 - 6;
      v49 = 1 - v11;
      v20 = 5;
      while ( 1 )
      {
        v48 = v20;
        if ( (signed int)v42 >= 0 )
          break;
LABEL_13:
        v50 += v49;
        v20 = v48 - 1;
        if ( v48 < 1 )
        {
          result = 0xFFFFFFFFi64;
          if ( v33 == v45 )
          {
            if ( (unsigned int)(a9 >> 3) != 1 )
            {
              v27 = (char *)&v34;
              v28 = 8 * v47;
              v29 = 0i64;
              do
              {
                sub_1B930((char *)(a10 + ((unsigned int)v29 & 0xFFFFFFF8)), v27, 8ui64);
                v29 += 8i64;
                v27 += 16;
              }
              while ( v28 != v29 );
            }
            *a11 = v46;
            result = 0i64;
          }
          return result;
        }
      }
      v21 = v50;
      v22 = v44;
      v23 = v43;
      while ( 1 )
      {
        v24 = 16 * ((unsigned int)v23 % v12);
        *v22 = *(&v33 + 2 * ((unsigned int)v23 % v12)) ^ _byteswap_uint64(v21);
        v32 = 0i64;
        v31 = 0i64;
        LOBYTE(v24) = -86;
        sub_F180(&v30, v24, 0xF4ui64);
        if ( v14 != 16 )
          break;
        v25 = sub_40E1(v41, (__int64)&v30);
        sub_194E0((__m128i *)v25.m128_u64[0], a5, a6, a7, a8);
        v22 -= 2;
        --v21;
        v26 = __OFSUB__(v23--, 1i64);
        if ( (unsigned __int8)((v23 < 0) ^ v26) | (v23 == 0) )
          goto LABEL_13;
      }
      result = 0xFFFFFFFFi64;
    }
  }
  return result;
}

//----- (000000000001980F) ----------------------------------------------------
signed __int64 __fastcall sub_1980F(__int64 a1)
{
  return a1 - 8;
}

//----- (0000000000019819) ----------------------------------------------------
__int64 __fastcall sub_19819(char *a1, unsigned __int8 a2, unsigned __int8 a3)
{
  __int64 result; // rax
  char *v4; // rsi
  __int64 v5; // rbx
  unsigned __int64 v6; // rdi
  unsigned int v7; // ecx

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v4 = a1;
    v5 = a3;
    v6 = a2;
    v7 = a3 + a2;
    if ( v7 < 0x100 )
      result = 0i64;
    if ( (_BYTE)v6 && v7 <= 0xFF )
    {
      sub_198A7();
      if ( qword_94DE0 )
      {
        result = (*(__int64 (__fastcall **)(__int64, char *, unsigned __int64, __int64))(qword_94DE0 + 8))(
                   qword_94DE0,
                   v4,
                   v6,
                   v5);
      }
      else
      {
        sub_1995F();
        sub_1B930(v4, (char *)&qword_94DF0 + v5, v6);
        result = 0i64;
      }
    }
  }
  return result;
}
// 94DE0: using guessed type __int64 qword_94DE0;
// 94DF0: using guessed type __int64 qword_94DF0;

//----- (00000000000198A7) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_198A7()
{
  __int64 v0; // rax
  __int64 v1; // rax

  if ( !qword_94DE0 && !(byte_94EF0 & 1) )
  {
    v0 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92C10, 0i64, &qword_94DE0);
    if ( v0 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`RTC:CP] %r @ LocP %g\n", v0, (__int64)qword_92C10);
      byte_94EF0 = 1;
    }
    else
    {
      v1 = (*(__int64 (__fastcall **)(signed __int64, signed __int64, void (*)(), _QWORD, __int64 *))(qword_96CD8 + 80))(
             513i64,
             8i64,
             sub_19B1A,
             0i64,
             &qword_96C00);
      if ( v1 < 0 )
        sub_1A2B6(1, (__int64)"[EB|`RTC:CP] %r @ BS.CE 0x%08X\n", v1, 513i64);
    }
  }
}
// 19952: write access to const memory at 94EF0 has been detected
// 92C10: using guessed type __int64 qword_92C10[2];
// 94DE0: using guessed type __int64 qword_94DE0;
// 94EF0: using guessed type char byte_94EF0;
// 96C00: using guessed type __int64 qword_96C00;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000001995F) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_1995F()
{
  signed __int64 v0; // rcx
  unsigned __int8 v1; // al

  if ( !byte_94EF1 )
  {
    v0 = 14i64;
    do
    {
      if ( (v0 & 0x80u) != 0i64 )
      {
        __outbyte(0x72u, v0);
        v1 = __inbyte(0x73u);
      }
      else
      {
        __outbyte(0x70u, v0);
        v1 = __inbyte(0x71u);
      }
      *((_BYTE *)&qword_94DF0 + v0++) = v1;
    }
    while ( v0 != 256 );
    byte_94EF1 = 1;
  }
}
// 19997: write access to const memory at 94EF1 has been detected
// 94DF0: using guessed type __int64 qword_94DF0;
// 94EF1: using guessed type char byte_94EF1;

//----- (00000000000199A0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_199A0(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3)
{
  __int64 result; // rax
  unsigned __int64 v4; // rdi
  __int64 v5; // r14
  unsigned int v6; // ebx
  unsigned __int8 *v7; // rsi
  signed int v8; // eax
  unsigned __int8 v9; // cl
  char v10; // di
  unsigned int v11; // esi
  unsigned int v12; // eax

  result = -9223372036854775806i64;
  if ( a1 )
  {
    if ( a3 >= 0xEu )
    {
      v4 = a3;
      v5 = a2;
      v6 = a3 + a2;
      if ( v6 <= 0xFF )
      {
        if ( a2 )
        {
          v7 = a1;
          sub_198A7();
          if ( qword_94DE0 )
            return (*(__int64 (__fastcall **)(__int64, unsigned __int8 *, __int64, unsigned __int64))(qword_94DE0 + 16))(
                     qword_94DE0,
                     v7,
                     v5,
                     v4);
          sub_1995F();
          v8 = 0;
          do
          {
            v9 = *v7;
            if ( *v7 != *((_BYTE *)&qword_94DF0 + v4) )
            {
              if ( (v4 & 0x80u) != 0i64 )
              {
                __outbyte(0x72u, v4);
                __outbyte(0x73u, v9);
              }
              else
              {
                __outbyte(0x70u, v4);
                __outbyte(0x71u, v9);
              }
              *((_BYTE *)&qword_94DF0 + v4) = *v7;
              v8 = 1;
            }
            ++v7;
            ++v4;
          }
          while ( v4 < v6 );
          if ( v8 )
          {
            if ( (unsigned __int16)word_94E2E != sub_17D61(0, (__int64)&word_94DFE, 48) )
            {
              __outbyte(0x70u, 0x3Eu);
              __outbyte(0x71u, word_94E2E);
              __outbyte(0x70u, 0x3Fu);
              __outbyte(0x71u, HIBYTE(word_94E2E));
            }
            v10 = HIBYTE(word_94E48);
            LOBYTE(v11) = word_94E48;
            word_94E48 = 0;
            LOWORD(v12) = sub_17D61(0, (__int64)&word_94DFE, 242);
            if ( (HIBYTE(word_94E48) | ((unsigned __int8)word_94E48 << 8)) != (unsigned __int16)v12 )
            {
              v11 = v12 >> 8;
              __outbyte(0x70u, 0x58u);
              __outbyte(0x71u, BYTE1(v12));
              __outbyte(0x70u, 0x59u);
              __outbyte(0x71u, v12);
              v10 = v12;
            }
            LOBYTE(word_94E48) = v11;
            HIBYTE(word_94E48) = v10;
          }
        }
        result = 0i64;
      }
    }
  }
  return result;
}
// 19AA1: write access to const memory at 94E2E has been detected
// 19AA7: write access to const memory at 94E2F has been detected
// 19ABB: write access to const memory at 94E48 has been detected
// 19AFF: write access to const memory at 94E48 has been detected
// 19B06: write access to const memory at 94E49 has been detected
// 94DE0: using guessed type __int64 qword_94DE0;
// 94DF0: using guessed type __int64 qword_94DF0;
// 94DFE: using guessed type __int16 word_94DFE;
// 94E2E: using guessed type __int16 word_94E2E;
// 94E48: using guessed type __int16 word_94E48;

//----- (0000000000019B1A) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_19B1A()
{
  byte_94EF0 = 1;
  qword_94DE0 = 0i64;
}
// 19B1E: write access to const memory at 94EF0 has been detected
// 19B25: write access to const memory at 94DE0 has been detected
// 94DE0: using guessed type __int64 qword_94DE0;
// 94EF0: using guessed type char byte_94EF0;

//----- (0000000000019B32) ----------------------------------------------------
__int64 __fastcall sub_19B32(unsigned int *a1, int a2, __int64 *a3, unsigned __int64 a4)
{
  unsigned int *v4; // rsi
  __int64 result; // rax
  unsigned __int64 v6; // r14
  __int64 *v7; // r12
  int v8; // er15
  unsigned int v9; // eax
  unsigned __int64 v10; // rcx
  char v11; // bl
  unsigned __int64 v12; // r8
  char v13[128]; // [rsp+20h] [rbp-F0h]
  __int64 v14; // [rsp+A0h] [rbp-70h]
  __int64 v15; // [rsp+A8h] [rbp-68h]
  __int64 v16; // [rsp+B0h] [rbp-60h]
  __int64 v17; // [rsp+B8h] [rbp-58h]
  __int64 v18; // [rsp+C0h] [rbp-50h]
  __int64 v19; // [rsp+C8h] [rbp-48h]
  __int64 v20; // [rsp+D0h] [rbp-40h]
  __int64 v21; // [rsp+D8h] [rbp-38h]

  v4 = a1;
  result = -6148914691236517206i64;
  v21 = -6148914691236517206i64;
  v20 = -6148914691236517206i64;
  v19 = -6148914691236517206i64;
  v18 = -6148914691236517206i64;
  v17 = -6148914691236517206i64;
  v16 = -6148914691236517206i64;
  v15 = -6148914691236517206i64;
  v14 = -6148914691236517206i64;
  memset(v13, 0xAAu, sizeof(v13));
  if ( a1 )
  {
    v6 = a4;
    v7 = a3;
    v8 = a2;
    result = sub_F1B0(a1, 368i64);
    if ( v8 == 2 )
    {
      *(_QWORD *)v4 = 274877906976i64;
      *((_QWORD *)v4 + 43) = sub_1B84F;
      *((_QWORD *)v4 + 44) = sub_1AAAE;
      *((_QWORD *)v4 + 45) = sub_1B87F;
      sub_1B84F((__int64)(v4 + 2));
      if ( v4[1] < v6 )
      {
        (*((void (__fastcall **)(unsigned int *, __int64 *, _QWORD))v4 + 44))(v4 + 2, v7, (unsigned int)v6);
        (*((void (__fastcall **)(__int64 *, unsigned int *))v4 + 45))(&v14, v4 + 2);
        v6 = *v4;
        (*((void (__fastcall **)(unsigned int *))v4 + 43))(v4 + 2);
        v7 = &v14;
      }
      if ( v6 )
      {
        v9 = 1;
        v10 = 0i64;
        do
        {
          v11 = *((_BYTE *)v7 + v10);
          v13[v10] = v11 ^ 0x36;
          *((_BYTE *)v4 + v10 + 216) = v11 ^ 0x5C;
          v10 = v9++;
        }
        while ( v6 > v10 );
      }
      v12 = v4[1];
      if ( v6 < v12 )
      {
        sub_F180(&v13[v6], 54, v12 - v6);
        sub_F180((char *)v4 + v6 + 216, 92, v4[1] - v6);
        v12 = v4[1];
      }
      result = (*((__int64 (__fastcall **)(unsigned int *, char *, unsigned __int64))v4 + 44))(v4 + 2, v13, v12);
    }
  }
  return result;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 19B32: using guessed type char var_F0[128];

//----- (0000000000019CB6) ----------------------------------------------------
__int64 __fastcall sub_19CB6(void (__fastcall **a1)(signed __int64), __int64 a2)
{
  __int64 v2; // rsi
  void (__fastcall **v3)(signed __int64); // rdi
  signed __int64 v4; // rbx

  v2 = a2;
  v3 = a1;
  v4 = (signed __int64)(a1 + 1);
  ((void (__fastcall *)(__int64, unsigned int *))a1[45])(a2, (unsigned int *)a1 + 2);
  v3[43](v4);
  ((void (__fastcall *)(signed __int64, unsigned int *, _QWORD))v3[44])(
    v4,
    (unsigned int *)v3 + 54,
    *((unsigned int *)v3 + 1));
  ((void (__fastcall *)(signed __int64, __int64, _QWORD))v3[44])(v4, v2, *(unsigned int *)v3);
  return ((__int64 (__fastcall *)(__int64, signed __int64))v3[45])(v2, v4);
}

//----- (0000000000019D1B) ----------------------------------------------------
__int64 __fastcall sub_19D1B(int a1, __int64 *a2, unsigned __int64 a3, __int64 a4, unsigned int a5, __int64 a6)
{
  __int64 v6; // r14
  unsigned __int64 v7; // rdi
  __int64 *v8; // rbx
  int v9; // esi
  void (__fastcall *v11)(signed __int64); // [rsp+28h] [rbp-1B8h]
  char v12; // [rsp+30h] [rbp-1B0h]
  void (__fastcall *v13)(char *, __int64, _QWORD); // [rsp+188h] [rbp-58h]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  LOBYTE(a2) = -86;
  sub_F180((char *)&v11, (int)a2, 0x180ui64);
  sub_19B32((unsigned int *)&v11, v9, v8, v7);
  v13(&v12, v6, a5);
  return sub_19CB6(&v11, a6);
}

//----- (0000000000019D9D) ----------------------------------------------------
__int64 __fastcall sub_19D9D(int a1, __int64 *a2, unsigned __int64 a3, __int64 a4, unsigned int a5, __int64 a6)
{
  int v6; // ecx
  __int64 result; // rax

  v6 = a1 - 1;
  if ( (unsigned int)v6 <= 4 )
    result = sub_19D1B(*((_DWORD *)qword_8FB10 + v6), a2, a3, a4, a5, a6);
  return result;
}
// 8FB10: using guessed type __int64 qword_8FB10[3];

//----- (0000000000019DBC) ----------------------------------------------------
signed __int64 __fastcall sub_19DBC(int a1, __int64 *a2, unsigned __int64 a3, char *a4, unsigned __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned __int64 a9)
{
  char *v9; // rdi
  int v10; // er15
  int v11; // edx
  int v12; // edx
  int v13; // edx
  signed __int64 result; // rax
  unsigned __int64 v15; // r13
  unsigned __int64 v16; // r12
  __int64 v17; // r12
  __int64 v18; // rdi
  signed int v19; // ecx
  __int64 v20; // rax
  unsigned __int64 v21; // rdi
  __int64 v22; // rax
  signed int v23; // er14
  __int64 v24; // rax
  char v25; // [rsp+30h] [rbp-2B0h]
  char v26[144]; // [rsp+C0h] [rbp-220h]
  char v27[144]; // [rsp+150h] [rbp-190h]
  char v28[144]; // [rsp+1E0h] [rbp-100h]
  unsigned __int64 v29; // [rsp+270h] [rbp-70h]
  __int64 v30; // [rsp+278h] [rbp-68h]
  unsigned __int64 v31; // [rsp+280h] [rbp-60h]
  __int64 v32; // [rsp+288h] [rbp-58h]
  __int64 v33; // [rsp+290h] [rbp-50h]
  unsigned __int64 v34; // [rsp+298h] [rbp-48h]
  __int64 *v35; // [rsp+2A0h] [rbp-40h]

  v9 = a4;
  v34 = a3;
  v35 = a2;
  v10 = a1;
  LOBYTE(a2) = -86;
  sub_F180(&v25, (int)a2, 0x84ui64);
  LOBYTE(v11) = -86;
  sub_F180(v26, v11, 0x84ui64);
  LOBYTE(v12) = -86;
  sub_F180(v27, v12, 0x84ui64);
  LOBYTE(v13) = -86;
  sub_F180(v28, v13, 0x84ui64);
  result = 0xFFFFFFFFi64;
  if ( v10 == 2 && a5 + 1 >= 2 && (_DWORD)a7 && a9 )
  {
    if ( (unsigned int)(a6 - 1) > 4 )
      v15 = 0i64;
    else
      v15 = qword_8FB28[(signed int)a6 - 1];
    v16 = (a9 + v15 - 1) / v15;
    v30 = a9 % v15;
    sub_1B930(v27, v9, a5);
    sub_F1B0(a8, a9);
    if ( (signed int)v16 > 0 )
    {
      v32 = (unsigned int)v16;
      v33 = (signed int)v16;
      v31 = a5 + 4;
      v17 = 0i64;
      do
      {
        v18 = v17++;
        v19 = 24;
        v20 = 0i64;
        do
        {
          v27[a5 + v20++] = (unsigned int)v17 >> v19;
          v19 -= 8;
        }
        while ( v20 != 4 );
        v21 = v15 * v18;
        v22 = v15;
        if ( v17 == v32 )
          v22 = v30;
        v29 = v22;
        sub_19D9D(a6, v35, v34, (__int64)v27, v31, (__int64)&v25);
        sub_1B930(v28, &v25, v15);
        if ( (unsigned int)a7 >= 2 )
        {
          v23 = 1;
          do
          {
            sub_19D9D(a6, v35, v34, (__int64)&v25, v15, (__int64)v26);
            sub_1B930(&v25, v26, v15);
            if ( v15 )
            {
              v24 = 0i64;
              do
              {
                v28[v24] ^= v26[v24];
                ++v24;
              }
              while ( v15 != v24 );
            }
            ++v23;
          }
          while ( v23 != (_DWORD)a7 );
        }
        sub_1B930((char *)(a8 + v21), v28, v29);
      }
      while ( v17 < v33 );
    }
    sub_F1B0(&v25, 132i64);
    sub_F1B0(v26, 132i64);
    sub_F1B0(v28, 132i64);
    sub_F1B0(v27, 132i64);
    result = 0i64;
  }
  return result;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 8FB28: using guessed type __int64 qword_8FB28[5];
// 19DBC: using guessed type char var_220[144];
// 19DBC: using guessed type char var_190[144];
// 19DBC: using guessed type char var_100[144];

//----- (000000000001A042) ----------------------------------------------------
signed __int64 __usercall sub_1A042@<rax>(__int64 a1@<rdx>, unsigned int *a2@<r9>, __m128i *a3@<xmm1>, __m128i *a4@<xmm2>, __m128i *a5@<xmm6>, __m128i *a6@<xmm7>, __int64 a7, char *a8, unsigned __int64 a9, __int64 a10, unsigned __int64 *a11)
{
  __int64 v11; // rdi
  __int64 v12; // r8

  v11 = 0i64;
  v12 = 0i64;
  do
    v12 = (v12 << 8) | *(unsigned __int8 *)(a1 + v11++);
  while ( v11 != 8 );
  return sub_1959F(a7, a2, v12, a8, a3, a4, a5, a6, a9, a10, a11);
}

//----- (000000000001A0A1) ----------------------------------------------------
signed __int64 __fastcall sub_1A0A1(__int64 a1, __int64 a2)
{
  return sub_1980F(a2);
}

//----- (000000000001A0B0) ----------------------------------------------------
signed __int64 __fastcall sub_1A0B0(__int64 a1, int a2)
{
  signed __int64 result; // rax
  int v3; // esi
  __int64 v4; // rdi
  __int64 *v5; // rbx

  result = 8i64;
  v3 = a2;
  v4 = a1;
  v5 = &qword_92700;
  do
  {
    if ( v4 & result )
    {
      if ( v3 == 1 )
      {
        if ( *((_BYTE *)v5 - 8) )
        {
          ((void (__fastcall *)(signed __int64))*(v5 - 3))(1i64);
          *((_BYTE *)v5 - 8) = 0;
        }
      }
      else if ( !v3 && !*((_BYTE *)v5 - 8) && ((__int64 (__fastcall *)(_QWORD))*(v5 - 3))(0i64) >= 0 )
      {
        *((_BYTE *)v5 - 8) = 1;
      }
    }
    result = *v5;
    v5 += 4;
  }
  while ( result );
  return result;
}
// 92700: using guessed type __int64 qword_92700;

//----- (000000000001A11E) ----------------------------------------------------
void sub_1A11E()
{
  ;
}

//----- (000000000001A127) ----------------------------------------------------
void sub_1A127(__int64 a1, __int64 a2, ...)
{
  va_list v2; // [rsp+20h] [rbp-20h]
  __int64 v3; // [rsp+28h] [rbp-18h]
  __int64 v4; // [rsp+30h] [rbp-10h]
  va_list va; // [rsp+60h] [rbp+20h]

  va_start(va, a2);
  v3 = -6148914691236517206i64;
  v4 = -6148914691236517206i64;
  va_copy(v2, va);
  sub_17D9C(a2, (void (__fastcall *)(signed __int64, __int64))sub_1A1D3, a1, (unsigned __int64 **)&v2);
}

//----- (000000000001A171) ----------------------------------------------------
_BYTE *__fastcall sub_1A171(_QWORD *a1)
{
  _BYTE *result; // rax
  _QWORD *v2; // r14
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 *v5; // rsi
  bool v6; // zf

  result = (_BYTE *)a1[1];
  if ( (unsigned __int64)result > *a1 )
  {
    v2 = a1;
    *result = 0;
    v3 = *a1;
    v4 = a1[1] - *a1;
    v5 = &qword_92700;
    do
    {
      if ( *((_BYTE *)v5 - 8) )
        result = (_BYTE *)((__int64 (__fastcall *)(__int64, __int64))*(v5 - 2))(v3, v4);
      v6 = *v5 == 0;
      v5 += 4;
    }
    while ( !v6 );
    v2[1] = *v2;
  }
  return result;
}
// 92700: using guessed type __int64 qword_92700;

//----- (000000000001A1D3) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_BYTE *__fastcall sub_1A1D3(int a1, _QWORD *a2)
{
  _QWORD *v2; // rsi
  char v3; // di
  signed __int64 v4; // rbx
  _BYTE *result; // rax
  __int16 v6; // [rsp+20h] [rbp-30h]
  int v7; // [rsp+22h] [rbp-2Eh]
  __int16 v8; // [rsp+26h] [rbp-2Ah]
  __int64 v9; // [rsp+28h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  v6 = -21846;
  v7 = -1431655766;
  v8 = -21846;
  v9 = -6148914691236517206i64;
  if ( byte_94EF8 == 1 )
    byte_94EF8 = 0;
  if ( a1 == 10 )
  {
    sub_1A1D3(13i64, a2);
    byte_94EF8 = 1;
  }
  else if ( a1 == 9 )
  {
    v4 = -4i64;
    do
    {
      sub_1A1D3(32i64, v2);
      ++v4;
    }
    while ( v4 );
  }
  result = (_BYTE *)v2[1];
  if ( result == (_BYTE *)(v2[2] - 1i64) )
  {
    sub_1A171(v2);
    result = (_BYTE *)v2[1];
  }
  *result = v3;
  ++v2[1];
  return result;
}
// 1A20F: write access to const memory at 94EF8 has been detected
// 1A281: write access to const memory at 94EF8 has been detected
// 94EF8: using guessed type char byte_94EF8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001A2B6) ----------------------------------------------------
_BYTE *__fastcall sub_1A2B6(char a1, __int64 a2, __int64 a3, __int64 a4)
{
  _BYTE *result; // rax
  __int64 *v5; // [rsp+20h] [rbp-20h]
  __int64 v6; // [rsp+28h] [rbp-18h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  __int64 v8; // [rsp+60h] [rbp+20h]
  __int64 v9; // [rsp+68h] [rbp+28h]

  v8 = a3;
  v9 = a4;
  result = (_BYTE *)-6148914691236517206i64;
  v5 = (__int64 *)-6148914691236517206i64;
  v6 = -6148914691236517206i64;
  v7 = -6148914691236517206i64;
  if ( a1 & 1 )
  {
    v5 = &v8;
    result = sub_1A301(a2, (unsigned __int64 **)&v5);
  }
  return result;
}
// 92420: using guessed type __int64 qword_92420;

//----- (000000000001A301) ----------------------------------------------------
_BYTE *__fastcall sub_1A301(__int64 a1, unsigned __int64 **a2)
{
  unsigned __int64 **v2; // r14
  __int64 v3; // rdi
  char v5; // [rsp+20h] [rbp-D0h]
  char v6; // [rsp+B5h] [rbp-3Bh]
  char *v7; // [rsp+B8h] [rbp-38h]
  char *v8; // [rsp+C0h] [rbp-30h]
  char *v9; // [rsp+C8h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  LOBYTE(a2) = -86;
  sub_F180(&v5, (int)a2, 0x95ui64);
  v7 = &v5;
  v8 = &v5;
  v9 = &v6;
  sub_17D9C(v3, (void (__fastcall *)(signed __int64, __int64))sub_1A1D3, (__int64)&v7, v2);
  return sub_1A171(&v7);
}

//----- (000000000001A36C) ----------------------------------------------------
_BYTE *sub_1A36C(__int64 a1, ...)
{
  va_list v2; // [rsp+20h] [rbp-20h]
  __int64 v3; // [rsp+28h] [rbp-18h]
  __int64 v4; // [rsp+30h] [rbp-10h]
  va_list va; // [rsp+58h] [rbp+18h]

  va_start(va, a1);
  v3 = -6148914691236517206i64;
  v4 = -6148914691236517206i64;
  va_copy(v2, va);
  return sub_1A301(a1, (unsigned __int64 **)&v2);
}

//----- (000000000001A3A7) ----------------------------------------------------
__int64 __fastcall sub_1A3A7(int a1)
{
  if ( !a1 )
    sub_21A08();
  return 0i64;
}

//----- (000000000001A3C0) ----------------------------------------------------
signed __int64 __fastcall sub_1A3C0(__int64 a1, unsigned __int8 a2)
{
  return sub_219D7(a1, a2);
}

//----- (000000000001A3CA) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_1A3CA(int a1)
{
  if ( a1 == 1 && qword_96C08 )
  {
    sub_136C5(qword_96C08);
    qword_96C08 = 0i64;
  }
  return 0i64;
}
// 1A3E8: write access to const memory at 96C08 has been detected
// 96C08: using guessed type __int64 qword_96C08;

//----- (000000000001A3FB) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_1A3FB(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rcx
  unsigned __int64 v6; // rax
  char *v7; // rbx
  __int64 v8; // rax
  __int64 v9; // r14
  __int64 v10; // rax

  if ( a1 )
  {
    v2 = a2;
    if ( a2 )
    {
      v3 = a1;
      v4 = qword_96C08;
      if ( qword_96C08 )
      {
        v5 = qword_96C10;
        v6 = qword_96C18;
      }
      else
      {
        if ( !qword_96CD8 )
          return;
        v10 = sub_1364F(0x8000i64);
        v5 = v10;
        qword_96C08 = v10;
        qword_96C10 = v10;
        v6 = v10 + 0x8000;
        qword_96C18 = v6;
        v4 = v5;
        if ( !v5 )
          return;
      }
      if ( v5 + v2 > v6 )
      {
        v7 = (char *)sub_1000
           + v5
           + v2
           + ~v4
           - ((unsigned __int64)sub_1000 + v5 + v2 + ~v4) % (unsigned __int64)sub_1000;
        v8 = sub_1364F((__int64)v7);
        if ( !v8 )
          return;
        v9 = v8;
        (*(void (__fastcall **)(__int64, __int64, __int64))(qword_96CD8 + 352))(
          v8,
          qword_96C08,
          qword_96C10 - qword_96C08);
        qword_96C10 = v9 + qword_96C10 - qword_96C08;
        qword_96C18 = (__int64)&v7[v9];
        sub_136C5(qword_96C08);
        qword_96C08 = v9;
        v5 = qword_96C10;
      }
      (*(void (__fastcall **)(__int64, __int64, __int64))(qword_96CD8 + 352))(v5, v3, v2);
      qword_96C10 += v2;
    }
  }
}
// 1A4AB: write access to const memory at 96C10 has been detected
// 1A4B5: write access to const memory at 96C18 has been detected
// 1A4C1: write access to const memory at 96C08 has been detected
// 1A4E2: write access to const memory at 96C10 has been detected
// 1A50D: write access to const memory at 96C08 has been detected
// 1A514: write access to const memory at 96C10 has been detected
// 1A525: write access to const memory at 96C18 has been detected
// 96C08: using guessed type __int64 qword_96C08;
// 96C10: using guessed type __int64 qword_96C10;
// 96C18: using guessed type __int64 qword_96C18;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000001A53A) ----------------------------------------------------
__int64 sub_1A53A()
{
  return 0i64;
}

//----- (000000000001A542) ----------------------------------------------------
__int64 __fastcall sub_1A542(unsigned __int8 *a1)
{
  unsigned __int8 *v1; // rsi
  __int64 result; // rax
  __int64 v3; // rcx
  char v4; // [rsp+20h] [rbp-140h]

  v1 = a1;
  result = sub_F180(&v4, -86, 0x12Aui64);
  if ( qword_96CD0 )
  {
    sub_2394B(v1, &v4);
    result = qword_96CD0;
    v3 = *(_QWORD *)(qword_96CD0 + 64);
    if ( v3 || (v3 = *(_QWORD *)(qword_96CD0 + 80)) != 0 )
      result = (*(__int64 (__fastcall **)(__int64, char *))(v3 + 8))(v3, &v4);
  }
  return result;
}
// 96CD0: using guessed type __int64 qword_96CD0;

//----- (000000000001A5AB) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_1A5AB(int a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+28h] [rbp-8h]

  v2 = -6148914691236517206i64;
  if ( a1 == 1 )
  {
    qword_94F00 = 0i64;
    return 0i64;
  }
  if ( a1 )
    return 0i64;
  result = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92BD0, 0i64, &v2);
  if ( result >= 0 )
    qword_94F00 = v2;
  return result;
}
// 1A5ED: write access to const memory at 94F00 has been detected
// 1A5F6: write access to const memory at 94F00 has been detected
// 92BD0: using guessed type __int64 qword_92BD0[2];
// 94F00: using guessed type __int64 qword_94F00;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000001A609) ----------------------------------------------------
__int64 sub_1A609()
{
  __int64 result; // rax

  result = qword_94F00;
  if ( qword_94F00 )
  {
    result = (*(__int64 (**)(void))(qword_94F00 + 8))();
    if ( !byte_94F09 )
    {
      if ( byte_94F08 & 1 )
        result = (*(__int64 (**)(void))(qword_94F00 + 24))();
    }
  }
  return result;
}
// 94F00: using guessed type __int64 qword_94F00;
// 94F08: using guessed type char byte_94F08;
// 94F09: using guessed type char byte_94F09;

//----- (000000000001A648) ----------------------------------------------------
_BYTE *__fastcall sub_1A648(unsigned int a1)
{
  char *v1; // rsi
  __int16 *v2; // rdi
  __int16 v4; // [rsp+28h] [rbp-28h]
  int v5; // [rsp+2Ah] [rbp-26h]
  __int16 v6; // [rsp+2Eh] [rbp-22h]
  __int64 v7; // [rsp+30h] [rbp-20h]

  v4 = -21846;
  v5 = -1431655766;
  v6 = -21846;
  v7 = -6148914691236517206i64;
  v1 = off_915E0[a1];
  if ( a1 <= 0xA )
  {
    v2 = &v4;
    if ( (*(__int64 (__fastcall **)(__int16 *, _QWORD))(qword_96CE0 + 24))(&v4, 0i64) < 0 )
      v2 = 0i64;
    return sub_1A2B6(1, (__int64)"[EB|#LOG:%s] %t\n", (__int64)v1, (__int64)v2);
  }
  if ( a1 == 11 )
  {
    v2 = 0i64;
    return sub_1A2B6(1, (__int64)"[EB|#LOG:%s] %t\n", (__int64)v1, (__int64)v2);
  }
  return sub_1A2B6(1, (__int64)"[EB|#LOG:%s] (%d) %t\n", (__int64)v1, a1);
}
// 915E0: using guessed type char *off_915E0[13];
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001A6EF) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_1A6EF(unsigned int a1)
{
  unsigned int v1; // er15
  char v2; // r14
  bool v3; // bl
  bool v4; // cf
  bool v5; // zf
  char v6; // al
  __int64 *v7; // rdx
  unsigned __int64 v8; // rdx
  char v9; // si
  __int64 v10; // rcx
  signed __int64 result; // rax
  signed __int64 *v12; // rdi

  v1 = a1;
  v2 = 1;
  switch ( a1 )
  {
    case 0u:
      if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(
             qword_92BD0,
             0i64,
             &qword_94F28) < 0 )
        qword_94F28 = 0i64;
      v6 = sub_1487D();
      byte_94F18 = v6;
      v7 = &qword_923F8;
      if ( !v6 )
        v7 = &qword_923F0;
      v8 = *v7;
      qword_94F20 = v8;
      if ( qword_94F28 )
      {
        LOBYTE(qword_94F10) = qword_94F10 | 0x10;
        if ( v8 >= 4 )
        {
          byte_94F08 = 1;
          if ( v6 )
            (*(void (**)(void))(qword_94F28 + 32))();
        }
      }
      if ( !qword_94F28 )
        LOBYTE(qword_94F10) = qword_94F10 | 1;
      v3 = 0;
      goto LABEL_24;
    case 1u:
      LOBYTE(qword_94F10) = qword_94F10 | 1;
      break;
    case 2u:
    case 4u:
      v3 = qword_94F20 != 0;
      qword_94F10 = 0i64;
      goto LABEL_24;
    case 3u:
      v4 = (unsigned __int64)qword_94F20 < 2;
      v5 = qword_94F20 == 2;
      goto LABEL_17;
    case 5u:
    case 6u:
      v4 = (unsigned __int64)qword_94F20 < 1;
      v5 = qword_94F20 == 1;
LABEL_17:
      v3 = !v4 && !v5;
      qword_94F10 = 0i64;
      goto LABEL_24;
    case 7u:
      v3 = 0;
      v2 = 0;
      goto LABEL_24;
    case 8u:
      sub_1A0B0(qword_94F10, 0);
      byte_94F09 = 0;
      sub_1A648(8u);
      goto LABEL_33;
    case 9u:
      v3 = 0;
      goto LABEL_24;
    case 0xAu:
      v3 = (unsigned __int64)qword_94F20 > 2;
      qword_94F10 = 0i64;
      qword_92418 = 0i64;
      v2 = 1;
      v9 = 1;
      goto LABEL_25;
    case 0xBu:
      qword_94F10 = 0i64;
      break;
    default:
      break;
  }
  v3 = 0;
LABEL_24:
  v9 = 0;
LABEL_25:
  sub_1A0B0(qword_94F10, 0);
  sub_1A648(v1);
  if ( !v2 )
    byte_94F09 = 1;
  v10 = qword_94F28;
  if ( qword_94F28 != 0 && v3 )
  {
    if ( byte_94F18 )
    {
      (*(void (**)(void))(qword_94F28 + 32))();
      v10 = qword_94F28;
    }
    (*(void (**)(void))(v10 + 24))();
  }
  if ( v9 )
    qword_94F28 = 0i64;
LABEL_33:
  result = 8i64;
  v12 = &qword_92700;
  do
  {
    if ( ~qword_94F10 & result )
    {
      if ( *((_BYTE *)v12 - 8) )
      {
        ((void (__fastcall *)(signed __int64))*(v12 - 3))(1i64);
        *((_BYTE *)v12 - 8) = 0;
      }
    }
    result = *v12;
    v12 += 4;
  }
  while ( result );
  return result;
}
// 1A72C: write access to const memory at 94F10 has been detected
// 1A767: write access to const memory at 94F28 has been detected
// 1A777: write access to const memory at 94F18 has been detected
// 1A794: write access to const memory at 94F20 has been detected
// 1A7A7: write access to const memory at 94F10 has been detected
// 1A7B4: write access to const memory at 94F08 has been detected
// 1A7DA: write access to const memory at 94F10 has been detected
// 1A7F9: write access to const memory at 94F10 has been detected
// 1A810: write access to const memory at 94F10 has been detected
// 1A81C: write access to const memory at 94F10 has been detected
// 1A833: write access to const memory at 94F10 has been detected
// 1A85D: write access to const memory at 94F09 has been detected
// 1A89E: write access to const memory at 94F10 has been detected
// 1A8A5: write access to const memory at 92418 has been detected
// 1A8CA: write access to const memory at 94F10 has been detected
// 1A8F2: write access to const memory at 94F09 has been detected
// 1A939: write access to const memory at 94F28 has been detected
// 923F0: using guessed type __int64 qword_923F0;
// 923F8: using guessed type __int64 qword_923F8;
// 92418: using guessed type __int64 qword_92418;
// 92700: using guessed type __int64 qword_92700;
// 92BD0: using guessed type __int64 qword_92BD0[2];
// 94F08: using guessed type char byte_94F08;
// 94F09: using guessed type char byte_94F09;
// 94F10: using guessed type __int64 qword_94F10;
// 94F18: using guessed type char byte_94F18;
// 94F20: using guessed type __int64 qword_94F20;
// 94F28: using guessed type __int64 qword_94F28;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000001A9C4) ----------------------------------------------------
signed __int64 *__fastcall sub_1A9C4(__int64 a1)
{
  __int64 v1; // rdi
  signed __int64 *result; // rax
  signed __int64 *v3; // rsi
  char *v4; // rbx
  __int64 v5; // [rsp+28h] [rbp-28h]
  int v6; // [rsp+34h] [rbp-1Ch]

  v1 = a1;
  v6 = -1431655766;
  v5 = -6148914691236517206i64;
  result = (signed __int64 *)sub_A398();
  if ( result )
  {
    v3 = result;
    if ( v1 )
    {
      v6 = 0;
      v5 = 0i64;
      result = (signed __int64 *)(*(__int64 (__fastcall **)(int *, __int64 *, _QWORD, _QWORD))(v1 + 16))(
                                   &v6,
                                   &v5,
                                   0i64,
                                   0i64);
      if ( (signed __int64)result >= 0 )
      {
        result = (signed __int64 *)sub_1364F(v5);
        if ( result )
        {
          v4 = (char *)result;
          v6 = 0;
          if ( (*(__int64 (__fastcall **)(int *, __int64 *, signed __int64 *, _QWORD))(v1 + 16))(&v6, &v5, result, 0i64) >= 0 )
            sub_9EC7(v3, "efiboot", v5, v4, 1);
          result = (signed __int64 *)sub_136C5((__int64)v4);
        }
      }
    }
    else if ( qword_96C08 < (unsigned __int64)qword_96C10 )
    {
      result = (signed __int64 *)sub_9EC7(result, "efiboot", qword_96C10 - qword_96C08, (char *)qword_96C08, 1);
    }
  }
  return result;
}
// 96C08: using guessed type __int64 qword_96C08;
// 96C10: using guessed type __int64 qword_96C10;

//----- (000000000001AAAE) ----------------------------------------------------
signed __int64 __fastcall sub_1AAAE(_DWORD *a1, char *a2, unsigned int a3)
{
  unsigned int v3; // edi
  char *v4; // r14
  _DWORD *v5; // rbx
  int v6; // ecx
  __int64 v7; // rax
  unsigned int v8; // er15
  char *v9; // rcx
  signed __int64 v10; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *a1;
  v7 = v6 & 0x3F;
  v8 = 64 - v7;
  *v5 = a3 + v6;
  if ( __CFADD__(a3, v6) )
    ++v5[1];
  v9 = (char *)v5 + v7 + 40;
  if ( v8 <= a3 )
  {
    do
    {
      sub_1B930(v9, v4, v8);
      v4 += v8;
      v10 = 25i64;
      do
      {
        v5[v10] = _byteswap_ulong(v5[v10]);
        --v10;
      }
      while ( v10 != 9 );
      v3 -= v8;
      sub_1AB55((__int64)v5);
      v8 = 64;
      v9 = (char *)(v5 + 10);
    }
    while ( v3 > 0x3F );
    v9 = (char *)(v5 + 10);
  }
  sub_1B930(v9, v4, v3);
  return 1i64;
}

//----- (000000000001AB55) ----------------------------------------------------
__int64 __fastcall sub_1AB55(__int64 a1)
{
  _DWORD *v1; // r14
  int v2; // er11
  int v3; // er8
  int v4; // er12
  int v5; // er13
  int v6; // er9
  int v7; // er10
  unsigned __int64 v8; // rdi
  int v9; // er15
  int v10; // edx
  int v11; // eax
  int v12; // eax
  int v13; // er13
  int v14; // edi
  int v15; // eax
  unsigned int v16; // er8
  int v17; // eax
  int v18; // er15
  int v19; // er14
  _DWORD *v20; // rsi
  unsigned int v21; // edi
  int v22; // eax
  int v23; // er9
  int v24; // er12
  _DWORD *v25; // rdi
  unsigned int v26; // esi
  int v27; // eax
  int v28; // er10
  int v29; // er11
  int v30; // edi
  _DWORD *v31; // rsi
  unsigned int v32; // er9
  int v33; // eax
  int v34; // er13
  int v35; // er8
  int v36; // er15
  int v37; // ecx
  int v38; // eax
  unsigned int v39; // er15
  int v40; // ebx
  int v41; // er14
  int v42; // er8
  int v43; // edi
  int v44; // ecx
  int v45; // eax
  int v46; // edi
  int v47; // ebx
  int v48; // er12
  int v49; // er9
  int v50; // ebx
  int v51; // edi
  int v52; // er11
  int v53; // er15
  _DWORD *v54; // rdi
  unsigned int v55; // esi
  _DWORD *v56; // r10
  int v57; // edi
  int v58; // er13
  _DWORD *v59; // rsi
  unsigned int v60; // er10
  int v61; // edx
  int v62; // er8
  _DWORD *v63; // rdi
  unsigned int v64; // esi
  int v65; // edx
  int v66; // er9
  int v67; // er12
  unsigned int v68; // ebx
  __int64 v69; // rdi
  int v70; // eax
  int v71; // er15
  int v72; // er11
  int v73; // er14
  int v74; // eax
  unsigned int v75; // er10
  __int64 v76; // rdi
  int v77; // eax
  int v78; // esi
  unsigned int v79; // ebx
  int v80; // eax
  unsigned int v81; // ebx
  int v82; // eax
  __int64 result; // rax
  __int64 v84; // [rsp+20h] [rbp-A0h]
  __int64 v85; // [rsp+28h] [rbp-98h]
  __int64 v86; // [rsp+30h] [rbp-90h]
  __int64 v87; // [rsp+38h] [rbp-88h]
  unsigned int v88; // [rsp+48h] [rbp-78h]
  unsigned int v89; // [rsp+4Ch] [rbp-74h]
  unsigned int v90; // [rsp+50h] [rbp-70h]
  unsigned int v91; // [rsp+54h] [rbp-6Ch]
  unsigned int v92; // [rsp+58h] [rbp-68h]
  unsigned int v93; // [rsp+5Ch] [rbp-64h]
  unsigned int v94; // [rsp+60h] [rbp-60h]
  unsigned int v95; // [rsp+64h] [rbp-5Ch]
  unsigned __int64 v96; // [rsp+68h] [rbp-58h]
  int v97; // [rsp+74h] [rbp-4Ch]
  _DWORD *v98; // [rsp+78h] [rbp-48h]
  unsigned int v99; // [rsp+84h] [rbp-3Ch]

  v1 = (_DWORD *)a1;
  v84 = -6148914691236517206i64;
  v85 = -6148914691236517206i64;
  v86 = -6148914691236517206i64;
  v87 = -6148914691236517206i64;
  sub_1B930((char *)&v84, (char *)(a1 + 8), 0x20ui64);
  v2 = v86;
  v3 = v87;
  v4 = HIDWORD(v86);
  v99 = HIDWORD(v87);
  v5 = HIDWORD(v85);
  v6 = HIDWORD(v84);
  v7 = v84;
  v8 = 0i64;
  v9 = v85;
  v98 = v1;
  do
  {
    v96 = v8;
    if ( v8 )
    {
      v8 = v96;
      v10 = (__ROL4__(v1[11], 25) ^ __ROL4__(v1[11], 14) ^ (v1[11] >> 3))
          + (__ROL4__(v1[24], 15) ^ __ROL4__(v1[24], 13) ^ (v1[24] >> 10))
          + v1[19]
          + v1[10];
      v1[10] = v10;
    }
    else
    {
      v10 = v1[10];
    }
    v11 = *((_DWORD *)qword_8FB90 + v8);
    v93 = v10;
    v12 = v99 + v10 + v11 + (__ROL4__(v2, 26) ^ __ROL4__(v2, 21) ^ __ROL4__(v2, 7)) + (v3 ^ v2 & (v3 ^ v4));
    v13 = v12 + v5;
    v99 = (__ROL4__(v7, 30) ^ __ROL4__(v7, 19) ^ __ROL4__(v7, 10)) + v12 + (v7 & v6 | v9 & (v7 ^ v6));
    if ( v8 )
    {
      v14 = (__ROL4__(v1[12], 25) ^ __ROL4__(v1[12], 14) ^ (v1[12] >> 3))
          + (__ROL4__(v1[25], 15) ^ __ROL4__(v1[25], 13) ^ (v1[25] >> 10))
          + v1[20]
          + v1[11];
      v1[11] = v14;
    }
    else
    {
      v14 = v1[11];
    }
    v15 = v3 + (v4 ^ v13 & (v2 ^ v4));
    v16 = v99;
    v95 = v14;
    v17 = *((_DWORD *)qword_8FB90 + v96 + 1) + v14 + (__ROL4__(v13, 26) ^ __ROL4__(v13, 21) ^ __ROL4__(v13, 7)) + v15;
    v18 = v17 + v9;
    v19 = v17 + (__ROL4__(v99, 30) ^ __ROL4__(v99, 19) ^ __ROL4__(v99, 10)) + (v7 & v99 | v6 & (v7 ^ v99));
    if ( v96 )
    {
      v20 = v98;
      v21 = (__ROL4__(v98[13], 25) ^ __ROL4__(v98[13], 14) ^ (v98[13] >> 3))
          + (__ROL4__(v93, 15) ^ __ROL4__(v93, 13) ^ (v93 >> 10))
          + v98[21]
          + v98[12];
      v98[12] = v21;
    }
    else
    {
      v20 = v98;
      v21 = v98[12];
    }
    v22 = *((_DWORD *)&qword_8FB90[1] + v96)
        + v21
        + (__ROL4__(v18, 26) ^ __ROL4__(v18, 21) ^ __ROL4__(v18, 7))
        + v4
        + (v2 ^ v18 & (v2 ^ v13));
    v23 = v22 + v6;
    v24 = v22 + (__ROL4__(v19, 30) ^ __ROL4__(v19, 19) ^ __ROL4__(v19, 10)) + (v16 & v19 | v7 & (v16 ^ v19));
    v94 = v21;
    if ( v96 )
    {
      v25 = v20;
      v26 = (__ROL4__(v20[14], 25) ^ __ROL4__(v20[14], 14) ^ (v20[14] >> 3))
          + (__ROL4__(v95, 15) ^ __ROL4__(v95, 13) ^ (v95 >> 10))
          + v20[22]
          + v20[13];
      v25[13] = v26;
    }
    else
    {
      v26 = v20[13];
    }
    v88 = v26;
    v27 = *((_DWORD *)&qword_8FB90[1] + v96 + 1)
        + v26
        + (__ROL4__(v23, 26) ^ __ROL4__(v23, 21) ^ __ROL4__(v23, 7))
        + v2
        + (v13 ^ v23 & (v13 ^ v18));
    v28 = v27 + v7;
    v29 = v27 + (__ROL4__(v24, 30) ^ __ROL4__(v24, 19) ^ __ROL4__(v24, 10)) + (v19 & v24 | v16 & (v19 ^ v24));
    v30 = v23;
    if ( v96 )
    {
      v31 = v98;
      v32 = (__ROL4__(v98[15], 25) ^ __ROL4__(v98[15], 14) ^ (v98[15] >> 3))
          + (__ROL4__(v94, 15) ^ __ROL4__(v94, 13) ^ (v94 >> 10))
          + v98[23]
          + v98[14];
      v98[14] = v32;
    }
    else
    {
      v31 = v98;
      v32 = v98[14];
    }
    v33 = *((_DWORD *)&qword_8FB90[2] + v96)
        + v32
        + (__ROL4__(v28, 26) ^ __ROL4__(v28, 21) ^ __ROL4__(v28, 7))
        + v13
        + (v18 ^ v28 & (v18 ^ v30));
    v99 = v33 + v16;
    v34 = v33 + (__ROL4__(v29, 30) ^ __ROL4__(v29, 19) ^ __ROL4__(v29, 10)) + (v24 & v29 | v19 & (v24 ^ v29));
    v35 = v18;
    if ( v96 )
    {
      v36 = v31[15];
      v37 = __ROL4__(v31[16], 25);
      v38 = __ROL4__(v31[16], 14) ^ (v31[16] >> 3);
      v31 = v98;
      v39 = (v37 ^ v38) + (__ROL4__(v88, 15) ^ __ROL4__(v88, 13) ^ (v88 >> 10)) + v98[24] + v36;
      v98[15] = v39;
    }
    else
    {
      v39 = v31[15];
    }
    v97 = v30;
    v40 = *((_DWORD *)&qword_8FB90[2] + v96 + 1)
        + v39
        + (__ROL4__(v99, 26) ^ __ROL4__(v99, 21) ^ __ROL4__(v99, 7))
        + v35
        + (v30 ^ v99 & (v30 ^ v28));
    v41 = v40 + v19;
    v42 = v40 + (__ROL4__(v34, 30) ^ __ROL4__(v34, 19) ^ __ROL4__(v34, 10)) + (v29 & v34 | v24 & (v29 ^ v34));
    v91 = v32;
    if ( v96 )
    {
      v43 = v31[16];
      v44 = __ROL4__(v31[17], 25);
      v45 = __ROL4__(v31[17], 14) ^ (v31[17] >> 3);
      v31 = v98;
      v46 = (v44 ^ v45) + (__ROL4__(v32, 15) ^ __ROL4__(v32, 13) ^ (v32 >> 10)) + v98[25] + v43;
      v98[16] = v46;
    }
    else
    {
      v46 = v31[16];
    }
    v89 = v46;
    v47 = *((_DWORD *)&qword_8FB90[3] + v96)
        + v46
        + (__ROL4__(v41, 26) ^ __ROL4__(v41, 21) ^ __ROL4__(v41, 7))
        + v97
        + (v28 ^ v41 & (v28 ^ v99));
    v48 = v47 + v24;
    v49 = v47 + (__ROL4__(v42, 30) ^ __ROL4__(v42, 19) ^ __ROL4__(v42, 10)) + (v34 & v42 | v29 & (v34 ^ v42));
    v92 = v39;
    if ( v96 )
    {
      v31 = v98;
      v50 = (__ROL4__(v98[18], 25) ^ __ROL4__(v98[18], 14) ^ (v98[18] >> 3))
          + (__ROL4__(v39, 15) ^ __ROL4__(v39, 13) ^ (v39 >> 10))
          + v93
          + v98[17];
      v98[17] = v50;
    }
    else
    {
      v50 = v31[17];
    }
    v51 = *((_DWORD *)&qword_8FB90[3] + v96 + 1)
        + v50
        + (__ROL4__(v48, 26) ^ __ROL4__(v48, 21) ^ __ROL4__(v48, 7))
        + v28
        + (v99 ^ v48 & (v99 ^ v41));
    v52 = v51 + v29;
    v53 = v51 + (__ROL4__(v49, 30) ^ __ROL4__(v49, 19) ^ __ROL4__(v49, 10)) + (v42 & v49 | v34 & (v42 ^ v49));
    v90 = v50;
    if ( v96 )
    {
      v54 = v31;
      v55 = (__ROL4__(v31[19], 25) ^ __ROL4__(v31[19], 14) ^ (v31[19] >> 3))
          + (__ROL4__(v89, 15) ^ __ROL4__(v89, 13) ^ (v89 >> 10))
          + v31[18]
          + v95;
      v56 = v54;
      v54[18] = v55;
    }
    else
    {
      v56 = v31;
      v55 = v31[18];
    }
    v95 = v55;
    v57 = *((_DWORD *)&qword_8FB90[4] + v96)
        + v55
        + (__ROL4__(v52, 26) ^ __ROL4__(v52, 21) ^ __ROL4__(v52, 7))
        + v99
        + (v41 ^ v52 & (v41 ^ v48));
    v58 = v57 + v34;
    v99 = v57 + (__ROL4__(v53, 30) ^ __ROL4__(v53, 19) ^ __ROL4__(v53, 10)) + (v49 & v53 | v42 & (v49 ^ v53));
    if ( v96 )
    {
      v59 = v56;
      v60 = (__ROL4__(v56[20], 25) ^ __ROL4__(v56[20], 14) ^ (v56[20] >> 3))
          + (__ROL4__(v90, 15) ^ __ROL4__(v90, 13) ^ (v90 >> 10))
          + v56[19]
          + v94;
      v59[19] = v60;
    }
    else
    {
      v59 = v56;
      v60 = v56[19];
    }
    v94 = v60;
    v61 = *((_DWORD *)&qword_8FB90[4] + v96 + 1)
        + v60
        + (__ROL4__(v58, 26) ^ __ROL4__(v58, 21) ^ __ROL4__(v58, 7))
        + v41
        + (v48 ^ v58 & (v48 ^ v52));
    v62 = v61 + v42;
    v97 = v61 + (__ROL4__(v99, 30) ^ __ROL4__(v99, 19) ^ __ROL4__(v99, 10)) + (v53 & v99 | v49 & (v53 ^ v99));
    if ( v96 )
    {
      v63 = v59;
      v64 = (__ROL4__(v59[21], 25) ^ __ROL4__(v59[21], 14) ^ (v59[21] >> 3))
          + (__ROL4__(v95, 15) ^ __ROL4__(v95, 13) ^ (v95 >> 10))
          + v59[20]
          + v88;
      v63[20] = v64;
    }
    else
    {
      v64 = v59[20];
    }
    v65 = *((_DWORD *)&qword_8FB90[5] + v96)
        + v64
        + (__ROL4__(v62, 26) ^ __ROL4__(v62, 21) ^ __ROL4__(v62, 7))
        + v48
        + (v52 ^ v62 & (v52 ^ v58));
    v66 = v65 + v49;
    v67 = v65 + (__ROL4__(v97, 30) ^ __ROL4__(v97, 19) ^ __ROL4__(v97, 10)) + (v99 & v97 | v53 & (v99 ^ v97));
    if ( v96 )
    {
      v68 = (__ROL4__(v98[22], 25) ^ __ROL4__(v98[22], 14) ^ (v98[22] >> 3))
          + (__ROL4__(v94, 15) ^ __ROL4__(v94, 13) ^ (v94 >> 10))
          + v98[21]
          + v91;
      v98[21] = v68;
    }
    else
    {
      v68 = v98[21];
    }
    v91 = v68;
    v69 = v96;
    v70 = *((_DWORD *)&qword_8FB90[5] + v96 + 1)
        + v68
        + (__ROL4__(v66, 26) ^ __ROL4__(v66, 21) ^ __ROL4__(v66, 7))
        + v52
        + (v58 ^ v66 & (v58 ^ v62));
    v71 = v70 + v53;
    v72 = v70 + (__ROL4__(v67, 30) ^ __ROL4__(v67, 19) ^ __ROL4__(v67, 10)) + (v97 & v67 | v99 & (v97 ^ v67));
    if ( v96 )
    {
      v73 = (__ROL4__(v98[23], 25) ^ __ROL4__(v98[23], 14) ^ (v98[23] >> 3))
          + (__ROL4__(v64, 15) ^ __ROL4__(v64, 13) ^ (v64 >> 10))
          + v98[22]
          + v92;
      v98[22] = v73;
    }
    else
    {
      v73 = v98[22];
    }
    v92 = v73;
    v74 = *((_DWORD *)&qword_8FB90[6] + v69)
        + v73
        + (__ROL4__(v71, 26) ^ __ROL4__(v71, 21) ^ __ROL4__(v71, 7))
        + v58
        + (v62 ^ v71 & (v62 ^ v66));
    v99 += v74;
    v5 = v74 + (__ROL4__(v72, 30) ^ __ROL4__(v72, 19) ^ __ROL4__(v72, 10)) + (v67 & v72 | v97 & (v67 ^ v72));
    if ( v69 )
    {
      v1 = v98;
      v75 = (__ROL4__(v98[24], 25) ^ __ROL4__(v98[24], 14) ^ (v98[24] >> 3))
          + (__ROL4__(v91, 15) ^ __ROL4__(v91, 13) ^ (v91 >> 10))
          + v98[23]
          + v89;
      v98[23] = v75;
    }
    else
    {
      v1 = v98;
      v75 = v98[23];
    }
    v76 = v96;
    v77 = *((_DWORD *)&qword_8FB90[6] + v96 + 1)
        + v75
        + (__ROL4__(v99, 26) ^ __ROL4__(v99, 21) ^ __ROL4__(v99, 7))
        + v62
        + (v66 ^ v99 & (v66 ^ v71));
    v3 = v77 + v97;
    v78 = v77 + (__ROL4__(v5, 30) ^ __ROL4__(v5, 19) ^ __ROL4__(v5, 10)) + (v72 & v5 | v67 & (v72 ^ v5));
    if ( v96 )
    {
      v79 = (__ROL4__(v1[25], 25) ^ __ROL4__(v1[25], 14) ^ (v1[25] >> 3))
          + (__ROL4__(v92, 15) ^ __ROL4__(v92, 13) ^ (v92 >> 10))
          + v1[24]
          + v90;
      v1[24] = v79;
    }
    else
    {
      v79 = v1[24];
    }
    v80 = *((_DWORD *)&qword_8FB90[7] + v76)
        + v79
        + (__ROL4__(v3, 26) ^ __ROL4__(v3, 21) ^ __ROL4__(v3, 7))
        + v66
        + (v71 ^ v3 & (v71 ^ v99));
    v4 = v80 + v67;
    v6 = v80 + (__ROL4__(v78, 30) ^ __ROL4__(v78, 19) ^ __ROL4__(v78, 10)) + (v5 & v78 | v72 & (v5 ^ v78));
    if ( v76 )
    {
      v81 = (__ROL4__(v93, 25) ^ __ROL4__(v93, 14) ^ (v93 >> 3))
          + (__ROL4__(v75, 15) ^ __ROL4__(v75, 13) ^ (v75 >> 10))
          + v1[25]
          + v95;
      v1[25] = v81;
    }
    else
    {
      v81 = v1[25];
    }
    v82 = *((_DWORD *)&qword_8FB90[7] + v76 + 1)
        + v81
        + (__ROL4__(v4, 26) ^ __ROL4__(v4, 21) ^ __ROL4__(v4, 7))
        + v71
        + (v99 ^ v4 & (v99 ^ v3));
    v2 = v82 + v72;
    v9 = v78;
    v7 = v82 + (__ROL4__(v6, 30) ^ __ROL4__(v6, 19) ^ __ROL4__(v6, 10)) + (v78 & v6 | v5 & (v78 ^ v6));
    v8 = v76 + 16;
  }
  while ( v8 < 0x40 );
  v1[2] += v7;
  v1[3] += v6;
  v1[4] += v78;
  v1[5] += v5;
  v1[6] += v2;
  v1[7] += v4;
  v1[8] += v3;
  result = v99;
  v1[9] += v99;
  return result;
}
// 8FB90: using guessed type __int64 qword_8FB90[32];

//----- (000000000001B757) ----------------------------------------------------
__int64 __fastcall sub_1B757(__int64 a1, int *a2, unsigned int a3)
{
  unsigned int v3; // er14
  int *v4; // rsi
  __int64 v5; // r15
  int v6; // ecx
  unsigned int v7; // er8
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rdx
  __int64 v11; // rdx
  unsigned int v12; // edx
  __int64 v13; // rax
  int v14; // eax
  __int64 result; // rax
  int v16; // edx
  __int64 v17; // rbx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *a2;
  v7 = *a2 & 0x3F;
  v8 = v7 + 3i64;
  if ( v8 & 0x7C )
  {
    v9 = v8 >> 2;
    v10 = v9;
    do
    {
      v4[v9 + 9] = _byteswap_ulong(v4[v9 + 9]);
      v9 = --v10;
    }
    while ( v10 );
  }
  v11 = v7 >> 2;
  v4[v11 + 10] = v4[v11 + 10] & (-128 << (~(8 * v6) & 0x18)) | (128 << (~(8 * v6) & 0x18));
  if ( v7 < 0x38 )
  {
    v12 = v11 + 1;
    if ( v12 > 0xD )
      goto LABEL_11;
  }
  else
  {
    if ( v7 <= 0x3B )
      v4[25] = 0;
    sub_1AB55((__int64)v4);
    v12 = 0;
  }
  v13 = v12;
  do
    v4[v13++ + 10] = 0;
  while ( v13 != 14 );
LABEL_11:
  v14 = *v4;
  v4[24] = *(_QWORD *)v4 >> 29;
  v4[25] = 8 * v14;
  result = sub_1AB55((__int64)v4);
  if ( v3 )
  {
    result = v3;
    v16 = 0;
    v17 = 0i64;
    do
    {
      *(_BYTE *)(v5 + v17) = *(unsigned int *)((char *)v4 + ((unsigned int)v17 & 0xFFFFFFFC) + 8) >> (~(_BYTE)v16 & 0x18);
      ++v17;
      v16 += 8;
    }
    while ( v3 != v17 );
  }
  return result;
}

//----- (000000000001B84F) ----------------------------------------------------
signed __int64 __fastcall sub_1B84F(__int64 a1)
{
  *(_QWORD *)a1 = 0i64;
  sub_1B930((char *)(a1 + 8), (char *)qword_8FB70, 0x20ui64);
  return 1i64;
}
// 8FB70: using guessed type __int64 qword_8FB70[4];

//----- (000000000001B87F) ----------------------------------------------------
signed __int64 __fastcall sub_1B87F(__int64 a1, int *a2)
{
  sub_1B757(a1, a2, 0x20u);
  return 1i64;
}

//----- (000000000001B89D) ----------------------------------------------------
__int64 __fastcall sub_1B89D(char *a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rsi
  char *v4; // rbx
  char *v5; // rdi
  signed __int64 i; // rcx
  unsigned int v7; // er14
  int v9[2]; // [rsp+28h] [rbp-88h]
  char v10; // [rsp+30h] [rbp-80h]

  v3 = a3;
  v4 = a1;
  v5 = (char *)v9;
  for ( i = 26i64; i; --i )
  {
    *(_DWORD *)v5 = -1431655766;
    v5 += 4;
  }
  if ( a3 )
  {
    v7 = a2;
    *(_QWORD *)v9 = 0i64;
    sub_1B930(&v10, (char *)qword_8FB70, 0x20ui64);
    sub_1AAAE(v9, v4, v7);
    sub_1B757(v3, v9, 0x20u);
  }
  return v3;
}
// 8FB70: using guessed type __int64 qword_8FB70[4];

//----- (000000000001B930) ----------------------------------------------------
char *__fastcall sub_1B930(char *a1, char *a2, unsigned __int64 a3)
{
  qmemcpy(a1, a2, 8 * (a3 >> 3));
  qmemcpy(&a1[8 * (a3 >> 3)], &a2[8 * (a3 >> 3)], a3 & 7);
  return a1;
}

//----- (000000000001B950) ----------------------------------------------------
char *__fastcall sub_1B950(char *a1, char *a2, unsigned __int64 a3)
{
  char *v3; // rsi
  char *result; // rax
  unsigned __int64 v5; // rcx
  char *v6; // rdi
  char *v7; // rsi

  v3 = a1;
  result = a2;
  if ( a1 < a2 && &a1[a3 - 1] >= a2 )
  {
    v7 = &a1[a3 - 1];
    v6 = &a2[a3 - 1];
  }
  else
  {
    v5 = a3;
    a3 &= 7u;
    v5 >>= 3;
    qmemcpy(a2, v3, 8 * v5);
    v7 = &v3[8 * v5];
    v6 = &a2[8 * v5];
  }
  qmemcpy(v6, v7, a3);
  return result;
}

//----- (000000000001B98C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_1B98C()
{
  __int64 v0; // rax
  __int64 v2; // [rsp+28h] [rbp-8h]

  v2 = 0i64;
  if ( !byte_94F30 )
  {
    v2 = 4i64;
    v0 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
           L"csr-active-config",
           qword_92360,
           0i64);
    if ( v0 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`CSR:S] %r @ GV %S\n", v0, (__int64)L"csr-active-config");
    }
    else
    {
      sub_1A2B6(1, (__int64)"[EB|`CSR:S] %S = 0x%08X\n", (__int64)L"csr-active-config", (unsigned int)dword_94F34);
      byte_94F30 = 1;
    }
  }
  return dword_94F34 & 0x40;
}
// 1B9FB: write access to const memory at 94F30 has been detected
// 41154: using guessed type __int16 aCsrActiveConfi[18];
// 92360: using guessed type __int64 qword_92360[2];
// 94F30: using guessed type char byte_94F30;
// 94F34: using guessed type int dword_94F34;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001BA2E) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_1BA2E()
{
  __int64 v0; // rax
  __int64 v2; // [rsp+28h] [rbp-8h]

  v2 = 0i64;
  if ( !byte_94F30 )
  {
    v2 = 4i64;
    v0 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
           L"csr-active-config",
           qword_92360,
           0i64);
    if ( v0 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`CSR:R] %r @ GV %S\n", v0, (__int64)L"csr-active-config");
    }
    else
    {
      sub_1A2B6(1, (__int64)"[EB|`CSR:R] %S = 0x%08X\n", (__int64)L"csr-active-config", (unsigned int)dword_94F34);
      byte_94F30 = 1;
    }
  }
  return dword_94F34 & 0x100;
}
// 1BA9D: write access to const memory at 94F30 has been detected
// 41154: using guessed type __int16 aCsrActiveConfi[18];
// 92360: using guessed type __int64 qword_92360[2];
// 94F30: using guessed type char byte_94F30;
// 94F34: using guessed type int dword_94F34;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001BAD2) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_BYTE *__fastcall sub_1BAD2(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rsi
  __int64 v5; // rax
  __int64 v6; // r9
  __int64 v7; // r8
  __int64 v9; // [rsp+30h] [rbp-10h]

  v4 = a1;
  v9 = 0i64;
  if ( !byte_94F30 )
  {
    v9 = 4i64;
    v5 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
           L"csr-active-config",
           qword_92360,
           0i64);
    if ( v5 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`CSR:F] %r @ GV %S\n", v5, (__int64)L"csr-active-config");
      if ( !byte_94F30 )
      {
        v7 = *(unsigned int *)(v4 + 1176);
        return sub_1A2B6(1, (__int64)"[EB|#CSR:OUT] 0x%08X\n", v7, a4);
      }
    }
    else
    {
      sub_1A2B6(1, (__int64)"[EB|#CSR:IN] 0x%08X\n", (unsigned int)dword_94F34, v6);
      byte_94F30 = 1;
    }
  }
  *(_BYTE *)(v4 + 6) |= 8u;
  v7 = dword_94F34 & 0xFFFFFFEF;
  *(_DWORD *)(v4 + 1176) = v7;
  return sub_1A2B6(1, (__int64)"[EB|#CSR:OUT] 0x%08X\n", v7, a4);
}
// 1BB3E: write access to const memory at 94F30 has been detected
// 41154: using guessed type __int16 aCsrActiveConfi[18];
// 92360: using guessed type __int64 qword_92360[2];
// 94F30: using guessed type char byte_94F30;
// 94F34: using guessed type int dword_94F34;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001BBA2) ----------------------------------------------------
char *__usercall sub_1BBA2@<rax>(unsigned int a1@<edx>, __int64 *a2@<rcx>, char *a3@<r8>, char *a4@<r9>, __m128i *a5@<xmm1>, __m128i *a6@<xmm2>, __m128i *a7@<xmm6>, __m128i *a8@<xmm7>)
{
  char *v8; // r14
  char *v9; // rbx
  int v10; // ecx
  char *result; // rax
  __int64 v12; // [rsp+28h] [rbp-D8h]
  __int64 v13; // [rsp+30h] [rbp-D0h]
  char v14; // [rsp+50h] [rbp-B0h]
  __int64 v15; // [rsp+D8h] [rbp-28h]

  v8 = a4;
  v9 = a3;
  memset(&v14, 0xAAu, 0x80ui64);
  v15 = -6148914691236517206i64;
  LODWORD(v13) = *((_DWORD *)a3 + 42);
  LODWORD(v12) = *(_DWORD *)a3;
  if ( (unsigned int)sub_19DBC(
                       2,
                       a2,
                       a1,
                       v9 + 8,
                       *((unsigned int *)v9 + 1),
                       v12,
                       v13,
                       (__int64)&v14,
                       *((unsigned int *)v9 + 6)) == -1 )
    return 0i64;
  v15 = sub_1A0A1(1i64, *((unsigned int *)v9 + 7));
  if ( (unsigned int)sub_1A042(
                       (__int64)&byte_8FB57,
                       (unsigned int *)&v14,
                       a5,
                       a6,
                       a7,
                       a8,
                       *((unsigned int *)v9 + 6),
                       v9 + 32,
                       *((unsigned int *)v9 + 7),
                       (__int64)(v8 + 4),
                       (unsigned __int64 *)&v15) == -1 )
    return 0i64;
  *(_DWORD *)v8 = v15;
  v10 = sub_1BCB1((__int64)(v9 + 176), v8);
  result = 0i64;
  if ( v10 )
    result = v8;
  return result;
}
// 8FB57: using guessed type char byte_8FB57;

//----- (000000000001BCB1) ----------------------------------------------------
signed __int64 __fastcall sub_1BCB1(__int64 a1, char *a2)
{
  char *v2; // rbx
  __int64 v3; // r12
  __int64 v4; // rdi
  unsigned int v5; // esi
  __int64 v6; // rax
  bool v7; // zf
  char v9; // [rsp+20h] [rbp-110h]
  char v10[159]; // [rsp+41h] [rbp-EFh]
  __int64 v11; // [rsp+E0h] [rbp-50h]
  __int64 v12; // [rsp+E8h] [rbp-48h]
  __int64 v13; // [rsp+F0h] [rbp-40h]
  __int64 v14; // [rsp+F8h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  LOBYTE(a2) = -86;
  sub_F180(&v9, (int)a2, 0xC0ui64);
  v11 = -6148914691236517206i64;
  v12 = -6148914691236517206i64;
  v13 = -6148914691236517206i64;
  v14 = -6148914691236517206i64;
  v4 = (unsigned int)(*(_DWORD *)v2 + 64);
  sub_F1B0(&v9, v4);
  sub_1B950((char *)(v3 + 44), &v9, 0x20ui64);
  sub_1B950(v2 + 4, v10, *(unsigned int *)v2);
  sub_1B950((char *)(v3 + 76), &v10[*(unsigned int *)v2], 0x20ui64);
  sub_1B89D(&v9, v4, (__int64)&v11);
  sub_F1B0(&v9, v4);
  if ( *(_DWORD *)(v3 + 8) >= 2u )
  {
    v5 = 1;
    do
    {
      sub_1B950((char *)&v11, &v9, 0x20ui64);
      sub_1B89D(&v9, 0x20u, (__int64)&v11);
      ++v5;
    }
    while ( v5 < *(_DWORD *)(v3 + 8) );
  }
  v6 = 0i64;
  while ( (_DWORD)v6 != 32 )
  {
    v7 = *((_BYTE *)&v11 + v6) == *(_BYTE *)(v3 + v6 + 12);
    ++v6;
    if ( !v7 )
      return 0i64;
  }
  return 1i64;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 1BCB1: using guessed type char var_EF[159];

//----- (000000000001BDDD) ----------------------------------------------------
__int64 __usercall sub_1BDDD@<rax>(__int64 a1@<rdx>, unsigned int *a2@<rcx>, __int64 a3@<r8>, __m128i *a4@<xmm1>, __m128i *a5@<xmm2>, __m128i *a6@<xmm6>, __m128i *a7@<xmm7>)
{
  __int64 v7; // rsi
  __int64 v8; // rdi
  unsigned int *v9; // rbx
  int v10; // ecx
  __int64 result; // rax
  __int64 v12; // [rsp+50h] [rbp-20h]

  v7 = a3;
  v8 = a1;
  v9 = a2;
  v12 = sub_1A0A1(1i64, *(unsigned int *)(a1 + 4));
  if ( (unsigned int)sub_1A042(
                       (__int64)&byte_8FB57,
                       v9 + 1,
                       a4,
                       a5,
                       a6,
                       a7,
                       *v9,
                       (char *)(v8 + 8),
                       *(unsigned int *)(v8 + 4),
                       v7 + 8,
                       (unsigned __int64 *)&v12) == -1 )
    return 0i64;
  *(_DWORD *)v7 = *(_DWORD *)v8;
  *(_DWORD *)(v7 + 4) = v12;
  v10 = sub_1BCB1(v8 + 144, (char *)(v7 + 4));
  result = 0i64;
  if ( v10 )
    result = v7;
  return result;
}
// 8FB57: using guessed type char byte_8FB57;

//----- (000000000001BE84) ----------------------------------------------------
bool sub_1BE84()
{
  bool result; // al
  __int64 v1; // rdi
  int v2; // eax

  result = 1;
  if ( !(qword_96AA8 & 0x80000) )
  {
    result = 0;
    if ( qword_94F38 )
    {
      if ( qword_94F40 )
      {
        v1 = *(_QWORD *)qword_96C38;
        v2 = sub_189FE((_BYTE *)qword_94F40);
        result = (unsigned int)sub_18A43(qword_94F40, v1, v2) == 0;
      }
    }
  }
  return result;
}
// 94F38: using guessed type __int64 qword_94F38;
// 94F40: using guessed type __int64 qword_94F40;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96C38: using guessed type __int64 qword_96C38;

//----- (000000000001BEDE) ----------------------------------------------------
signed __int64 __fastcall sub_1BEDE(unsigned __int16 a1, _WORD *a2, __int64 a3, unsigned int a4, __int64 a5)
{
  signed __int64 v5; // rbx
  unsigned int v6; // esi
  __int64 v7; // rdi
  _WORD *v8; // r13
  signed __int64 v9; // r14
  unsigned __int16 v10; // ax
  unsigned __int16 v11; // r15
  __int64 v12; // r12
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // rax
  __int64 v17; // [rsp+30h] [rbp-80h]
  __int64 v18; // [rsp+40h] [rbp-70h]
  __int64 v19; // [rsp+48h] [rbp-68h]
  __int16 v20; // [rsp+50h] [rbp-60h]
  __int64 v21; // [rsp+60h] [rbp-50h]
  __int64 v22; // [rsp+68h] [rbp-48h]
  unsigned int v23; // [rsp+70h] [rbp-40h]
  unsigned __int16 v24; // [rsp+74h] [rbp-3Ch]
  unsigned __int16 v25; // [rsp+76h] [rbp-3Ah]

  v5 = -9223372036854775806i64;
  v24 = a1;
  v18 = -6148914691236517206i64;
  v19 = -6148914691236517206i64;
  v20 = -21846;
  if ( a3 )
  {
    v6 = a4;
    v7 = a3;
    v8 = a2;
    v25 = a1;
    v9 = sub_23764(a2);
    v10 = sub_23D3E(v7);
    v11 = v10;
    v12 = v10;
    v23 = v6;
    v22 = v6;
    v21 = v10 + v9 + v6 + 6;
    v13 = sub_1364F(v21);
    if ( v13 )
    {
      v14 = v13;
      *(_DWORD *)v13 = 1;
      *(_WORD *)(v13 + 4) = v11;
      (*(void (__fastcall **)(__int64, _WORD *, signed __int64))(qword_96CD8 + 352))(v13 + 6, v8, v9);
      (*(void (__fastcall **)(__int64, __int64, __int64))(qword_96CD8 + 352))(v14 + v9 + 6, v7, v12);
      if ( a5 )
        (*(void (__fastcall **)(__int64, __int64, __int64))(qword_96CD8 + 352))(v11 + v14 + v9 + 6, a5, v22);
      LODWORD(v17) = v23;
      sub_1A2B6(1, (__int64)"[EB|`CS:BBO] { 0x%08X, %d, (%S), (%D), %.*E }\n", 1i64, v11);
      sub_22ED4((__int64)&v18, 18i64, (__int64)"B", v25, v8, v7, v17, a5, v18, v19, *(_QWORD *)&v20);
      v15 = (*(__int64 (__fastcall **)(__int64 *, int *, signed __int64, __int64, __int64))(qword_96CE0 + 88))(
              &v18,
              &dword_92004,
              7i64,
              v21,
              v14);
      if ( v15 >= 0 )
        v15 = (*(__int64 (__fastcall **)(const __int16 *, int *, signed __int64, signed __int64, unsigned __int16 *))(qword_96CE0 + 88))(
                L"BootNext",
                &dword_92004,
                7i64,
                2i64,
                &v24);
      v5 = v15;
    }
    else
    {
      v5 = -9223372036854775799i64;
    }
  }
  return v5;
}
// 411B0: using guessed type __int16 aBootnext[9];
// 92004: using guessed type int dword_92004;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001C099) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __usercall sub_1C099@<rax>(__m128 *a1@<xmm0>, __m128i *a2@<xmm7>)
{
  __int64 v2; // r8
  __int64 v3; // r9
  unsigned int v4; // esi
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rsi
  const char *v11; // rdx
  signed __int64 v12; // rax
  __int64 v13; // r9
  __int64 v14; // rax
  char *v15; // rdx
  unsigned __int64 v16; // r8
  __int64 v17; // rax
  __int64 v18; // r8
  __int64 v19; // rax
  __int64 v20; // r9
  __int64 v21; // r8
  __int64 v22; // rsi
  unsigned __int64 *v23; // r12
  __int64 v24; // rax
  unsigned __int64 v25; // rdi
  unsigned __int64 v26; // r13
  unsigned __int64 v27; // rsi
  signed __int64 v28; // r15
  unsigned __int64 v29; // r14
  char *v30; // rbx
  __int64 v31; // rax
  __int64 v32; // r9
  __int64 v33; // r8
  __int64 v34; // r9
  __m128i v35[19]; // [rsp+30h] [rbp-360h]
  __m128i v36[2]; // [rsp+168h] [rbp-228h]
  unsigned int v37; // [rsp+190h] [rbp-200h]
  char v38; // [rsp+194h] [rbp-1FCh]
  unsigned int v39; // [rsp+214h] [rbp-17Ch]
  char v40; // [rsp+218h] [rbp-178h]
  int v41; // [rsp+298h] [rbp-F8h]
  char v42; // [rsp+29Ch] [rbp-F4h]
  __int64 v43; // [rsp+320h] [rbp-70h]
  __int64 v44; // [rsp+328h] [rbp-68h]
  unsigned __int64 v45; // [rsp+330h] [rbp-60h]
  __int64 v46; // [rsp+338h] [rbp-58h]
  __int64 v47; // [rsp+340h] [rbp-50h]
  __int64 v48; // [rsp+348h] [rbp-48h]
  __int64 v49; // [rsp+350h] [rbp-40h]

  sub_F180((char *)v35, -86, 0x130ui64);
  sub_F180((char *)v36, -86, 0x130ui64);
  sub_F180((char *)&v41, -86, 0x84ui64);
  v43 = -6148914691236517206i64;
  sub_1A2B6(1, (__int64)"[EB|`CS:CSKSD] {\n", v2, v3);
  if ( qword_96AA8 & 0x3000 )
  {
    v4 = 0;
    (*(void (__fastcall **)(const char *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
      "b",
      qword_92790,
      0i64,
      0i64,
      0i64);
    (*(void (__fastcall **)(const char *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
      "b",
      qword_92360,
      0i64,
      0i64,
      0i64);
    return v4;
  }
  v43 = 304i64;
  v5 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("b", qword_92790, 0i64);
  if ( v5 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`CS:CSKSD] %r @ GV %g:%S\n", v5, (__int64)qword_92790);
    return (unsigned int)-1;
  }
  (*(void (__fastcall **)(const char *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
    "b",
    qword_92790,
    0i64,
    0i64,
    0i64);
  sub_F1B0(&v41, 132i64);
  v49 = -6148914691236517206i64;
  v45 = -6148914691236517206i64;
  v46 = -6148914691236517206i64;
  v47 = -6148914691236517206i64;
  v48 = -6148914691236517206i64;
  v44 = 32i64;
  v6 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(qword_96CD8 + 320))(qword_92BA0, 0i64);
  if ( v6 < 0 )
  {
    v9 = v6;
    v11 = "[EB|`CS:GEBK] %r @ LocP %g\n";
LABEL_15:
    sub_1A2B6(1, (__int64)v11, v9, (__int64)qword_92BA0);
    goto LABEL_17;
  }
  sub_F1B0(&v45, 32i64);
  v7 = (*(__int64 (__fastcall **)(__int64, signed __int64, unsigned __int64 *, __int64 *))(v49 + 16))(
         v49,
         1212304208i64,
         &v45,
         &v44);
  if ( v7 < 0 )
  {
    v9 = v7;
    v11 = "[EB|`CS:GEBK] %r @ %g.GL\n";
    goto LABEL_15;
  }
  if ( v44 == 32 )
  {
    v41 = 16;
    sub_1B950((char *)&v45, &v42, 0x20ui64);
    v8 = (*(__int64 (__fastcall **)(__int64, signed __int64))(v49 + 24))(v49, 1212304208i64);
    if ( v8 < 0 )
      sub_1A2B6(1, (__int64)"[EB|`CS:GEBK] %r @ %g.EL\n", v8, (__int64)qword_92BA0);
    v9 = 0i64;
  }
  else
  {
    v9 = -9223372036854775804i64;
  }
LABEL_17:
  if ( v9 < 0 )
  {
    sub_F1B0(&v41, 132i64);
    v49 = -6148914691236517206i64;
    v45 = -6148914691236517206i64;
    v46 = -6148914691236517206i64;
    v47 = -6148914691236517206i64;
    v48 = -6148914691236517206i64;
    v17 = (*(__int64 (__fastcall **)(__int64 *, _QWORD))(qword_96CD8 + 320))(qword_92C40, 0i64);
    if ( v17 < 0 )
    {
      v22 = v17;
      sub_1A2B6(1, (__int64)"[EB|`CS:GEBK] %r @ LocP %g\n", v17, (__int64)qword_92C40);
      goto LABEL_33;
    }
    sub_F1B0(&v45, 32i64);
    LOBYTE(v18) = 32;
    v19 = (*(__int64 (__fastcall **)(__int64, signed __int64, __int64, unsigned __int64 *))(v49 + 8))(
            v49,
            1212304208i64,
            v18,
            &v45);
    if ( v19 < 0 )
    {
      v22 = v19;
      sub_1A2B6(1, (__int64)"[EB|`CS:GSBK] %r @ HBKP\n", v19, v20);
      goto LABEL_33;
    }
    v41 = 16;
    sub_1B950((char *)&v45, &v42, 0x20ui64);
    sub_F1B0(&v45, 32i64);
    LOBYTE(v21) = 32;
    (*(void (__fastcall **)(__int64, signed __int64, __int64, unsigned __int64 *))(v49 + 16))(
      v49,
      1212304208i64,
      v21,
      &v45);
  }
  v12 = sub_1C727(v36, v35, (unsigned int *)&v41, a1, a2);
  if ( v12 >= 0 )
  {
    v14 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
            "b",
            qword_92360,
            0i64,
            0i64,
            0i64);
    sub_1A2B6(1, (__int64)"[EB|`CS:CSKSD] %r @ SV- %S\n", v14, (__int64)"b");
    goto LABEL_20;
  }
  v22 = v12;
LABEL_33:
  sub_1A2B6(1, (__int64)"[EB|`CS:CSKSD] %r @ E/S\n", v22, v13);
  sub_F1B0(&v41, 132i64);
  v45 = 0i64;
  if ( (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("b", qword_92360, 0i64) != -9223372036854775803i64
    || !v45 )
  {
    return (unsigned int)-1;
  }
  v23 = (unsigned __int64 *)sub_1364F(v45);
  v24 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, unsigned __int64 *, unsigned __int64 *))(qword_96CE0 + 72))(
          "b",
          qword_92360,
          0i64,
          &v45,
          v23);
  if ( !v23 || v24 < 0 )
    v45 = 0i64;
  (*(void (__fastcall **)(const char *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
    "b",
    qword_92360,
    0i64,
    0i64,
    0i64);
  if ( !v45 )
    return (unsigned int)-1;
  if ( v45 < 0x18 )
    return (unsigned int)-1;
  v25 = *v23;
  v26 = v23[1];
  if ( *v23 != 32 && v25 != 16 )
    return (unsigned int)-1;
  v27 = v45 >> 3;
  v28 = -9223372036854775781i64;
  v29 = 2i64;
  do
  {
    v30 = (char *)v23[v29];
    if ( v26 == (unsigned int)sub_17CD4(0, v23[v29], v25) )
    {
      v41 = 16;
      sub_1B950(v30, &v42, v25);
      sub_F1B0(v30, v25);
      v28 = 0i64;
    }
    ++v29;
  }
  while ( v29 < v27 );
  v4 = -1;
  if ( v28 >= 0 )
  {
    sub_F1B0(v36, 304i64);
    v31 = sub_1C727(v36, v35, (unsigned int *)&v41, a1, a2);
    if ( v31 < 0 )
    {
      sub_1A2B6(1, (__int64)"[EB|`CS:CSKSD] %r @ CS:DAVB\n", v31, v32);
      return v4;
    }
LABEL_20:
    sub_F1B0(&v41, 132i64);
    sub_F1B0(v35, 304i64);
    v4 = -1;
    if ( v37 > 0x80ui64 || v39 > 0x80 || !(v37 | v39) )
      return v4;
    if ( qword_96AA8 & 0x80000 )
    {
      if ( v37 )
      {
        qword_94FE0 = v37;
        qword_94FE8 = sub_24103(v37);
        v16 = qword_94FE0;
        v15 = (char *)qword_94FE8;
LABEL_51:
        sub_1B950(&v38, v15, v16);
        goto LABEL_52;
      }
    }
    else if ( v37 )
    {
      if ( v37 != 16 )
        return v4;
      dword_94F58 = 16;
      v15 = (char *)&dword_94F5C;
      v16 = 16i64;
      goto LABEL_51;
    }
LABEL_52:
    if ( v39 )
    {
      dword_96C48 = v39;
      sub_1B950(&v40, (char *)&dword_96C4C, v39);
    }
    sub_F1B0(v36, 304i64);
    sub_1A2B6(1, (__int64)"[EB|`CS:CSKSD] }\n", v33, v34);
    v4 = 0;
  }
  return v4;
}
// 1C3E4: write access to const memory at 94F58 has been detected
// 1C6AF: write access to const memory at 94FE0 has been detected
// 1C6BB: write access to const memory at 94FE8 has been detected
// 1C6E4: write access to const memory at 96C48 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 92360: using guessed type __int64 qword_92360[2];
// 92790: using guessed type __int64 qword_92790[2];
// 92BA0: using guessed type __int64 qword_92BA0[2];
// 92C40: using guessed type __int64 qword_92C40[2];
// 94F58: using guessed type int dword_94F58;
// 94F5C: using guessed type int dword_94F5C;
// 94FE0: using guessed type __int64 qword_94FE0;
// 94FE8: using guessed type __int64 qword_94FE8;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96C48: using guessed type int dword_96C48;
// 96C4C: using guessed type int dword_96C4C;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001C727) ----------------------------------------------------
signed __int64 __usercall sub_1C727@<rax>(__m128i *a1@<rdx>, __m128i *a2@<rcx>, unsigned int *a3@<r8>, __m128 *a4@<xmm0>, __m128i *a5@<xmm7>)
{
  unsigned int *v5; // rdi
  __m128i *v6; // rsi
  __m128i *v7; // r15
  unsigned int *v8; // rbx
  signed __int64 v9; // r14
  signed __int64 v10; // rcx
  char *v11; // rdi
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v15; // [rsp+38h] [rbp-438h]
  int v16[246]; // [rsp+48h] [rbp-428h]
  __int64 v17; // [rsp+420h] [rbp-50h]
  __int64 v18; // [rsp+428h] [rbp-48h]
  __int64 v19; // [rsp+430h] [rbp-40h]
  __int64 v20; // [rsp+438h] [rbp-38h]

  v5 = a3;
  v6 = a1;
  v7 = a2;
  v8 = (unsigned int *)((char *)a3 + *a3 + 4);
  LOBYTE(a1) = -86;
  sub_F180((char *)v16, (int)a1, 0x3D4ui64);
  sub_F1B0(v16, 980i64);
  v9 = 0i64;
  LODWORD(v15) = 0;
  sub_1EA39(0, v5 + 1, *v5, a4, a5, v8, *v5, 0, v15, v16);
  sub_1EB0D(v7, 0x130ui64, v6, (__int64)v8, (__int64)v16);
  sub_1EC69((char *)v16);
  v17 = -6148914691236517206i64;
  v18 = -6148914691236517206i64;
  v19 = -6148914691236517206i64;
  v20 = -6148914691236517206i64;
  v10 = 26i64;
  v11 = (char *)v16;
  while ( v10 )
  {
    *(_DWORD *)v11 = -1431655766;
    v11 += 4;
    --v10;
  }
  sub_1B84F((__int64)v16);
  sub_1AAAE(v16, v6[2].m128i_i8, 8u);
  sub_1AAAE(v16, &v6[2].m128i_i8[8], 0x84u);
  sub_1AAAE(v16, &v6[10].m128i_i8[12], 0x84u);
  sub_1B87F((__int64)&v17, v16);
  if ( (unsigned int)sub_189D2((__int64)&v17, (__int64)v6, 32i64) )
  {
    sub_1A2B6(1, (__int64)"[EB|`CS:DAVB] ! 'CK\n", v12, v13);
    v9 = -9223372036854775781i64;
  }
  return v9;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);

//----- (000000000001C881) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __usercall sub_1C881@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __m128 *a5@<xmm0>, __m128i *a6@<xmm7>)
{
  char v6; // r13
  __int64 v7; // rdi
  __int64 v8; // rsi
  signed __int64 v9; // r14
  signed __int64 v10; // rsi
  unsigned __int64 v12; // rdi
  __m128i *v13; // r12
  int v14; // esi
  __int64 v15; // rbx
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // r15
  __int64 v19; // rax
  int v20; // edx
  __int64 v21; // r8
  __int64 v22; // r9
  _DWORD *v23; // rax
  _DWORD *v24; // rdi
  unsigned int v25; // eax
  __int64 v26; // rsi
  unsigned int v27; // er15
  _DWORD *v28; // r12
  _DWORD *v29; // rax
  __int64 v30; // rdi
  __int64 v31; // rax
  __int64 v32; // rbx
  signed __int64 v33; // rax
  unsigned __int64 v34; // rcx
  __int64 v35; // rsi
  __int64 v36; // rax
  __int64 v37; // rbx
  __int64 v38; // r12
  __int64 v39; // rax
  __int64 v40; // r15
  _BYTE *v41; // r13
  __int64 v42; // rax
  __int64 v43; // r13
  _DWORD *v44; // rax
  _DWORD *v45; // rsi
  __int64 v46; // rax
  __int64 v47; // rax
  _DWORD *v48; // rax
  __int64 v49; // rax
  __int64 v50; // r9
  __int64 v51; // rbx
  __int64 v52; // rax
  __int64 v53; // rcx
  _DWORD *v54; // rax
  _DWORD *v55; // rbx
  __int64 v56; // rax
  __int64 v57; // rcx
  __int64 v58; // r9
  int v59; // ecx
  signed __int64 v60; // rax
  int v61; // eax
  __int64 v62; // rax
  __int64 v63; // rcx
  __int64 v64; // rdx
  unsigned int v65; // edx
  _DWORD *v66; // rax
  __int64 v67; // rsi
  int v68; // eax
  __int64 v69; // rax
  __int64 v70; // rcx
  bool v71; // zf
  __int64 v72; // rax
  unsigned __int64 v73; // rdx
  __int64 v74; // rax
  __int64 v75; // rbx
  __int64 v76; // rax
  __int64 v77; // rbx
  __int64 v78; // rdx
  unsigned __int64 v79; // rax
  __int64 v80; // rcx
  __int64 v81; // rsi
  __int64 v82; // rax
  unsigned __int64 v83; // r13
  __int64 v84; // rbx
  unsigned __int64 v85; // rsi
  __int64 v86; // rdi
  __int64 v87; // r8
  __int64 v88; // r9
  _DWORD *v89; // rax
  __int64 v90; // r8
  __int64 v91; // r9
  __int64 v92; // rbx
  __int64 v93; // rsi
  __int64 v94; // rcx
  signed __int64 v95; // rdi
  __int64 v96; // [rsp+38h] [rbp-4A8h]
  __int64 v97; // [rsp+50h] [rbp-490h]
  __int64 v98; // [rsp+428h] [rbp-B8h]
  __int64 v99; // [rsp+430h] [rbp-B0h]
  __int64 v100; // [rsp+438h] [rbp-A8h]
  char *v101; // [rsp+448h] [rbp-98h]
  __int64 v102; // [rsp+450h] [rbp-90h]
  __int64 v103; // [rsp+458h] [rbp-88h]
  __int64 v104; // [rsp+460h] [rbp-80h]
  unsigned __int64 v105; // [rsp+468h] [rbp-78h]
  __int64 v106; // [rsp+470h] [rbp-70h]
  __m128i *v107; // [rsp+478h] [rbp-68h]
  _BYTE *v108; // [rsp+480h] [rbp-60h]
  unsigned int v109; // [rsp+488h] [rbp-58h]
  unsigned int v110; // [rsp+48Ch] [rbp-54h]
  int v111; // [rsp+490h] [rbp-50h]
  int v112; // [rsp+494h] [rbp-4Ch]
  unsigned __int64 v113; // [rsp+498h] [rbp-48h]
  __int64 v114; // [rsp+4A0h] [rbp-40h]

  v6 = a3;
  v7 = a1;
  v8 = a2;
  v9 = -9223372036854775798i64;
  v105 = 0i64;
  v107 = 0i64;
  sub_1A2B6(1, (__int64)"[EB|`CS:LFC] {\n", a3, a4);
  if ( v8 )
    return -9223372036854775805i64;
  v10 = sub_D739(0i64, v7, (__int64)"S", 0i64, &v105, (__int64 *)&v107);
  if ( v10 < 0 )
    v10 = sub_D739(0i64, v7, (__int64)"E", 0i64, &v105, (__int64 *)&v107);
  if ( v10 )
    goto LABEL_27;
  v12 = v105;
  if ( !v105 )
    goto LABEL_27;
  if ( !(qword_96AA8 & 0x80000) )
  {
    v13 = v107;
    v103 = -6148914691236517206i64;
    v104 = -6148914691236517206i64;
    v14 = sub_1ECA5(qword_96AD8);
    if ( v14 == -1 )
      sub_9CE0((__int64)"[EB|#STOP|`CS:DCFP] ! @ V:GPI\n");
    v15 = sub_1ECEF(qword_96AD8, v14 - 1);
    if ( !v15 )
      sub_9CE0((__int64)"[EB|#STOP|`CS:DCFP] ! @ V:FP\n");
    v16 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(v15, qword_92A60, &v104);
    if ( v16 < 0
      || (v16 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(v15, qword_92AA0, &v103),
          v16 < 0) )
    {
      v10 = v16;
    }
    else
    {
      v17 = sub_1364F(512i64);
      if ( v17 )
      {
        v18 = v17;
        v19 = (*(__int64 (__fastcall **)(__int64, _QWORD, signed __int64, signed __int64, __int64))(v103 + 8))(
                v103,
                **(unsigned int **)(v104 + 8),
                (*(_QWORD *)(*(_QWORD *)(v104 + 8) + 24i64) + 1i64) * *(unsigned int *)(*(_QWORD *)(v104 + 8) + 12i64)
              - 512,
                512i64,
                v17);
        if ( v19 >= 0 )
        {
          v10 = v19;
          if ( (unsigned __int8)sub_1E928(v18, v19) )
            goto LABEL_177;
        }
        v10 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, signed __int64, __int64))(v103 + 8))(
                v103,
                **(unsigned int **)(v104 + 8),
                0i64,
                512i64,
                v18);
        if ( v10 < 0 )
        {
LABEL_23:
          sub_F1B0(v18, 512i64);
          sub_136C5(v18);
          goto LABEL_27;
        }
        if ( (unsigned __int8)sub_1E928(v18, v10) )
        {
LABEL_177:
          LODWORD(v113) = *(unsigned __int8 *)(v18 + 168);
          v100 = 0i64;
          v99 = 0i64;
          LOBYTE(v20) = -86;
          sub_F180((char *)&v97, v20, 0x3D4ui64);
          if ( *(_WORD *)(v18 + 172) == 2 )
          {
            sub_F1B0(&v97, 980i64);
            LODWORD(v96) = 0;
            sub_1EA39(0, (unsigned int *)(v18 + 176), v113, a5, a6, (unsigned int *)&v99, 16, 0, v96, &v97);
            sub_1EB0D(v13, v12, v13, (__int64)&v99, (__int64)&v97);
            sub_1EC69((char *)&v97);
            sub_F1B0(&v97, 980i64);
          }
          goto LABEL_23;
        }
        sub_F1B0(v18, 512i64);
        sub_136C5(v18);
        v10 = -9223372036854775798i64;
      }
      else
      {
        v10 = -9223372036854775799i64;
      }
    }
LABEL_27:
    if ( v10 >= 0 )
      goto LABEL_28;
LABEL_31:
    if ( v107 )
      sub_136C5((__int64)v107);
    return v10;
  }
  if ( !sub_B3CF(1) )
  {
    v10 = -9223372036854775784i64;
    goto LABEL_31;
  }
LABEL_28:
  v10 = -9223372036854775794i64;
  if ( v105 )
  {
    if ( sub_12DC6((__int64)v107, &qword_94F38) )
    {
      sub_1A2B6(1, (__int64)"[EB|`CS:LFC] ! @ X:XPF 'ER\n", v21, v22);
      qword_94F38 = 0i64;
      return v10;
    }
    v23 = (_DWORD *)sub_124B2(qword_94F38, "CryptoUsers");
    v10 = -9223372036854775778i64;
    if ( v23 )
    {
      v24 = v23;
      if ( *v23 == 9 )
      {
        v25 = sub_12D6F((__int64)v23);
        if ( v25 )
        {
          v113 = v25;
          v26 = 0i64;
          v27 = 0;
          while ( 1 )
          {
            v28 = v24;
            v29 = (_DWORD *)sub_12D9A((__int64)v24, v26);
            if ( !v29
              || (v30 = (__int64)v29, *v29 != 1)
              || (v31 = sub_124B2((__int64)v29, "UserType")) == 0
              || (v32 = v31, *(_DWORD *)v31 != 4) )
            {
              v27 = dword_94FF0;
              v24 = v28;
LABEL_55:
              if ( *v24 != 9 )
                return -9223372036854775806i64;
              v35 = v27;
              if ( v27 )
              {
                v36 = sub_1364F(8i64 * v27);
                v37 = v113;
                if ( v36 )
                {
                  v38 = v36;
                  v109 = v27;
                  goto LABEL_62;
                }
                return -9223372036854775799i64;
              }
              v109 = 0;
              v38 = 0i64;
              v37 = v113;
LABEL_62:
              v39 = sub_1364F(8 * v37);
              if ( !v39 )
                return -9223372036854775799i64;
              v40 = v39;
              v106 = 0i64;
              v98 = v35;
              if ( v6 )
              {
                v41 = 0i64;
                v97 = 0i64;
                if ( (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
                       L"last-oslogin-ident",
                       qword_92790,
                       0i64) == -9223372036854775803i64
                  && v97 )
                {
                  v42 = sub_1364F(v97 + 1);
                  if ( v42 )
                  {
                    v41 = (_BYTE *)v42;
                    if ( (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD, __int64 *, __int64))(qword_96CE0 + 72))(
                           L"last-oslogin-ident",
                           qword_92790,
                           0i64,
                           &v97,
                           v42) >= 0 )
                    {
                      v41[v97] = 0;
                      goto LABEL_73;
                    }
                    sub_136C5((__int64)v41);
                  }
                  v41 = 0i64;
                }
LABEL_73:
                v108 = v41;
              }
              else
              {
                v108 = 0i64;
              }
              v43 = 0i64;
              v111 = 0;
              v110 = 0;
              while ( 2 )
              {
                v44 = (_DWORD *)sub_12D9A((__int64)v24, v43);
                if ( !v44 )
                  goto LABEL_98;
                v45 = v44;
                if ( *v44 != 1 )
                  goto LABEL_98;
                v46 = sub_124B2((__int64)v44, "UserIdent");
                if ( !v46 || *(_DWORD *)v46 != 3 )
                  goto LABEL_98;
                v101 = *(char **)(v46 + 8);
                v47 = sub_124B2((__int64)v45, "UserType");
                if ( v47 )
                {
                  if ( *(_DWORD *)v47 == 4 && *(_QWORD *)(v47 + 16) == 536936456i64 )
                  {
                    v48 = (_DWORD *)sub_124B2((__int64)v45, "ExternalKeyProps");
                    if ( v48 )
                    {
                      if ( *v48 == 1 )
                      {
                        v49 = sub_124B2((__int64)v48, "OS User UUID");
                        if ( v49 )
                        {
                          v51 = v49;
                          if ( *(_DWORD *)v49 == 3 )
                          {
                            sub_1A2B6(1, (__int64)"[EB|`CS:GICRUU] %e\n", *(_QWORD *)(v49 + 8), v50);
                            v52 = *(_QWORD *)(v51 + 8);
                            if ( v52 )
                            {
                              v53 = (unsigned int)v106;
                              v106 = (unsigned int)(v106 + 1);
                              *(_QWORD *)(v40 + 8 * v53) = v52;
                            }
                          }
                        }
                        v37 = v113;
                      }
                    }
                  }
                }
                if ( *v45 != 1 )
                  goto LABEL_98;
                v54 = (_DWORD *)sub_124B2((__int64)v45, "UserType");
                if ( !v54 || (v55 = v54, *v54 != 4) || (v56 = sub_1364F(72i64)) == 0 )
                {
                  v37 = v113;
                  goto LABEL_98;
                }
                v114 = v56;
                sub_F1B0(v56, 72i64);
                v57 = v114;
                *(_QWORD *)v114 = v101;
                *(_QWORD *)(v57 + 8) = v45;
                sub_1A2B6(1, (__int64)"[EB|`CS:BU] UT: 0x%08x\n", *((_QWORD *)v55 + 2), v58);
                v60 = *((_QWORD *)v55 + 2);
                if ( v60 > 268566530 )
                {
                  v37 = v113;
                  if ( v60 != 268566531 )
                  {
                    if ( v60 != 268828674 )
                      goto LABEL_125;
                    v61 = v114;
                    *(_BYTE *)(v114 + 56) = 1;
                    LOBYTE(v61) = 1;
                    v112 = v61;
                    goto LABEL_106;
                  }
                  qword_96C20 = v114;
                }
                else
                {
                  v37 = v113;
                  if ( v60 != 268435457 )
                  {
                    if ( v60 == 268500997 )
                    {
                      qword_96C28 = v114;
                      break;
                    }
LABEL_125:
                    LOBYTE(v59) = 1;
                    v112 = v59;
                    if ( !_bittest((const signed int *)&v60, 0x1Cu) )
                    {
                      sub_136C5(v114);
                      goto LABEL_98;
                    }
LABEL_106:
                    v62 = sub_124B2((__int64)v45, "EFILoginGraphics");
                    if ( v62 )
                    {
                      if ( *(_DWORD *)v62 == 5 )
                      {
                        v63 = *(_QWORD *)(v62 + 32);
                        if ( v63 )
                        {
                          v64 = v114;
                          *(_QWORD *)(v114 + 40) = *(_QWORD *)(v62 + 24);
                          *(_QWORD *)(v64 + 48) = v63;
                        }
                      }
                    }
                    v65 = -1;
                    if ( *v45 == 1 )
                    {
                      v66 = (_DWORD *)sub_124B2((__int64)v45, "UserNamesData");
                      if ( v66
                        && (v67 = (__int64)v66, *v66 == 9)
                        && (v68 = sub_12D6F((__int64)v66), (*(_DWORD *)(v114 + 24) = v68) != 0) )
                      {
                        v69 = sub_1364F(16i64 * v68);
                        v70 = v114;
                        *(_QWORD *)(v114 + 32) = v69;
                        v71 = v69 == 0;
                        v72 = v70;
                        v65 = -1;
                        if ( !v71 )
                        {
                          if ( *(_DWORD *)(v70 + 24) )
                          {
                            v73 = 0i64;
                            while ( 1 )
                            {
                              v102 = v73;
                              v74 = sub_12D9A(v67, v73);
                              if ( !v74 )
                                break;
                              v75 = v74;
                              if ( *(_DWORD *)v74 != 5 )
                                break;
                              if ( !*(_QWORD *)(v74 + 24) )
                                break;
                              if ( !*(_QWORD *)(v74 + 32) )
                                break;
                              v76 = sub_1364F(16i64);
                              if ( !v76 )
                                break;
                              *(_QWORD *)v76 = *(_QWORD *)(v75 + 24);
                              *(_DWORD *)(v76 + 8) = *(_DWORD *)(v75 + 32);
                              v77 = v114;
                              v78 = v102;
                              *(_QWORD *)(*(_QWORD *)(v114 + 32) + 8 * v102) = v76;
                              v73 = v78 + 1;
                              v79 = *(unsigned int *)(v77 + 24);
                              v37 = v113;
                              if ( v73 >= v79 )
                                goto LABEL_136;
                            }
                            v65 = v102 - 1;
                            v37 = v113;
                            goto LABEL_128;
                          }
LABEL_136:
                          if ( v108 )
                          {
                            if ( !(unsigned int)sub_18A1A(v101, v108) )
                            {
                              qword_96C38 = v114;
                              sub_136C5((__int64)v108);
                              goto LABEL_139;
                            }
                          }
                          else
                          {
LABEL_139:
                            v108 = 0i64;
                          }
                          ++v111;
                          if ( v110 < v109 && (_BYTE)v112 )
                          {
                            v82 = v110++;
                            *(_QWORD *)(v38 + 8 * v82) = v114;
                          }
LABEL_98:
                          if ( ++v43 == v37 )
                          {
                            if ( v110 )
                            {
                              qword_95010 = v38;
                              if ( (_DWORD)v106 )
                              {
                                v83 = (unsigned int)v106;
                                v84 = v110;
                                v85 = 0i64;
                                do
                                {
                                  v86 = 0i64;
                                  do
                                  {
                                    if ( !(unsigned int)sub_18A1A(
                                                          **(char ***)(v38 + 8 * v86),
                                                          *(_BYTE **)(v40 + 8 * v85))
                                      || qword_96AA8 & 0x80000 )
                                    {
                                      *(_BYTE *)(*(_QWORD *)(v38 + 8 * v86) + 58i64) = 1;
                                    }
                                    ++v86;
                                  }
                                  while ( v84 != v86 );
                                  ++v85;
                                }
                                while ( v85 < v83 && !((unsigned int)qword_80000 & (unsigned int)qword_96AA8) );
                              }
                            }
                            sub_136C5(v40);
                            if ( v111 )
                            {
                              sub_1A2B6(1, (__int64)"[EB|`CS:BUs] }\n", v87, v88);
                              v89 = (_DWORD *)sub_124B2(qword_94F38, "WrappedVolumeKeys");
                              if ( v89 && *v89 == 9 )
                              {
                                qword_95000 = (__int64)v89;
                                dword_95008 = sub_12D6F((__int64)v89);
                                v10 = -9223372036854775798i64;
                                if ( dword_95008 )
                                {
                                  sub_1A2B6(1, (__int64)"[EB|`CS:LFC] }\n", v90, v91);
                                  v10 = 0i64;
                                }
                                return v10;
                              }
                            }
                            else
                            {
                              sub_1A2B6(1, (__int64)"[EB|`CS:BUs] ! 'LU?\n", v87, v88);
                              if ( v38 )
                              {
                                v92 = v98;
                                if ( v109 )
                                {
                                  v93 = 0i64;
                                  do
                                  {
                                    v94 = *(_QWORD *)(v38 + 8 * v93);
                                    if ( *(_DWORD *)(v94 + 24) > 0 )
                                    {
                                      v95 = 0i64;
                                      do
                                      {
                                        sub_136C5(*(_QWORD *)(*(_QWORD *)(v94 + 32) + 8 * v95++));
                                        v94 = *(_QWORD *)(v38 + 8 * v93);
                                      }
                                      while ( v95 < *(signed int *)(v94 + 24) );
                                    }
                                    sub_136C5(v94);
                                    ++v93;
                                  }
                                  while ( v93 != v92 );
                                }
                                sub_136C5(v38);
                              }
                              if ( qword_96C20 )
                                sub_136C5(qword_96C20);
                              if ( qword_96C28 )
                                sub_136C5(qword_96C28);
                              if ( qword_96C40 )
                                sub_136C5(qword_96C40);
                              if ( qword_96C30 )
                                sub_136C5(qword_96C30);
                              sub_F1B0(&qword_96C20, 40i64);
                            }
                            return v9;
                          }
                          continue;
                        }
                      }
                      else
                      {
                        v72 = v114;
                        v65 = -1;
                      }
                    }
                    else
                    {
LABEL_128:
                      v72 = v114;
                    }
                    v80 = *(_QWORD *)(v72 + 32);
                    if ( v80 )
                    {
                      if ( v65 )
                      {
                        v81 = v65;
                        do
                        {
                          if ( *(_QWORD *)(v80 + 8 * v81) )
                          {
                            sub_136C5(*(_QWORD *)(v80 + 8 * v81));
                            v80 = *(_QWORD *)(v114 + 32);
                          }
                          --v81;
                        }
                        while ( v81 );
                      }
                      sub_136C5(v80);
                      *(_QWORD *)(v114 + 32) = 0i64;
                    }
                    goto LABEL_136;
                  }
                  qword_96C30 = v114;
                }
                break;
              }
              v112 = 0;
              goto LABEL_106;
            }
            sub_1A2B6(1, (__int64)"[EB|`CS:CUBT] UT.%d 0x%08x\n", (unsigned int)v26, *(_QWORD *)(v31 + 16));
            v33 = *(_QWORD *)(v32 + 16);
            if ( v33 <= 268566530 )
              break;
            v34 = v113;
            if ( v33 == 268566531 )
              goto LABEL_50;
            if ( v33 == 537395207 )
            {
              qword_94FF8 = v30;
LABEL_50:
              v24 = v28;
              goto LABEL_51;
            }
            v24 = v28;
            if ( v33 != 268828674 )
              goto LABEL_48;
            ++v27;
LABEL_51:
            if ( ++v26 >= v34 )
            {
              dword_94FF0 = v27;
              goto LABEL_55;
            }
          }
          v24 = v28;
          v34 = v113;
          if ( v33 == 268435457 || v33 == 268500997 )
            goto LABEL_51;
LABEL_48:
          v27 += ((unsigned int)v33 >> 28) & 1;
          goto LABEL_51;
        }
      }
    }
  }
  return v10;
}
// 1CBD0: write access to const memory at 94F38 has been detected
// 1CCF2: write access to const memory at 94FF8 has been detected
// 1CD08: write access to const memory at 94FF0 has been detected
// 1CFDF: write access to const memory at 96C28 has been detected
// 1D028: write access to const memory at 96C30 has been detected
// 1D035: write access to const memory at 96C20 has been detected
// 1D1ED: write access to const memory at 96C38 has been detected
// 1D243: write access to const memory at 95010 has been detected
// 1D2E1: write access to const memory at 95000 has been detected
// 1D2F0: write access to const memory at 95008 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 41178: using guessed type __int16 aLastOsloginIde[19];
// 80000: using guessed type __int64 qword_80000[512];
// 92790: using guessed type __int64 qword_92790[2];
// 92A60: using guessed type __int64 qword_92A60[2];
// 92AA0: using guessed type __int64 qword_92AA0[2];
// 94F38: using guessed type __int64 qword_94F38;
// 94FF0: using guessed type int dword_94FF0;
// 94FF8: using guessed type __int64 qword_94FF8;
// 95000: using guessed type __int64 qword_95000;
// 95008: using guessed type int dword_95008;
// 95010: using guessed type __int64 qword_95010;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AD8: using guessed type __int64 qword_96AD8;
// 96C20: using guessed type __int64 qword_96C20;
// 96C28: using guessed type __int64 qword_96C28;
// 96C30: using guessed type __int64 qword_96C30;
// 96C38: using guessed type __int64 qword_96C38;
// 96C40: using guessed type __int64 qword_96C40;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001D3D6) ----------------------------------------------------
_BYTE *__fastcall sub_1D3D6(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // ebx
  __int64 v4; // r14
  __int64 v5; // rsi
  __int64 v6; // r8
  __int64 v7; // r9
  _BYTE *result; // rax
  char v9; // [rsp+30h] [rbp-B0h]
  __int64 v10; // [rsp+B0h] [rbp-30h]
  int v11; // [rsp+BCh] [rbp-24h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  memset(&v9, 0, 0x80ui64);
  v10 = 128i64;
  v11 = 0;
  if ( (*(__int64 (__fastcall **)(const char *, __int64 *))(qword_96CE0 + 72))("r", qword_92360)
    || (unsigned int)sub_18A43((__int64)&v9, (__int64)"locked", 6) )
  {
    result = (_BYTE *)(*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, __int64, __int64))(qword_96CE0 + 88))(
                        "r",
                        qword_92360,
                        v3,
                        v4,
                        v5);
  }
  else
  {
    result = sub_1A2B6(1, (__int64)"[EB|#CS:RBML]\n", v6, v7);
  }
  return result;
}
// 92360: using guessed type __int64 qword_92360[2];
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001D49C) ----------------------------------------------------
signed __int64 sub_1D49C()
{
  signed __int64 v0; // rsi
  __int64 v1; // rax
  __int64 v3; // [rsp+30h] [rbp-20h]
  __int64 v4; // [rsp+38h] [rbp-18h]

  v0 = -9223372036854775794i64;
  v1 = sub_B3CF(1);
  if ( v1 )
  {
    v4 = 0i64;
    v3 = 0i64;
    v0 = -9223372036854775793i64;
    if ( !(unsigned int)sub_1D4EF(v1, 0i64, &v3, 0i64, 0i64) )
      v0 = 0i64;
  }
  return v0;
}

//----- (000000000001D4EF) ----------------------------------------------------
signed __int64 __fastcall sub_1D4EF(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, _QWORD *a5)
{
  __int64 v5; // r14
  __int64 *v6; // rsi
  __int64 v7; // rbx
  __int64 v8; // rdi
  __int64 (__fastcall *v9)(__int64 *, __int64 *, __int64, __int64 *, __int64 *, __int64 *, __int64, __int64); // rax
  __int64 v10; // rdi
  const char *v11; // rdx
  __int64 v12; // rdi
  __int64 v13; // r9
  __int64 v14; // ST20_8
  signed __int64 result; // rax
  __int64 *v16; // [rsp+28h] [rbp-58h]
  __int64 v17; // [rsp+30h] [rbp-50h]
  __int64 v18; // [rsp+38h] [rbp-48h]
  __int64 *v19; // [rsp+40h] [rbp-40h]
  __int64 v20; // [rsp+48h] [rbp-38h]
  __int64 v21; // [rsp+50h] [rbp-30h]
  __int64 v22; // [rsp+58h] [rbp-28h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v19 = (__int64 *)-6148914691236517206i64;
  v22 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v8 = (*(__int64 (__fastcall **)(__int64, __int64 *))(qword_96CD8 + 152))(a1, qword_92CF0);
  if ( v8 < 0 || !v19 )
  {
    v11 = "[EB|`CS:AUV] %r @ HdlP %g\n";
LABEL_11:
    sub_1A2B6(1, (__int64)v11, v8, (__int64)qword_92CF0);
    goto LABEL_12;
  }
  if ( (unsigned __int64)*v19 < 0x20000 )
  {
    v9 = (__int64 (__fastcall *)(__int64 *, __int64 *, __int64, __int64 *, __int64 *, __int64 *, __int64, __int64))v19[1];
    v12 = *v6;
    v18 = v6[1];
    v17 = v12;
  }
  else
  {
    v9 = (__int64 (__fastcall *)(__int64 *, __int64 *, __int64, __int64 *, __int64 *, __int64 *, __int64, __int64))v19[3];
    v10 = *v6;
    v18 = v6[1];
    v17 = v10;
    v16 = &v20;
  }
  v8 = v9(v19, &v17, v7, &v22, &v21, v16, v17, v18);
  if ( v8 < 0 )
  {
    v14 = *v19;
    v11 = "[EB|`CS:AUV] %r @ %g(0x%08qx).VU(I)\n";
    goto LABEL_11;
  }
  sub_1A2B6(1, (__int64)"[EB|#CS:AVU] VBS: %qd\n", v22, v13);
  if ( v5 )
  {
    *(_QWORD *)(v5 + 168) = v21;
    *(_QWORD *)(v5 + 160) = v22;
  }
LABEL_12:
  if ( v8 == -9223372036854775802i64 )
  {
    result = 2i64;
    if ( a5 )
      *a5 = v20;
  }
  else if ( v8 )
  {
    result = 1i64;
    if ( v8 == -9223372036854775782i64 )
      result = 3i64;
  }
  else
  {
    result = 0i64;
  }
  return result;
}
// 92CF0: using guessed type __int64 qword_92CF0[2];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000001D658) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __usercall sub_1D658@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, __int64 a3@<r8>, __int64 a4@<r9>, __m128i *a5@<xmm1>, __m128i *a6@<xmm2>, __m128i *a7@<xmm6>, __m128i *a8@<xmm7>)
{
  char v8; // r14
  _BYTE *v9; // rbx
  __int64 v10; // r15
  __int64 v11; // rdi
  int v12; // edx
  _DWORD *v13; // rax
  __int64 v14; // rax
  __int64 v15; // rsi
  __int64 v16; // rax
  __int64 v17; // rax
  const char *v18; // rdx
  __int64 v19; // rsi
  __int64 v20; // r9
  __int64 v21; // rax
  void *v22; // rbx
  unsigned int v23; // ebx
  int v24; // ecx
  unsigned int v25; // ebx
  unsigned __int8 v26; // cf
  signed __int64 v27; // rax
  int v28; // ebx
  char v29; // al
  int v30; // ecx
  __int64 v31; // rsi
  __int64 v32; // r8
  __int64 v33; // r9
  __int64 v34; // r9
  __int64 v35; // r9
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 v38; // rdx
  __int64 v39; // r8
  __int64 v40; // r9
  int v41; // er8
  __int64 v42; // rax
  signed __int64 v43; // rdx
  unsigned int v44; // ecx
  unsigned int v45; // edx
  __int64 v47; // [rsp+50h] [rbp-190h]
  __int64 *v48; // [rsp+D8h] [rbp-108h]
  __int64 v49; // [rsp+E0h] [rbp-100h]
  __int64 v50; // [rsp+160h] [rbp-80h]
  void *v51; // [rsp+168h] [rbp-78h]
  unsigned __int64 v52; // [rsp+170h] [rbp-70h]
  __int64 *v53; // [rsp+178h] [rbp-68h]
  __int64 v54; // [rsp+180h] [rbp-60h]
  __int64 v55; // [rsp+188h] [rbp-58h]
  _BYTE *(__fastcall *v56)(__int64, __int64); // [rsp+190h] [rbp-50h]
  __int64 v57; // [rsp+198h] [rbp-48h]
  __int64 v58; // [rsp+1A0h] [rbp-40h]
  unsigned int v59; // [rsp+1ACh] [rbp-34h]

  v8 = a4;
  v9 = (_BYTE *)a3;
  v10 = a1;
  v11 = a2;
  v58 = -6148914691236517206i64;
  v57 = 0i64;
  v56 = 0i64;
  v55 = 0i64;
  v54 = 0i64;
  v53 = 0i64;
  v52 = 0i64;
  v51 = 0i64;
  if ( qword_94FF8 )
  {
    LOBYTE(a1) = -86;
    sub_F180((char *)&v47, a1, 0x84ui64);
    LOBYTE(v12) = -86;
    sub_F180((char *)&v48, v12, 0x88ui64);
    sub_F1B0(&v47, 132i64);
    LODWORD(v47) = 16;
    v13 = (_DWORD *)sub_124B2(qword_94FF8, "ExternalKeyProps");
    if ( !v13 )
      goto LABEL_30;
    if ( *v13 != 1 )
      goto LABEL_30;
    v14 = sub_124B2((__int64)v13, "revert-user-version");
    if ( !v14 )
      goto LABEL_30;
    if ( *(_DWORD *)v14 != 4 )
      goto LABEL_30;
    if ( *(_QWORD *)(v14 + 16) != 1i64 )
      goto LABEL_30;
    v15 = sub_124B2(qword_94FF8, "KeyWrappedKEKStruct");
    v16 = sub_124B2(qword_94FF8, "WrapVersion");
    if ( !v15 )
      goto LABEL_30;
    if ( !v16 )
      goto LABEL_30;
    if ( *(_DWORD *)v15 != 5 )
      goto LABEL_30;
    if ( *(_DWORD *)v16 != 4 )
      goto LABEL_30;
    if ( *(_QWORD *)(v16 + 16) != 1i64 )
      goto LABEL_30;
    v17 = sub_124B2(qword_94FF8, "KeyEncryptingKeyIdent");
    if ( !v17 || *(_DWORD *)v17 != 3 )
      goto LABEL_30;
    qword_94F50 = *(_QWORD *)(v17 + 8);
    if ( sub_1BDDD(*(_QWORD *)(v15 + 24), (unsigned int *)&v47, (__int64)&v48, a5, a6, a7, a8) )
    {
      sub_1B950((char *)&v48 + 4, (char *)&dword_94F58, 0x84ui64);
LABEL_68:
      if ( !(qword_96AA8 & 0x80000) )
        sub_1DE44(a5, a6, a7, a8);
      goto LABEL_72;
    }
  }
  if ( qword_96AA8 & 0x80000 )
  {
    v19 = sub_B3CF(1);
    if ( v19 )
    {
      if ( qword_94FE8 )
      {
        v48 = (__int64 *)-6148914691236517206i64;
        if ( (*(__int64 (__fastcall **)(__int64, __int64 *))(qword_96CD8 + 152))(v19, qword_92CF0) >= 0
          && v48
          && ((__int64 (__fastcall *)(__int64 *, __int64, __int64))v48[2])(v48, qword_94FE0, qword_94FE8) >= 0 )
        {
          v18 = "[EB|#CS:SLW] AUVWV\n";
          goto LABEL_71;
        }
      }
    }
    if ( v19 )
    {
      v49 = 0i64;
      v48 = 0i64;
      if ( !(unsigned int)sub_1D4EF(v19, 0i64, (__int64 *)&v48, (__int64)&qword_94F40, 0i64) )
      {
        v18 = "[EB|#CS:SLW] AUV\n";
        goto LABEL_71;
      }
    }
    if ( qword_94FE8 )
    {
      sub_F1B0(qword_94FE8, qword_94FE0);
      (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(qword_94FE8);
      qword_94FE8 = 0i64;
      qword_94FE0 = (unsigned __int8)qword_94FE8;
    }
  }
  else if ( dword_94F58 && (unsigned __int8)sub_1DE44(a5, a6, a7, a8) )
  {
    v18 = "[EB|#CS:SLW] UVs\n";
LABEL_71:
    sub_1A2B6(1, (__int64)v18, a3, a4);
    *v9 = 1;
LABEL_72:
    if ( v57 )
      (*(void (**)(void))(qword_96CD8 + 72))();
    return 0i64;
  }
LABEL_30:
  *v9 = 0;
  sub_C2C4(1, v8, a3, a4);
  sub_D39E();
  v21 = qword_96AA8;
  v22 = sub_1DFC6;
  if ( !_bittest((const signed int *)&v21, 0x13u) )
    v22 = sub_1E09C;
  v51 = v22;
  v52 = (qword_96AA8 << 44 >> 63) & (unsigned __int64)sub_1DFE7;
  v53 = &qword_94F40;
  v56 = sub_1E195;
  v57 = 0i64;
  v23 = ((unsigned int)qword_96AA8 >> 10) & 8;
  v24 = v23 + 4;
  v25 = v23 | 0x44;
  if ( !byte_96B48 )
    v25 = v24;
  if ( qword_96AE8 )
  {
    v26 = _bittest((const signed int *)&v21, 0x13u);
    v48 = (__int64 *)-6148914691236517206i64;
    v47 = 0i64;
    if ( v26 )
      v27 = sub_B59D(*(_QWORD *)(qword_96A98 + 24), *(_QWORD *)(qword_96A98 + 32), &v48, &v47);
    else
      v27 = sub_1EF8A(qword_96AD8, &v48, &v47);
    if ( v27 >= 0 )
    {
      (*(void (__fastcall **)(__int64 *))(qword_96CD8 + 224))(v48);
      if ( qword_96AA8 & 0x40 )
      {
        v29 = sub_FE80();
        v30 = v25 | 0x10;
        if ( !v29 )
          v30 = v25;
        v28 = v30;
      }
      else
      {
        v28 = v25 | 0x10;
      }
      v25 = v28 | 0x20;
      v57 = v47;
    }
    v21 = qword_96AA8;
  }
  v50 = 0i64;
  v59 = -1431655766;
  qword_96AA8 = v21 | 0x400000;
  sub_1A2B6(1, (__int64)"[EB|`CS:UFVK] LWLO: 0x%02x\n", v25, v20);
  sub_1905F((__int64)"Start LoginWindow Initialize");
  v31 = sub_24B90(&v58, v11, v10, qword_96AE8, dword_94FF0, qword_95010, &qword_96C20, v25, &v51);
  sub_1905F((__int64)"End LoginWindow Initialize");
  if ( v31 >= 0 )
  {
    v48 = qword_95018;
    sub_1905F((__int64)"Start EfiLibNamedEventSignal for gAppleEfiLoginWindowEnterGuid");
    sub_24047((__int64)&dword_927D4);
    sub_1905F((__int64)"End EfiLibNamedEventSignal for gAppleEfiLoginWindowEnterGuid");
    sub_1A2B6(1, (__int64)"[EB|#LW+]\n", v32, v33);
    v31 = sub_257CF(v58, (char **)&v48);
    sub_1A2B6(1, (__int64)"[EB|#LW-] %r\n", v31, v34);
    sub_1905F((__int64)"Start EfiLibNamedEventSignal for gAppleEfiLoginWindowExitGuid");
    sub_24047((__int64)&dword_927E4);
    sub_1905F((__int64)"End EfiLibNamedEventSignal for gAppleEfiLoginWindowExitGuid");
    if ( v31 < 0 )
      return v31;
    sub_2580F(v58);
    if ( byte_95030 == 1
      && *(_DWORD *)v48 != 3
      && (*(__int64 (__fastcall **)(const __int16 *, int *, signed __int64, _QWORD, _QWORD))(qword_96CE0 + 88))(
           L"BootNext",
           &dword_92004,
           7i64,
           0i64,
           0i64) >= 0 )
    {
      sub_1D3D6(0i64, 0i64, 0);
      byte_95030 = 0;
      sub_1A2B6(1, (__int64)"[EB|#CS:RB-ONCE-]\n", v36, v37);
    }
    if ( v57 )
    {
      (*(void (**)(void))(qword_96CD8 + 72))();
      v57 = 0i64;
    }
    sub_1A2B6(1, (__int64)"[EB|`CS:UFVK] LWES: %d\n", *(unsigned int *)v48, v35);
    switch ( *(_DWORD *)v48 )
    {
      case 2:
        sub_16FB7((__int64)off_1DE30, v38, v39, v40);
        v41 = 29;
        goto LABEL_64;
      case 3:
        sub_1000(7u);
        sub_1D3D6((__int64)"guest", 5i64, 7u);
        sub_2724(64, 0i64, 27);
        sub_5ABA(0);
        v43 = 3i64;
        goto LABEL_67;
      case 4:
        (*(void (__fastcall **)(const __int16 *, __int64 *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
          L"boot-image",
          qword_92360,
          0i64,
          0i64,
          0i64);
        sub_2724(0, 0i64, 28);
        v44 = 1;
        v45 = 4;
        goto LABEL_65;
      case 5:
        sub_16FB7((__int64)off_1DE30, v38, v39, v40);
        v41 = 30;
LABEL_64:
        sub_2724(0, 0i64, v41);
        v44 = 2;
        v45 = 3;
LABEL_65:
        sub_52BA(v44, v45);
        break;
      case 6:
        sub_1D3D6((__int64)"fde-password-reset", 18i64, 7u);
        sub_2724(64, 0i64, 26);
        sub_5ABA(0);
        v43 = 6i64;
LABEL_67:
        sub_9CE0((__int64)"[EB|#STOP|`CS:UFVK] ?! @ B:RB (%d)\n", v43);
        break;
      default:
        goto LABEL_68;
    }
    goto LABEL_68;
  }
  sub_2724(0, v31, 31);
  if ( v31 == -9223372036854775798i64 )
  {
    v42 = (*(__int64 (__fastcall **)(const __int16 *, int *, unsigned int *, __int64 *, _QWORD))(qword_96CE0 + 72))(
            L"AAPL,PathProperties0000",
            &dword_91FF4,
            &v59,
            &v50,
            0i64);
    if ( v42 >= 0 || (v31 = v42, v42 == -9223372036854775803i64) )
    {
      v31 = (*(__int64 (__fastcall **)(const __int16 *, int *, _QWORD, _QWORD, _QWORD))(qword_96CE0 + 88))(
              L"AAPL,PathProperties0000",
              &dword_91FF4,
              v59,
              0i64,
              0i64);
      if ( v31 >= 0 )
        sub_52BA(0, 4u);
    }
  }
  return v31;
}
// 1D7C1: write access to const memory at 94F50 has been detected
// 1D8FE: write access to const memory at 94FE8 has been detected
// 1D905: write access to const memory at 94FE0 has been detected
// 1DA51: write access to const memory at 96AA8 has been detected
// 1DBC7: write access to const memory at 95030 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 1DE30: using guessed type void *__ptr32 off_1DE30[5];
// 411B0: using guessed type __int16 aBootnext[9];
// 412E8: using guessed type __int16 aAaplPathproper[24];
// 41318: using guessed type __int16 aBootImage[11];
// 91FF4: using guessed type int dword_91FF4;
// 92004: using guessed type int dword_92004;
// 92360: using guessed type __int64 qword_92360[2];
// 927D4: using guessed type int dword_927D4;
// 927E4: using guessed type int;
// 92CF0: using guessed type __int64 qword_92CF0[2];
// 94F40: using guessed type __int64 qword_94F40;
// 94F50: using guessed type __int64 qword_94F50;
// 94F58: using guessed type int dword_94F58;
// 94FE0: using guessed type __int64 qword_94FE0;
// 94FE8: using guessed type __int64 qword_94FE8;
// 94FF0: using guessed type int dword_94FF0;
// 94FF8: using guessed type __int64 qword_94FF8;
// 95010: using guessed type __int64 qword_95010;
// 95018: using guessed type __int64 qword_95018[2];
// 95030: using guessed type char byte_95030;
// 96A98: using guessed type __int64 qword_96A98;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AD8: using guessed type __int64 qword_96AD8;
// 96AE8: using guessed type __int64 qword_96AE8;
// 96B48: using guessed type char byte_96B48;
// 96C20: using guessed type __int64 qword_96C20;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000001DE44) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __usercall sub_1DE44@<rax>(__m128i *a1@<xmm1>, __m128i *a2@<xmm2>, __m128i *a3@<xmm6>, __m128i *a4@<xmm7>)
{
  unsigned __int64 v4; // rsi
  unsigned int v5; // er13
  _DWORD *v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // r15
  __int64 v10; // r14
  __int64 v11; // rax

  qword_95038 = sub_1364F(144i64 * (unsigned int)dword_95008);
  if ( dword_95008 )
  {
    v4 = 0i64;
    v5 = 0;
    do
    {
      v6 = (_DWORD *)sub_12D9A(qword_95000, v4);
      if ( v6 )
      {
        v7 = (__int64)v6;
        if ( *v6 == 1 )
        {
          v8 = sub_124B2((__int64)v6, "KeyEncryptingKeyIdent");
          if ( v8 )
          {
            v9 = v8;
            if ( *(_DWORD *)v8 == 3
              && (!qword_94F50 || !(unsigned int)sub_18A1A((char *)qword_94F50, *(_BYTE **)(v8 + 8))) )
            {
              v10 = sub_124B2(v7, "KEKWrappedVolumeKeyStruct");
              v11 = sub_124B2(v7, "WrapVersion");
              if ( v10 )
              {
                if ( v11 )
                {
                  if ( *(_DWORD *)v10 == 5 && *(_DWORD *)v11 == 4 && *(_QWORD *)(v11 + 16) == 1i64 )
                  {
                    if ( sub_1BDDD(
                           *(_QWORD *)(v10 + 24),
                           (unsigned int *)&dword_94F58,
                           qword_95038 + 144i64 * (unsigned int)dword_95034 + 8,
                           a1,
                           a2,
                           a3,
                           a4) )
                    {
                      *(_QWORD *)(qword_95038 + 144i64 * (unsigned int)++dword_95034) = v7;
                      LOBYTE(v5) = 1;
                      if ( !qword_94F50 )
                        qword_94F50 = *(_QWORD *)(v9 + 8);
                    }
                  }
                }
              }
            }
          }
        }
      }
      ++v4;
    }
    while ( v4 < (unsigned int)dword_95008 );
  }
  else
  {
    v5 = 0;
  }
  return v5;
}
// 1DE6A: write access to const memory at 95038 has been detected
// 1DF71: write access to const memory at 95034 has been detected
// 1DF94: write access to const memory at 94F50 has been detected
// 94F50: using guessed type __int64 qword_94F50;
// 94F58: using guessed type int dword_94F58;
// 95000: using guessed type __int64 qword_95000;
// 95008: using guessed type int dword_95008;
// 95034: using guessed type int dword_95034;
// 95038: using guessed type __int64 qword_95038;

//----- (000000000001DFC6) ----------------------------------------------------
bool __fastcall sub_1DFC6(__int64 a1, char **a2, _WORD *a3, char **a4)
{
  return (unsigned int)sub_1DFE7(a1, a2, a3, a4, 0i64) == 0;
}

//----- (000000000001DFE7) ----------------------------------------------------
__int64 __fastcall sub_1DFE7(__int64 a1, char **a2, _WORD *a3, char **a4, _DWORD *a5)
{
  unsigned int v5; // esi
  char **v6; // rdi
  _WORD *v7; // rbx
  char **v8; // r14
  __int64 v9; // rax
  unsigned int v10; // eax
  char *v11; // rax
  __int64 v13; // [rsp+28h] [rbp-38h]
  __int64 v14; // [rsp+30h] [rbp-30h]
  __int64 v15; // [rsp+38h] [rbp-28h]

  v13 = -6148914691236517206i64;
  v14 = -6148914691236517206i64;
  v15 = 0i64;
  v5 = 1;
  if ( a4 )
  {
    v6 = a4;
    v7 = a3;
    v8 = a2;
    sub_11070(*a2, &v13);
    v9 = sub_B3CF(1);
    if ( v9 )
    {
      v10 = sub_1D4EF(v9, (__int64)v7, &v13, (__int64)v6, &v15);
      if ( v10 )
      {
        if ( a5 )
        {
          v5 = v10;
          if ( v10 == 2 )
          {
            *a5 = v15;
            v5 = 2;
          }
        }
        else
        {
          v5 = v10;
        }
      }
      else
      {
        v11 = sub_71CF(v7);
        if ( v11 )
        {
          *v6 = *v8;
          v6[1] = v11;
          v5 = 0;
        }
      }
    }
  }
  return v5;
}

//----- (000000000001E09C) ----------------------------------------------------
__int64 __usercall sub_1E09C@<rax>(_QWORD *a1@<rdx>, unsigned int a2@<esi>, _WORD *a3@<r8>, __int64 a4@<r9>, __m128i *a5@<xmm1>, __m128i *a6@<xmm2>, __m128i *a7@<xmm6>, __m128i *a8@<xmm7>)
{
  __int64 v8; // r12
  _QWORD *v9; // r14
  __int64 v10; // rdi
  __int64 *v11; // rax
  __int64 *v12; // rbx
  __int64 v13; // r15
  __int64 v14; // rax
  _DWORD *v15; // rax
  _DWORD *v16; // rdi
  unsigned int v17; // eax
  int v18; // eax

  LOBYTE(a2) = 1;
  if ( a4 )
  {
    v8 = a4;
    v9 = a1;
    v10 = a1[1];
    v11 = (__int64 *)sub_71CF(a3);
    if ( v11 )
    {
      v12 = v11;
      v13 = sub_124B2(v10, "PassphraseWrappedKEKStruct");
      v14 = sub_124B2(v10, "WrapVersion");
      if ( v13 )
      {
        if ( v14 )
        {
          if ( *(_DWORD *)v13 == 5 && *(_DWORD *)v14 == 4 && *(_QWORD *)(v14 + 16) == 1i64 )
          {
            v15 = (_DWORD *)sub_124B2(v10, "KeyEncryptingKeyIdent");
            if ( v15 )
            {
              v16 = v15;
              if ( *v15 == 3 )
              {
                v17 = sub_189FE(v12);
                if ( sub_1BBA2(v17, v12, *(char **)(v13 + 24), (char *)(v8 + 24), a5, a6, a7, a8) )
                {
                  *(_QWORD *)(v8 + 16) = *((_QWORD *)v16 + 1);
                  *(_QWORD *)(v8 + 8) = v12;
                  *(_QWORD *)v8 = *v9;
                  return a2;
                }
              }
            }
          }
        }
      }
      v18 = sub_189FE(v12);
      sub_F1B0(v12, v18);
      sub_136C5((__int64)v12);
    }
    a2 = 0;
  }
  return a2;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);

//----- (000000000001E195) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_BYTE *__fastcall sub_1E195(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  __int64 v4; // r8
  __int64 v5; // r9

  sub_1BEDE(0x81u, "R", a2, 0, 0i64);
  byte_95030 = 1;
  sub_1D3D6((__int64)"fde-recovery", 12i64, 7u);
  sub_1A2B6(1, (__int64)"NVRAM was configured to boot once from the Recovery OS.\n", v2, v3);
  return sub_1A2B6(1, (__int64)"[EB|#CS:RB-ONCE+]\n", v4, v5);
}
// 1E1BC: write access to const memory at 95030 has been detected
// 95030: using guessed type char byte_95030;

//----- (000000000001E202) ----------------------------------------------------
signed __int64 __fastcall sub_1E202(char **a1, __int64 *a2)
{
  __int64 *v2; // rsi
  char *v3; // rdx
  unsigned __int64 v4; // r8
  _QWORD *v5; // rdi
  char *v6; // rbx
  unsigned __int64 v7; // rax
  __int64 v8; // rdi
  __int64 v9; // r9
  __int64 v11; // [rsp+20h] [rbp-20h]

  v2 = a2;
  v11 = 0i64;
  v3 = (char *)qword_94FE8;
  if ( !qword_94FE8 )
    return 0i64;
  v4 = qword_94FE0;
  v11 = qword_94FE0;
  if ( !qword_94FE0 )
    return 0i64;
  v5 = a1;
  *v2 = qword_94FE0;
  if ( !a1 )
    return 0i64;
  v6 = *a1;
  if ( !*a1 )
  {
    v7 = sub_17500(&v11, 0i64);
    if ( !v7 )
      return -9223372036854775799i64;
    v6 = (char *)v7;
    *v5 = v7;
    v3 = (char *)qword_94FE8;
    v4 = *v2;
  }
  sub_1B930(v6, v3, v4);
  v8 = 0i64;
  sub_F180(&v6[*v2], 0, v11 - *v2);
  sub_1A2B6(1, (__int64)"[EB|`CS:PFAKD] S: %qd\n", *v2, v9);
  return v8;
}
// 94FE0: using guessed type __int64 qword_94FE0;
// 94FE8: using guessed type __int64 qword_94FE8;

//----- (000000000001E2B5) ----------------------------------------------------
__int64 sub_1E2B5()
{
  __int64 v0; // rax
  signed __int64 *v1; // rsi
  int v2; // eax
  __int64 v3; // r8
  __int64 v4; // r9
  char *v5; // rdi
  int v6; // eax

  if ( qword_96AA8 & 0x200 )
  {
    if ( qword_94F40 )
    {
      v0 = sub_A398();
      if ( v0 )
      {
        v1 = (signed __int64 *)v0;
        v2 = sub_189FE((_BYTE *)qword_94F40);
        sub_9EC7(v1, "efilogin-unlock-ident", v2 + 1, (char *)qword_94F40, 0);
        if ( qword_95028 )
        {
          v5 = *(char **)qword_95028;
          v6 = sub_189FE(*(_BYTE **)qword_95028);
          sub_9EC7(v1, "efilogin-reset-ident", v6 + 1, v5, 0);
        }
        sub_1A2B6(1, (__int64)"[EB|`CS:PFDTI]\n", v3, v4);
      }
    }
  }
  return 0i64;
}
// 94F40: using guessed type __int64 qword_94F40;
// 95028: using guessed type __int64 qword_95028;
// 96AA8: using guessed type __int64 qword_96AA8;

//----- (000000000001E360) ----------------------------------------------------
signed __int64 __fastcall sub_1E360(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // rsi
  unsigned __int64 *v3; // rdi
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rax
  unsigned int v7; // ebx
  signed __int64 v8; // rsi
  unsigned int v9; // eax
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // r15
  _DWORD *v13; // r14
  _BYTE *v14; // rdx
  __int64 v15; // r8
  __int64 v16; // r9
  char *v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  unsigned __int64 v21; // [rsp+20h] [rbp-30h]

  v2 = a2;
  v3 = a1;
  v21 = 0i64;
  if ( qword_96AA8 & 0x200 )
  {
    if ( qword_94F48 )
    {
      v4 = ((signed int)sub_189FE((_BYTE *)qword_94F48) + 55i64) & 0xFFFFFFFFFFFFFFF8ui64;
      v21 = v4;
    }
    else
    {
      v4 = 0i64;
    }
    if ( qword_94F50 )
    {
      v4 = ((unsigned int)dword_94F58 + v4 + 55) & 0xFFFFFFFFFFFFFFF8ui64;
      v21 = v4;
    }
  }
  else
  {
    v4 = 0i64;
  }
  if ( dword_96C48 )
  {
    v4 = ((unsigned int)dword_96C48 + v4 + 55) & 0xFFFFFFFFFFFFFFF8ui64;
    v21 = v4;
  }
  if ( !v4 )
  {
    v8 = 0i64;
    if ( !v3 )
      return v8;
    goto LABEL_29;
  }
  *v2 = v4;
  if ( v3 )
  {
    v5 = *v3;
    if ( !*v3 )
    {
      v6 = sub_17500((__int64 *)&v21, 0i64);
      if ( !v6 )
      {
        v8 = -9223372036854775799i64;
LABEL_29:
        sub_1E5B1();
        return v8;
      }
      v5 = v6;
      *v3 = v6;
    }
    if ( qword_96AA8 & 0x200 )
    {
      if ( qword_94F48 )
      {
        *(_QWORD *)(v5 + 4) = 2i64;
        sub_11070((char *)qword_94F40, (_BYTE *)(v5 + 12));
        sub_F180((char *)(v5 + 28), 0, 0x10ui64);
        v9 = sub_189FE((_BYTE *)qword_94F48);
        *(_DWORD *)(v5 + 44) = v9;
        sub_1B930((char *)(v5 + 48), (char *)qword_94F48, v9);
        v7 = (*(_DWORD *)(v5 + 44) + 55) & 0xFFFFFFF8;
        *(_DWORD *)v5 = v7;
        sub_1A2B6(1, (__int64)"[EB|`CS:PFCSKSD] U\n", v10, v11);
      }
      else
      {
        v7 = 0;
      }
      if ( qword_94F50 )
      {
        v12 = v7;
        v13 = (_DWORD *)(v5 + v7);
        v14 = (_BYTE *)(v5 + v7 + 12);
        *((_DWORD *)v14 - 2) = 1;
        sub_11070((char *)qword_94F50, v14);
        sub_F180((char *)(v5 + v7 + 28), 0, 0x10ui64);
        *(_DWORD *)(v5 + v12 + 8) = 2;
        *(_DWORD *)(v5 + v12 + 44) = dword_94F58;
        sub_1B930((char *)(v5 + v7 + 48), (char *)&dword_94F5C, (unsigned int)dword_94F58);
        v7 = (v7 + *(_DWORD *)(v5 + v7 + 44) + 55) & 0xFFFFFFF8;
        *(_DWORD *)(v5 + v12) = v7;
        sub_1A2B6(1, (__int64)"[EB|`CS:PFCSKSD] K\n", v15, v16);
LABEL_26:
        if ( dword_96C48 )
        {
          v13 = (_DWORD *)(v5 + v7);
          v17 = (char *)(v5 + v7 + 48);
          *(_QWORD *)(v17 - 44) = 8589934596i64;
          *((_DWORD *)v17 - 1) = dword_96C48;
          sub_1B930(v17, (char *)&dword_96C4C, (unsigned int)dword_96C48);
          sub_1A2B6(1, (__int64)"[EB|`CS:PFCSKSD] M\n", v18, v19);
        }
        *v13 = 0;
        v8 = 0i64;
        goto LABEL_29;
      }
    }
    else
    {
      v7 = 0;
    }
    v13 = (_DWORD *)v5;
    goto LABEL_26;
  }
  return 0i64;
}
// 94F40: using guessed type __int64 qword_94F40;
// 94F48: using guessed type __int64 qword_94F48;
// 94F50: using guessed type __int64 qword_94F50;
// 94F58: using guessed type int dword_94F58;
// 94F5C: using guessed type int dword_94F5C;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96C48: using guessed type int dword_96C48;
// 96C4C: using guessed type int dword_96C4C;

//----- (000000000001E5B1) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_1E5B1()
{
  signed __int64 v0; // rsi
  unsigned __int64 v1; // rdi
  int v2; // eax

  if ( dword_95034 )
  {
    v0 = 8i64;
    v1 = 0i64;
    do
    {
      sub_F1B0(v0 + qword_95038, 136i64);
      ++v1;
      v0 += 144i64;
    }
    while ( v1 < (unsigned int)dword_95034 );
  }
  dword_95034 = 0;
  if ( qword_95038 )
  {
    sub_136C5(qword_95038);
    qword_95038 = 0i64;
  }
  if ( qword_94F48 )
  {
    v2 = sub_189FE((_BYTE *)qword_94F48);
    sub_F1B0(qword_94F48, v2);
    sub_136C5(qword_94F48);
    qword_94F48 = 0i64;
  }
  if ( qword_94FE8 )
  {
    sub_F1B0(qword_94FE8, qword_94FE0);
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(qword_94FE8);
    qword_94FE8 = 0i64;
  }
  sub_F1B0(&dword_94F58, 132i64);
  return sub_F1B0(&dword_96C48, 132i64);
}
// 1E5F4: write access to const memory at 95034 has been detected
// 1E60F: write access to const memory at 95038 has been detected
// 1E645: write access to const memory at 94F48 has been detected
// 1E679: write access to const memory at 94FE8 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 94F48: using guessed type __int64 qword_94F48;
// 94F58: using guessed type int dword_94F58;
// 94FE0: using guessed type __int64 qword_94FE0;
// 94FE8: using guessed type __int64 qword_94FE8;
// 95034: using guessed type int dword_95034;
// 95038: using guessed type __int64 qword_95038;
// 96C48: using guessed type int dword_96C48;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000001E6AD) ----------------------------------------------------
unsigned int *__fastcall sub_1E6AD(_QWORD *a1, __int64 a2, unsigned int *a3)
{
  _DWORD *v3; // rsi
  char *v4; // rbx
  _QWORD *v5; // rdi
  signed __int64 v6; // r14
  __int64 v7; // r15
  unsigned __int64 v8; // r12
  __int64 v9; // rax
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rbx
  int v12; // er12
  __int64 v13; // r13
  unsigned __int8 v14; // cf
  unsigned __int64 v15; // rbx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  char *v19; // rdx
  char *v20; // rcx
  unsigned int v21; // eax
  unsigned int v22; // ecx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // [rsp+20h] [rbp-F0h]
  unsigned int v27; // [rsp+2Ch] [rbp-E4h]
  char v28; // [rsp+30h] [rbp-E0h]
  __int64 v29; // [rsp+B0h] [rbp-60h]
  __int64 v30; // [rsp+B8h] [rbp-58h]
  __int64 v31; // [rsp+C0h] [rbp-50h]
  char *v32; // [rsp+C8h] [rbp-48h]
  unsigned int *v33; // [rsp+D0h] [rbp-40h]

  v3 = a3;
  v4 = (char *)a2;
  v5 = a1;
  v29 = -6148914691236517206i64;
  v30 = -6148914691236517206i64;
  if ( qword_96AA8 & 0x80000 )
  {
    v10 = *a3;
    if ( qword_94FE0 >= v10 )
    {
      if ( qword_94FE0 > v10 )
      {
        v6 = -9223372036854775803i64;
        if ( (unsigned __int64)qword_94FE0 >= 0x18 && *(_DWORD *)qword_94FE8 == 1097225794 )
        {
          if ( *(_DWORD *)(qword_94FE8 + 4) )
          {
            v33 = (unsigned int *)-9223372036854775791i64;
            v32 = (char *)a2;
            v11 = 24i64;
            v12 = 0;
            while ( 1 )
            {
              v13 = v11 + qword_94FE8;
              if ( __CFADD__(v11, qword_94FE8) )
                break;
              v14 = __CFADD__(v11, 20i64);
              v15 = v11 + 20;
              if ( v14 )
                break;
              if ( v15 > qword_94FE0 )
                break;
              v16 = *(unsigned int *)(v13 + 16);
              v14 = __CFADD__(v16, v15);
              v11 = v16 + v15;
              if ( v14 || v11 > qword_94FE0 )
                break;
              if ( !sub_236BB(v5, (_QWORD *)v13, 16i64) )
              {
                sub_1A2B6(1, (__int64)"[EB|#CS:FVKRO]\n", v17, v18);
                v24 = (unsigned int)*v3;
                v25 = *(unsigned int *)(v13 + 16);
                if ( (unsigned int)v24 < (unsigned int)v25 )
                {
                  sub_1A2B6(1, (__int64)"[EB|`CS:LFVKFR] ! @ 'SZ (%d < %d)\n", v24, v25);
                  return (unsigned int *)v6;
                }
                v20 = v32;
                v19 = (char *)(v13 + 20);
                v10 = *(unsigned int *)(v13 + 16);
                goto LABEL_26;
              }
              if ( (unsigned int)++v12 >= *(_DWORD *)(qword_94FE8 + 4) )
                return v33;
            }
          }
          else
          {
            v6 = -9223372036854775791i64;
          }
        }
        return (unsigned int *)v6;
      }
    }
    else
    {
      *v3 = qword_94FE0;
      v10 = (unsigned int)qword_94FE0;
    }
    v19 = (char *)qword_94FE8;
    v20 = v4;
LABEL_26:
    sub_1B930(v20, v19, v10);
    return 0i64;
  }
  v6 = -9223372036854775791i64;
  if ( dword_95034 )
  {
    v33 = a3;
    v32 = (char *)a2;
    v31 = -9223372036854775791i64;
    v7 = 0i64;
    v8 = 0i64;
    while ( 1 )
    {
      sub_1B930((char *)&v26, (char *)qword_8FC90, 0x90ui64);
      sub_1B930((char *)&v26, (char *)(v7 + qword_95038), 0x90ui64);
      v9 = sub_124B2(v26, "VolumeKeyIdent");
      sub_11070(*(char **)(v9 + 8), &v29);
      if ( !sub_236BB(v5, &v29, 16i64) )
        break;
      ++v8;
      v7 += 144i64;
      if ( v8 >= (unsigned int)dword_95034 )
        return (unsigned int *)v31;
    }
    v21 = *v33;
    v22 = v27;
    if ( *v33 > v27 )
    {
      *v33 = v27;
      v21 = v22;
    }
    v19 = &v28;
    v10 = v21;
    v20 = v32;
    goto LABEL_26;
  }
  return (unsigned int *)v6;
}
// 8FC90: using guessed type __int64 qword_8FC90[18];
// 94FE0: using guessed type __int64 qword_94FE0;
// 94FE8: using guessed type __int64 qword_94FE8;
// 95034: using guessed type int dword_95034;
// 95038: using guessed type __int64 qword_95038;
// 96AA8: using guessed type __int64 qword_96AA8;

//----- (000000000001E8F2) ----------------------------------------------------
__int64 __fastcall sub_1E8F2(__int64 a1)
{
  __int64 v2; // [rsp+28h] [rbp-8h]

  v2 = a1;
  return (*(__int64 (__fastcall **)(__int64 *, char *, __int64 *, _QWORD))(qword_96CD8 + 328))(
           &v2,
           &byte_927A8,
           &qword_927B8,
           0i64);
}
// 927A8: using guessed type char byte_927A8;
// 927B8: using guessed type __int64 qword_927B8;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000001E928) ----------------------------------------------------
__int64 __usercall sub_1E928@<rax>(__int64 a1@<rcx>, unsigned int a2@<esi>)
{
  int v2; // ebx
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v7; // [rsp+20h] [rbp-30h]
  __int64 v8; // [rsp+28h] [rbp-28h]

  v2 = *(unsigned __int16 *)(a1 + 90);
  v7 = -6148914691236517206i64;
  v8 = -6148914691236517206i64;
  if ( *(_BYTE *)(a1 + 10) != 16 )
    return 0;
  v3 = a1;
  if ( *(_BYTE *)(a1 + 11) || *(_WORD *)(a1 + 88) != 21315 )
    return 0;
  v4 = 0i64;
  do
  {
    *((_BYTE *)&v7 + v4) = *(_BYTE *)(a1 + v4);
    ++v4;
  }
  while ( v4 != 8 );
  LOBYTE(a2) = 1;
  if ( (_WORD)v2 )
  {
    if ( (_WORD)v2 == 1 )
    {
      sub_17D0C(v2, (__int64)&v8);
      sub_17D26(v2, v3 + 8, 504i64, (unsigned int *)&v8);
      v5 = 0i64;
      while ( *((_BYTE *)&v7 + v5) == *((_BYTE *)&v8 + v5) )
      {
        if ( (unsigned __int64)++v5 > 7 )
          return a2;
      }
    }
    return 0;
  }
  return a2;
}

//----- (000000000001E9D0) ----------------------------------------------------
signed __int64 __fastcall sub_1E9D0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  signed __int64 result; // rax

  result = -9223372036854775806i64;
  if ( a2 )
  {
    if ( a3 )
    {
      *a2 = qword_94FE0;
      *a3 = qword_94FE8;
      result = 0i64;
    }
  }
  return result;
}
// 94FE0: using guessed type __int64 qword_94FE0;
// 94FE8: using guessed type __int64 qword_94FE8;

//----- (000000000001EA00) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_1EA00(__int64 a1, unsigned __int64 a2, char *a3)
{
  qword_94F50 = (__int64)"7C37D7E6-A6F1-420F-A5BD-F81358CCB3D5";
  dword_94F58 = a2;
  sub_1B930((char *)&dword_94F5C, a3, a2);
  return 0i64;
}
// 1EA12: write access to const memory at 94F50 has been detected
// 1EA19: write access to const memory at 94F58 has been detected
// 94F50: using guessed type __int64 qword_94F50;
// 94F58: using guessed type int dword_94F58;
// 94F5C: using guessed type int dword_94F5C;

//----- (000000000001EA39) ----------------------------------------------------
signed __int64 __usercall sub_1EA39@<rax>(int a1@<ecx>, unsigned int *a2@<r8>, unsigned int a3@<r9d>, __m128 *a4@<xmm0>, __m128i *a5@<xmm7>, unsigned int *a6, int a7, int a8, __int64 a9, _DWORD *a10)
{
  signed __int64 result; // rax
  unsigned int v11; // edi
  int v12; // er14

  result = 16i64;
  if ( a2 )
  {
    if ( a6 )
    {
      if ( a10 )
      {
        v11 = a3;
        v12 = a1;
        result = sub_1EAA3(a3, a2, a10, a4, a5);
        if ( !(_DWORD)result )
        {
          result = sub_1EAA3(v11, a6, a10 + 122, a4, a5);
          if ( !(_DWORD)result )
          {
            a10[244] = v12;
            result = 0i64;
          }
        }
      }
    }
  }
  return result;
}

//----- (000000000001EAA3) ----------------------------------------------------
signed __int64 __usercall sub_1EAA3@<rax>(unsigned int a1@<edx>, unsigned int *a2@<rcx>, _DWORD *a3@<r8>, __m128 *a4@<xmm0>, __m128i *a5@<xmm7>)
{
  signed __int64 result; // rax
  signed int v6; // edi
  unsigned int *v7; // rbx
  unsigned __int64 v8; // rcx
  signed __int64 v9; // rdx
  _DWORD *v10; // rsi
  int v11; // eax
  int v12; // ecx
  int v13; // eax

  result = 3i64;
  if ( a1 <= 0x20 )
  {
    v6 = a1;
    v7 = a2;
    v8 = a1;
    v9 = 4311810048i64;
    if ( _bittest64(&v9, v8) )
    {
      v10 = a3;
      sub_3B0E(v6, v7, (__int64)(a3 + 61), a4);
      v12 = v11;
      result = 1i64;
      if ( !v12 )
      {
        sub_4067(v6, v7, v10, a5);
        result = v13 != 0;
      }
    }
  }
  return result;
}

//----- (000000000001EB0D) ----------------------------------------------------
signed __int64 __fastcall sub_1EB0D(__m128i *a1, unsigned __int64 a2, __m128i *a3, __int64 a4, __int64 a5)
{
  signed __int64 result; // rax
  __m128i *v6; // r12
  char v7; // di
  unsigned __int64 v8; // rsi
  __m128i *v9; // rbx
  int v10; // ecx
  __int64 v11; // rdi
  __int64 v12; // rsi
  signed __int64 v13; // rsi
  __int64 v14; // rax
  __int64 v15; // [rsp+30h] [rbp-60h]
  __int64 v16; // [rsp+38h] [rbp-58h]
  __int64 v17; // [rsp+40h] [rbp-50h]
  __int64 v18; // [rsp+48h] [rbp-48h]
  __int64 v19; // [rsp+50h] [rbp-40h]
  __int64 v20; // [rsp+58h] [rbp-38h]

  v15 = -6148914691236517206i64;
  v16 = -6148914691236517206i64;
  v17 = -6148914691236517206i64;
  v18 = -6148914691236517206i64;
  v19 = -6148914691236517206i64;
  v20 = -6148914691236517206i64;
  result = 1i64;
  if ( a1 )
  {
    v6 = a3;
    if ( a3 )
    {
      if ( a4 && a5 )
      {
        v7 = a2;
        v8 = a2 >> 4;
        if ( a2 >> 4 )
        {
          v9 = a1;
          v10 = sub_31B4();
          result = 3i64;
          if ( !v10 )
          {
            v11 = v7 & 0xF;
            v12 = v8 - (v11 != 0);
            if ( v12 )
            {
              sub_212D0(v9, v6, (__m128i *)&v19, a5);
              v13 = 16 * v12;
              v9 = (__m128i *)((char *)v9 + v13);
              v6 = (__m128i *)((char *)v6 + v13);
            }
            if ( !v11 )
              goto LABEL_19;
            sub_1B930((char *)&v17, (char *)&v19, 0x10ui64);
            sub_20A40((__m128i *)&v17);
            result = sub_21220(v9, (__m128i *)&v15, (__m128i *)&v17);
            if ( !(_DWORD)result )
            {
              v14 = 0i64;
              do
              {
                *((_BYTE *)&v17 + v14) = v9[1].m128i_i8[v14];
                v6[1].m128i_i8[v14] = *((_BYTE *)&v15 + v14);
                ++v14;
              }
              while ( v11 != v14 );
              do
              {
                *((_BYTE *)&v17 + v11) = *((_BYTE *)&v15 + v11);
                ++v11;
              }
              while ( v11 != 16 );
              result = sub_21220((__m128i *)&v17, v6, (__m128i *)&v19);
              if ( !(_DWORD)result )
LABEL_19:
                result = 0i64;
            }
          }
        }
        else
        {
          result = 16i64;
        }
      }
    }
  }
  return result;
}

//----- (000000000001EC69) ----------------------------------------------------
__int64 __fastcall sub_1EC69(char *a1)
{
  char *v1; // rsi
  __int64 result; // rax

  if ( a1 )
  {
    v1 = a1;
    sub_F180(a1, 0, 0x1E8ui64);
    result = sub_F180(v1 + 488, 0, 0x1E8ui64);
  }
  return result;
}

//----- (000000000001ECA5) ----------------------------------------------------
signed __int64 __fastcall sub_1ECA5(__int64 a1)
{
  char v1; // al

  while ( 1 )
  {
    v1 = *(_BYTE *)a1 & 0x7F;
    if ( v1 == 4 )
      break;
    if ( v1 == 127 && *(_BYTE *)(a1 + 1) == -1 )
      return 0xFFFFFFFFi64;
LABEL_8:
    a1 += *(unsigned __int16 *)(a1 + 2);
  }
  if ( *(_BYTE *)(a1 + 1) != 1 || *(_BYTE *)(a1 + 40) != 2 || *(_BYTE *)(a1 + 41) != 2 )
    goto LABEL_8;
  return *(unsigned int *)(a1 + 4);
}

//----- (000000000001ECEF) ----------------------------------------------------
__int64 __fastcall sub_1ECEF(__int64 a1, int a2)
{
  int v2; // er14
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rsi
  __int64 v6; // rcx
  unsigned __int64 v7; // r15
  __int64 v8; // rax
  __int64 v9; // rcx
  unsigned __int64 v10; // r13
  __int64 v11; // r14
  __int64 v12; // rbx
  unsigned __int8 v13; // al
  unsigned __int8 v14; // cl
  _BYTE *v15; // rax
  int v16; // eax
  __int64 v18; // [rsp+28h] [rbp-88h]
  __int64 v19; // [rsp+30h] [rbp-80h]
  __int64 v20; // [rsp+38h] [rbp-78h]
  __int64 v21; // [rsp+40h] [rbp-70h]
  unsigned __int64 v22; // [rsp+48h] [rbp-68h]
  __int64 v23; // [rsp+50h] [rbp-60h]
  __int64 v24; // [rsp+58h] [rbp-58h]
  unsigned __int64 v25; // [rsp+60h] [rbp-50h]
  int v26; // [rsp+6Ch] [rbp-44h]
  __int64 v27; // [rsp+70h] [rbp-40h]

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  if ( (*(__int64 (__fastcall **)(signed __int64, __int64 *, _QWORD))(qword_96CD8 + 312))(2i64, qword_92A60, 0i64) >= 0
    && v22 )
  {
    if ( v3 )
    {
      v5 = 0i64;
      v6 = v3;
      while ( (*(_BYTE *)v6 & 0x7F) != 127 || *(_BYTE *)(v6 + 1) != -1 )
      {
        --v5;
        v6 += *(unsigned __int16 *)(v6 + 2);
        if ( !v6 )
          goto LABEL_10;
      }
      if ( v5 )
      {
LABEL_10:
        v23 = v3;
        v26 = v2;
        v20 = -v5;
        v25 = -v5 - 1;
        v7 = 0i64;
        do
        {
          v27 = *(_QWORD *)(v21 + 8 * v7);
          v24 = sub_23D7F(v27);
          if ( v24 )
          {
            v8 = 0i64;
            v9 = v24;
            do
            {
              if ( (*(_BYTE *)v9 & 0x7F) == 127 && *(_BYTE *)(v9 + 1) == -1 )
                break;
              ++v8;
              v9 += *(unsigned __int16 *)(v9 + 2);
            }
            while ( v9 );
            if ( v8 == v20 )
            {
              if ( v25 )
              {
                v10 = 1i64;
                v11 = v24;
                v12 = v23;
                do
                {
                  v13 = *(_BYTE *)(v12 + 2);
                  v14 = *(_BYTE *)(v12 + 3);
                  if ( *(unsigned __int16 *)(v12 + 2) != *(unsigned __int16 *)(v11 + 2) )
                    break;
                  if ( (*(_BYTE *)v12 & 0x7F) == 3 && *(_BYTE *)(v12 + 1) == 10 )
                  {
                    v19 = 5605573624590294191i64;
                    v18 = 1286059769157115316i64;
                    if ( sub_23695(v12 + 4, (__int64)&v18)
                      && (*(_QWORD *)(v12 + 24) != *(_QWORD *)(v11 + 24)
                       || *(_QWORD *)(v12 + 32) != *(_QWORD *)(v11 + 32)
                       || *(_WORD *)(v12 + 42) != *(_WORD *)(v11 + 42)) )
                    {
                      break;
                    }
                    v13 = *(_BYTE *)(v12 + 2);
                    v14 = *(_BYTE *)(v12 + 3);
                  }
                  if ( sub_236BB((_QWORD *)v12, (_QWORD *)v11, v13 | ((unsigned __int64)v14 << 8)) )
                    break;
                  v15 = (_BYTE *)(v12 + *(unsigned __int16 *)(v12 + 2));
                  if ( (*v15 & 0x7F) == 127 && v15[1] == -1 )
                    goto LABEL_37;
                  v11 += *(unsigned __int8 *)(v11 + 2) | ((unsigned __int64)*(unsigned __int8 *)(v11 + 3) << 8);
                  if ( (*(_BYTE *)v11 & 0x7F) == 127 )
                  {
                    if ( v10 >= v25 || *(_BYTE *)(v11 + 1) == -1 )
                      goto LABEL_37;
                  }
                  else if ( v10 >= v25 )
                  {
                    goto LABEL_37;
                  }
                  ++v10;
                  v12 += *(unsigned __int16 *)(v12 + 2);
                }
                while ( v15 );
              }
              else
              {
LABEL_37:
                v16 = sub_1ECA5(v24);
                if ( v16 != -1 && v16 == v26 )
                  goto LABEL_41;
              }
            }
          }
          ++v7;
        }
        while ( v7 < v22 );
      }
    }
    v27 = 0i64;
LABEL_41:
    if ( v21 )
      (*(void (**)(void))(qword_96CD8 + 72))();
    v4 = v27;
  }
  return v4;
}
// 92A60: using guessed type __int64 qword_92A60[2];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000001EF8A) ----------------------------------------------------
signed __int64 __fastcall sub_1EF8A(__int64 a1, _QWORD *a2, __int64 *a3)
{
  __int64 *v3; // r12
  _QWORD *v4; // r13
  signed __int64 v5; // rsi
  int v6; // eax
  __int64 v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rax
  bool v15; // zf
  char *v16; // r14
  __int64 v17; // r15
  __int64 v18; // rbx
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rdi
  char *v22; // rdi
  __int64 v23; // rax
  __int64 v24; // rax
  signed __int64 v25; // rax
  __int64 v26; // r9
  __int64 v27; // rax
  __int64 v28; // r14
  __int64 v29; // rax
  __int64 v30; // r9
  __int64 v31; // rbx
  __int64 v32; // r9
  const char *v33; // rdx
  const char *v34; // rdx
  __int64 v36; // [rsp+38h] [rbp-88h]
  char *v37; // [rsp+40h] [rbp-80h]
  __int64 v38; // [rsp+48h] [rbp-78h]
  __int64 v39; // [rsp+50h] [rbp-70h]
  __int64 v40; // [rsp+58h] [rbp-68h]
  __int64 v41; // [rsp+60h] [rbp-60h]
  __int64 v42; // [rsp+68h] [rbp-58h]
  __int64 v43; // [rsp+70h] [rbp-50h]
  __int64 v44; // [rsp+78h] [rbp-48h]
  unsigned __int64 v45; // [rsp+80h] [rbp-40h]

  v3 = a3;
  v4 = a2;
  v5 = -9223372036854775794i64;
  v44 = 0i64;
  v45 = 0i64;
  v6 = sub_1ECA5(a1);
  if ( v6 == -1 )
    return v5;
  v7 = sub_1ECEF(qword_96AD8, (~BYTE1(qword_96AA8) & 1u) + v6);
  if ( !v7 )
  {
    sub_1A2B6(1, (__int64)"[EB|`V:FRB] ! @ V:FP\n", v8, v9);
    return v5;
  }
  v10 = sub_23D7F(v7);
  v11 = sub_ADC4(v10, "\\");
  if ( (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD, _QWORD *))(qword_96CD8 + 200))(
         0i64,
         qword_96A90,
         v11,
         0i64,
         0i64,
         v4) >= 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|#V:RP] %D\n", v11, v13);
    if ( v3 )
      *v3 = v11;
    return 0i64;
  }
  if ( !(qword_96AA8 & 0x100) )
  {
    sub_1A2B6(1, (__int64)"[EB|`V:FRB] %r @ 'BR\n", -9223372036854775794i64, v13);
    return v5;
  }
  sub_C2C4(1, 0, v12, v13);
  if ( (*(__int64 (__fastcall **)(signed __int64, __int64 *, _QWORD, unsigned __int64 *, __int64 *))(qword_96CD8 + 312))(
         2i64,
         qword_92A60,
         0i64,
         &v45,
         &v44) >= 0 )
  {
    if ( v45 )
    {
      v14 = sub_11012("Root UUID");
      if ( v14 )
      {
        v37 = (char *)v14;
        v15 = v45 == 0;
        *v4 = 0i64;
        if ( v15 )
          goto LABEL_46;
        v16 = "\\";
        v17 = 0i64;
        while ( 1 )
        {
          v18 = *(_QWORD *)(v44 + 8 * v17);
          if ( !v18 )
            goto LABEL_39;
          v19 = sub_23D7F(*(_QWORD *)(v44 + 8 * v17));
          v20 = sub_ADC4(v19, v16);
          if ( !v20 )
            goto LABEL_39;
          v21 = v20;
          if ( (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, _QWORD, _QWORD, _QWORD *))(qword_96CD8 + 200))(
                 0i64,
                 qword_96A90,
                 v20,
                 0i64,
                 0i64,
                 v4) < 0 )
            goto LABEL_39;
          v36 = v21;
          v22 = v16;
          v38 = -6148914691236517206i64;
          v39 = -6148914691236517206i64;
          v40 = 0i64;
          v41 = 0i64;
          v42 = 0i64;
          v43 = 0i64;
          v23 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(v18, qword_92B40, &v38);
          if ( v23 < 0 )
            break;
          v24 = (*(__int64 (__fastcall **)(__int64, __int64 *))(v38 + 8))(v38, &v39);
          if ( v24 < 0 )
          {
            v28 = v24;
            v33 = "[EB|`V:CU] %r @ %g.OV\n";
            goto LABEL_28;
          }
          v25 = sub_5310(v39, &v40);
          if ( v25 < 0 )
          {
            v28 = v25;
            v34 = "[EB|`V:CU] %r @ B:FRPS\n";
LABEL_32:
            sub_1A2B6(1, (__int64)v34, v28, v26);
            goto LABEL_33;
          }
          v27 = sub_10310(qword_96AE0, v40, (__int64)"L", (__int64)&v41, &v42);
          if ( v27 < 0 )
          {
            v28 = v27;
            v34 = "[EB|`V:CU] %r @ OPT:LXF!\n";
            goto LABEL_32;
          }
          v28 = sub_12DC6(v42, &v43);
          if ( v28 < 0 )
          {
            v34 = "[EB|`V:CU] %r @ X:PF\n";
            goto LABEL_32;
          }
          v29 = sub_124B2(v43, "Root UUID");
          if ( v29 )
          {
            v31 = v29;
            if ( !(unsigned int)sub_18A1A(v37, *(_BYTE **)(v29 + 8)) )
            {
              v28 = 0i64;
              goto LABEL_33;
            }
            sub_1A2B6(1, (__int64)"[EB|`V:CU] %r @ 'CMP (%e)\n", v28, *(_QWORD *)(v31 + 8));
          }
          else
          {
            sub_1A2B6(1, (__int64)"[EB|`V:CU] ! @ X:GP (%s)\n", (__int64)"Root UUID", v30);
          }
          v28 = -9223372036854775794i64;
LABEL_33:
          if ( v41 )
            sub_136C5(v42);
          if ( v43 )
            sub_12C84(v43);
          if ( v28 >= 0 )
          {
            sub_1A2B6(1, (__int64)"[EB|#V:RP] %D\n", v36, v32);
            if ( v3 )
              *v3 = v36;
LABEL_46:
            if ( v44 )
              (*(void (**)(void))(qword_96CD8 + 72))();
            if ( *v4 )
              v5 = 0i64;
            return v5;
          }
          (*(void (__fastcall **)(_QWORD))(qword_96CD8 + 224))(*v4);
          *v4 = 0i64;
          v16 = v22;
LABEL_39:
          if ( v45 <= ++v17 )
            goto LABEL_46;
        }
        v28 = v23;
        v33 = "[EB|`V:CU] %r @ HdlP %g\n";
LABEL_28:
        sub_1A2B6(1, (__int64)v33, v28, (__int64)qword_92B40);
        goto LABEL_33;
      }
    }
  }
  return v5;
}
// 92A60: using guessed type __int64 qword_92A60[2];
// 92B40: using guessed type __int64 qword_92B40[2];
// 96A90: using guessed type __int64 qword_96A90;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AD8: using guessed type __int64 qword_96AD8;
// 96AE0: using guessed type __int64 qword_96AE0;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000001F3B0) ----------------------------------------------------
signed __int64 __fastcall sub_1F3B0(__m128i *a1, _OWORD *a2, __int64 _R8)
{
  __m128i v3; // xmm0
  int v4; // eax
  signed __int64 result; // rax

  v3 = *a1;
  v4 = *(_DWORD *)(_R8 + 240);
  switch ( v4 )
  {
    case 160:
      if ( _R8 & 0xF )
      {
        _XMM0 = _mm_xor_si128(v3, *(__m128i *)_R8);
        _XMM1 = *(_OWORD *)(_R8 + 16);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 32);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 48);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 64);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 80);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 96);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 112);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 128);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 144);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 160);
        __asm { aesenclast xmm0, xmm1 }
      }
      else
      {
        _XMM0 = _mm_xor_si128(v3, *(__m128i *)_R8);
        __asm
        {
          aesenc  xmm0, xmmword ptr [r8+10h]
          aesenc  xmm0, xmmword ptr [r8+20h]
          aesenc  xmm0, xmmword ptr [r8+30h]
          aesenc  xmm0, xmmword ptr [r8+40h]
          aesenc  xmm0, xmmword ptr [r8+50h]
          aesenc  xmm0, xmmword ptr [r8+60h]
          aesenc  xmm0, xmmword ptr [r8+70h]
          aesenc  xmm0, xmmword ptr [r8+80h]
          aesenc  xmm0, xmmword ptr [r8+90h]
          aesenclast xmm0, xmmword ptr [r8+0A0h]
        }
      }
      result = 0i64;
      *a2 = _XMM0;
      break;
    case 192:
      if ( _R8 & 0xF )
      {
        _XMM0 = _mm_xor_si128(v3, *(__m128i *)_R8);
        _XMM1 = *(_OWORD *)(_R8 + 16);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 32);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 48);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 64);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 80);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 96);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 112);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 128);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 144);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 160);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 176);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 192);
        __asm { aesenclast xmm0, xmm1 }
      }
      else
      {
        _XMM0 = _mm_xor_si128(v3, *(__m128i *)_R8);
        __asm
        {
          aesenc  xmm0, xmmword ptr [r8+10h]
          aesenc  xmm0, xmmword ptr [r8+20h]
          aesenc  xmm0, xmmword ptr [r8+30h]
          aesenc  xmm0, xmmword ptr [r8+40h]
          aesenc  xmm0, xmmword ptr [r8+50h]
          aesenc  xmm0, xmmword ptr [r8+60h]
          aesenc  xmm0, xmmword ptr [r8+70h]
          aesenc  xmm0, xmmword ptr [r8+80h]
          aesenc  xmm0, xmmword ptr [r8+90h]
          aesenc  xmm0, xmmword ptr [r8+0A0h]
          aesenc  xmm0, xmmword ptr [r8+0B0h]
          aesenclast xmm0, xmmword ptr [r8+0C0h]
        }
      }
      result = 0i64;
      *a2 = _XMM0;
      break;
    case 224:
      if ( _R8 & 0xF )
      {
        _XMM0 = _mm_xor_si128(v3, *(__m128i *)_R8);
        _XMM1 = *(_OWORD *)(_R8 + 16);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 32);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 48);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 64);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 80);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 96);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 112);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 128);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 144);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 160);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 176);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 192);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 208);
        __asm { aesenc  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 224);
        __asm { aesenclast xmm0, xmm1 }
      }
      else
      {
        _XMM0 = _mm_xor_si128(v3, *(__m128i *)_R8);
        __asm
        {
          aesenc  xmm0, xmmword ptr [r8+10h]
          aesenc  xmm0, xmmword ptr [r8+20h]
          aesenc  xmm0, xmmword ptr [r8+30h]
          aesenc  xmm0, xmmword ptr [r8+40h]
          aesenc  xmm0, xmmword ptr [r8+50h]
          aesenc  xmm0, xmmword ptr [r8+60h]
          aesenc  xmm0, xmmword ptr [r8+70h]
          aesenc  xmm0, xmmword ptr [r8+80h]
          aesenc  xmm0, xmmword ptr [r8+90h]
          aesenc  xmm0, xmmword ptr [r8+0A0h]
          aesenc  xmm0, xmmword ptr [r8+0B0h]
          aesenc  xmm0, xmmword ptr [r8+0C0h]
          aesenc  xmm0, xmmword ptr [r8+0D0h]
          aesenclast xmm0, xmmword ptr [r8+0E0h]
        }
      }
      result = 0i64;
      *a2 = _XMM0;
      break;
    default:
      result = 0xFFFFFFFFi64;
      break;
  }
  return result;
}

//----- (000000000001F770) ----------------------------------------------------
signed __int64 __fastcall sub_1F770(__m128i *a1, _OWORD *a2, __int64 _R8)
{
  __m128i v3; // xmm0
  int v4; // eax
  signed __int64 result; // rax

  v3 = *a1;
  v4 = *(_DWORD *)(_R8 + 240);
  switch ( v4 )
  {
    case 160:
      if ( _R8 & 0xF )
      {
        _XMM0 = _mm_xor_si128(v3, *(__m128i *)(_R8 + 160));
        _XMM1 = *(_OWORD *)(_R8 + 144);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 128);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 112);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 96);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 80);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 64);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 48);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 32);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 16);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)_R8;
        __asm { aesdeclast xmm0, xmm1 }
      }
      else
      {
        _XMM0 = _mm_xor_si128(v3, *(__m128i *)(_R8 + 160));
        __asm
        {
          aesdec  xmm0, xmmword ptr [r8+90h]
          aesdec  xmm0, xmmword ptr [r8+80h]
          aesdec  xmm0, xmmword ptr [r8+70h]
          aesdec  xmm0, xmmword ptr [r8+60h]
          aesdec  xmm0, xmmword ptr [r8+50h]
          aesdec  xmm0, xmmword ptr [r8+40h]
          aesdec  xmm0, xmmword ptr [r8+30h]
          aesdec  xmm0, xmmword ptr [r8+20h]
          aesdec  xmm0, xmmword ptr [r8+10h]
          aesdeclast xmm0, xmmword ptr [r8]
        }
      }
      result = 0i64;
      *a2 = _XMM0;
      break;
    case 192:
      if ( _R8 & 0xF )
      {
        _XMM0 = _mm_xor_si128(v3, *(__m128i *)(_R8 + 192));
        _XMM1 = *(_OWORD *)(_R8 + 176);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 160);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 144);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 128);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 112);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 96);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 80);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 64);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 48);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 32);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 16);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)_R8;
        __asm { aesdeclast xmm0, xmm1 }
      }
      else
      {
        _XMM0 = _mm_xor_si128(v3, *(__m128i *)(_R8 + 192));
        __asm
        {
          aesdec  xmm0, xmmword ptr [r8+0B0h]
          aesdec  xmm0, xmmword ptr [r8+0A0h]
          aesdec  xmm0, xmmword ptr [r8+90h]
          aesdec  xmm0, xmmword ptr [r8+80h]
          aesdec  xmm0, xmmword ptr [r8+70h]
          aesdec  xmm0, xmmword ptr [r8+60h]
          aesdec  xmm0, xmmword ptr [r8+50h]
          aesdec  xmm0, xmmword ptr [r8+40h]
          aesdec  xmm0, xmmword ptr [r8+30h]
          aesdec  xmm0, xmmword ptr [r8+20h]
          aesdec  xmm0, xmmword ptr [r8+10h]
          aesdeclast xmm0, xmmword ptr [r8]
        }
      }
      result = 0i64;
      *a2 = _XMM0;
      break;
    case 224:
      if ( _R8 & 0xF )
      {
        _XMM0 = _mm_xor_si128(v3, *(__m128i *)(_R8 + 224));
        _XMM1 = *(_OWORD *)(_R8 + 208);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 192);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 176);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 160);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 144);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 128);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 112);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 96);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 80);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 64);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 48);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 32);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)(_R8 + 16);
        __asm { aesdec  xmm0, xmm1 }
        _XMM1 = *(_OWORD *)_R8;
        __asm { aesdeclast xmm0, xmm1 }
      }
      else
      {
        _XMM0 = _mm_xor_si128(v3, *(__m128i *)(_R8 + 224));
        __asm
        {
          aesdec  xmm0, xmmword ptr [r8+0D0h]
          aesdec  xmm0, xmmword ptr [r8+0C0h]
          aesdec  xmm0, xmmword ptr [r8+0B0h]
          aesdec  xmm0, xmmword ptr [r8+0A0h]
          aesdec  xmm0, xmmword ptr [r8+90h]
          aesdec  xmm0, xmmword ptr [r8+80h]
          aesdec  xmm0, xmmword ptr [r8+70h]
          aesdec  xmm0, xmmword ptr [r8+60h]
          aesdec  xmm0, xmmword ptr [r8+50h]
          aesdec  xmm0, xmmword ptr [r8+40h]
          aesdec  xmm0, xmmword ptr [r8+30h]
          aesdec  xmm0, xmmword ptr [r8+20h]
          aesdec  xmm0, xmmword ptr [r8+10h]
          aesdeclast xmm0, xmmword ptr [r8]
        }
      }
      result = 0i64;
      *a2 = _XMM0;
      break;
    default:
      result = 0xFFFFFFFFi64;
      break;
  }
  return result;
}

//----- (000000000001FEC0) ----------------------------------------------------
signed __int64 __fastcall sub_1FEC0(__m128i *a1, __m128i *a2, signed int a3, __m128i *a4)
{
  __m128i *v4; // rsi
  signed int v5; // edx
  __int128 *v6; // r8
  __m128i *v7; // rbx
  __m128i v8; // xmm0
  __m128i *v9; // r14
  int v10; // eax
  __m128i v12; // xmm3
  int v23; // er13
  __m128i v68; // xmm1
  __m128i v69; // xmm2
  __m128i v70; // xmm14
  __m128i v71; // xmm15
  unsigned __int8 v72; // of
  int v73; // er13
  __m128i v96; // xmm1
  __m128i v97; // xmm2
  __m128i v109; // xmm2
  __m128i v110; // xmm0
  __m128i v111; // xmm3
  __int128 v122; // xmm14
  __int128 v123; // xmm15
  int v124; // er13
  __m128i v179; // xmm1
  __m128i v180; // xmm2
  __m128i v181; // xmm14
  __m128i v182; // xmm15
  int v183; // er13
  __m128i v199; // xmm2
  __m128i v200; // xmm3
  __int128 v211; // xmm14
  __int128 v212; // xmm15
  int v213; // er13
  __m128i v278; // xmm1
  __m128i v279; // xmm2
  __m128i v280; // xmm14
  __m128i v281; // xmm15
  int v282; // er13
  __m128i v302; // xmm2
  __int64 savedregs; // [rsp+130h] [rbp+0h]

  v4 = a2;
  v5 = a3;
  v6 = *(__int128 **)((unsigned int)&savedregs + 48);
  v7 = a1;
  v8 = *v4;
  v9 = a4;
  v10 = *((_DWORD *)v6 + 60);
  switch ( v10 )
  {
    case 160:
      if ( v5 >= 1 )
      {
        v12 = (__m128i)v6[10];
        _XMM4 = v6[9];
        _XMM5 = v6[8];
        _XMM6 = v6[7];
        _XMM7 = v6[6];
        _XMM8 = v6[5];
        _XMM9 = v6[4];
        _XMM10 = v6[3];
        _XMM11 = v6[2];
        _XMM12 = v6[1];
        _XMM13 = *v6;
        v23 = v5 - 4;
        if ( v5 >= 4 )
        {
          do
          {
            _XMM1 = _mm_xor_si128(*v7, v12);
            _XMM2 = _mm_xor_si128(v7[1], v12);
            _XMM14 = _mm_xor_si128(v7[2], v12);
            _XMM15 = _mm_xor_si128(v7[3], v12);
            __asm
            {
              aesdec  xmm1, xmm4
              aesdec  xmm2, xmm4
              aesdec  xmm14, xmm4
              aesdec  xmm15, xmm4
              aesdec  xmm1, xmm5
              aesdec  xmm2, xmm5
              aesdec  xmm14, xmm5
              aesdec  xmm15, xmm5
              aesdec  xmm1, xmm6
              aesdec  xmm2, xmm6
              aesdec  xmm14, xmm6
              aesdec  xmm15, xmm6
              aesdec  xmm1, xmm7
              aesdec  xmm2, xmm7
              aesdec  xmm14, xmm7
              aesdec  xmm15, xmm7
              aesdec  xmm1, xmm8
              aesdec  xmm2, xmm8
              aesdec  xmm14, xmm8
              aesdec  xmm15, xmm8
              aesdec  xmm1, xmm9
              aesdec  xmm2, xmm9
              aesdec  xmm14, xmm9
              aesdec  xmm15, xmm9
              aesdec  xmm1, xmm10
              aesdec  xmm2, xmm10
              aesdec  xmm14, xmm10
              aesdec  xmm15, xmm10
              aesdec  xmm1, xmm11
              aesdec  xmm2, xmm11
              aesdec  xmm14, xmm11
              aesdec  xmm15, xmm11
              aesdec  xmm1, xmm12
              aesdec  xmm2, xmm12
              aesdec  xmm14, xmm12
              aesdec  xmm15, xmm12
              aesdeclast xmm1, xmm13
              aesdeclast xmm2, xmm13
              aesdeclast xmm14, xmm13
              aesdeclast xmm15, xmm13
            }
            v68 = _mm_xor_si128(_XMM1, v8);
            v69 = _mm_xor_si128(_XMM2, *v7);
            v70 = _mm_xor_si128(_XMM14, v7[1]);
            v71 = _mm_xor_si128(_XMM15, v7[2]);
            v8 = v7[3];
            *v9 = v68;
            v9[1] = v69;
            v9[2] = v70;
            v9[3] = v71;
            v7 += 4;
            v9 += 4;
            v72 = __OFSUB__(v23, 4);
            v23 -= 4;
          }
          while ( !((v23 < 0) ^ v72) );
        }
        v73 = v23 + 4;
        if ( v73 )
        {
          if ( v73 & 2 )
          {
            _XMM1 = _mm_xor_si128(*v7, v12);
            _XMM2 = _mm_xor_si128(v7[1], v12);
            __asm
            {
              aesdec  xmm1, xmm4
              aesdec  xmm2, xmm4
              aesdec  xmm1, xmm5
              aesdec  xmm2, xmm5
              aesdec  xmm1, xmm6
              aesdec  xmm2, xmm6
              aesdec  xmm1, xmm7
              aesdec  xmm2, xmm7
              aesdec  xmm1, xmm8
              aesdec  xmm2, xmm8
              aesdec  xmm1, xmm9
              aesdec  xmm2, xmm9
              aesdec  xmm1, xmm10
              aesdec  xmm2, xmm10
              aesdec  xmm1, xmm11
              aesdec  xmm2, xmm11
              aesdec  xmm1, xmm12
              aesdec  xmm2, xmm12
              aesdeclast xmm1, xmm13
              aesdeclast xmm2, xmm13
            }
            v96 = _mm_xor_si128(_XMM1, v8);
            v97 = _mm_xor_si128(_XMM2, *v7);
            v8 = v7[1];
            *v9 = v96;
            v9[1] = v97;
            v7 += 2;
            v9 += 2;
          }
          if ( v73 & 1 )
          {
            _XMM2 = _mm_xor_si128(*v7, v12);
            __asm
            {
              aesdec  xmm2, xmm4
              aesdec  xmm2, xmm5
              aesdec  xmm2, xmm6
              aesdec  xmm2, xmm7
              aesdec  xmm2, xmm8
              aesdec  xmm2, xmm9
              aesdec  xmm2, xmm10
              aesdec  xmm2, xmm11
              aesdec  xmm2, xmm12
              aesdeclast xmm2, xmm13
            }
            v109 = _mm_xor_si128(_XMM2, v8);
            v110 = *v7;
            *v9 = v109;
          }
        }
      }
      break;
    case 192:
      if ( v5 >= 1 )
      {
        v111 = (__m128i)v6[12];
        _XMM4 = v6[11];
        _XMM5 = v6[10];
        _XMM6 = v6[9];
        _XMM7 = v6[8];
        _XMM8 = v6[7];
        _XMM9 = v6[6];
        _XMM10 = v6[5];
        _XMM11 = v6[4];
        _XMM12 = v6[3];
        _XMM13 = v6[2];
        v122 = v6[1];
        v123 = *v6;
        v124 = v5 - 4;
        if ( v5 >= 4 )
        {
          do
          {
            _XMM1 = _mm_xor_si128(*v7, v111);
            _XMM2 = _mm_xor_si128(v7[1], v111);
            _XMM14 = _mm_xor_si128(v7[2], v111);
            _XMM15 = _mm_xor_si128(v7[3], v111);
            __asm
            {
              aesdec  xmm1, xmm4
              aesdec  xmm2, xmm4
              aesdec  xmm14, xmm4
              aesdec  xmm15, xmm4
              aesdec  xmm1, xmm5
              aesdec  xmm2, xmm5
              aesdec  xmm14, xmm5
              aesdec  xmm15, xmm5
              aesdec  xmm1, xmm6
              aesdec  xmm2, xmm6
              aesdec  xmm14, xmm6
              aesdec  xmm15, xmm6
              aesdec  xmm1, xmm7
              aesdec  xmm2, xmm7
              aesdec  xmm14, xmm7
              aesdec  xmm15, xmm7
              aesdec  xmm1, xmm8
              aesdec  xmm2, xmm8
              aesdec  xmm14, xmm8
              aesdec  xmm15, xmm8
              aesdec  xmm1, xmm9
              aesdec  xmm2, xmm9
              aesdec  xmm14, xmm9
              aesdec  xmm15, xmm9
              aesdec  xmm1, xmm10
              aesdec  xmm2, xmm10
              aesdec  xmm14, xmm10
              aesdec  xmm15, xmm10
              aesdec  xmm1, xmm11
              aesdec  xmm2, xmm11
              aesdec  xmm14, xmm11
              aesdec  xmm15, xmm11
              aesdec  xmm1, xmm12
              aesdec  xmm2, xmm12
              aesdec  xmm14, xmm12
              aesdec  xmm15, xmm12
            }
            _XMM12 = v6[1];
            __asm
            {
              aesdec  xmm1, xmm13
              aesdec  xmm2, xmm13
              aesdec  xmm14, xmm13
              aesdec  xmm15, xmm13
            }
            _XMM13 = *v6;
            __asm
            {
              aesdec  xmm1, xmm12
              aesdec  xmm2, xmm12
              aesdec  xmm14, xmm12
              aesdec  xmm15, xmm12
            }
            _XMM12 = v6[3];
            __asm
            {
              aesdeclast xmm1, xmm13
              aesdeclast xmm2, xmm13
              aesdeclast xmm14, xmm13
              aesdeclast xmm15, xmm13
            }
            _XMM13 = v6[2];
            v179 = _mm_xor_si128(_XMM1, v8);
            v180 = _mm_xor_si128(_XMM2, *v7);
            v181 = _mm_xor_si128(_XMM14, v7[1]);
            v182 = _mm_xor_si128(_XMM15, v7[2]);
            v8 = v7[3];
            *v9 = v179;
            v9[1] = v180;
            v9[2] = v181;
            v9[3] = v182;
            v7 += 4;
            v9 += 4;
            v72 = __OFSUB__(v124, 4);
            v124 -= 4;
          }
          while ( !((v124 < 0) ^ v72) );
        }
        v183 = v124 + 4;
        if ( v183 )
        {
          _XMM14 = v6[1];
          _XMM15 = *v6;
          do
          {
            _XMM2 = _mm_xor_si128(*v7, v111);
            __asm
            {
              aesdec  xmm2, xmm4
              aesdec  xmm2, xmm5
              aesdec  xmm2, xmm6
              aesdec  xmm2, xmm7
              aesdec  xmm2, xmm8
              aesdec  xmm2, xmm9
              aesdec  xmm2, xmm10
              aesdec  xmm2, xmm11
              aesdec  xmm2, xmm12
              aesdec  xmm2, xmm13
              aesdec  xmm2, xmm14
              aesdeclast xmm2, xmm15
            }
            v199 = _mm_xor_si128(_XMM2, v8);
            v8 = *v7;
            *v9 = v199;
            ++v7;
            ++v9;
            v72 = __OFSUB__(v183--, 1);
          }
          while ( !((unsigned __int8)((v183 < 0) ^ v72) | (v183 == 0)) );
        }
      }
      break;
    case 224:
      if ( v5 >= 1 )
      {
        v200 = (__m128i)v6[14];
        _XMM4 = v6[13];
        _XMM5 = v6[12];
        _XMM6 = v6[11];
        _XMM7 = v6[10];
        _XMM8 = v6[9];
        _XMM9 = v6[8];
        _XMM10 = v6[7];
        _XMM11 = v6[6];
        _XMM12 = v6[5];
        _XMM13 = v6[4];
        v211 = v6[3];
        v212 = v6[2];
        v213 = v5 - 4;
        if ( v5 >= 4 )
        {
          do
          {
            _XMM1 = _mm_xor_si128(*v7, v200);
            _XMM2 = _mm_xor_si128(v7[1], v200);
            _XMM14 = _mm_xor_si128(v7[2], v200);
            _XMM15 = _mm_xor_si128(v7[3], v200);
            __asm
            {
              aesdec  xmm1, xmm4
              aesdec  xmm2, xmm4
              aesdec  xmm14, xmm4
              aesdec  xmm15, xmm4
              aesdec  xmm1, xmm5
              aesdec  xmm2, xmm5
              aesdec  xmm14, xmm5
              aesdec  xmm15, xmm5
              aesdec  xmm1, xmm6
              aesdec  xmm2, xmm6
              aesdec  xmm14, xmm6
              aesdec  xmm15, xmm6
              aesdec  xmm1, xmm7
              aesdec  xmm2, xmm7
              aesdec  xmm14, xmm7
              aesdec  xmm15, xmm7
              aesdec  xmm1, xmm8
              aesdec  xmm2, xmm8
              aesdec  xmm14, xmm8
              aesdec  xmm15, xmm8
              aesdec  xmm1, xmm9
              aesdec  xmm2, xmm9
              aesdec  xmm14, xmm9
              aesdec  xmm15, xmm9
              aesdec  xmm1, xmm10
              aesdec  xmm2, xmm10
              aesdec  xmm14, xmm10
              aesdec  xmm15, xmm10
              aesdec  xmm1, xmm11
              aesdec  xmm2, xmm11
              aesdec  xmm14, xmm11
              aesdec  xmm15, xmm11
              aesdec  xmm1, xmm12
              aesdec  xmm2, xmm12
              aesdec  xmm14, xmm12
              aesdec  xmm15, xmm12
            }
            _XMM12 = v6[3];
            __asm
            {
              aesdec  xmm1, xmm13
              aesdec  xmm2, xmm13
              aesdec  xmm14, xmm13
              aesdec  xmm15, xmm13
            }
            _XMM13 = v6[2];
            __asm
            {
              aesdec  xmm1, xmm12
              aesdec  xmm2, xmm12
              aesdec  xmm14, xmm12
              aesdec  xmm15, xmm12
            }
            _XMM12 = v6[1];
            __asm
            {
              aesdec  xmm1, xmm13
              aesdec  xmm2, xmm13
              aesdec  xmm14, xmm13
              aesdec  xmm15, xmm13
            }
            _XMM13 = *v6;
            __asm
            {
              aesdec  xmm1, xmm12
              aesdec  xmm2, xmm12
              aesdec  xmm14, xmm12
              aesdec  xmm15, xmm12
            }
            _XMM12 = v6[5];
            __asm
            {
              aesdeclast xmm1, xmm13
              aesdeclast xmm2, xmm13
              aesdeclast xmm14, xmm13
              aesdeclast xmm15, xmm13
            }
            _XMM13 = v6[4];
            v278 = _mm_xor_si128(_XMM1, v8);
            v279 = _mm_xor_si128(_XMM2, *v7);
            v280 = _mm_xor_si128(_XMM14, v7[1]);
            v281 = _mm_xor_si128(_XMM15, v7[2]);
            v8 = v7[3];
            *v9 = v278;
            v9[1] = v279;
            v9[2] = v280;
            v9[3] = v281;
            v7 += 4;
            v9 += 4;
            v72 = __OFSUB__(v213, 4);
            v213 -= 4;
          }
          while ( !((v213 < 0) ^ v72) );
        }
        v282 = v213 + 4;
        if ( v282 )
        {
          _XMM14 = v6[3];
          _XMM15 = v6[2];
          do
          {
            _XMM2 = _mm_xor_si128(*v7, v200);
            __asm
            {
              aesdec  xmm2, xmm4
              aesdec  xmm2, xmm5
              aesdec  xmm2, xmm6
              aesdec  xmm2, xmm7
              aesdec  xmm2, xmm8
              aesdec  xmm2, xmm9
              aesdec  xmm2, xmm10
              aesdec  xmm2, xmm11
              aesdec  xmm2, xmm12
              aesdec  xmm2, xmm13
              aesdec  xmm2, xmm14
              aesdec  xmm2, xmm15
            }
            _XMM1 = v6[1];
            __asm { aesdec  xmm2, xmm1 }
            _XMM1 = *v6;
            __asm { aesdeclast xmm2, xmm1 }
            v302 = _mm_xor_si128(_XMM2, v8);
            v8 = *v7;
            *v9 = v302;
            ++v7;
            ++v9;
            v72 = __OFSUB__(v282--, 1);
          }
          while ( !((unsigned __int8)((v282 < 0) ^ v72) | (v282 == 0)) );
        }
      }
      break;
    default:
      return 0xFFFFFFFFi64;
  }
  return 0i64;
}

//----- (0000000000020782) ----------------------------------------------------
void __fastcall sub_20782(__int64 a1, unsigned int a2)
{
  unsigned int v2; // er15
  __int64 v3; // r14
  unsigned int v4; // ebx
  __int64 (__fastcall **v5)(); // rdi
  unsigned __int64 v6; // rsi
  int v7; // eax

  v2 = a2;
  v3 = a1;
  if ( a2 & 7 )
    sub_5202(-9223372036854775787i64);
  if ( v2 )
  {
    v4 = 0;
    v5 = off_91650;
    v6 = 1i64;
    do
    {
      v7 = ((__int64 (__fastcall *)(__int64, _QWORD))*v5)(v3 + v4, v2 - v4);
      if ( v6 > 2 )
        break;
      v4 += v7;
      ++v5;
      ++v6;
    }
    while ( v4 < v2 );
  }
}
// 91650: using guessed type __int64 (__fastcall *off_91650[3])();

//----- (00000000000207EC) ----------------------------------------------------
__int64 __fastcall sub_207EC(__int64 a1, unsigned int a2)
{
  unsigned int v2; // esi
  __int64 v3; // r14
  unsigned int v9; // edi

  v2 = a2;
  v3 = a1;
  _RAX = 7i64;
  __asm { cpuid }
  v9 = 0;
  if ( _bittest((const signed int *)&_RBX, 0x12u) && v2 )
  {
    v9 = 0;
    do
    {
      if ( !(unsigned int)sub_13980(__CFADD__(v3, v9), (_QWORD *)(v3 + v9)) )
        break;
      v9 += 8;
    }
    while ( v9 < v2 );
  }
  return v9;
}

//----- (0000000000020858) ----------------------------------------------------
__int64 __fastcall sub_20858(__int64 a1, unsigned int a2)
{
  unsigned int v2; // er15
  __int64 v3; // r14
  char *v4; // rdi
  signed __int64 i; // rcx
  unsigned int v11; // edi
  bool v12; // cf
  unsigned int v13; // er12
  unsigned __int64 v14; // r8
  int v16[26]; // [rsp+28h] [rbp-D8h]
  __int64 v17; // [rsp+90h] [rbp-70h]
  __int64 v18; // [rsp+98h] [rbp-68h]
  __int64 v19; // [rsp+A0h] [rbp-60h]
  __int64 v20; // [rsp+A8h] [rbp-58h]
  __int64 v21; // [rsp+B0h] [rbp-50h]
  int v22; // [rsp+B8h] [rbp-48h]
  int v23; // [rsp+BCh] [rbp-44h]
  int v24; // [rsp+C0h] [rbp-40h]
  int v25; // [rsp+C4h] [rbp-3Ch]

  v2 = a2;
  v3 = a1;
  v22 = -1431655766;
  v23 = -1431655766;
  v24 = -1431655766;
  v25 = -1431655766;
  v21 = -6148914691236517206i64;
  v4 = (char *)v16;
  for ( i = 26i64; i; --i )
  {
    *(_DWORD *)v4 = -1431655766;
    v4 += 4;
  }
  v17 = -6148914691236517206i64;
  v18 = -6148914691236517206i64;
  v19 = -6148914691236517206i64;
  v20 = -6148914691236517206i64;
  _RAX = 1i64;
  __asm { cpuid }
  v11 = 0;
  v22 = _RAX;
  v23 = _RBX;
  v24 = _RCX;
  v25 = _RDX;
  if ( _bittest((const signed int *)&_RCX, 0x1Eu) )
  {
    v11 = 0;
    if ( v2 )
    {
LABEL_6:
      sub_1B84F((__int64)v16);
      v12 = 0;
      v13 = 0;
      while ( (unsigned int)sub_21A60(v12, &v21) )
      {
        sub_1AAAE(v16, (char *)&v21, 8u);
        v12 = ++v13 < 0x400;
        if ( v13 >= 0x400 )
        {
          sub_1B87F((__int64)&v17, v16);
          v14 = v2 - v11;
          if ( (unsigned int)v14 >= 0x10 )
            v14 = 16i64;
          sub_1B930((char *)(v3 + v11), (char *)&v17, v14);
          v11 += 16;
          if ( v11 < v2 )
            goto LABEL_6;
          break;
        }
      }
    }
    sub_F1B0(&v21, 8i64);
    sub_F1B0(&v17, 32i64);
    sub_F1B0(v16, 104i64);
    if ( v11 > v2 )
      v11 = v2;
  }
  return v11;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);

//----- (00000000000209A2) ----------------------------------------------------
__int64 __fastcall sub_209A2(__int64 a1, unsigned int a2)
{
  unsigned int v2; // er14
  __int64 v3; // r15
  __int64 v4; // rax
  unsigned __int16 v5; // bx
  __int64 v6; // rdi
  unsigned int v7; // ecx
  unsigned __int16 v8; // ax
  unsigned __int16 v9; // si
  unsigned __int64 v10; // rax

  v2 = a2;
  v3 = a1;
  v4 = sub_74E9("FACP");
  if ( !v4 || (v5 = *(_WORD *)(v4 + 76)) == 0 )
  {
    sub_F1B0(v3, v2);
    return 0;
  }
  if ( !v2 )
    return 0;
  v6 = 0i64;
  LOWORD(v7) = 0;
  do
  {
    v7 = (unsigned __int16)v7;
    do
    {
      v8 = __inword(v5);
      v9 = v8;
    }
    while ( v7 > v8 );
    v10 = sub_18D72();
    LOBYTE(v7) = BYTE2(v10) ^ v9 ^ v10 ^ BYTE1(v10);
    *(_BYTE *)(v3 + v6) = v7;
    LOWORD(v7) = v9 + (v7 & 0x2F);
    ++v6;
  }
  while ( v6 != v2 );
  return v2;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);

//----- (0000000000020A40) ----------------------------------------------------
void __fastcall sub_20A40(__m128i *a1)
{
  *a1 = _mm_xor_si128(
          _mm_or_si128(_mm_slli_epi64(*a1, 1u), _mm_shuffle_epi32(_mm_srli_epi64(*a1, 0x3Fu), 198)),
          _mm_and_si128(_mm_cvtsi32_si128(0x86u), _mm_shuffle_epi32(_mm_srai_epi32(*a1, 0x1Fu), 3)));
}

//----- (0000000000021220) ----------------------------------------------------
signed __int64 __fastcall sub_21220(__m128i *a1, __m128i *a2, __m128i *a3)
{
  __m128i *v3; // r13
  __m128i *v4; // r14
  __m128i v5; // xmm7
  signed __int64 result; // rax

  v3 = a2;
  v4 = a3;
  v5 = *a3;
  *a2 = _mm_xor_si128(*a1, *a3);
  result = sub_341F();
  if ( !(_DWORD)result )
  {
    *v3 = _mm_xor_si128(*v3, v5);
    *v4 = _mm_xor_si128(
            _mm_or_si128(_mm_slli_epi64(v5, 1u), _mm_shuffle_epi32(_mm_srli_epi64(v5, 0x3Fu), 198)),
            _mm_and_si128(_mm_cvtsi32_si128(0x86u), _mm_shuffle_epi32(_mm_srai_epi32(v5, 0x1Fu), 3)));
  }
  return result;
}

//----- (00000000000212D0) ----------------------------------------------------
char __fastcall sub_212D0(__m128i *a1, __m128i *a2, __m128i *a3, __int64 a4)
{
  __m128i *v4; // r12
  __m128i *v5; // r13
  __m128i *v6; // r14
  __int64 v7; // r15
  __int64 v8; // rbx
  int v9; // eax
  unsigned __int8 v10; // of
  int v11; // ebx
  __m128i v12; // xmm7
  __m128i v13; // xmm7
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm2
  __m128i v17; // xmm3
  int v18; // eax
  __m128i v19; // xmm4
  __m128i v74; // xmm4
  __m128i v135; // xmm4
  __m128i v206; // xmm7
  int v207; // ebx
  __m128i v209; // [rsp+10h] [rbp-F0h]
  __m128i v210; // [rsp+20h] [rbp-E0h]
  __m128i v211; // [rsp+30h] [rbp-D0h]
  __m128i v212; // [rsp+40h] [rbp-C0h]
  __int64 savedregs; // [rsp+100h] [rbp+0h]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  v8 = *(_QWORD *)((unsigned int)&savedregs + 48);
  LOBYTE(v9) = sub_9DAB();
  if ( !v9 )
    goto LABEL_21;
  v10 = __OFSUB__((_DWORD)v8, 4);
  v11 = v8 - 4;
  if ( !((v11 < 0) ^ v10) )
  {
    v12 = *v6;
    do
    {
      v209 = v12;
      v13 = _mm_xor_si128(
              _mm_or_si128(_mm_slli_epi64(v12, 1u), _mm_shuffle_epi32(_mm_srli_epi64(v12, 0x3Fu), 198)),
              _mm_and_si128(_mm_cvtsi32_si128(0x86u), _mm_shuffle_epi32(_mm_srai_epi32(v12, 0x1Fu), 3)));
      v210 = v13;
      v211 = v13;
      v212 = v13;
      v12 = _mm_xor_si128(
              _mm_or_si128(_mm_slli_epi64(v212, 1u), _mm_shuffle_epi32(_mm_srli_epi64(v212, 0x3Fu), 198)),
              _mm_and_si128(_mm_cvtsi32_si128(0x86u), _mm_shuffle_epi32(_mm_srai_epi32(v212, 0x1Fu), 3)));
      v14 = _mm_xor_si128(*v4, v209);
      v15 = _mm_xor_si128(v4[1], v210);
      v16 = _mm_xor_si128(v4[2], v211);
      v17 = _mm_xor_si128(v4[3], v212);
      v18 = *(_DWORD *)(v7 + 240);
      switch ( v18 )
      {
        case 160:
          v19 = *(__m128i *)(v7 + 160);
          _XMM5 = *(_OWORD *)(v7 + 144);
          _XMM0 = _mm_xor_si128(v14, v19);
          _XMM1 = _mm_xor_si128(v15, v19);
          _XMM2 = _mm_xor_si128(v16, v19);
          _XMM3 = _mm_xor_si128(v17, v19);
          _XMM4 = *(_OWORD *)(v7 + 128);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 112);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)(v7 + 96);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 80);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)(v7 + 64);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 48);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)(v7 + 32);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 16);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)v7;
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
            aesdeclast xmm0, xmm4
            aesdeclast xmm1, xmm4
            aesdeclast xmm2, xmm4
            aesdeclast xmm3, xmm4
          }
          break;
        case 192:
          v74 = *(__m128i *)(v7 + 192);
          _XMM5 = *(_OWORD *)(v7 + 176);
          _XMM0 = _mm_xor_si128(v14, v74);
          _XMM1 = _mm_xor_si128(v15, v74);
          _XMM2 = _mm_xor_si128(v16, v74);
          _XMM3 = _mm_xor_si128(v17, v74);
          _XMM4 = *(_OWORD *)(v7 + 160);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 144);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)(v7 + 128);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 112);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)(v7 + 96);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 80);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)(v7 + 64);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 48);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)(v7 + 32);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 16);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)v7;
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
            aesdeclast xmm0, xmm4
            aesdeclast xmm1, xmm4
            aesdeclast xmm2, xmm4
            aesdeclast xmm3, xmm4
          }
          break;
        case 224:
          v135 = *(__m128i *)(v7 + 224);
          _XMM5 = *(_OWORD *)(v7 + 208);
          _XMM0 = _mm_xor_si128(v14, v135);
          _XMM1 = _mm_xor_si128(v15, v135);
          _XMM2 = _mm_xor_si128(v16, v135);
          _XMM3 = _mm_xor_si128(v17, v135);
          _XMM4 = *(_OWORD *)(v7 + 192);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 176);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)(v7 + 160);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 144);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)(v7 + 128);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 112);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)(v7 + 96);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 80);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)(v7 + 64);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 48);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)(v7 + 32);
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
          }
          _XMM5 = *(_OWORD *)(v7 + 16);
          __asm
          {
            aesdec  xmm0, xmm4
            aesdec  xmm1, xmm4
            aesdec  xmm2, xmm4
            aesdec  xmm3, xmm4
          }
          _XMM4 = *(_OWORD *)v7;
          __asm
          {
            aesdec  xmm0, xmm5
            aesdec  xmm1, xmm5
            aesdec  xmm2, xmm5
            aesdec  xmm3, xmm5
            aesdeclast xmm0, xmm4
            aesdeclast xmm1, xmm4
            aesdeclast xmm2, xmm4
            aesdeclast xmm3, xmm4
          }
          break;
        default:
          LOBYTE(v9) = -1;
          return v9;
      }
      *v5 = _mm_xor_si128(_XMM0, v209);
      v5[1] = _mm_xor_si128(_XMM1, v210);
      v5[2] = _mm_xor_si128(_XMM2, v211);
      v5[3] = _mm_xor_si128(_XMM3, v212);
      v4 += 4;
      v5 += 4;
      v10 = __OFSUB__(v11, 4);
      v11 -= 4;
    }
    while ( !((v11 < 0) ^ v10) );
    *v6 = v12;
  }
  LOBYTE(v9) = 0;
  LODWORD(v8) = v11 + 4;
  if ( (_DWORD)v8 )
  {
LABEL_21:
    v206 = *v6;
    v10 = __OFSUB__((_DWORD)v8, 1);
    v207 = v8 - 1;
    if ( (v207 < 0) ^ v10 )
    {
LABEL_17:
      *v6 = v206;
    }
    else
    {
      while ( 1 )
      {
        *v5 = _mm_xor_si128(*v4, v206);
        v9 = sub_38CC(v5, (int *)v5->m128i_i64, v7);
        if ( v9 )
          break;
        *v5 = _mm_xor_si128(*v5, v206);
        v206 = _mm_xor_si128(
                 _mm_or_si128(_mm_slli_epi64(v206, 1u), _mm_shuffle_epi32(_mm_srli_epi64(v206, 0x3Fu), 198)),
                 _mm_and_si128(_mm_cvtsi32_si128(0x86u), _mm_shuffle_epi32(_mm_srai_epi32(v206, 0x1Fu), 3)));
        ++v4;
        ++v5;
        v10 = __OFSUB__(v207--, 1);
        if ( (v207 < 0) ^ v10 )
          goto LABEL_17;
      }
    }
  }
  return v9;
}

//----- (0000000000021984) ----------------------------------------------------
signed __int64 __fastcall sub_21984(unsigned int a1)
{
  signed __int64 result; // rax
  unsigned __int8 v2; // al

  if ( byte_96CCC )
  {
    result = 4261634048i64;
    while ( !(MEMORY[0xFE036014] & 0x20) )
      ;
    MEMORY[0xFE036000] = (unsigned __int16)a1;
  }
  else if ( byte_96CCD )
  {
    result = 4261634048i64;
    while ( !(MEMORY[0xFE410005] & 0x20) )
      ;
    MEMORY[0xFE410000] = a1;
  }
  else
  {
    do
      v2 = __inbyte(0x3FDu);
    while ( !(v2 & 0x20) );
    result = a1;
    __outbyte(0x3F8u, a1);
  }
  return result;
}
// 96CCC: using guessed type char byte_96CCC;
// 96CCD: using guessed type char byte_96CCD;

//----- (00000000000219D7) ----------------------------------------------------
signed __int64 __fastcall sub_219D7(__int64 a1, unsigned __int8 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // rbx
  signed __int64 result; // rax

  if ( a2 )
  {
    v2 = a1;
    v3 = a2;
    v4 = 0i64;
    do
      result = sub_21984(*(unsigned __int8 *)(v2 + v4++));
    while ( v3 != v4 );
  }
  return result;
}

//----- (0000000000021A08) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 sub_21A08()
{
  signed __int64 result; // rax

  result = 4261634076i64;
  MEMORY[0xFE03601C] = 90;
  byte_96CCC = 1;
  return result;
}
// 21A26: write access to const memory at 96CCC has been detected
// 21A51: write access to const memory at 96CCD has been detected
// 96CCC: using guessed type char byte_96CCC;
// 96CCD: using guessed type char byte_96CCD;

//----- (0000000000021A60) ----------------------------------------------------
__int64 __usercall sub_21A60@<rax>(char a1@<cf>, _QWORD *a2@<rcx>)
{
  signed int v2; // edx

  v2 = 10;
  do
  {
    __asm { rdrand  rax }
    if ( a1 )
      break;
    --v2;
  }
  while ( v2 );
  *a2 = _RAX;
  return (unsigned int)a1;
}

//----- (0000000000021A79) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __usercall sub_21A79@<rax>(int a1@<r12d>)
{
  __int64 v1; // rax
  __int64 v2; // r9
  __int64 v3; // r8
  const char *v4; // rdx
  const __int16 *v5; // r9
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rsi
  __int64 *v10; // rdi
  signed __int64 i; // rcx
  __int64 v12; // rsi
  __int64 v13; // r8
  __int64 v14; // r9
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // r15
  bool v17; // cf
  bool v18; // zf
  signed __int16 v19; // ax
  __int64 v20; // rbx
  __int64 v21; // r9
  __int64 v22; // rax
  unsigned __int64 v23; // rsi
  __int64 v24; // r12
  __int64 v25; // r13
  signed __int16 v26; // ax
  __int64 v27; // rdi
  signed int v28; // esi
  char v29; // di
  __int64 v30; // rax
  __int64 v31; // r8
  __int64 v32; // r9
  char v33; // bl
  __int64 v34; // rax
  __int64 result; // rax
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 v38; // rsi
  __int64 v39; // r8
  __int64 v40; // r9
  __int64 v41; // r8
  __int64 v42; // r9
  __int64 v43; // r8
  __int64 v44; // r9
  __int64 v45; // r8
  __int64 v46; // r9
  __int64 v47; // rax
  __int64 v48; // rax
  signed __int64 v49; // rcx
  __int64 v50; // rax
  __int16 v51; // r12
  unsigned int v52; // er13
  __int64 v53; // r15
  signed __int64 v54; // r14
  unsigned int v55; // esi
  unsigned int v56; // eax
  unsigned int v57; // edx
  unsigned int v58; // eax
  int v59; // er8
  int v60; // er8
  int v61; // esi
  int v62; // edi
  __int64 v63; // rsi
  __int64 v64; // rax
  __int64 v65; // r8
  __int64 v66; // r9
  __int64 v67; // rax
  const char *v68; // rdx
  __int64 v69; // r8
  unsigned __int8 *v70; // rsi
  int v71; // esi
  __int64 v72; // rcx
  int v73; // edi
  __int64 v74; // rax
  __int64 v75; // r9
  __int64 v76; // r8
  __int64 v77; // r9
  __int64 v78; // [rsp+28h] [rbp-128h]
  __int64 v79; // [rsp+30h] [rbp-120h]
  __int64 v80; // [rsp+38h] [rbp-118h]
  __int64 v81[10]; // [rsp+40h] [rbp-110h]
  int v82; // [rsp+94h] [rbp-BCh]
  unsigned int v83; // [rsp+98h] [rbp-B8h]
  int v84; // [rsp+9Ch] [rbp-B4h]
  __int64 v85; // [rsp+A0h] [rbp-B0h]
  __int64 v86; // [rsp+A8h] [rbp-A8h]
  __int128 v87; // [rsp+B0h] [rbp-A0h]
  __int64 v88; // [rsp+C0h] [rbp-90h]
  __int64 v89; // [rsp+C8h] [rbp-88h]
  __int64 v90; // [rsp+D0h] [rbp-80h]
  __int64 v91; // [rsp+E0h] [rbp-70h]
  __int64 v92; // [rsp+E8h] [rbp-68h]
  __int64 v93; // [rsp+F0h] [rbp-60h]
  __int64 v94; // [rsp+F8h] [rbp-58h]
  __int64 v95; // [rsp+100h] [rbp-50h]
  __int64 v96; // [rsp+108h] [rbp-48h]
  int v97; // [rsp+114h] [rbp-3Ch]

  v86 = -6148914691236517206i64;
  v91 = -6148914691236517206i64;
  v78 = 4i64;
  v1 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
         L"panicmedic-threshold",
         qword_92360,
         0i64);
  if ( v1 >= 0 )
  {
    v3 = v78;
    if ( v78 == 4 )
    {
      sub_1A2B6(1, (__int64)"[EB|`P:DC] pmt = %d\n", 240i64, v2);
      goto LABEL_9;
    }
    v4 = "[EB|`P:DC] sz (%qd != %d)\n";
    v5 = (const __int16 *)4;
    goto LABEL_7;
  }
  if ( v1 != -9223372036854775794i64 )
  {
    v4 = "[EB|`P:DC] %r @ GV %S\n";
    v5 = L"panicmedic-threshold";
    v3 = v1;
LABEL_7:
    sub_1A2B6(1, (__int64)v4, v3, (__int64)v5);
  }
  dword_927D0 = 240;
LABEL_9:
  LOBYTE(v87) = 0;
  LOBYTE(v93) = 0;
  v79 = 1i64;
  v6 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("A", qword_92360, 0i64);
  if ( v6 < 0 )
  {
    v9 = v6;
    sub_1A2B6(1, (__int64)"[EB|#P:CPR] N\n", v7, v8);
    if ( v9 != -9223372036854775794i64 )
      sub_1A2B6(1, (__int64)"[EB|`P:DCCPR] %r @ GV %S\n", v9, (__int64)"A");
    goto LABEL_14;
  }
  sub_1A2B6(1, (__int64)"[EB|#P:CPR] %d\n", (unsigned __int8)v87, v8);
  if ( !(_BYTE)v87 )
  {
LABEL_14:
    a1 = 0;
    goto LABEL_15;
  }
  (*(void (__fastcall **)(const char *, __int64 *, signed __int64, __int64, __int64 *))(qword_96CE0 + 88))(
    "A",
    qword_92360,
    7i64,
    v79,
    &v93);
  LOBYTE(a1) = 1;
LABEL_15:
  v10 = &v79;
  for ( i = 23i64; i; --i )
  {
    *(_DWORD *)v10 = -1431655766;
    v10 = (__int64 *)((char *)v10 + 4);
  }
  LOWORD(v93) = -21846;
  *(_DWORD *)((char *)&v93 + 2) = -1431655766;
  HIWORD(v93) = -21846;
  v94 = -6148914691236517206i64;
  v85 = 0i64;
  v12 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
          L"AAPL,PanicInfo0000",
          qword_92360,
          0i64);
  if ( v12 != -9223372036854775803i64 || !v85 )
  {
    sub_1A2B6(1, (__int64)"[EB|#P:MPI] N\n", v13, v14);
    if ( v12 != -9223372036854775794i64 || v85 )
      sub_1A2B6(1, (__int64)"[EB|`P:DCMOSP] %r @ GV %S (%qd)\n", v12, (__int64)L"AAPL,PanicInfo0000");
    v29 = 0;
    goto LABEL_47;
  }
  v97 = a1;
  sub_1A2B6(1, (__int64)"[EB|#P:MPI] Y\n", v13, v14);
  (*(void (__fastcall **)(__int64 *, _QWORD))(qword_96CE0 + 24))(&v93, 0i64);
  v90 = -6148914691236517206i64;
  v92 = 0i64;
  *(_QWORD *)&v87 = 21392441831653441i64;
  *((_QWORD *)&v87 + 1) = 30962664055242796i64;
  v88 = 30962560977272937i64;
  v89 = 13511005047816294i64;
  LODWORD(v90) = 3145776;
  WORD2(v90) = 0;
  v96 = 0i64;
  v15 = 0i64;
  do
  {
    v16 = v15;
    v17 = v15 < 9;
    v18 = v15 == 9;
    v19 = 48;
    if ( !v17 && !v18 )
      v19 = 55;
    WORD1(v90) = v16 + v19;
    v92 = 0i64;
    v20 = (*(__int64 (__fastcall **)(__int128 *, __int64 *, _QWORD, __int64 *, _QWORD))(qword_96CE0 + 72))(
            &v87,
            qword_92360,
            0i64,
            &v92,
            0i64);
    if ( v20 < 0 )
    {
      if ( v20 == -9223372036854775803i64 )
      {
        v96 += v92;
      }
      else if ( v20 == -9223372036854775794i64 )
      {
        break;
      }
    }
    v15 = v16 + 1;
  }
  while ( v16 + 1 < 0x10 );
  if ( !v96 )
  {
    v20 = -9223372036854775804i64;
    LOBYTE(a1) = v97;
LABEL_45:
    sub_1A2B6(1, (__int64)"[EB|`P:DCMOSP] %r @ P:PIC\n", v20, v21);
    goto LABEL_46;
  }
  v22 = sub_1364F(v96);
  LOBYTE(a1) = v97;
  if ( !v22 )
  {
    v20 = -9223372036854775799i64;
    goto LABEL_45;
  }
  v95 = v22;
  if ( v16 )
  {
    v23 = 0i64;
    v24 = v96;
    v25 = v95;
    while ( 1 )
    {
      v26 = 48;
      if ( v23 > 9 )
        v26 = 55;
      WORD1(v90) = v23 + v26;
      v92 = v24;
      v20 = (*(__int64 (__fastcall **)(__int128 *, __int64 *, _QWORD, __int64 *, __int64))(qword_96CE0 + 72))(
              &v87,
              qword_92360,
              0i64,
              &v92,
              v25);
      if ( v20 < 0 )
        break;
      v24 -= v92;
      if ( v24 )
      {
        v25 += v92;
        if ( ++v23 < v16 )
          continue;
      }
      goto LABEL_38;
    }
    v28 = -1431655766;
    v27 = v95;
  }
  else
  {
LABEL_38:
    v27 = v95;
    v28 = sub_17CD4(0, v95, v96);
  }
  sub_136C5(v27);
  LOBYTE(a1) = v97;
  if ( v20 < 0 )
    goto LABEL_45;
  LODWORD(v95) = v28;
  v85 = 92i64;
  v50 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("A", qword_92360, 0i64);
  if ( v50 < 0 )
  {
    v63 = v50;
    sub_1A2B6(1, (__int64)"[EB|`P:DCMOSP] %r @ GV %S\n", v50, (__int64)"A");
    if ( v63 != -9223372036854775794i64 )
    {
LABEL_93:
      v67 = (*(__int64 (__fastcall **)(const char *, __int64 *, signed __int64, _QWORD, _QWORD))(qword_96CE0 + 88))(
              "A",
              qword_92360,
              3i64,
              0i64,
              0i64);
      v68 = "[EB|`P:DCMOSP] %r @ SV- %S\n";
      v69 = v67;
LABEL_94:
      sub_1A2B6(1, (__int64)v68, v69, (__int64)"A");
      goto LABEL_46;
    }
    sub_F1B0(&v79, 92i64);
    v79 = 4660i64;
    LODWORD(v80) = v95;
    sub_1B950((char *)&v93, (char *)&v80 + 4, 0x10ui64);
    v64 = (*(__int64 (__fastcall **)(const char *, __int64 *, signed __int64, signed __int64, __int64 *))(qword_96CE0 + 88))(
            "A",
            qword_92360,
            3i64,
            92i64,
            &v79);
    if ( v64 < 0 )
    {
      v68 = "[EB|`P:DCMOSP] %r @ SV %S (1st)\n";
      v69 = v64;
      goto LABEL_94;
    }
    sub_1A2B6(1, (__int64)"[EB|#P:LOG1]\n", v65, v66);
LABEL_46:
    v29 = 1;
    goto LABEL_47;
  }
  if ( (_DWORD)v79 != 4660 )
  {
    sub_1A2B6(1, (__int64)"[EB|`P:DCMOSP] ! @ 'PLV (%ld, %d)\n", (unsigned int)v79, 4660i64);
    goto LABEL_93;
  }
  v51 = v93;
  LOBYTE(v96) = BYTE2(v93);
  v83 = 3600 * BYTE4(v93) + 60 * BYTE5(v93) + BYTE6(v93);
  v82 = BYTE3(v93);
  v84 = -BYTE3(v93);
  v52 = 0;
  v53 = 0i64;
  while ( 1 )
  {
    v54 = 2 * v53;
    if ( *((_WORD *)&v80 + 8 * v53 + 2) != v51 )
      break;
    if ( *((_BYTE *)&v80 + v54 * 8 + 6) != (_BYTE)v96 )
      break;
    v55 = sub_228E7((unsigned __int16 *)((char *)&v80 + v54 * 8 + 4));
    v56 = sub_228E7((unsigned __int16 *)&v93);
    if ( v55 > v56 )
      break;
    if ( v56 == v55 )
    {
      v57 = 3600 * LOBYTE(v81[v54]) + 60 * BYTE1(v81[v54]) + BYTE2(v81[v54]);
      v58 = v83 - v57;
      if ( v83 < v57 )
        v58 = 0;
    }
    else
    {
      v59 = *((unsigned __int8 *)&v80 + v54 * 8 + 7);
      if ( (unsigned __int8)v59 >= (unsigned __int8)v82 )
        break;
      v60 = v84 + v59;
      v61 = 0;
      v58 = 0;
      do
      {
        v62 = 86400;
        if ( !v61 )
          v62 = -3600 * LOBYTE(v81[v54]) - 60 * BYTE1(v81[v54]) - BYTE2(v81[v54]) + 86400;
        v58 += v62;
        --v61;
      }
      while ( v60 != v61 );
    }
    if ( !v58 )
      break;
    if ( v58 > v52 )
      v52 = v58;
    if ( (unsigned __int64)++v53 >= 5 )
      goto LABEL_102;
  }
  v52 = 0;
LABEL_102:
  v71 = v80;
  v72 = 0i64;
  if ( (unsigned int)(HIDWORD(v79) + 1) <= 4 )
    v72 = (unsigned int)(HIDWORD(v79) + 1);
  v73 = v95;
  LODWORD(v80) = v95;
  HIDWORD(v79) = v72;
  sub_1B950((char *)&v93, (char *)&v80 + 16 * v72 + 4, 0x10ui64);
  v74 = (*(__int64 (__fastcall **)(const char *, __int64 *, signed __int64, signed __int64, __int64 *))(qword_96CE0 + 88))(
          "A",
          qword_92360,
          3i64,
          92i64,
          &v79);
  if ( v74 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`P:DCMOSP] %r @ SV %S\n", v74, (__int64)"A");
    v29 = 1;
    goto LABEL_108;
  }
  sub_1A2B6(1, (__int64)"[EB|#P:SLOT] %d\n", HIDWORD(v79), v75);
  if ( v71 == v73 )
  {
    sub_1A2B6(1, (__int64)"[EB|#P:SKIP.3]\n", v76, v77);
    v29 = 0;
LABEL_108:
    LOBYTE(a1) = v97;
    goto LABEL_47;
  }
  LOBYTE(a1) = v97;
  if ( v52 && v52 < 0xF0 )
  {
    sub_1A2B6(1, (__int64)"[EB|#P:STAT] %d in %d s\n", 5i64, v52);
    sub_226B1(5u, v52);
  }
  else
  {
    sub_1A2B6(1, (__int64)"[EB|#P:SKIP.4] %d s\n", v52, v77);
  }
  v29 = 1;
LABEL_47:
  LOBYTE(v87) = 0;
  v79 = 1i64;
  v30 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(
          L"panicmedic-panic-count",
          qword_92360,
          0i64);
  if ( v30 < 0 )
  {
    v38 = v30;
    result = (__int64)sub_1A2B6(1, (__int64)"[EB|#P:BPI] N\n", v31, v32);
    v33 = 1;
    if ( v38 != -9223372036854775794i64 )
      result = (__int64)sub_1A2B6(1, (__int64)"[EB|`P:DCMOSPG] %r @ GV %S\n", v38, (__int64)L"panicmedic-panic-count");
  }
  else if ( v79 == 1 )
  {
    sub_1A2B6(1, (__int64)"[EB|#P:BPI] Y (%d)\n", (unsigned __int8)v87, v32);
    v33 = 0;
    v34 = (*(__int64 (__fastcall **)(const __int16 *, __int64 *, signed __int64, _QWORD, _QWORD))(qword_96CE0 + 88))(
            L"panicmedic-panic-count",
            qword_92360,
            3i64,
            0i64,
            0i64);
    result = (__int64)sub_1A2B6(1, (__int64)"[EB|`P:DCMOSPG] %r @ SV- %S\n", v34, (__int64)L"panicmedic-panic-count");
    if ( (unsigned __int8)v87 >= 5u )
    {
      result = (__int64)sub_226B1((unsigned __int8)v87, 0xF0u);
      v33 = 0;
    }
  }
  else
  {
    result = (__int64)sub_1A2B6(1, (__int64)"[EB|`P:DCMOSPG] sz (%qd != %d)\n", v79, 1i64);
    v33 = 1;
  }
  if ( (unsigned __int8)a1 | (unsigned __int8)v29 || !v33 )
  {
    sub_1A2B6(1, (__int64)"\n", v36, v37);
    sub_1A2B6(1, (__int64)"**************************************************\n", v39, v40);
    sub_1A2B6(1, (__int64)"This system was automatically rebooted after panic\n", v41, v42);
    sub_1A2B6(1, (__int64)"**************************************************\n", v43, v44);
    if ( qword_96AA8 & 2 )
    {
      sub_BA8B(2u);
      v48 = qword_96CD8;
      v49 = 5000000i64;
    }
    else
    {
      sub_C2C4(0, 0, v45, v46);
      result = sub_B95F();
      if ( result < 0 )
        return result;
      sub_CAE6(0i64, 0i64);
      sub_D24B();
      if ( (*(__int64 (__fastcall **)(signed __int64, _QWORD, _QWORD, _QWORD, __int64 *))(qword_96CD8 + 80))(
             0x80000000i64,
             0i64,
             0i64,
             0i64,
             &v91) >= 0 )
      {
        v93 = -6148914691236517206i64;
        v87 = xmmword_8F040;
        v81[0] = -6148914691236517206i64;
        (*(void (__fastcall **)(__int64, signed __int64, signed __int64))(qword_96CD8 + 88))(v91, 2i64, 100000000i64);
        v79 = v91;
        v80 = *(_QWORD *)(*(_QWORD *)(qword_96CD0 + 48) + 16i64);
        if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92B50, 0i64, &v93) < 0 )
        {
          (*(void (__fastcall **)(signed __int64, __int64 *, __int64 *))(qword_96CD8 + 96))(2i64, &v79, &v86);
        }
        else
        {
          v81[0] = *(_QWORD *)(v93 + 16);
          do
          {
            if ( (*(__int64 (__fastcall **)(signed __int64, __int64 *, __int64 *))(qword_96CD8 + 96))(3i64, &v79, &v86) < 0 )
              break;
            if ( v86 != 2 )
              break;
            v47 = (*(__int64 (__fastcall **)(__int64, __int128 *))(v93 + 8))(v93, &v87);
            if ( WORD6(v87) )
              break;
          }
          while ( v47 >= 0 );
        }
        (*(void (__fastcall **)(__int64))(qword_96CD8 + 112))(v91);
      }
      sub_B814();
      v48 = qword_96CD8;
      v49 = 1000000i64;
    }
    (*(void (__fastcall **)(signed __int64))(v48 + 248))(v49);
    result = sub_FF72();
    if ( qword_96AA0 )
    {
      v70 = sub_F403(qword_96AA8, qword_96AA0, 0i64, 0i64);
      result = sub_136C5(qword_96AA0);
      qword_96AA0 = (__int64)v70;
    }
  }
  return result;
}
// 21B43: write access to const memory at 927D0 has been detected
// 22522: write access to const memory at 96AA0 has been detected
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);
// 41404: using guessed type __int16 aPanicmedicThre[21];
// 4145C: using guessed type __int16 aAaplPanicinfo0[19];
// 414BC: using guessed type __int16 aPanicmedicPani[23];
// 8F040: using guessed type __int128 xmmword_8F040;
// 92360: using guessed type __int64 qword_92360[2];
// 927D0: using guessed type int dword_927D0;
// 92B50: using guessed type __int64 qword_92B50[2];
// 96AA0: using guessed type __int64 qword_96AA0;
// 96AA8: using guessed type __int64 qword_96AA8;
// 96CD0: using guessed type __int64 qword_96CD0;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;
// 21A79: using guessed type __int64 var_110[10];

//----- (00000000000226B1) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_BYTE *__fastcall sub_226B1(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // er14
  unsigned int v3; // er15
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 (__fastcall *v13)(const char *, __int64 *, signed __int64, signed __int64, char *); // rax
  _BYTE *result; // rax
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // [rsp+30h] [rbp-40h]
  char v20; // [rsp+3Eh] [rbp-32h]
  char v21; // [rsp+3Fh] [rbp-31h]

  v2 = a2;
  v3 = a1;
  v21 = -86;
  v19 = 1i64;
  v4 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("p", qword_92360, 0i64);
  if ( v4 < 0 )
  {
    sub_1A2B6(1, (__int64)"[EB|`P:TPM] %r @ GV %S\n", v4, (__int64)"p");
    v21 = 0;
  }
  else if ( v21 )
  {
    sub_1A2B6(1, (__int64)"[EB|#P:PM] Shutdown\n", v5, v6);
    v7 = (*(__int64 (__fastcall **)(const char *, __int64 *, signed __int64, _QWORD, _QWORD))(qword_96CE0 + 88))(
           "A",
           qword_92360,
           3i64,
           0i64,
           0i64);
    sub_1A2B6(1, (__int64)"[EB|`P:TPM] %r @ SV- %S\n", v7, (__int64)"A");
    v8 = (*(__int64 (__fastcall **)(const char *, __int64 *, signed __int64, _QWORD, _QWORD))(qword_96CE0 + 88))(
           "p",
           qword_92360,
           7i64,
           0i64,
           0i64);
    sub_1A2B6(1, (__int64)"[EB|`P:TPM] %r @ SV- %S\n", v8, (__int64)"A");
    sub_C2C4(0, 0, v9, v10);
    if ( qword_96AA8 & 2 )
    {
      sub_BA8B(2u);
    }
    else if ( sub_B95F() >= 0 )
    {
      sub_CAE6(0i64, 0i64);
      sub_BB0D();
    }
    sub_1A2B6(1, (__int64)"***************************************************************\n", v11, v12);
    sub_1A2B6(1, (__int64)"Panic loop detected (%d in %3d seconds).  System will shut down.\n", v3, v2);
    sub_1A2B6(1, (__int64)"Try booting into the Recovery HD volume by holding Command + R.\n", v15, v16);
    sub_1A2B6(1, (__int64)"***************************************************************\n", v17, v18);
    (*(void (__fastcall **)(signed __int64))(qword_96CD8 + 248))(30000000i64);
    return (_BYTE *)sub_52BA(2u, 4u);
  }
  sub_1A2B6(1, (__int64)"[EB|#P:PM] Enable\n", v5, v6);
  v13 = *(__int64 (__fastcall **)(const char *, __int64 *, signed __int64, signed __int64, char *))(qword_96CE0 + 88);
  v20 = 1;
  result = (_BYTE *)v13("p", qword_92360, 7i64, 1i64, &v20);
  if ( (signed __int64)result < 0 )
    result = sub_1A2B6(1, (__int64)"[EB|`P:TPM] %r @ SV %S\n", (__int64)result, (__int64)"p");
  byte_96AD0 = 1;
  return result;
}
// 2285B: write access to const memory at 96AD0 has been detected
// 92360: using guessed type __int64 qword_92360[2];
// 96AA8: using guessed type __int64 qword_96AA8;
// 96AD0: using guessed type char byte_96AD0;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (00000000000228E7) ----------------------------------------------------
__int64 __fastcall sub_228E7(unsigned __int16 *a1)
{
  unsigned __int64 v1; // r11
  __int16 v2; // r10
  unsigned int v3; // er8
  bool v4; // r9
  unsigned __int64 v5; // rcx
  __int64 *v6; // rdx
  __int64 result; // rax

  v1 = *((unsigned __int8 *)a1 + 2);
  if ( *((_BYTE *)a1 + 2) )
  {
    v2 = *a1;
    v3 = *a1 - 100 * (5243 * ((unsigned int)*a1 >> 2) >> 17);
    v4 = *a1 == 400 * (2622 * ((unsigned int)*a1 >> 4) >> 16) && (_BYTE)v1 == 2;
    v5 = 0i64;
    v6 = qword_8FD20;
    LODWORD(result) = 0;
    while ( 1 )
    {
      if ( !(v2 & 3) )
      {
        if ( (_WORD)v3 )
        {
          if ( (_BYTE)v1 == 2 )
            goto LABEL_11;
        }
        else if ( v4 )
        {
LABEL_11:
          result = (unsigned int)(result + 29);
          goto LABEL_5;
        }
      }
      result = (unsigned int)(*(_DWORD *)v6 + result);
LABEL_5:
      ++v5;
      v6 = (__int64 *)((char *)v6 + 4);
      if ( v5 >= v1 )
        return result;
    }
  }
  return 0i64;
}
// 8FD20: using guessed type __int64 qword_8FD20[6];

//----- (0000000000022976) ----------------------------------------------------
__int64 __fastcall sub_22976(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 v5; // rbx
  __int64 v6; // r14
  __int64 v7; // rax
  __int64 v8; // r8
  char v10; // [rsp+30h] [rbp-60h]
  char v11; // [rsp+37h] [rbp-59h]
  char v12; // [rsp+38h] [rbp-58h]
  char *v13; // [rsp+48h] [rbp-48h]
  __int64 v14; // [rsp+50h] [rbp-40h]
  __int64 v15; // [rsp+58h] [rbp-38h]
  __int64 v16; // [rsp+60h] [rbp-30h]

  v16 = 0i64;
  v14 = 0i64;
  v3 = -9223372036854775806i64;
  if ( a1 )
  {
    v4 = a2;
    if ( a2 )
    {
      v5 = a3;
      if ( a3 )
      {
        v6 = a1;
        v7 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92AE0, 0i64, &v16);
        if ( v7 < 0
          || (v7 = (*(__int64 (__fastcall **)(__int64, __int64 *))v16)(v16, &v14), v7 < 0)
          || (v7 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(
                     qword_92AF0,
                     0i64,
                     &v15),
              v7 < 0)
          || (v13 = &v10,
              (*(void (__fastcall **)(char *, signed __int64, _QWORD))(qword_96CD8 + 360))(&v10, 20i64, 0i64),
              v7 = (*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD, int *, signed __int64, char **))(v15 + 8))(
                     v15,
                     qword_92B00,
                     0i64,
                     &dword_92D2C,
                     16i64,
                     &v13),
              v7 < 0) )
        {
          v3 = v7;
        }
        else
        {
          LOBYTE(v8) = 1;
          v3 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64, __int64, __int64, char **))(v15 + 8))(
                 v15,
                 qword_92B00,
                 v8,
                 v4,
                 v5,
                 &v13);
          if ( v3 >= 0 )
          {
            v11 = v11 & 0xF | 0x50;
            v12 = v12 & 0x3F | 0x80;
            (*(void (__fastcall **)(__int64, char *, signed __int64))(qword_96CD8 + 352))(v6, &v10, 16i64);
          }
        }
      }
    }
  }
  if ( v16 && v14 )
    (*(void (**)(void))(v16 + 8))();
  return v3;
}
// 92AE0: using guessed type __int64 qword_92AE0[2];
// 92AF0: using guessed type __int64 qword_92AF0[2];
// 92B00: using guessed type __int64 qword_92B00[2];
// 92D2C: using guessed type int dword_92D2C;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000022AE1) ----------------------------------------------------
void __fastcall sub_22AE1(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rsi
  __int64 v5; // r15
  unsigned __int64 v6; // rcx
  bool v7; // cf
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rax
  _QWORD *v10; // rdi
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // r14
  unsigned __int64 v14; // rsi
  __int64 v15; // r15
  unsigned __int64 *v16; // rdi
  unsigned __int64 v17; // rbx

  if ( a2 )
  {
    v4 = a4;
    if ( a4 )
    {
      v5 = a1;
      if ( a1 )
      {
        v6 = a2[2];
        v7 = v6 < a3;
        v8 = v6 - a3;
        if ( !v7 )
        {
          if ( v8 < a4 )
            v4 = v8;
          if ( a2[2] > a3 )
          {
            v9 = *a2;
            if ( *a2 )
            {
              v10 = a2 + 3;
              v11 = 0i64;
              v12 = a3;
              while ( 1 )
              {
                v7 = v12 < v10[1];
                v12 -= v10[1];
                if ( v7 )
                  break;
                v10 += 2;
                ++v11;
                a3 = v12;
                if ( v11 >= v9 )
                {
                  a3 = 0i64;
                  break;
                }
              }
              if ( v11 != v9 )
              {
                v13 = v10[1] - a3;
                if ( v13 >= v4 )
                  v13 = v4;
                (*(void (__fastcall **)(__int64, unsigned __int64, unsigned __int64))(qword_96CD8 + 352))(
                  v5,
                  *v10 + a3,
                  v13);
                v14 = v4 - v13;
                if ( v14 )
                {
                  v15 = v13 + v5;
                  v16 = v10 + 3;
                  do
                  {
                    v17 = *v16;
                    if ( v14 < *v16 )
                      v17 = v14;
                    (*(void (__fastcall **)(__int64, _QWORD, unsigned __int64))(qword_96CD8 + 352))(
                      v15,
                      *(v16 - 1),
                      v17);
                    v15 += v17;
                    v16 += 2;
                    v14 -= v17;
                  }
                  while ( v14 );
                }
              }
            }
          }
        }
      }
    }
  }
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000022C00) ----------------------------------------------------
__int64 __fastcall sub_22C00(__int64 a1, unsigned __int64 a2, _QWORD *a3, __int64 a4)
{
  if ( a2 >= 8 && a3 <= (_QWORD *)((char *)a3 + a4 - 8) )
    JUMPOUT(__CS__, *(&off_91680 + (unsigned __int8)*a3));
  return 0i64;
}
// 91680: using guessed type void *off_91680;

//----- (0000000000022ED4) ----------------------------------------------------
__int64 sub_22ED4(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list v4; // [rsp+20h] [rbp-20h]
  va_list va; // [rsp+68h] [rbp+28h]

  va_start(va, a3);
  va_copy(v4, va);
  return sub_22EF5(a1, a2, (signed __int16 *)a3, (unsigned __int64 **)&v4);
}

//----- (0000000000022EF5) ----------------------------------------------------
signed __int64 __fastcall sub_22EF5(__int64 a1, unsigned __int64 a2, signed __int16 *a3, unsigned __int64 **a4)
{
  __int64 v4; // r13
  signed __int16 v5; // ax
  unsigned __int64 v6; // r15
  unsigned __int64 v7; // r12
  signed __int16 *v8; // rbx
  unsigned __int64 v9; // r11
  __int64 v10; // r8
  unsigned __int64 v11; // rcx
  __int64 v12; // r9
  signed __int16 *v13; // rax
  unsigned __int16 v14; // di
  unsigned __int64 *v15; // rax
  unsigned __int16 v16; // bx
  unsigned __int64 *v17; // rax
  __int16 v18; // cx
  __int16 *v19; // rax
  const char **v20; // rax
  const char *v21; // r8
  __int16 v22; // di
  __int64 v23; // rax
  unsigned __int64 v24; // rsi
  unsigned __int64 *v25; // rax
  unsigned __int64 *v26; // rdx
  signed __int64 v27; // rdx
  signed __int64 v28; // r8
  __int16 v29; // cx
  __int16 *v30; // rax
  unsigned int **v31; // rax
  __int64 v32; // rax
  signed __int64 *v33; // rax
  __int16 v34; // cx
  __int16 *v35; // rax
  const char **v36; // rax
  const char *v37; // r8
  unsigned __int8 v38; // r10
  __int64 v39; // rax
  unsigned __int64 v40; // rsi
  __int64 *v41; // rax
  unsigned __int16 **v42; // rax
  __int64 v43; // rax
  unsigned __int64 v44; // rsi
  bool v45; // cf
  unsigned __int64 v46; // rsi
  __int16 v48; // [rsp+40h] [rbp-90h]
  char v49; // [rsp+42h] [rbp-8Eh]
  unsigned __int64 v50; // [rsp+80h] [rbp-50h]
  unsigned __int64 **v51; // [rsp+88h] [rbp-48h]
  unsigned __int64 v52; // [rsp+90h] [rbp-40h]

  v51 = a4;
  v4 = a1;
  v5 = *a3;
  v6 = 0i64;
  if ( *a3 )
  {
    v7 = (a2 >> 1) - 1;
    if ( a2 >> 1 != 1 )
    {
      v8 = a3;
      v9 = (a2 >> 1) - 2;
      v6 = 0i64;
      v10 = a2;
      v50 = a2;
      v52 = (a2 >> 1) - 2;
      while ( 1 )
      {
        if ( v5 == 10 )
        {
          v5 = 10;
          if ( v6 < v9 )
          {
            *(_WORD *)(v4 + 2 * v6++) = 13;
            v10 -= 2i64;
            v5 = *v8;
          }
        }
        else if ( v5 == 37 )
        {
          v11 = 0i64;
          v12 = 0i64;
LABEL_7:
          v13 = v8;
          ++v8;
          while ( 1 )
          {
            v14 = *v8;
            if ( *v8 > 82 )
              break;
            switch ( v14 )
            {
              case 0x25u:
                *(_WORD *)(v4 + 2 * v6) = 37;
                goto LABEL_62;
              case 0x26u:
              case 0x27u:
              case 0x28u:
              case 0x29u:
              case 0x2Eu:
              case 0x2Fu:
              case 0x3Au:
              case 0x3Bu:
              case 0x3Cu:
              case 0x3Du:
              case 0x3Eu:
              case 0x3Fu:
              case 0x40u:
              case 0x41u:
              case 0x42u:
              case 0x43u:
              case 0x44u:
              case 0x45u:
              case 0x46u:
              case 0x47u:
              case 0x48u:
              case 0x49u:
              case 0x4Au:
              case 0x4Bu:
                goto LABEL_43;
              case 0x2Au:
                v15 = *v51;
                ++*v51;
                v11 = *v15;
                goto LABEL_7;
              case 0x2Bu:
                v12 |= 2ui64;
                break;
              case 0x2Cu:
                v12 |= 8ui64;
                break;
              case 0x2Du:
                v12 |= 1ui64;
                break;
              case 0x30u:
                v12 |= 0x20ui64;
                goto LABEL_20;
              case 0x31u:
              case 0x32u:
              case 0x33u:
              case 0x34u:
              case 0x35u:
              case 0x36u:
              case 0x37u:
              case 0x38u:
              case 0x39u:
LABEL_20:
                v11 = 0i64;
                do
                {
                  v11 = v14 + 10 * v11 - 48;
                  v14 = v13[2];
                  v16 = v13[2] - 48;
                  ++v13;
                }
                while ( v16 < 0xAu );
                v8 = v13;
                goto LABEL_7;
              case 0x4Cu:
                goto LABEL_12;
              default:
                if ( v14 != 32 )
                  goto LABEL_43;
                v12 |= 4ui64;
                break;
            }
LABEL_17:
            ++v8;
            ++v13;
          }
          switch ( v14 )
          {
            case 0x61u:
              v36 = (const char **)*v51;
              ++*v51;
              v37 = *v36;
              if ( !*v36 )
                v37 = "<null string>";
              if ( v6 >= v7 )
              {
                v40 = 0i64;
              }
              else
              {
                v38 = *v37;
                if ( *v37 )
                {
                  v39 = 0i64;
                  do
                  {
                    *(_WORD *)(v4 + 2 * v6 + 2 * v39) = v38;
                    v40 = v39 + 1;
                    if ( v6 + v39 + 1 >= v7 )
                      break;
                    v38 = v37[v39++ + 1];
                  }
                  while ( v38 );
                  v6 += v40;
                }
                else
                {
                  v40 = 0i64;
                }
              }
              if ( v6 < v7 && v40 < v11 )
              {
                v46 = v40 + 1;
                do
                {
                  *(_WORD *)(v4 + 2 * v6++) = 32;
                  if ( v6 >= v7 )
                    break;
                  v45 = v46++ < v11;
                }
                while ( v45 );
              }
              goto LABEL_76;
            case 0x62u:
            case 0x65u:
            case 0x66u:
            case 0x68u:
            case 0x69u:
            case 0x6Au:
            case 0x6Bu:
            case 0x6Du:
            case 0x6Eu:
            case 0x6Fu:
            case 0x70u:
            case 0x71u:
            case 0x76u:
            case 0x77u:
              goto LABEL_43;
            case 0x63u:
              v25 = *v51;
              ++*v51;
              *(_WORD *)(v4 + 2 * v6) = *(_WORD *)v25;
              goto LABEL_62;
            case 0x64u:
              v26 = *v51;
              ++*v51;
              v27 = *v26;
              v28 = (signed int)v27;
              if ( v12 & 0x10 )
                v28 = v27;
              sub_23A4C(&v48, 0x1Eui64, v28, v12 | 0x80, v11);
              if ( v6 >= v7 )
                goto LABEL_74;
              v29 = v48;
              a2 = v50;
              if ( !v48 )
                goto LABEL_75;
              v30 = (__int16 *)&v49;
              v9 = v52;
              do
              {
                *(_WORD *)(v4 + 2 * v6++) = v29;
                if ( v6 >= v7 )
                  break;
                v29 = *v30;
                ++v30;
              }
              while ( v29 );
              goto LABEL_76;
            case 0x67u:
              v31 = (unsigned int **)*v51;
              ++*v51;
              if ( !*v31 )
                goto LABEL_76;
              v32 = sub_23590(*v31, v4 + 2 * v6, v10);
              goto LABEL_72;
            case 0x6Cu:
LABEL_12:
              v12 |= 0x10ui64;
              goto LABEL_17;
            case 0x72u:
              v41 = (__int64 *)*v51;
              ++*v51;
              v32 = sub_2362C(*v41, v4 + 2 * v6, v10);
LABEL_72:
              v9 = v52;
              a2 = v50;
              v6 += v32;
              goto LABEL_76;
            case 0x73u:
              goto LABEL_35;
            case 0x74u:
              v42 = (unsigned __int16 **)*v51;
              ++*v51;
              v43 = sub_22ED4(
                      v4 + 2 * v6,
                      v10,
                      (__int64)L"%02d/%02d/%04d  %02d:%02d",
                      *((unsigned __int8 *)*v42 + 2),
                      *((unsigned __int8 *)*v42 + 3),
                      **v42,
                      *((unsigned __int8 *)*v42 + 4),
                      *((unsigned __int8 *)*v42 + 5));
              v9 = v52;
              a2 = v50;
              v6 = v43 + v6 - 1;
              goto LABEL_76;
            case 0x75u:
              v33 = (signed __int64 *)*v51;
              ++*v51;
              sub_23A4C(&v48, 0x1Eui64, *v33, v12, v11);
              if ( v6 >= v7 )
                goto LABEL_74;
              v34 = v48;
              a2 = v50;
              if ( !v48 )
                goto LABEL_75;
              v35 = (__int16 *)&v49;
              v9 = v52;
              do
              {
                *(_WORD *)(v4 + 2 * v6++) = v34;
                if ( v6 >= v7 )
                  break;
                v34 = *v35;
                ++v35;
              }
              while ( v34 );
              goto LABEL_76;
            case 0x78u:
              goto LABEL_29;
            default:
              if ( v14 == 83 )
              {
LABEL_35:
                v20 = (const char **)*v51;
                ++*v51;
                v21 = *v20;
                if ( !*v20 )
                  v21 = "<";
                if ( v6 < v7 && (v22 = *(_WORD *)v21) != 0 )
                {
                  v23 = 0i64;
                  do
                  {
                    *(_WORD *)(v4 + 2 * v6 + 2 * v23) = v22;
                    v24 = v23 + 1;
                    if ( v6 + v23 + 1 >= v7 )
                      break;
                    v22 = *(_WORD *)&v21[2 * v23++ + 2];
                  }
                  while ( v22 );
                  v6 += v24;
                }
                else
                {
                  v24 = 0i64;
                }
                if ( v6 < v7 && v24 < v11 )
                {
                  v44 = v24 + 1;
                  do
                  {
                    *(_WORD *)(v4 + 2 * v6++) = 32;
                    if ( v6 >= v7 )
                      break;
                    v45 = v44++ < v11;
                  }
                  while ( v45 );
                }
              }
              else if ( v14 == 88 )
              {
                LOBYTE(v12) = v12 | 0x20;
                v11 = 16i64;
LABEL_29:
                v17 = *v51;
                ++*v51;
                sub_23982(&v48, 0x1Eui64, *v17, v12, v11);
                if ( v6 >= v7 )
                {
LABEL_74:
                  a2 = v50;
LABEL_75:
                  v9 = v52;
                }
                else
                {
                  v18 = v48;
                  a2 = v50;
                  v9 = v52;
                  if ( v48 )
                  {
                    v19 = (__int16 *)&v49;
                    do
                    {
                      *(_WORD *)(v4 + 2 * v6++) = v18;
                      if ( v6 >= v7 )
                        break;
                      v18 = *v19;
                      ++v19;
                    }
                    while ( v18 );
                  }
                }
              }
              else
              {
LABEL_43:
                *(_WORD *)(v4 + 2 * v6) = v14;
LABEL_62:
                ++v6;
              }
LABEL_76:
              v10 = a2 - 2 * v6;
              break;
          }
          goto LABEL_77;
        }
        *(_WORD *)(v4 + 2 * v6++) = v5;
        v10 -= 2i64;
LABEL_77:
        v5 = v8[1];
        if ( v5 )
        {
          ++v8;
          if ( v6 < v7 )
            continue;
        }
        break;
      }
    }
  }
  *(_WORD *)(v4 + 2 * v6) = 0;
  return (signed __int64)(2 * v6 + 2) >> 1;
}
// 41568: using guessed type __int16 a02d02d04d02d02[26];

//----- (0000000000023590) ----------------------------------------------------
__int64 __fastcall sub_23590(unsigned int *a1, __int64 a2, __int64 a3)
{
  return sub_22ED4(
           a2,
           a3,
           (__int64)"%",
           *a1,
           *((unsigned __int16 *)a1 + 2),
           *((unsigned __int16 *)a1 + 3),
           *((unsigned __int8 *)a1 + 8),
           *((unsigned __int8 *)a1 + 9),
           *((unsigned __int8 *)a1 + 10),
           *((unsigned __int8 *)a1 + 11),
           *((unsigned __int8 *)a1 + 12),
           *((unsigned __int8 *)a1 + 13),
           *((unsigned __int8 *)a1 + 14),
           *((unsigned __int8 *)a1 + 15))
       - 1;
}

//----- (000000000002362C) ----------------------------------------------------
__int64 __fastcall sub_2362C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r10
  __int64 v4; // r11
  __int64 v5; // rax
  __int64 *v6; // rcx
  __int64 v7; // rdx
  __int64 v8; // r9
  const __int16 *v9; // r8
  __int64 v10; // rcx
  __int64 v11; // rdx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = &qword_92850;
  do
  {
    v7 = *v6;
    v6 += 2;
  }
  while ( v7 != v5 && v7 != 0x8000000000000000i64 );
  v8 = *(v6 - 1);
  if ( v8 )
  {
    v9 = L"%a";
    v10 = v4;
    v11 = v3;
  }
  else
  {
    v9 = (const __int16 *)"%";
    v10 = v4;
    v11 = v3;
    v8 = v5;
  }
  return sub_22ED4(v10, v11, (__int64)v9, v8) - 1;
}
// 4159C: using guessed type __int16 aA_3[3];
// 92850: using guessed type __int64 qword_92850;

//----- (0000000000023695) ----------------------------------------------------
bool __fastcall sub_23695(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  int v3; // er8

  v2 = 0i64;
  v3 = 0;
  do
  {
    v3 |= *(_DWORD *)(a1 + 4 * v2) - *(_DWORD *)(a2 + 4 * v2);
    ++v2;
  }
  while ( v2 != 4 );
  return v3 == 0;
}

//----- (00000000000236BB) ----------------------------------------------------
signed __int64 __fastcall sub_236BB(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  signed __int64 result; // rax

  if ( (unsigned __int8)a1 & 7 || ((unsigned __int8)a3 | (unsigned __int8)a2) & 7 )
  {
    if ( a3 )
      goto LABEL_4;
    return 0i64;
  }
  if ( !a3 )
    return 0i64;
  result = 0i64;
  while ( *a1 == *a2 )
  {
    ++a1;
    ++a2;
    a3 -= 8i64;
    if ( !a3 )
      return result;
  }
LABEL_4:
  while ( 1 )
  {
    result = *(char *)a1 - (signed __int64)*(char *)a2;
    if ( *(char *)a1 != (signed __int64)*(char *)a2 )
      break;
    a1 = (_QWORD *)((char *)a1 + 1);
    a2 = (_QWORD *)((char *)a2 + 1);
    if ( !--a3 )
      return 0i64;
  }
  return result;
}

//----- (000000000002370D) ----------------------------------------------------
void __fastcall sub_2370D(_WORD *a1, __int16 *a2)
{
  __int16 v2; // ax
  __int16 *v3; // rdx

  if ( a1 && a2 )
  {
    v2 = *a2;
    if ( *a2 )
    {
      v3 = a2 + 1;
      do
      {
        *a1 = v2;
        ++a1;
        v2 = *v3;
        ++v3;
      }
      while ( v2 );
    }
    *a1 = 0;
  }
}

//----- (0000000000023741) ----------------------------------------------------
__int64 __fastcall sub_23741(_WORD *a1)
{
  __int64 result; // rax

  if ( !a1 || !*a1 )
    return 0i64;
  result = 0i64;
  while ( a1[result++ + 1] != 0 )
    ;
  return result;
}

//----- (0000000000023764) ----------------------------------------------------
signed __int64 __fastcall sub_23764(_WORD *a1)
{
  signed __int64 result; // rax
  bool v2; // zf

  result = 1i64;
  if ( a1 && *a1 )
  {
    result = 1i64;
    do
    {
      v2 = a1[result] == 0;
      ++result;
    }
    while ( !v2 );
  }
  return result * 2;
}

//----- (000000000002378A) ----------------------------------------------------
unsigned __int64 __fastcall sub_2378A(unsigned __int16 *a1, _WORD *a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 *v3; // rcx

  v2 = *a1;
  if ( *a1 )
  {
    v3 = a1 + 1;
    while ( v2 == *a2 )
    {
      ++a2;
      v2 = *v3;
      ++v3;
      if ( !v2 )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v2 = 0;
  }
  return v2 - (unsigned __int64)(unsigned __int16)*a2;
}

//----- (00000000000237BC) ----------------------------------------------------
signed __int64 __fastcall sub_237BC(_WORD *a1, __int16 *a2)
{
  signed __int64 result; // rax
  __int16 v4; // cx
  __int16 *v5; // rdx

  if ( a1 && *a1 )
  {
    result = 0i64;
    while ( a1[result++ + 1] != 0 )
      ;
  }
  else
  {
    result = 0i64;
  }
  if ( a2 )
  {
    result = (signed __int64)&a1[result];
    if ( result )
    {
      v4 = *a2;
      if ( *a2 )
      {
        v5 = a2 + 1;
        do
        {
          *(_WORD *)result = v4;
          result += 2i64;
          v4 = *v5;
          ++v5;
        }
        while ( v4 );
      }
      *(_WORD *)result = 0;
    }
  }
  return result;
}

//----- (0000000000023811) ----------------------------------------------------
__int64 __fastcall sub_23811(_BYTE *a1)
{
  __int64 result; // rax

  if ( !*a1 )
    return 0i64;
  result = 0i64;
  while ( a1[result++ + 1] != 0 )
    ;
  return result;
}

//----- (000000000002382D) ----------------------------------------------------
signed __int64 __fastcall sub_2382D(_BYTE *a1, char *a2)
{
  _BYTE *v2; // rax
  char v3; // cl
  char *v4; // rdx

  v2 = a1;
  v3 = *a2;
  if ( *a2 )
  {
    v4 = a2 + 1;
    do
    {
      *v2++ = v3;
      v3 = *v4++;
    }
    while ( v3 );
  }
  *v2 = 0;
  return (signed __int64)(v2 + 1);
}

//----- (0000000000023853) ----------------------------------------------------
void __fastcall sub_23853(signed __int64 a1, char *a2, signed __int64 a3)
{
  char v3; // r10
  __int64 v4; // rax
  signed __int64 v5; // r11

  if ( a3 )
  {
    v3 = *a2;
    if ( *a2 )
    {
      v4 = 0i64;
      do
      {
        *(_BYTE *)(a1 + v4) = v3;
        v5 = v4 + 1;
        if ( a3 - 1 == v4 )
          break;
        v3 = a2[v4++ + 1];
      }
      while ( v3 );
      a3 -= v5;
      a1 += v5;
    }
    sub_23C16(a1, a3);
  }
}

//----- (0000000000023894) ----------------------------------------------------
signed __int64 __fastcall sub_23894(_BYTE *a1)
{
  signed __int64 result; // rax

  if ( !*a1 )
    return 1i64;
  result = 1i64;
  while ( a1[result++] != 0 )
    ;
  return result;
}

//----- (00000000000238B5) ----------------------------------------------------
unsigned __int64 __fastcall sub_238B5(unsigned __int8 *a1, _BYTE *a2, unsigned __int64 a3)
{
  unsigned __int8 v3; // al
  unsigned __int8 *v4; // rcx

  if ( !a3 )
    return 0i64;
  v3 = *a1;
  if ( *a1 )
  {
    v4 = a1 + 1;
    while ( a3 >= 2 && v3 == *a2 )
    {
      ++a2;
      --a3;
      v3 = *v4++;
      if ( !v3 )
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v3 = 0;
  }
  return v3 - (unsigned __int64)(unsigned __int8)*a2;
}

//----- (00000000000238F1) ----------------------------------------------------
_WORD *__fastcall sub_238F1(_WORD *a1, _WORD *a2)
{
  __int16 v2; // r11
  _WORD *v3; // r8
  _WORD *v4; // r9
  signed __int64 v5; // r10
  _WORD *result; // rax

  v2 = *a1;
  if ( *a1 )
  {
    v3 = a2;
    v4 = a1;
    do
    {
      if ( !*v3 )
        break;
      if ( v2 == *v3 )
      {
        ++v3;
        v5 = (signed __int64)(v4 + 1);
      }
      else
      {
        v4 = a1;
        v5 = (signed __int64)(a1 + 1);
        v3 = a2;
        ++a1;
      }
      v2 = v4[1];
      v4 = (_WORD *)v5;
    }
    while ( v2 );
  }
  else
  {
    v3 = a2;
  }
  result = 0i64;
  if ( !*v3 )
    result = a1;
  return result;
}

//----- (000000000002394B) ----------------------------------------------------
_WORD *__fastcall sub_2394B(unsigned __int8 *a1, _WORD *a2)
{
  _WORD *result; // rax
  unsigned __int8 v3; // r8
  _WORD *v4; // r9
  unsigned __int8 *v5; // rcx

  result = a2;
  v3 = *a1;
  v4 = a2;
  if ( *a1 )
  {
    v5 = a1 + 1;
    v4 = a2;
    do
    {
      *v4 = v3;
      ++v4;
      v3 = *v5++;
    }
    while ( v3 );
  }
  *v4 = 0;
  return result;
}

//----- (0000000000023982) ----------------------------------------------------
unsigned __int64 __fastcall sub_23982(_WORD *a1, unsigned __int64 a2, unsigned __int64 a3, char a4, unsigned __int64 a5)
{
  char v5; // r12
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // r14
  _WORD *v8; // rsi
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // rax
  unsigned int v11; // er12
  unsigned __int64 v12; // rax
  __int16 v14; // [rsp+1Eh] [rbp-72h]
  __int16 v15[56]; // [rsp+20h] [rbp-70h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = 0i64;
  do
  {
    v15[v9++] = a0123456789abcd_0[v6 & 0xF];
    v6 = sub_23C9F(v6, 4);
  }
  while ( v6 );
  v10 = 29i64;
  if ( a5 < 0x1D )
    v10 = a5;
  if ( !(v5 & 1) && v9 < v10 )
  {
    v11 = ((v5 & 0x20u) >> 1) | 0x20;
    do
      v15[v9++] = v11;
    while ( v9 < v10 );
  }
  if ( !v7 )
    goto LABEL_20;
  if ( (signed __int64)(2 * v9) >> 1 >= v7 )
    v9 = v7 - 1;
  if ( !v9 )
  {
    v9 = 0i64;
  }
  else
  {
LABEL_20:
    v12 = v9;
    do
    {
      *v8 = *(&v14 + v12);
      ++v8;
      --v12;
    }
    while ( v12 );
  }
  *v8 = 0;
  return v9;
}
// 8FD50: using guessed type __int16 a0123456789abcd_0[16];
// 23982: using guessed type __int16 var_70[56];

//----- (0000000000023A4C) ----------------------------------------------------
signed __int64 __fastcall sub_23A4C(_WORD *a1, unsigned __int64 a2, signed __int64 a3, __int64 a4, unsigned __int64 a5)
{
  _WORD *v5; // r12
  unsigned __int64 v6; // rcx
  signed __int64 v7; // r14
  signed __int64 v8; // rdi
  signed __int64 result; // rax
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r13
  signed __int64 v12; // r15
  unsigned __int64 v13; // rcx
  char v14; // bl
  int v15; // edi
  __int16 v16; // bx
  signed __int64 v17; // rcx
  __int16 v18; // [rsp+1Eh] [rbp-A2h]
  __int16 v19; // [rsp+20h] [rbp-A0h]
  __int16 v20[35]; // [rsp+22h] [rbp-9Eh]
  unsigned __int64 v21; // [rsp+68h] [rbp-58h]
  unsigned __int64 v22; // [rsp+70h] [rbp-50h]
  __int64 v23; // [rsp+78h] [rbp-48h]
  bool v24; // [rsp+87h] [rbp-39h]

  v22 = a2;
  v5 = a1;
  v23 = a4;
  v6 = -a3;
  v24 = (a4 & 0x80u) != 0i64 && a3 < 0;
  if ( !v24 )
    v6 = a3;
  v7 = -1i64;
  v8 = 1i64;
  result = 0i64;
  v10 = 0i64;
  do
  {
    v11 = v10;
    v12 = result;
    v6 = sub_23CAD(v6, 0xAui64, &v21);
    result = v12 + 1;
    v10 = v11 + 1;
    *(&v19 + v12) = v21 + 48;
    if ( v23 & 8
      && v6
      && !(v7 + 3 * ((unsigned __int64)(0xAAAAAAAAAAAAAAABui64 * (unsigned __int128)(unsigned __int64)v8 >> 64) >> 1)) )
    {
      v20[v12] = 44;
      result = v12 + 2;
      v10 = v11 + 2;
    }
    --v7;
    ++v8;
  }
  while ( v6 );
  v13 = 29i64;
  if ( a5 < 0x1D )
    v13 = a5;
  v14 = v24;
  if ( v24 )
  {
    *(&v19 + result++) = 45;
    ++v10;
  }
  v15 = 16 * (unsigned __int8)(v14 ^ 1) | 0x20;
  v16 = 32;
  if ( v23 & 0x20 )
    v16 = v15;
  if ( !(v23 & 1) )
  {
    while ( v10 < v13 )
    {
      *(&v19 + result++) = v16;
      ++v10;
    }
  }
  if ( v22 && 2 * result >> 1 >= v22 )
    result = v22 - 1;
  if ( result )
  {
    v17 = result;
    do
    {
      *v5 = *(&v18 + v17);
      ++v5;
      --v17;
    }
    while ( v17 );
  }
  *v5 = 0;
  return result;
}
// 23A4C: using guessed type __int16 var_9E[35];

//----- (0000000000023BC8) ----------------------------------------------------
void __fastcall sub_23BC8(_QWORD *a1)
{
  *a1 = a1;
  a1[1] = a1;
}

//----- (0000000000023BD5) ----------------------------------------------------
bool __fastcall sub_23BD5(_QWORD *a1)
{
  return *a1 == (_QWORD)a1;
}

//----- (0000000000023BE1) ----------------------------------------------------
__int64 __fastcall sub_23BE1(__int64 *a1)
{
  __int64 result; // rax
  _QWORD *v2; // rcx

  result = *a1;
  v2 = (_QWORD *)a1[1];
  *v2 = result;
  *(_QWORD *)(result + 8) = v2;
  return result;
}

//----- (0000000000023BF5) ----------------------------------------------------
_QWORD *__fastcall sub_23BF5(__int64 a1, _QWORD *a2)
{
  _QWORD *result; // rax

  result = *(_QWORD **)(a1 + 8);
  *a2 = a1;
  a2[1] = result;
  *result = a2;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

//----- (0000000000023C0D) ----------------------------------------------------
__int64 __fastcall sub_23C0D(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (0000000000023C16) ----------------------------------------------------
void __fastcall sub_23C16(signed __int64 a1, signed __int64 a2)
{
  signed __int64 v2; // rdi
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // r8
  signed __int64 v6; // rcx
  char *v7; // rdi
  _QWORD *savedregs; // [rsp+0h] [rbp+0h]

  savedregs = &savedregs;
  if ( a2 )
  {
    v2 = a1;
    v3 = a2;
    v4 = 0i64;
    if ( a2 >= 16 )
    {
      BYTE1(v4) = 0;
      v4 |= (v4 << 16) | ((v4 | (v4 << 16)) << 32);
      v5 = a2 - (-v2 & 7);
      v6 = -v2 & 7;
      memset((void *)v2, v4, v6);
      v7 = (char *)(v2 + v6);
      memset64(v7, v4, v5 >> 3);
      v2 = (signed __int64)&v7[8 * (v5 >> 3)];
      v3 = v5 & 7;
    }
    memset((void *)v2, v4, v3);
  }
}

//----- (0000000000023C84) ----------------------------------------------------
__int64 __fastcall sub_23C84(__int64 a1, char a2)
{
  return a1 << a2;
}

//----- (0000000000023C92) ----------------------------------------------------
__int64 __fastcall sub_23C92(__int64 a1, __int64 a2)
{
  return a2 * a1;
}

//----- (0000000000023C9F) ----------------------------------------------------
unsigned __int64 __fastcall sub_23C9F(unsigned __int64 a1, char a2)
{
  return a1 >> a2;
}

//----- (0000000000023CAD) ----------------------------------------------------
unsigned __int64 __fastcall sub_23CAD(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  if ( a3 )
    *a3 = a1 % a2;
  return a1 / a2;
}

//----- (0000000000023CCE) ----------------------------------------------------
char __fastcall sub_23CCE(unsigned __int64 a1)
{
  unsigned __int64 v1; // rcx
  char v2; // cl

  if ( !a1 )
    return -1;
  v1 = a1 >> 1;
  if ( v1 )
  {
    _BitScanReverse64(&v1, v1);
    v2 = v1 ^ 0x3F;
  }
  else
  {
    v2 = 64;
  }
  return 64 - v2;
}

//----- (0000000000023CF5) ----------------------------------------------------
__int64 __fastcall sub_23CF5(__int64 a1)
{
  __int64 v1; // r8
  __int64 v2; // rcx
  __int64 result; // rax

  if ( !a1 )
    goto LABEL_11;
  v1 = a1;
  while ( (*(_BYTE *)a1 & 0x7F) != 127 || *(_BYTE *)(a1 + 1) != -1 )
    a1 += *(unsigned __int16 *)(a1 + 2);
  v2 = a1 - v1 + 4;
  if ( v2 )
    result = sub_2418C(v2, v1);
  else
LABEL_11:
    result = 0i64;
  return result;
}

//----- (0000000000023D3E) ----------------------------------------------------
signed __int64 __fastcall sub_23D3E(__int64 a1)
{
  __int64 i; // rax

  if ( !a1 )
    return 0i64;
  for ( i = a1; (*(_BYTE *)i & 0x7F) != 127 || *(_BYTE *)(i + 1) != -1; i += *(unsigned __int16 *)(i + 2) )
    ;
  return i - a1 + 4;
}

//----- (0000000000023D7F) ----------------------------------------------------
__int64 __fastcall sub_23D7F(__int64 a1)
{
  __int64 v2; // [rsp+20h] [rbp-10h]

  v2 = 0i64;
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(a1, qword_92A90, &v2);
  return v2;
}
// 92A90: using guessed type __int64 qword_92A90[2];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000023DB4) ----------------------------------------------------
__int64 __fastcall sub_23DB4(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 i; // rax
  __int64 j; // rdi
  signed __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // rax
  __int64 v8; // rbx

  v2 = a2;
  if ( !a1 )
  {
    a1 = a2;
    return sub_23CF5(a1);
  }
  if ( !a2 )
    return sub_23CF5(a1);
  for ( i = a1; (*(_BYTE *)i & 0x7F) != 127 || *(_BYTE *)(i + 1) != -1; i += *(unsigned __int16 *)(i + 2) )
    ;
  for ( j = a2; (*(_BYTE *)j & 0x7F) != 127 || *(_BYTE *)(j + 1) != -1; j += *(unsigned __int16 *)(j + 2) )
    ;
  v5 = j - a2 + 4;
  v6 = i - a1;
  v7 = sub_2418C(i - a1 + v5, a1);
  v8 = v7;
  if ( v7 )
    (*(void (__fastcall **)(__int64, __int64, signed __int64))(qword_96CD8 + 352))(v7 + v6, v2, v5);
  return v8;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000023E90) ----------------------------------------------------
__int64 __fastcall sub_23E90(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rax
  __int64 v4; // rdi
  __int64 v5; // rsi

  v2 = a1;
  v3 = sub_2418C(*(unsigned __int8 *)(a2 + 2) + ((unsigned __int64)*(unsigned __int8 *)(a2 + 3) << 8) + 4, a2);
  if ( !v3 )
    return 0i64;
  v4 = v3;
  *(_DWORD *)(v4 + (*(unsigned __int8 *)(v3 + 2) | ((unsigned __int64)*(unsigned __int8 *)(v4 + 3) << 8))) = (_DWORD)&byte_4FF7F;
  v5 = sub_23DB4(v2, v3);
  (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v4);
  return v5;
}
// 4FF7F: using guessed type char byte_4FF7F;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000023EFD) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_23EFD(__int64 a1, __int64 a2)
{
  _WORD *v2; // rax
  __int16 v3; // cx
  _WORD *v4; // rdi
  __int64 v5; // rdx
  __int64 v6; // rcx
  _WORD *v8; // [rsp+28h] [rbp-18h]

  qword_96CD0 = a2;
  qword_96CD8 = *(_QWORD *)(a2 + 96);
  qword_96CE0 = *(_QWORD *)(a2 + 88);
  sub_23FC3((__int64)&dword_92804, &v8);
  v2 = v8;
  v3 = *v8;
  if ( *v8 != -1 )
  {
    while ( 1 )
    {
      if ( v2 )
      {
        v4 = v2;
        while ( v3 != -1 && v3 != 4 )
        {
          v5 = (unsigned __int16)v4[1];
          v3 = *(_WORD *)((char *)v4 + v5);
          v4 = (_WORD *)((char *)v4 + v5);
        }
        if ( v3 == -1 )
          v4 = v2;
      }
      else
      {
        v4 = 0i64;
      }
      if ( *v4 == 4 && sub_23695((__int64)&dword_92834, (__int64)(v4 + 4)) )
        break;
      v6 = (unsigned __int16)v4[1];
      v2 = (_WORD *)((char *)v4 + v6);
      v8 = (_WORD *)((char *)v4 + v6);
      v3 = *(_WORD *)((char *)v4 + v6);
      if ( v3 == -1 )
        return 0i64;
    }
    v8 = (_WORD *)((char *)v4 + (unsigned __int16)v4[1]);
    sub_241E9(*((_QWORD *)v4 + 3));
  }
  return 0i64;
}
// 23F07: write access to const memory at 96CD0 has been detected
// 23F12: write access to const memory at 96CD8 has been detected
// 23F1D: write access to const memory at 96CE0 has been detected
// 92804: using guessed type int;
// 92834: using guessed type int;
// 96CD0: using guessed type __int64 qword_96CD0;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000023FC3) ----------------------------------------------------
signed __int64 __fastcall sub_23FC3(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rbx
  signed __int64 v3; // r14
  __int64 v4; // rax
  _QWORD *v5; // r15
  __int64 v6; // rsi
  unsigned __int64 v7; // rdi

  v2 = a1;
  v3 = -9223372036854775794i64;
  *a2 = 0i64;
  v4 = qword_96CD0;
  if ( *(_QWORD *)(qword_96CD0 + 104) )
  {
    v5 = a2;
    v6 = 0i64;
    v7 = 0i64;
    while ( !sub_23695(v2, v6 + *(_QWORD *)(v4 + 112)) )
    {
      ++v7;
      v4 = qword_96CD0;
      v6 += 24i64;
      if ( v7 >= *(_QWORD *)(qword_96CD0 + 104) )
        return v3;
    }
    *v5 = *(_QWORD *)(*(_QWORD *)(qword_96CD0 + 112) + v6 + 16);
    v3 = 0i64;
  }
  return v3;
}
// 96CD0: using guessed type __int64 qword_96CD0;

//----- (0000000000024047) ----------------------------------------------------
__int64 __fastcall sub_24047(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v3; // [rsp+28h] [rbp-18h]

  v1 = a1;
  v3 = 0i64;
  (*(void (__fastcall **)(__int64 *, __int64, _QWORD, _QWORD))(qword_96CD8 + 128))(&v3, a1, 0i64, 0i64);
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(qword_96CD8 + 144))(v3, v1, 0i64);
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000024098) ----------------------------------------------------
__int64 __fastcall sub_24098(_QWORD *a1, __int64 a2)
{
  __int64 result; // rax

  *a1 = a2;
  result = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  return result;
}

//----- (00000000000240AB) ----------------------------------------------------
signed __int64 __fastcall sub_240AB(_QWORD *a1)
{
  _QWORD *v2; // rsi

  if ( a1[2] )
    return -9223372036854775793i64;
  v2 = a1;
  a1[1] = (*(__int64 (__fastcall **)(_QWORD))(qword_96CD8 + 24))(*a1);
  ++v2[2];
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000240E8) ----------------------------------------------------
__int64 __fastcall sub_240E8(__int64 a1)
{
  __int64 v1; // rax

  v1 = *(_QWORD *)(a1 + 8);
  --*(_QWORD *)(a1 + 16);
  return (*(__int64 (__fastcall **)(__int64))(qword_96CD8 + 32))(v1);
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000024103) ----------------------------------------------------
__int64 __fastcall sub_24103(__int64 a1)
{
  __int64 v2; // [rsp+20h] [rbp-10h]

  v2 = 0i64;
  (*(void (__fastcall **)(signed __int64, __int64, __int64 *))(qword_96CD8 + 64))(4i64, a1, &v2);
  return v2;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000024136) ----------------------------------------------------
__int64 __fastcall sub_24136(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi
  __int64 v4; // [rsp+28h] [rbp-18h]

  v1 = a1;
  v4 = 0i64;
  (*(void (__fastcall **)(signed __int64, __int64, __int64 *))(qword_96CD8 + 64))(4i64, a1, &v4);
  v2 = v4;
  if ( v4 )
    (*(void (__fastcall **)(__int64, __int64, _QWORD))(qword_96CD8 + 360))(v4, v1, 0i64);
  return v2;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000002418C) ----------------------------------------------------
__int64 __fastcall sub_2418C(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v5; // [rsp+20h] [rbp-20h]

  v2 = a2;
  v3 = a1;
  v5 = 0i64;
  (*(void (__fastcall **)(signed __int64, __int64, __int64 *))(qword_96CD8 + 64))(4i64, a1, &v5);
  if ( !v5 )
    return 0i64;
  (*(void (__fastcall **)(__int64, __int64, __int64))(qword_96CD8 + 352))(v5, v2, v3);
  return v5;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000241E9) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_241E9(__int64 a1)
{
  qword_96CE8 = a1;
}
// 241ED: write access to const memory at 96CE8 has been detected
// 96CE8: using guessed type __int64 qword_96CE8;

//----- (00000000000241F6) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 sub_241F6()
{
  signed __int64 v0; // rsi
  char v1; // di
  unsigned __int64 v2; // rdi
  unsigned __int64 v3; // rax
  __int64 v4; // rax
  char v6; // [rsp+30h] [rbp-50h]
  char v7; // [rsp+34h] [rbp-4Ch]
  char v8; // [rsp+38h] [rbp-48h]
  int v9; // [rsp+40h] [rbp-40h]
  int v10; // [rsp+44h] [rbp-3Ch]
  unsigned __int64 v11; // [rsp+48h] [rbp-38h]
  _QWORD *v12; // [rsp+50h] [rbp-30h]

  v12 = 0i64;
  if ( byte_96CF0 )
    return 0i64;
  v0 = sub_26A90(1);
  if ( !(_DWORD)v0 )
  {
    v0 = (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
           *(_QWORD *)(qword_96CD0 + 56),
           qword_92AD0,
           &qword_96CF8);
    if ( v0 >= 0 )
    {
LABEL_21:
      byte_96CF0 = 1;
      goto LABEL_22;
    }
    v1 = 0;
    v0 = (*(__int64 (__fastcall **)(signed __int64, __int64 *, _QWORD, unsigned __int64 *, _QWORD **))(qword_96CD8 + 312))(
           2i64,
           qword_92B60,
           0i64,
           &v11,
           &v12);
    if ( !(_DWORD)v0 )
    {
      v0 = -9223372036854775805i64;
      if ( !v12 )
      {
        v0 = -9223372036854775807i64;
LABEL_19:
        v1 = 0;
        goto LABEL_20;
      }
      if ( !v11 )
        goto LABEL_19;
      if ( (*(__int64 (__fastcall **)(_QWORD, __int64 *, char *))(qword_96CD8 + 152))(*v12, qword_92A90, &v8) < 0 )
      {
        v2 = 1i64;
        while ( 1 )
        {
          v3 = v11;
          if ( v2 >= v11 )
            break;
          v4 = (*(__int64 (__fastcall **)(_QWORD, __int64 *, char *))(qword_96CD8 + 152))(v12[v2++], qword_92A90, &v8);
          if ( v4 >= 0 )
          {
            --v2;
            goto LABEL_15;
          }
        }
      }
      else
      {
        v2 = 0i64;
LABEL_15:
        v3 = v11;
      }
      if ( v2 >= v3 )
        goto LABEL_19;
      v0 = (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
             v12[v2],
             qword_92B60,
             &qword_95040);
      (*(void (__fastcall **)(_QWORD *))(qword_96CD8 + 72))(v12);
      v12 = 0i64;
      if ( (_DWORD)v0 )
        goto LABEL_19;
      v0 = (*(__int64 (__fastcall **)(__int64, int *, int *, char *, char *))qword_95040)(
             qword_95040,
             &v9,
             &v10,
             &v6,
             &v7);
      if ( (_DWORD)v0 )
        goto LABEL_19;
      sub_26AF2(byte_96D00, v9, v10);
      v1 = 1;
    }
LABEL_20:
    if ( !v1 )
      goto LABEL_22;
    goto LABEL_21;
  }
LABEL_22:
  if ( v12 )
    (*(void (**)(void))(qword_96CD8 + 72))();
  return v0;
}
// 24399: write access to const memory at 96CF0 has been detected
// 92A90: using guessed type __int64 qword_92A90[2];
// 92AD0: using guessed type __int64 qword_92AD0[2];
// 92B60: using guessed type __int64 qword_92B60[2];
// 95040: using guessed type __int64 qword_95040;
// 96CD0: using guessed type __int64 qword_96CD0;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CF0: using guessed type char byte_96CF0;
// 96CF8: using guessed type __int64 qword_96CF8;

//----- (00000000000243DB) ----------------------------------------------------
__int64 sub_243DB()
{
  return 0i64;
}

//----- (00000000000243E3) ----------------------------------------------------
__int64 __fastcall sub_243E3(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  __int64 v9; // rax
  __int64 v10; // r8
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 result; // rax

  v9 = a3;
  v10 = a2;
  v11 = a1;
  v12 = qword_96CF8;
  if ( qword_96CF8 || (v12 = qword_95040) != 0 )
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))(v12 + 16))(
               v12,
               v11,
               v10,
               v9,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9);
  else
    result = -9223372036854775802i64;
  return result;
}
// 95040: using guessed type __int64 qword_95040;
// 96CF8: using guessed type __int64 qword_96CF8;

//----- (000000000002445C) ----------------------------------------------------
signed __int64 __fastcall sub_2445C(int a1, __int64 a2, unsigned int *a3, unsigned int *a4)
{
  signed __int64 result; // rax
  unsigned int v5; // esi
  unsigned int v6; // er10
  unsigned int v7; // er11
  int v8; // edi

  result = -9223372036854775806i64;
  if ( a2 && a3 && a4 )
  {
    v5 = *a4;
    v6 = a4[1];
    v7 = v6 + a4[2];
    if ( (signed int)v7 > (signed int)*a3 )
      v7 = *a3;
    v8 = v5 + a4[3];
    if ( v8 > (signed int)a3[1] )
      v8 = a3[1];
    result = 0i64;
    if ( v6 < v7 )
    {
      while ( 1 )
      {
        while ( v5 < v8 )
          *(_DWORD *)(a2 + 4i64 * (v5++ + v6 * a3[1])) = a1;
        if ( ++v6 >= v7 )
          break;
        v5 = *a4;
      }
    }
  }
  return result;
}

//----- (00000000000244D1) ----------------------------------------------------
signed __int64 __fastcall sub_244D1(__int64 a1, __int64 a2, int *a3, __int64 a4, int *a5, int *a6, char a7, __int64 a8)
{
  __int64 v8; // r14
  int *v9; // rsi
  __int64 v10; // r12
  __int64 v11; // r13
  __int64 v12; // rdi
  unsigned int *v13; // rdi
  _QWORD *v14; // rax
  _DWORD *v15; // rsi
  int v16; // eax
  _DWORD *v17; // rax
  __int64 v18; // rax
  _QWORD *v19; // rax
  unsigned int v20; // eax
  int v21; // eax
  unsigned int v22; // ecx
  int v23; // edi
  unsigned int v24; // eax
  int v25; // eax
  unsigned int v26; // eax
  signed __int64 v27; // rax
  signed __int64 v28; // rbx
  signed __int64 v29; // rax
  int v30; // er8
  int v31; // er10
  int v32; // edi
  int v33; // esi
  int v34; // edx
  int v35; // ecx
  int v36; // esi
  int *v37; // rax
  int v38; // edi
  signed __int64 v39; // r12
  int v40; // er13
  int v41; // er15
  unsigned __int8 *v42; // rsi
  unsigned __int8 *v43; // rdi
  int v44; // er14
  __int64 v46; // rax
  __int64 v47; // r8
  int v48; // ebx
  __int64 v49; // r13
  signed __int64 v50; // r14
  __int64 v51; // r15
  __int64 v52; // r12
  int v53[4]; // [rsp+28h] [rbp-98h]
  __int64 v54; // [rsp+38h] [rbp-88h]
  int v55[5]; // [rsp+40h] [rbp-80h]
  int v56; // [rsp+54h] [rbp-6Ch]
  __int64 v57; // [rsp+58h] [rbp-68h]
  unsigned int v58; // [rsp+60h] [rbp-60h]
  int v59; // [rsp+64h] [rbp-5Ch]
  __int64 v60; // [rsp+68h] [rbp-58h]
  int v61; // [rsp+70h] [rbp-50h]
  int v62; // [rsp+74h] [rbp-4Ch]
  __int64 v63; // [rsp+78h] [rbp-48h]
  int *v64; // [rsp+80h] [rbp-40h]

  v8 = a4;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  (*(void (__fastcall **)(unsigned int *, signed __int64, _QWORD))(qword_96CD8 + 360))(&v58, 8i64, 0i64);
  v12 = -9223372036854775806i64;
  if ( !v11 || !v10 || !v9 || !v8 || !a5 || !a6 )
    return v12;
  v13 = (unsigned int *)a8;
  if ( a8 && *(_BYTE *)(a8 + 16) )
  {
    (*(void (__fastcall **)(int *, signed __int64, _QWORD))(qword_96CD8 + 360))(v55, 8i64, 0i64);
    v14 = *(_QWORD **)(a8 + 32);
    if ( !v14 )
      return -9223372036854775806i64;
    v64 = v9;
    v15 = (_DWORD *)*v14;
    if ( *v14 )
    {
      v16 = *(_DWORD *)(a8 + 20);
      while ( *v15 != v16 || *(_QWORD *)(v15 + 1) != *(_QWORD *)a5 )
      {
        v15 = (_DWORD *)*((_QWORD *)v15 + 5);
        if ( !v15 )
          goto LABEL_15;
      }
      if ( v15[8] == *(_DWORD *)a8 && v16 && v15[9] == *(_DWORD *)(a8 + 4) )
      {
        v63 = *((_QWORD *)v15 + 2);
        (*(void (__fastcall **)(int *, _DWORD *, signed __int64))(qword_96CD8 + 352))(v55, v15 + 6, 8i64);
        v12 = 0i64;
LABEL_70:
        v9 = v64;
        (*(void (__fastcall **)(unsigned int *, int *, signed __int64))(qword_96CD8 + 352))(&v58, v55, 8i64);
        v8 = v63;
LABEL_71:
        if ( (_DWORD)v12 )
          return v12;
        goto LABEL_24;
      }
    }
    else
    {
LABEL_15:
      v17 = (_DWORD *)sub_24136(48i64);
      v12 = -9223372036854775799i64;
      if ( !v17 )
        return v12;
      v15 = v17;
      *v17 = *(_DWORD *)(a8 + 20);
      (*(void (__fastcall **)(_DWORD *, int *, signed __int64))(qword_96CD8 + 352))(v17 + 1, a5, 8i64);
      v18 = sub_24136(4 * a5[1] * (signed __int64)*a5);
      if ( !v18 )
      {
        (*(void (__fastcall **)(_DWORD *))(qword_96CD8 + 72))(v15);
        return v12;
      }
      *((_QWORD *)v15 + 2) = v18;
      v13 = (unsigned int *)a8;
      v19 = *(_QWORD **)(a8 + 32);
      *((_QWORD *)v15 + 5) = *v19;
      *v19 = v15;
    }
    if ( *((_QWORD *)v15 + 2) )
    {
      v63 = *((_QWORD *)v15 + 2);
      v20 = sub_2C88C(*v13, a5[1]);
      v21 = sub_2C86B(v20);
      HIDWORD(v60) = v21;
      v22 = v13[1];
      v23 = v21;
      v24 = sub_2C88C(v22, *a5);
      v25 = sub_2C86B(v24);
      LODWORD(v60) = v25;
      if ( v15[2] == v23 && v15[1] == v25 )
      {
        v12 = sub_3E19E(v63, v8, *(_QWORD *)a5, v60);
        if ( (_DWORD)v12 )
        {
LABEL_60:
          if ( (_DWORD)v12 )
          {
            v8 = 0i64;
            v9 = v64;
            goto LABEL_71;
          }
          v15[8] = *(_DWORD *)a8;
          v15[9] = *(_DWORD *)(a8 + 4);
          (*(void (__fastcall **)(_DWORD *, int *, signed __int64))(qword_96CD8 + 352))(v15 + 6, v55, 8i64);
          goto LABEL_70;
        }
        v57 = 0i64;
        goto LABEL_57;
      }
      v46 = sub_24103(4i64 * v23 * v25);
      if ( v46 )
      {
        v56 = v23;
        v47 = *(_QWORD *)a5;
        v48 = v60;
        v57 = v46;
        v12 = sub_3E19E(v46, v8, v47, v60);
        if ( (_DWORD)v12 )
          goto LABEL_58;
        if ( v48 > 0 )
        {
          v54 = v11;
          v49 = v10;
          v50 = 4i64 * v56;
          v51 = v57;
          v52 = v63;
          do
          {
            (*(void (__fastcall **)(__int64, __int64, signed __int64))(qword_96CD8 + 352))(v52, v51, v50);
            v52 += 4i64 * (signed int)v15[2];
            v51 += v50;
            --v48;
          }
          while ( v48 );
          v10 = v49;
          v11 = v54;
        }
LABEL_57:
        (*(void (__fastcall **)(int *, __int64 *, signed __int64))(qword_96CD8 + 352))(v55, &v60, 8i64);
LABEL_58:
        if ( v57 )
          (*(void (**)(void))(qword_96CD8 + 72))();
        goto LABEL_60;
      }
      v12 = -9223372036854775799i64;
    }
    else
    {
      v12 = -9223372036854775806i64;
    }
    v9 = v64;
    v8 = 0i64;
    goto LABEL_71;
  }
  (*(void (__fastcall **)(unsigned int *, int *, signed __int64))(qword_96CD8 + 352))(&v58, a5, 8i64);
LABEL_24:
  if ( v8 )
  {
    v64 = v9;
    v26 = *(_DWORD *)v10;
    v63 = v10;
    sub_26B03(v55, 0, 0, *(_DWORD *)(v10 + 4), v26);
    sub_26B03(v53, *a6, a6[1], v59, v58);
    v27 = sub_26BB1(&v60, v55, v53);
    v28 = -9223372036854775794i64;
    if ( v27 != -9223372036854775794i64 )
    {
      v28 = v27;
      if ( !(_DWORD)v27 )
      {
        v29 = sub_26BB1(&v60, (int *)&v60, v64);
        v28 = -9223372036854775794i64;
        if ( v29 != -9223372036854775794i64 )
        {
          v28 = v29;
          if ( !(_DWORD)v29 )
          {
            v31 = v61;
            v28 = 0i64;
            if ( v61 > 0 )
            {
              LOBYTE(v30) = a7;
              v32 = *v64 - *a6;
              v33 = v64[1] - a6[1];
              v34 = HIDWORD(v60);
              v35 = a5[1];
              if ( v33 < 0 )
                v33 = 0;
              v36 = v35 * v33;
              if ( v32 < 0 )
                v32 = 0;
              v37 = (int *)(v8 + 4i64 * (v36 + v32));
              v38 = *(_DWORD *)(v63 + 4);
              v39 = v11 + 4 * ((signed int)v60 + (signed __int64)(HIDWORD(v60) * *(_DWORD *)(v63 + 4)));
              v40 = HIDWORD(v60);
              do
              {
                if ( v37 )
                {
                  if ( v39 )
                  {
                    v41 = v62;
                    if ( v62 )
                    {
                      v42 = (unsigned __int8 *)v39;
                      v64 = v37;
                      v43 = (unsigned __int8 *)v37;
                      do
                      {
                        v44 = v30;
                        sub_24A5F(v42, v43, v30);
                        v30 = v44;
                        v42 += 4;
                        v43 += 4;
                        --v41;
                      }
                      while ( v41 );
                      v38 = *(_DWORD *)(v63 + 4);
                      v35 = a5[1];
                      v34 = HIDWORD(v60);
                      v31 = v61;
                      v37 = v64;
                    }
                  }
                }
                v39 += 4i64 * v38;
                v37 += v35;
                ++v40;
              }
              while ( v40 < v34 + v31 );
            }
          }
        }
      }
    }
  }
  else
  {
    v28 = -9223372036854775806i64;
  }
  v12 = 0i64;
  if ( (_DWORD)v28 )
    v12 = v28;
  if ( v28 == -9223372036854775794i64 )
    v12 = -9223372036854775794i64;
  return v12;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000024A17) ----------------------------------------------------
__int64 __fastcall sub_24A17(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi

  if ( a1 )
  {
    v1 = a1;
    do
    {
      v2 = *(_QWORD *)(v1 + 40);
      if ( *(_QWORD *)(v1 + 16) )
        (*(void (**)(void))(qword_96CD8 + 72))();
      (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v1);
      v1 = v2;
    }
    while ( v2 );
  }
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000024A5F) ----------------------------------------------------
char __fastcall sub_24A5F(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3)
{
  int v3; // esi
  unsigned int v4; // er11
  unsigned int v5; // er10
  unsigned __int8 v6; // al
  unsigned int v7; // eax
  unsigned int v8; // er11

  if ( a1 )
  {
    if ( a2 )
    {
      v3 = a2[3];
      if ( v3 != 255 && a3 != -1 )
      {
        if ( (_BYTE)v3 )
        {
          v4 = 32897 * v3 * (unsigned int)a1[3] >> 23;
          v5 = v3 * (a1[3] ^ 0xFFu) / (unsigned __int8)~(_BYTE)v4;
          v6 = 255 * (v3 ^ 0xFFu) / (unsigned __int8)~(_BYTE)v4;
          a1[2] = (32897 * (unsigned __int8)v5 * (unsigned int)a1[2] >> 23) + (32897 * v6 * (unsigned int)a2[2] >> 23);
          a1[1] = (32897 * (unsigned __int8)v5 * (unsigned int)a1[1] >> 23) + (32897 * v6 * (unsigned int)a2[1] >> 23);
          v7 = (32897 * (unsigned __int8)v5 * (unsigned int)*a1 >> 23) + (32897 * v6 * (unsigned int)*a2 >> 23);
          *a1 = v7;
          a1[3] = v4;
        }
        else
        {
          v8 = *(_DWORD *)a2;
          *(_DWORD *)a1 = *(_DWORD *)a2;
          v4 = v8 >> 24;
        }
        if ( a3 )
        {
          LOBYTE(v7) = v4 + (32897 * (unsigned __int8)~(_BYTE)v4 * (unsigned int)a3 >> 23);
          a1[3] = v7;
        }
      }
    }
  }
  return v7;
}

//----- (0000000000024B90) ----------------------------------------------------
signed __int64 __fastcall sub_24B90(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 *a7, char a8, _QWORD *a9)
{
  __int64 v9; // r14
  __int64 v10; // rdi
  __int64 v11; // rsi
  __int64 *v12; // r13
  bool v13; // cl
  __int64 v14; // rbx
  __int64 v15; // rdx
  signed __int64 v16; // rdi
  int v17; // esi
  __int64 v18; // rax
  signed __int64 v19; // rsi
  signed __int64 result; // rax
  __int64 *v21; // rdi
  __int64 v22; // rax
  __int64 v23; // r9
  int v24; // ST20_4
  unsigned __int64 **v25; // rsi
  __int64 v26; // rax
  unsigned __int8 *v27; // rax
  __int64 v28; // r9
  int v29; // ST28_4
  int v30; // ST20_4
  _BYTE *v31; // rax
  unsigned __int64 *v32; // rcx
  char *v33; // rdx
  __int64 v34; // rax
  int v35; // edx
  __int64 v36; // rcx
  __int64 v37; // rdi
  unsigned int v38; // edx
  __int64 v39; // rax
  _QWORD *v40; // rsi
  __int64 v41; // rdi
  __int64 v42; // r13
  __int64 v43; // rsi
  char v44; // r15
  char v45; // r14
  __int64 v46; // r12
  __int64 v47; // rax
  char v48; // al
  __int64 v49; // rdx
  __int64 v50; // rdx
  __int64 v51; // rax
  __int64 v52; // r12
  signed __int64 v53; // rsi
  void (__fastcall *v54)(const char *, __int64 *, signed __int64, _QWORD, __int64 *); // r14
  int v55; // eax
  __int64 v56; // rax
  signed int v57; // edi
  signed int v58; // esi
  float v59; // xmm0_4
  float v60; // xmm1_4
  signed int v61; // eax
  signed int v62; // ecx
  __int64 v63; // rax
  __int64 v64; // [rsp+58h] [rbp-4A8h]
  __int64 v65; // [rsp+80h] [rbp-480h]
  unsigned __int64 v66; // [rsp+88h] [rbp-478h]
  __int64 *v67; // [rsp+488h] [rbp-78h]
  __int64 v68; // [rsp+490h] [rbp-70h]
  _QWORD *v69; // [rsp+498h] [rbp-68h]
  __int64 v70; // [rsp+4A0h] [rbp-60h]
  __int64 v71; // [rsp+4A8h] [rbp-58h]
  int v72; // [rsp+4B4h] [rbp-4Ch]
  __int64 v73; // [rsp+4B8h] [rbp-48h]
  char v74; // [rsp+4C7h] [rbp-39h]

  v9 = a4;
  v10 = a3;
  v11 = a2;
  v12 = a1;
  LODWORD(v70) = 0;
  v73 = 4i64;
  v66 = -9034400514174975832i64;
  v65 = 5457143572451254544i64;
  if ( !(*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("E", &v65, 0i64) )
  {
    v13 = (_BYTE)v70 == 49;
    goto LABEL_5;
  }
  v13 = 1;
  if ( a8 & 0x40 )
LABEL_5:
    sub_3FBFF(v13);
  v14 = sub_24136(824i64);
  *(_QWORD *)v14 = v11;
  *(_QWORD *)(v14 + 8) = v10;
  if ( sub_23EFD(v11, v10) )
    sub_1A11E();
  if ( qword_96CD8 )
  {
    (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(qword_96CD8 + 256))(0i64, 0i64, 0i64, 0i64);
    sub_1A11E();
  }
  if ( qword_96AA8 & 2 )
    sub_BA8B(2u);
  v15 = *(_QWORD *)(v14 + 8);
  if ( sub_27B30(*(_QWORD *)v14) < 0 )
    goto LABEL_38;
  *(_DWORD *)(v14 + 32) = sub_BCFC();
  v16 = sub_241F6();
  v65 = 0i64;
  v73 = 0i64;
  v17 = 12566463;
  v72 = 12566463;
  if ( v16 < 0 )
    sub_1A11E();
  if ( (_DWORD)v16 )
    goto LABEL_118;
  v70 = 0i64;
  if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD))(qword_96CD8 + 320))(qword_92CD0, 0i64) >= 0 )
  {
    if ( (*(__int64 (__fastcall **)(int *))(v70 + 8))(&v72) < 0 )
    {
      v17 = 12566463;
      v72 = 12566463;
    }
    else
    {
      v17 = v72;
    }
  }
  v16 = sub_3EF0E(&v73, v17);
  if ( v16 < 0 || !v73 )
    sub_1A11E();
  if ( (_DWORD)v16 )
    goto LABEL_118;
  LODWORD(v71) = *(_DWORD *)(v73 + 12) / 2;
  HIDWORD(v71) = *(_DWORD *)(v73 + 8) / 2 + 160;
  v16 = sub_3DE3B(&v65, (__int64)&dword_927F4, &v71);
  if ( v16 < 0 )
    sub_1A11E();
  if ( (_DWORD)v16 )
    goto LABEL_118;
  v16 = sub_3F18E(v73, v65);
  if ( v16 < 0 )
    sub_1A11E();
  if ( (_DWORD)v16 )
  {
LABEL_118:
    if ( v65 )
      sub_27054(v65);
    if ( v73 )
      sub_3F069((_QWORD *)v73);
    v18 = 0i64;
  }
  else
  {
    v18 = v73;
    v16 = 0i64;
    v65 = 0i64;
    v73 = 0i64;
  }
  if ( v16 >= 0 )
  {
    *(_QWORD *)(v14 + 24) = v18;
    sub_275C4(*(_QWORD *)(v18 + 40), 0);
    sub_1A11E();
    if ( sub_BA8B(1u) )
    {
LABEL_38:
      sub_1A11E();
      v19 = 1i64;
      sub_1A11E();
      return v19;
    }
    v21 = a7;
    sub_1A11E();
    *(_QWORD *)(v14 + 16) = v9;
    v22 = *(_QWORD *)(v14 + 24);
    v23 = *(unsigned int *)(v22 + 12);
    v24 = *(_DWORD *)(v22 + 8);
    sub_1A11E();
    sub_1A11E();
    if ( !a5 && !a7[2] )
    {
      sub_1A11E();
      return 1i64;
    }
    sub_3F181(*(_QWORD *)(v14 + 24), 0i64);
    v25 = (unsigned __int64 **)(v14 + 752);
    if ( sub_2C1A0(*(_QWORD *)(v14 + 16), L"appleLogo.efires", (_QWORD *)(v14 + 752)) )
    {
      sub_1A11E();
      v26 = *(_QWORD *)(v14 + 760);
      goto LABEL_59;
    }
    v27 = *(unsigned __int8 **)(v14 + 24);
    v28 = v27[50];
    v29 = v27[48];
    v30 = v27[49];
    sub_1A11E();
    v31 = *(_BYTE **)(v14 + 24);
    if ( v31[50] || v31[49] || v31[48] )
    {
      if ( a8 >= 0 )
      {
        v32 = *v25;
        v33 = "appleLogo_apple_gray.png";
LABEL_52:
        v26 = sub_2BA6A(v32, v33);
LABEL_58:
        *(_QWORD *)(v14 + 760) = v26;
LABEL_59:
        if ( v26 )
        {
          v34 = *(_QWORD *)(v14 + 24);
          v35 = *(_DWORD *)(v34 + 12) / 2;
          LODWORD(v34) = *(_DWORD *)(v34 + 8) / 2;
          v36 = *(_QWORD *)(v14 + 760);
          v37 = *(_QWORD *)(v36 + 44);
          v66 = *(_QWORD *)(v36 + 52);
          v21 = a7;
          LODWORD(v65) = v35 - SHIDWORD(v66) / 2;
          HIDWORD(v65) = v34 - (signed int)v66 / 2;
          sub_27500(v36, 0);
          sub_27402(*(_DWORD **)(v14 + 760), &v65);
          LOBYTE(v38) = 1;
          sub_275C4(*(_QWORD *)(v14 + 760), v38);
          sub_3F340(*(_QWORD *)(v14 + 24), *(_QWORD *)(v14 + 760));
          sub_3F6AA(*(_QWORD **)(v14 + 24));
          sub_36FB5();
        }
        sub_1A11E();
        LOBYTE(v65) = 0;
        v74 = sub_292C5();
        sub_25949(a6, a5);
        if ( !v21 )
          goto LABEL_119;
        v39 = v21[3];
        if ( v39 )
          *(_BYTE *)(v39 + 57) = 1;
        v40 = a9;
        v41 = a5 - (((unsigned __int64)v21[2] < 1) - 1);
        v69 = (_QWORD *)sub_24136(8 * v41);
        sub_1A11E();
        v67 = v12;
        v68 = v41;
        if ( a5 )
        {
          v42 = a5;
          v43 = 0i64;
          v44 = 0;
          v45 = 0;
          do
          {
            v46 = *(_QWORD *)(a6 + 8 * v43);
            v47 = sub_25B09(*(_QWORD *)(a6 + 8 * v43), (_QWORD *)v14, 0, a5);
            v69[v43] = v47;
            if ( v74 && *(_DWORD *)(v46 + 24) > 0 )
            {
              if ( v43 )
                sub_2A1D1(&v65, ",", 1024);
              sub_2A205(&v65, 1024, ***(_QWORD ***)(v46 + 32), *(_WORD *)(**(_QWORD **)(v46 + 32) + 8i64));
            }
            v48 = *(_BYTE *)(v46 + 16);
            v45 |= v48 & 1;
            v44 |= v48 & 2;
            ++v43;
          }
          while ( a5 != v43 );
          v40 = a9;
        }
        else
        {
          v42 = 0i64;
          v45 = 0;
          v44 = 0;
        }
        sub_1A11E();
        if ( !*v40 && !v40[1] )
          sub_1A11E();
        qmemcpy((void *)(v14 + 768), v40, 0x38ui64);
        *(_QWORD *)(v14 + 720) = a6;
        if ( *a7 )
        {
          sub_25B09(*a7, (_QWORD *)v14, 2u, v42);
          if ( v74 )
          {
            if ( (unsigned int)sub_189FE(&v65) )
              sub_2A1D1(&v65, ",", 1024);
            sub_2A1D1(&v65, "*MasterUser", 1024);
          }
        }
        v49 = a7[1];
        if ( v49 )
        {
          sub_25B09(v49, (_QWORD *)v14, 4u, v42);
          if ( v74 )
          {
            if ( (unsigned int)sub_189FE(&v65) )
              sub_2A1D1(&v65, ",", 1024);
            sub_2A1D1(&v65, "*RecoveryUser", 1024);
          }
        }
        v50 = a7[2];
        if ( v50 )
        {
          v51 = sub_25B09(v50, (_QWORD *)v14, 3u, v42);
          v69[v42] = v51;
          if ( v74 )
          {
            if ( (unsigned int)sub_189FE(&v65) )
              sub_2A1D1(&v65, ",", 1024);
            sub_2A1D1(&v65, "DiskPasswordUser", 1024);
          }
        }
        v52 = sub_25B09(0i64, (_QWORD *)v14, 5u, v42);
        LODWORD(v64) = (a8 & 0x30) == 48;
        v53 = sub_3681B(
                v14 + 40,
                *(_QWORD *)(v14 + 24),
                *(_QWORD *)(v14 + 16),
                v68,
                v69,
                a7[3],
                *a7,
                a7[1],
                v52,
                a8 & 4,
                a8 & 8,
                v64,
                (__int64)sub_25FE0,
                (__int64)sub_26191,
                (__int64)sub_261EC);
        *(_QWORD *)(v14 + 176) = v14;
        *(_BYTE *)(v14 + 344) = v44;
        *(_BYTE *)(v14 + 345) = v45;
        v12 = v67;
        if ( v74 && v52 && sub_34A08(*(unsigned __int64 ***)(v14 + 264)) )
        {
          if ( (unsigned int)sub_189FE(&v65) )
            sub_2A1D1(&v65, ",", 1024);
          sub_2A1D1(&v65, "GuestUser", 1024);
        }
        sub_1A11E();
        if ( v53 >= 0 )
        {
          if ( v74 && (unsigned int)sub_189FE(&v65) )
          {
            v54 = *(void (__fastcall **)(const char *, __int64 *, signed __int64, _QWORD, __int64 *))(qword_96CE0 + 88);
            v55 = sub_189FE(&v65);
            v54("l", qword_93650, 7i64, v55, &v65);
          }
          if ( !v53 )
            goto LABEL_107;
        }
        else
        {
LABEL_119:
          sub_1A11E();
        }
        sub_1A11E();
LABEL_107:
        sub_1A11E();
        v56 = *(_QWORD *)(v14 + 24);
        v57 = *(_DWORD *)(v56 + 8);
        v58 = *(_DWORD *)(v56 + 12);
        v73 = 0i64;
        if ( sub_2C317(
               *(unsigned __int64 **)(v14 + 184),
               "loginui_background.png",
               &v73,
               (unsigned __int64 *)&v71,
               &v70,
               1) )
        {
          sub_1A11E();
          *(_QWORD *)(v14 + 280) = 0i64;
        }
        else
        {
          sub_1A11E();
          sub_1A11E();
          v59 = (float)SHIDWORD(v71);
          v60 = (float)(signed int)v71;
          if ( (float)((float)SHIDWORD(v71) / (float)(signed int)v71) <= (float)((float)v58 / (float)v57) )
          {
            v62 = (signed int)(float)((float)((float)v58 / v59) * v60);
            v61 = v58;
          }
          else
          {
            v61 = (signed int)(float)((float)((float)v57 / v60) * v59);
            v62 = v57;
          }
          v66 = __PAIR__(v61, v62);
          LODWORD(v65) = (v58 - v61) / 2;
          HIDWORD(v65) = (v57 - v62) / 2;
          sub_1A11E();
          sub_26E4B((__int64 *)(v14 + 280), (__int64)&v65);
          v63 = *(_QWORD *)(v14 + 280);
          *(_QWORD *)(v63 + 24) = 4 * (signed int)v66 * (signed __int64)SHIDWORD(v66);
          *(_QWORD *)(v63 + 32) = v66;
          *(_QWORD *)(*(_QWORD *)(v14 + 280) + 16i64) = sub_24103(*(_QWORD *)(*(_QWORD *)(v14 + 280) + 24i64));
          sub_3E188(1u);
          sub_3E19E(*(_QWORD *)(*(_QWORD *)(v14 + 280) + 16i64), v73, v71, *(_QWORD *)(*(_QWORD *)(v14 + 280) + 32i64));
          sub_3E188(0);
          (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v73);
          sub_1A11E();
        }
        if ( v12 )
          *v12 = v14;
        return 0i64;
      }
    }
    else if ( a8 >= 0 )
    {
      v32 = *v25;
      v33 = "appleLogo_apple.png";
      goto LABEL_52;
    }
    v26 = 0i64;
    goto LABEL_58;
  }
  sub_1A11E();
  sub_1A11E();
  result = -9223372036854775798i64;
  if ( v16 != -9223372036854775802i64 )
    result = v16;
  return result;
}
// 415A8: using guessed type __int16 aApplelogoEfire[17];
// 927F4: using guessed type int dword_927F4;
// 92CD0: using guessed type __int64 qword_92CD0[2];
// 93650: using guessed type __int64 qword_93650[2];
// 96AA8: using guessed type __int64 qword_96AA8;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (00000000000257CF) ----------------------------------------------------
signed __int64 __fastcall sub_257CF(__int64 a1, char **a2)
{
  signed __int64 result; // rax

  result = sub_37012(a1 + 40, a2, *(_QWORD *)(a1 + 760));
  if ( result < 0 )
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}

//----- (000000000002580F) ----------------------------------------------------
signed __int64 __fastcall sub_2580F(__int64 a1)
{
  __int64 v1; // rsi
  signed __int64 v2; // rsi
  _QWORD *v3; // rcx

  v1 = a1;
  sub_1A11E();
  if ( v1 )
  {
    sub_36774(v1 + 40);
    sub_367A3(v1 + 40);
    sub_367EF(v1 + 40);
    if ( sub_36CB8((_QWORD *)(v1 + 40)) )
      sub_1A11E();
    sub_1A11E();
    if ( sub_BA8B(*(_DWORD *)(v1 + 32)) || (v3 = *(_QWORD **)(v1 + 24)) != 0i64 && sub_3F069(v3) < 0 || sub_243DB() < 0 )
    {
      sub_1A11E();
      v2 = 1i64;
      sub_1A11E();
    }
    else
    {
      v2 = 0i64;
    }
  }
  else
  {
    sub_1A11E();
    v2 = -1i64;
  }
  return v2;
}

//----- (0000000000025949) ----------------------------------------------------
void __fastcall sub_25949(__int64 a1, signed int a2)
{
  __int64 v2; // rsi
  __int64 v3; // r13
  __int64 v4; // rdi
  unsigned __int64 v5; // rax
  char *v6; // rbx
  __int64 v7; // r12
  __int64 v8; // r14
  unsigned int v9; // edi
  __int64 v10; // r15
  unsigned int v11; // eax
  char *v12; // rcx
  char *v13; // r14
  int v14; // er12
  __int64 v15; // rax
  __int64 v16; // rcx
  signed __int64 v17; // rcx
  __int64 v18; // rdx
  char *v19; // [rsp-68h] [rbp-68h]
  __int64 v20; // [rsp-60h] [rbp-60h]
  char *v21; // [rsp-58h] [rbp-58h]
  __int64 v22; // [rsp-50h] [rbp-50h]
  char **v23; // [rsp-48h] [rbp-48h]
  __int64 v24; // [rsp-40h] [rbp-40h]

  if ( a2 >= 2 )
  {
    v2 = a1;
    v3 = (unsigned int)a2 >> 1;
    v4 = *(_QWORD *)(a1 + 8 * v3);
    v5 = (8i64 * (unsigned int)a2 + 15) & 0xFFFFFFFFFFFFFFF0ui64;
    v6 = (char *)&v19 - v5;
    if ( v4 && *(_DWORD *)(v4 + 24) )
    {
      v21 = (char *)&v24 - v5;
      v23 = &v19;
      v20 = v4;
      v19 = ***(char ****)(v4 + 32);
      v7 = a2;
      v8 = 0i64;
      v9 = 0;
      v22 = 0i64;
      do
      {
        if ( v3 != v8 )
        {
          v10 = *(_QWORD *)(v2 + 8 * v8);
          if ( !*(_DWORD *)(v10 + 24) )
          {
            sub_1A11E();
            return;
          }
          if ( (signed int)sub_18A1A(v19, ***(_BYTE ****)(v10 + 32)) <= 0 )
          {
            v11 = v22;
            v12 = v21;
            v22 = (unsigned int)(v22 + 1);
          }
          else
          {
            v11 = v9;
            v12 = v6;
            ++v9;
          }
          *(_QWORD *)&v12[8 * v11] = v10;
        }
        ++v8;
      }
      while ( v8 < v7 );
      sub_25949(v6, v9);
      v13 = v21;
      v14 = v22;
      sub_25949(v21, (unsigned int)v22);
      if ( (signed int)v9 <= 0 )
      {
        v16 = 0i64;
      }
      else
      {
        v15 = 0i64;
        do
        {
          *(_QWORD *)(v2 + 8 * v15) = *(_QWORD *)&v6[8 * v15];
          ++v15;
        }
        while ( v9 != v15 );
        v16 = (unsigned int)v15;
      }
      *(_QWORD *)(v2 + 8 * v16) = v20;
      if ( v14 > 0 )
      {
        v17 = v2 + 8 * v16 + 8;
        v18 = 0i64;
        do
        {
          *(_QWORD *)(v17 + 8 * v18) = *(_QWORD *)&v13[8 * v18];
          ++v18;
        }
        while ( v14 != v18 );
      }
    }
    else
    {
      sub_1A11E();
    }
  }
}

//----- (0000000000025B09) ----------------------------------------------------
__int64 __usercall sub_25B09@<rax>(__int64 a1@<rdx>, _QWORD *a2@<rcx>, unsigned int a3@<r8d>, __int64 a4@<r13>)
{
  signed __int64 v4; // rbx
  __int64 v5; // r12
  _QWORD *v6; // r15
  __int64 v7; // rdi
  char *v8; // r14
  unsigned __int64 *v9; // rdi
  unsigned __int64 *v10; // rax
  unsigned __int64 *v11; // rsi
  int v12; // ebx
  bool v13; // zf
  char *v14; // r8
  __int64 v15; // r13
  char *v16; // r15
  char *v17; // r12
  char *v18; // r14
  int *v20; // [rsp+38h] [rbp-78h]
  __int64 v21; // [rsp+40h] [rbp-70h]
  __int64 v22; // [rsp+48h] [rbp-68h]
  char *v23; // [rsp+50h] [rbp-60h]
  __int64 v24; // [rsp+58h] [rbp-58h]
  __int64 v25; // [rsp+60h] [rbp-50h]
  unsigned __int64 *v26; // [rsp+68h] [rbp-48h]
  unsigned __int64 *v27; // [rsp+70h] [rbp-40h]

  v4 = a3;
  v5 = a1;
  v6 = a2;
  sub_1A11E();
  v26 = 0i64;
  if ( v5 && *(_QWORD *)(v5 + 40) && *(_QWORD *)(v5 + 48) )
  {
    sub_1A11E();
    sub_2C321(*(_QWORD *)(v5 + 40), *(_QWORD *)(v5 + 48), &v26);
    v7 = 0i64;
    v8 = "@@recovery";
    switch ( (_DWORD)v4 )
    {
      case 1:
        goto LABEL_7;
      case 2:
        goto LABEL_9;
      case 3:
        goto LABEL_10;
      case 4:
        goto LABEL_12;
      case 5:
        goto LABEL_11;
      default:
        break;
    }
LABEL_8:
    v27 = 0i64;
    a4 = 0i64;
    v8 = 0i64;
  }
  else
  {
    v7 = 0i64;
    v8 = "@@recovery";
    switch ( (_DWORD)v4 )
    {
      case 0:
        sub_1A11E();
        goto LABEL_7;
      case 1:
LABEL_7:
        sub_2625A((__int64)v6, (__int16 *)"u", v6 + 93);
        v7 = v6[93];
        v4 = 1i64;
        goto LABEL_8;
      case 2:
LABEL_9:
        v8 = "@@master";
        v7 = 0i64;
        break;
      case 3:
LABEL_10:
        sub_2625A((__int64)v6, L"disk_passwordUI.efires", v6 + 91);
        v7 = v6[91];
        v8 = "@@disk";
        break;
      case 4:
        break;
      case 5:
LABEL_11:
        sub_2625A((__int64)v6, (__int16 *)"g", v6 + 92);
        v7 = v6[92];
        v8 = "@@guest";
        break;
      default:
        goto LABEL_8;
    }
LABEL_12:
    v27 = 0i64;
    sub_1A11E();
    LOBYTE(a4) = 1;
  }
  if ( v7 && v26 )
  {
    sub_1A11E();
    sub_2C52E((__int64)v26, v7, &v27);
  }
  else if ( v26 )
  {
    sub_1A11E();
    v27 = v26;
  }
  else if ( v7 )
  {
    sub_1A11E();
    v27 = (unsigned __int64 *)v7;
  }
  else
  {
    sub_1A11E();
  }
  if ( v5 || (v5 = sub_24136(72i64)) != 0 )
  {
    v9 = v27;
    v10 = (unsigned __int64 *)sub_24136(112i64);
    *(_QWORD *)(v5 + 64) = v10;
    if ( v9 )
    {
      v11 = v10;
      v25 = a4;
      v23 = v8;
      v22 = v4;
      v12 = 0;
      v24 = v5;
      v13 = *(_BYTE *)(v5 + 57) == 0;
      v14 = "avatar_loggedin.png";
      if ( !*(_BYTE *)(v5 + 57) )
        v14 = "avatar.png";
      v15 = (__int64)v6;
      v16 = "avatar_loggedin_pressed.png";
      if ( !*(_BYTE *)(v5 + 57) )
        v16 = "avatar_pressed.png";
      v17 = "avatar_sel_loggedin.png";
      if ( v13 )
        v17 = "avatar_sel.png";
      v18 = "avatar_sel_loggedin_pressed.png";
      if ( v13 )
        v18 = "avatar_sel_pressed.png";
      sub_262D1(v15, v9, v14, v10 + 1, v10);
      sub_262D1(v15, v9, v16, v11 + 2, v11);
      sub_262D1(v15, v9, v17, v11 + 3, v11);
      sub_262D1(v15, v9, v18, v11 + 4, v11);
      sub_262D1(v15, v9, "avatar_back_up.png", v11 + 5, v11);
      sub_262D1(v15, v9, "avatar_back_down.png", v11 + 6, v11);
      sub_2BE2F(v9, "password_hint.png", v11 + 7, v11 + 8, 0i64, 0);
      sub_2BE2F(v9, "serial_record_numbers.png", v11 + 9, v11 + 10, 0i64, 0);
      sub_2BE2F(v9, "recovery_popmsg_call_someone_else.png", v11 + 11, v11 + 12, 0i64, 0);
      v20 = 0i64;
      v21 = 0i64;
      if ( sub_2C719(v9, "unlockOptions.int32", 0, (char **)&v20, (unsigned __int64 *)&v21, 0) || !v20 )
      {
        v8 = v23;
        v5 = v24;
        LOBYTE(a4) = v25;
      }
      else
      {
        v8 = v23;
        v5 = v24;
        LOBYTE(a4) = v25;
        if ( v21 == 4 )
          v12 = *v20;
      }
      *(_DWORD *)(v5 + 16) = v12;
      sub_1A11E();
      LODWORD(v4) = v22;
    }
  }
  else
  {
    sub_1A11E();
    v5 = 0i64;
  }
  if ( (_BYTE)a4 )
  {
    *(_QWORD *)(v5 + 32) = sub_24136(8i64);
    **(_QWORD **)(v5 + 32) = sub_24136(16i64);
    *(_DWORD *)(v5 + 24) = 1;
    ***(_QWORD ***)(v5 + 32) = v8;
    *(_DWORD *)(**(_QWORD **)(v5 + 32) + 8i64) = sub_189FE(v8);
  }
  *(_DWORD *)(v5 + 20) = v4;
  return v5;
}
// 41618: using guessed type __int16 aDiskPasswordui[23];

//----- (0000000000025FE0) ----------------------------------------------------
__int64 __usercall sub_25FE0@<rax>(__int64 a1@<rax>, __int64 a2@<rdx>, __int64 a3@<rcx>, __int16 *a4@<r8>, __int64 a5@<r9>)
{
  _QWORD *v5; // r12
  __int64 v6; // r14
  __int16 *v7; // rbx
  __int64 v8; // r15
  __int64 v9; // rdi
  __int64 *v10; // rsi
  __int64 v11; // rax
  __int64 v12; // rcx
  __int16 v13; // dx
  signed __int16 v14; // dx
  __int64 (__fastcall *v15)(_QWORD *, __int64, __int64 *, _QWORD, __int64); // rax
  unsigned int v16; // edi
  unsigned __int8 (__fastcall *v17)(_QWORD *, __int64, __int64 *, _QWORD, __int64); // rax
  __int64 v19; // [rsp+10h] [rbp-40h]

  v19 = a1;
  v5 = *(_QWORD **)(a3 + 136);
  if ( v5 )
  {
    v6 = a5;
    v7 = a4;
    v8 = a2;
    v9 = a3;
    v10 = &v19 - 258;
    sub_F180((char *)&v19 - 2064, 0, 0x802ui64);
    sub_2370D((_WORD *)&v19 - 1032, v7);
    if ( *(_QWORD *)(v9 + 80) == v8 )
    {
      sub_1A11E();
      v11 = sub_23741((_WORD *)&v19 - 1032);
      if ( v11 )
      {
        v12 = 0i64;
        while ( 1 )
        {
          v13 = *((_WORD *)v10 + v12);
          if ( v13 <= 82 )
            break;
          if ( v13 == 83 )
          {
            v14 = 53;
            goto LABEL_14;
          }
          if ( v13 == 108 )
            goto LABEL_11;
LABEL_15:
          if ( v11 == ++v12 )
            goto LABEL_16;
        }
        if ( v13 == 48 )
        {
          v14 = 79;
        }
        else
        {
          if ( v13 != 49 )
            goto LABEL_15;
LABEL_11:
          v14 = 76;
        }
LABEL_14:
        *((_WORD *)v10 + v12) = v14;
        goto LABEL_15;
      }
    }
LABEL_16:
    v15 = (__int64 (__fastcall *)(_QWORD *, __int64, __int64 *, _QWORD, __int64))v5[97];
    if ( v15 )
    {
      v16 = v15(v5, v8, &v19 - 258, v5[98], v6);
    }
    else
    {
      v17 = (unsigned __int8 (__fastcall *)(_QWORD *, __int64, __int64 *, _QWORD, __int64))v5[96];
      if ( v17 )
      {
        v16 = v17(v5, v8, &v19 - 258, v5[98], v19) == 0;
      }
      else
      {
        sub_1A11E();
        v16 = 1;
      }
    }
    sub_F180((char *)&v19 - 2064, 0, 0x802ui64);
  }
  else
  {
    sub_1A11E();
    v16 = 1;
  }
  return v16;
}

//----- (0000000000026191) ----------------------------------------------------
__int64 __fastcall sub_26191(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 (__fastcall *v4)(__int64, __int64, _QWORD, __int64); // r10

  v3 = *(_QWORD *)(a1 + 136);
  if ( v3 )
  {
    v4 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64))(v3 + 792);
    if ( v4 )
      return v4(a1, a2, *(_QWORD *)(v3 + 800), a3);
  }
  sub_1A11E();
  return 0i64;
}

//----- (00000000000261EC) ----------------------------------------------------
void __fastcall sub_261EC(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rcx
  void (__fastcall *v3)(__int64, _QWORD); // rax

  v1 = a1;
  sub_1A11E();
  v2 = *(_QWORD *)(v1 + 136);
  if ( v2 )
  {
    v3 = *(void (__fastcall **)(__int64, _QWORD))(v2 + 808);
    if ( v3 )
      v3(v2, *(_QWORD *)(v2 + 816));
  }
  else
  {
    sub_1A11E();
  }
}

//----- (000000000002625A) ----------------------------------------------------
signed __int64 __fastcall sub_2625A(__int64 a1, __int16 *a2, _QWORD *a3)
{
  signed __int64 v3; // rdi
  _QWORD *v4; // rdi
  __int16 *v5; // rsi
  __int64 v6; // rbx
  signed __int64 v7; // rax

  if ( *a3 )
    return 0i64;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  sub_1A11E();
  v7 = sub_2C1A0(*(_QWORD *)(v6 + 16), v5, v4);
  if ( !v7 )
    return 0i64;
  v3 = v7;
  sub_1A11E();
  return v3;
}

//----- (00000000000262D1) ----------------------------------------------------
void __fastcall sub_262D1(__int64 a1, unsigned __int64 *a2, char *a3, _QWORD *a4, unsigned __int64 *a5)
{
  _QWORD *v5; // r15
  char *v6; // rsi
  __int64 v7; // rbx
  unsigned __int64 **v8; // rdi

  v5 = a4;
  v6 = a3;
  v7 = a1;
  if ( sub_2BE2F(a2, a3, a4, a5, 0i64, 1) )
  {
    sub_1A11E();
    v8 = (unsigned __int64 **)(v7 + 744);
    if ( sub_2625A(v7, (__int16 *)"u", (_QWORD *)(v7 + 744)) || !*v8 )
    {
      sub_1A11E();
    }
    else if ( sub_2BE2F(*v8, v6, v5, a5, 0i64, 1) )
    {
      sub_1A11E();
    }
  }
}

//----- (00000000000263BE) ----------------------------------------------------
signed __int64 __fastcall sub_263BE(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  signed __int64 v4; // rsi
  __int64 v5; // r15
  __int64 v6; // r14
  __int64 v7; // rbx
  _QWORD *v8; // rdi
  char v10; // [rsp+30h] [rbp-110h]
  char v11; // [rsp+90h] [rbp-B0h]
  __int64 v12; // [rsp+100h] [rbp-40h]
  __int64 v13; // [rsp+108h] [rbp-38h]

  v13 = 0i64;
  v12 = 0i64;
  v4 = -9223372036854775806i64;
  if ( a1 )
  {
    v5 = a2;
    if ( a2 )
    {
      v6 = a3;
      if ( a3 )
      {
        v7 = a4;
        if ( a4 )
        {
          v8 = a1;
          (*(void (__fastcall **)(char *, signed __int64, _QWORD))(qword_96CD8 + 360))(&v10, 96i64, 0i64);
          (*(void (__fastcall **)(char *, signed __int64, _QWORD))(qword_96CD8 + 360))(&v11, 96i64, 0i64);
          sub_2653B((__int64)&v10, 0x60ui64, v7);
          v4 = sub_2665A(v7, &v13, (__int64)&v12);
          if ( !(_DWORD)v4 )
            v4 = sub_267C8(v13, v12, v8, v5, v6, dword_92D28);
        }
      }
    }
  }
  if ( v13 )
    (*(void (**)(void))(qword_96CD8 + 72))();
  return v4;
}
// 92D28: using guessed type int dword_92D28;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000002653B) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_2653B(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  signed __int64 result; // rax
  __int64 v4; // r14
  __int64 v5; // rbx
  __int64 v6; // rdi
  char v7; // al
  __int64 v8; // r15
  __int64 v9; // rsi
  bool v10; // al
  char v11; // [rsp+28h] [rbp-48h]
  __int64 v12; // [rsp+38h] [rbp-38h]

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v4 = a2;
    if ( a2 >= 3 )
    {
      v5 = a3;
      if ( a3 )
      {
        v6 = a1;
        v7 = 1;
        if ( !byte_95048 )
        {
          if ( sub_22976((__int64)&v11, (__int64)L"GuidList", 16i64) >= 0 )
          {
            v12 = 0i64;
            if ( sub_2665A((__int64)&v11, &qword_95050, (__int64)&v12) >= 0 )
              byte_95048 = 1;
          }
          v7 = byte_95048;
        }
        if ( v7 & 1 )
        {
          if ( qword_95050 )
          {
            v8 = qword_95050 + 16;
            if ( sub_23741((_WORD *)(qword_95050 + 16)) )
            {
              if ( sub_23695(qword_95050, v5) )
              {
LABEL_17:
                sub_22ED4(v6, v4, (__int64)"%", v8);
                return 0i64;
              }
              v9 = qword_95050 + 80;
              while ( sub_23741((_WORD *)(v9 + 16)) )
              {
                v10 = sub_23695(v9, v5);
                v9 += 80i64;
                if ( v10 )
                {
                  v8 = v9 - 64;
                  goto LABEL_17;
                }
              }
            }
          }
        }
        result = -9223372036854775794i64;
      }
    }
  }
  return result;
}
// 265C6: write access to const memory at 95048 has been detected
// 416A8: using guessed type __int16 aGuidlist[9];
// 95048: using guessed type char byte_95048;
// 95050: using guessed type __int64 qword_95050;

//----- (000000000002665A) ----------------------------------------------------
signed __int64 __fastcall sub_2665A(__int64 a1, _QWORD *a2, __int64 a3)
{
  signed __int64 v3; // rbx
  _QWORD *v4; // r13
  __int64 v5; // r14
  __int64 v6; // rdi
  __int64 v7; // rsi
  __int64 v8; // r15
  __int64 v9; // rax
  __int64 v10; // r8
  __int64 v11; // rax
  char v13; // [rsp+3Ch] [rbp-64h]
  __int64 v14; // [rsp+40h] [rbp-60h]
  unsigned __int64 v15; // [rsp+48h] [rbp-58h]
  __int64 v16; // [rsp+50h] [rbp-50h]
  __int64 v17; // [rsp+58h] [rbp-48h]
  __int64 v18; // [rsp+60h] [rbp-40h]

  v3 = -9223372036854775806i64;
  v18 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  if ( a1 )
  {
    v4 = a2;
    if ( a2 )
    {
      v5 = a3;
      if ( a3 )
      {
        v6 = a1;
        v7 = (*(__int64 (__fastcall **)(signed __int64, int *, _QWORD, unsigned __int64 *, __int64 *))(qword_96CD8 + 312))(
               2i64,
               &dword_92824,
               0i64,
               &v15,
               &v17);
        if ( !(_DWORD)v7 )
        {
          if ( !v15 )
            goto LABEL_22;
          v8 = 0i64;
          v3 = -9223372036854775794i64;
          while ( 1 )
          {
            v9 = (*(__int64 (__fastcall **)(_QWORD, int *, __int64 *))(qword_96CD8 + 152))(
                   *(_QWORD *)(v17 + 8 * v8),
                   &dword_92824,
                   &v14);
            if ( (_DWORD)v9 )
            {
              v3 = v9;
              goto LABEL_15;
            }
            LOBYTE(v10) = 25;
            v11 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, __int64 *, __int64 *, char *))(v14 + 24))(
                    v14,
                    v6,
                    v10,
                    0i64,
                    &v18,
                    &v16,
                    &v13);
            if ( v11 != -9223372036854775794i64 )
              break;
            if ( ++v8 >= v15 )
              goto LABEL_15;
          }
          v7 = v11;
          if ( !v11 )
          {
LABEL_22:
            *v4 = v18;
            (*(void (__fastcall **)(__int64, __int64 *, signed __int64))(qword_96CD8 + 352))(v5, &v16, 8i64);
            v18 = 0i64;
          }
        }
        v3 = v7;
      }
    }
  }
LABEL_15:
  if ( v17 )
    (*(void (**)(void))(qword_96CD8 + 72))();
  if ( v18 )
    (*(void (**)(void))(qword_96CD8 + 72))();
  return v3;
}
// 92824: using guessed type int;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000267C8) ----------------------------------------------------
__int64 __fastcall sub_267C8(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5, unsigned __int8 a6)
{
  __int64 v6; // r13
  __int64 v7; // rsi
  _QWORD *v8; // rdi
  __int64 v9; // r14
  __int64 v10; // rbx
  unsigned __int64 v12; // r12
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rdi
  bool v16; // cf
  _QWORD *v17; // [rsp+30h] [rbp-80h]
  unsigned __int64 v18; // [rsp+40h] [rbp-70h]
  __int64 v19; // [rsp+50h] [rbp-60h]
  __int64 v20; // [rsp+58h] [rbp-58h]
  __int64 v21; // [rsp+60h] [rbp-50h]
  __int64 v22; // [rsp+68h] [rbp-48h]
  __int64 v23; // [rsp+70h] [rbp-40h]

  v6 = -9223372036854775806i64;
  v21 = 0i64;
  v23 = 0i64;
  v19 = 0i64;
  if ( a2 )
  {
    v7 = a1;
    if ( a1 )
    {
      v8 = a3;
      if ( a3 )
      {
        v9 = a4;
        if ( a4 )
        {
          if ( a5 )
          {
            v10 = a2;
            v6 = (*(__int64 (__fastcall **)(signed __int64, __int64 *, _QWORD, unsigned __int64 *, __int64 *))(qword_96CD8 + 312))(
                   2i64,
                   qword_92CA0,
                   0i64,
                   &v18,
                   &v19);
            if ( !(_DWORD)v6 )
            {
              v6 = -9223372036854775805i64;
              if ( v18 )
              {
                v17 = v8;
                v12 = 1i64;
                do
                {
                  v13 = (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
                          *(_QWORD *)(v19 + 8 * v12 - 8),
                          qword_92CA0,
                          &v21);
                  if ( (_DWORD)v13 )
                  {
                    v6 = v13;
                    goto LABEL_7;
                  }
                  v14 = (*(__int64 (__fastcall **)(__int64, __int64))(v21 + 16))(v7, v10);
                  v15 = v14;
                  if ( v14 >= 0 )
                    break;
                  v16 = v12++ < v18;
                }
                while ( v16 );
                if ( (_DWORD)v14 )
                {
LABEL_18:
                  v6 = v15;
                  goto LABEL_7;
                }
                if ( v21 )
                {
                  if ( v23 )
                    goto LABEL_22;
                  v6 = (*(__int64 (__fastcall **)(__int64, __int64, char *, __int64 *))(v21 + 24))(
                         v7,
                         v10,
                         (char *)&v22 + 4,
                         &v22);
                  if ( !(_DWORD)v6 )
                  {
                    v15 = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, __int64 *))(v21 + 32))(
                            v7,
                            v10,
                            &v23,
                            &v20);
                    if ( (_DWORD)v15 )
                      goto LABEL_18;
                    if ( !v23 )
                    {
                      v6 = -9223372036854775799i64;
                      goto LABEL_7;
                    }
LABEL_22:
                    if ( a6 < 2u )
                    {
LABEL_30:
                      (*(void (__fastcall **)(__int64, __int64 *, signed __int64))(qword_96CD8 + 352))(a5, &v22, 8i64);
                      (*(void (__fastcall **)(__int64, __int64 *, signed __int64))(qword_96CD8 + 352))(v9, &v20, 8i64);
                      *v17 = v23;
                      v23 = 0i64;
                      goto LABEL_18;
                    }
                    if ( v20 )
                    {
                      v15 = 0i64;
                      goto LABEL_30;
                    }
                    v6 = -9223372036854775806i64;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_7:
  if ( v19 )
    (*(void (**)(void))(qword_96CD8 + 72))();
  if ( v23 )
    (*(void (**)(void))(qword_96CD8 + 72))();
  return v6;
}
// 92CA0: using guessed type __int64 qword_92CA0[2];
// 92D28: using guessed type int dword_92D28;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000026A90) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_26A90(int a1)
{
  if ( a1 <= 0 )
    return -9223372036854775806i64;
  dword_92D28 = a1;
  return 0i64;
}
// 26A98: write access to const memory at 92D28 has been detected
// 92D28: using guessed type int dword_92D28;

//----- (0000000000026AB0) ----------------------------------------------------
bool __fastcall sub_26AB0(int *a1, int *a2)
{
  int v2; // er8
  int v3; // er9
  int v4; // edx
  bool result; // al

  v2 = *a2;
  if ( *a2 < *a1 || (v3 = a2[1], v4 = a1[1], v3 < v4) || v2 >= a1[3] + *a1 )
    result = 0;
  else
    result = v3 < a1[2] + v4;
  return result;
}

//----- (0000000000026AE1) ----------------------------------------------------
void __fastcall sub_26AE1(_DWORD *a1, int a2, int a3)
{
  if ( a1 )
  {
    *a1 = a2;
    a1[1] = a3;
  }
}

//----- (0000000000026AF2) ----------------------------------------------------
void __fastcall sub_26AF2(_DWORD *a1, int a2, int a3)
{
  if ( a1 )
  {
    a1[1] = a2;
    *a1 = a3;
  }
}

//----- (0000000000026B03) ----------------------------------------------------
__int64 __fastcall sub_26B03(_DWORD *a1, int a2, int a3, int a4, unsigned int a5)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = a5;
    *a1 = a2;
    a1[1] = a3;
    a1[3] = a4;
    a1[2] = a5;
  }
  return result;
}

//----- (0000000000026B1E) ----------------------------------------------------
__int64 __fastcall sub_26B1E(__int64 a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // rsi
  _DWORD *v4; // rbx
  __int64 v5; // r14
  int v7; // [rsp+20h] [rbp-30h]
  int v8; // [rsp+24h] [rbp-2Ch]
  char v9; // [rsp+28h] [rbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  (*(void (__fastcall **)(char *, _DWORD *, signed __int64))(qword_96CD8 + 352))(&v9, a2, 8i64);
  v7 = *v3 + v3[3] / 2 - v4[1] / 2;
  v8 = v3[1] + v3[2] / 2 - *v4 / 2;
  return (*(__int64 (__fastcall **)(__int64, int *, signed __int64))(qword_96CD8 + 352))(v5, &v7, 16i64);
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000026BB1) ----------------------------------------------------
signed __int64 __fastcall sub_26BB1(_DWORD *a1, int *a2, int *a3)
{
  signed __int64 result; // rax
  int v4; // edi
  int v5; // er9
  int v6; // er11
  int v7; // er10
  int v8; // er14
  int v9; // edi
  int v10; // er9
  unsigned __int8 v11; // of
  int v12; // er9
  int v13; // esi
  int v14; // edx
  int v15; // ebx
  int v16; // er11
  int v17; // er10
  int v18; // er10

  result = -9223372036854775806i64;
  if ( a2 )
  {
    if ( a3 )
    {
      v4 = a2[3];
      if ( v4 > 0 )
      {
        v5 = a3[3];
        if ( v5 > 0 )
        {
          v6 = a2[2];
          if ( v6 > 0 )
          {
            v7 = a3[2];
            if ( v7 > 0 )
            {
              v8 = *a3;
              if ( *a2 >= *a3 )
                v8 = *a2;
              v9 = *a2 + v4;
              v10 = *a3 + v5;
              if ( v9 <= v10 )
                v10 = v9;
              result = -9223372036854775794i64;
              v11 = __OFSUB__(v10, v8);
              v12 = v10 - v8;
              if ( !((unsigned __int8)((v12 < 0) ^ v11) | (v12 == 0)) )
              {
                v13 = a2[1];
                v14 = a3[1];
                v15 = a3[1];
                if ( v13 >= v14 )
                  v15 = v13;
                v16 = v13 + v6;
                v17 = v14 + v7;
                if ( v16 <= v17 )
                  v17 = v16;
                v11 = __OFSUB__(v17, v15);
                v18 = v17 - v15;
                if ( !((unsigned __int8)((v18 < 0) ^ v11) | (v18 == 0)) )
                {
                  if ( a1 )
                  {
                    *a1 = v8;
                    a1[1] = v15;
                    a1[2] = v18;
                    a1[3] = v12;
                  }
                  result = 0i64;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0000000000026C52) ----------------------------------------------------
__int64 __fastcall sub_26C52(__int64 a1, int *a2, int *a3)
{
  int *v3; // r10
  int v4; // er8
  bool v5; // r9
  __int64 result; // rax
  int v7; // er11
  int v8; // er15
  int v9; // er14
  int v10; // ebx
  int v11; // edi
  int v12; // er10
  int v13; // esi
  int v14; // er8
  int v15; // eax
  int v16; // edi
  int v17; // er11
  __int64 v18; // rax
  int v19; // [rsp+28h] [rbp-38h]
  int v20; // [rsp+2Ch] [rbp-34h]
  int v21; // [rsp+30h] [rbp-30h]
  int v22; // [rsp+34h] [rbp-2Ch]

  v3 = a3;
  v4 = a2[3];
  if ( v4 )
    v5 = a2[2] != 0;
  else
    v5 = 0;
  result = (unsigned int)v3[3];
  if ( (_DWORD)result )
  {
    v7 = v3[2];
    if ( v5 && v7 )
    {
      v8 = *a2;
      v9 = *v3;
      v10 = *v3;
      if ( *a2 <= *v3 )
        v10 = *a2;
      v19 = v10;
      v11 = a2[1];
      v12 = v3[1];
      v13 = v12;
      if ( v11 <= v12 )
        v13 = a2[1];
      v20 = v13;
      v14 = v8 + v4;
      v15 = v9 + result;
      if ( v14 >= v15 )
        v15 = v14;
      v22 = v15 - v10;
      v16 = a2[2] + v11;
      v17 = v12 + v7;
      if ( v16 >= v17 )
        v17 = v16;
      v21 = v17 - v13;
      v18 = qword_96CD8;
      a2 = &v19;
      return (*(__int64 (__fastcall **)(__int64, int *, signed __int64))(v18 + 352))(a1, a2, 16i64);
    }
    if ( v5 )
      goto LABEL_19;
    if ( v7 )
    {
      v18 = qword_96CD8;
      a2 = v3;
      return (*(__int64 (__fastcall **)(__int64, int *, signed __int64))(v18 + 352))(a1, a2, 16i64);
    }
  }
  else if ( v5 )
  {
LABEL_19:
    v18 = qword_96CD8;
    return (*(__int64 (__fastcall **)(__int64, int *, signed __int64))(v18 + 352))(a1, a2, 16i64);
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000026D37) ----------------------------------------------------
signed __int64 __fastcall sub_26D37(__int64 a1, __int64 a2, unsigned int a3)
{
  signed __int64 result; // rax
  unsigned __int64 v4; // r10
  unsigned __int64 v5; // [rsp+28h] [rbp-8h]

  result = -9223372036854775806i64;
  if ( a1 && a2 && a3 != -1 )
  {
    v5 = *(_QWORD *)a2;
    v4 = v5 >> 32;
    result = a3;
    switch ( a3 )
    {
      case 0u:
        goto LABEL_12;
      case 1u:
        LODWORD(v5) = v5 + *(_DWORD *)(a2 + 12) / 2;
        goto LABEL_12;
      case 2u:
        LODWORD(v5) = *(_DWORD *)(a2 + 12) + v5;
        goto LABEL_12;
      case 3u:
        LODWORD(v5) = *(_DWORD *)(a2 + 12) + v5;
        goto LABEL_8;
      case 4u:
        LODWORD(v5) = *(_DWORD *)(a2 + 12) + v5;
        goto LABEL_11;
      case 5u:
        LODWORD(v5) = v5 + *(_DWORD *)(a2 + 12) / 2;
        goto LABEL_11;
      case 6u:
LABEL_11:
        HIDWORD(v5) = *(_DWORD *)(a2 + 8) + v4;
        goto LABEL_12;
      case 7u:
LABEL_8:
        HIDWORD(v5) = v4 + *(_DWORD *)(a2 + 8) / 2;
LABEL_12:
        (*(void (__fastcall **)(__int64, unsigned __int64 *, signed __int64))(qword_96CD8 + 352))(a1, &v5, 8i64);
        result = 0i64;
        break;
      default:
        return result;
    }
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000026E30) ----------------------------------------------------
char __fastcall sub_26E30(_BYTE *a1, char a2, char a3, char a4, char a5)
{
  char result; // al

  if ( a1 )
  {
    result = a5;
    a1[2] = a2;
    a1[1] = a3;
    *a1 = a4;
    a1[3] = a5;
  }
  return result;
}

//----- (0000000000026E4B) ----------------------------------------------------
signed __int64 __fastcall sub_26E4B(__int64 *a1, __int64 a2)
{
  signed __int64 v2; // rsi
  __int64 v3; // rbx
  __int64 *v4; // r14
  __int64 v5; // rax
  __int64 v6; // rdi

  v2 = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = a1;
      v5 = sub_24136(272i64);
      if ( v5 )
      {
        v6 = v5;
        (*(void (__fastcall **)(__int64, __int64, signed __int64))(qword_96CD8 + 352))(v5 + 32, v3 + 8, 8i64);
        (*(void (__fastcall **)(__int64, __int64, signed __int64))(qword_96CD8 + 352))(v6 + 44, v3, 16i64);
        (*(void (__fastcall **)(__int64, __int64, signed __int64))(qword_96CD8 + 352))(v6 + 60, v3, 16i64);
        *(_BYTE *)(v6 + 40) = 1;
        *(_QWORD *)(v6 + 80) = 0i64;
        *(_DWORD *)(v6 + 88) = 0;
        *(_QWORD *)(v6 + 96) = sub_26F86;
        *(_QWORD *)(v6 + 160) = 0i64;
        *(_QWORD *)(v6 + 144) = 0i64;
        *(_BYTE *)(v6 + 168) = 0;
        *(_BYTE *)(v6 + 225) = 1;
        if ( *(_BYTE *)(v6 + 192) )
          *(_BYTE *)(v6 + 192) = 0;
        *(_DWORD *)(v6 + 196) = 0;
        *(_BYTE *)(v6 + 224) = 0;
        *(_QWORD *)(v6 + 232) = 0i64;
        *(_QWORD *)(v6 + 240) = 0i64;
        sub_23BC8((_QWORD *)v6);
        v2 = sub_26FF5(v6, 5000);
        if ( (_DWORD)v2 )
          sub_27054(v6);
        else
          *v4 = v6;
      }
      else
      {
        v2 = -9223372036854775799i64;
      }
    }
  }
  return v2;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000026F86) ----------------------------------------------------
signed __int64 __fastcall sub_26F86(__int64 a1, int *a2, __int64 a3, __int64 a4)
{
  signed __int64 result; // rax

  if ( a1 && a2 && a3 && a4 )
    result = sub_244D1(
               a3,
               a4,
               a2,
               *(_QWORD *)(a1 + 16),
               (int *)(a1 + 32),
               (int *)(a1 + 44),
               *(_BYTE *)(a1 + 168),
               a1 + 176);
  else
    result = -9223372036854775806i64;
  return result;
}

//----- (0000000000026FF5) ----------------------------------------------------
signed __int64 __fastcall sub_26FF5(__int64 a1, int a2)
{
  signed __int64 result; // rax
  __int64 v3; // rsi

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a1;
    if ( (unsigned int)(a2 - 1000) <= 0x2328 )
    {
      if ( *(_DWORD *)(a1 + 248) == a2
        || (*(_DWORD *)(a1 + 248) = a2, !*(_QWORD *)(a1 + 80))
        || (sub_23BE1((__int64 *)a1), result = sub_3F340(*(_QWORD *)(v3 + 80), v3), !(_DWORD)result) )
      {
        result = 0i64;
      }
    }
  }
  return result;
}

//----- (0000000000027054) ----------------------------------------------------
signed __int64 __fastcall sub_27054(__int64 a1)
{
  signed __int64 result; // rax
  __int64 v2; // rsi
  void (*v3)(void); // rax
  __int64 v4; // rbx
  __int64 *v5; // rdi
  __int64 *v6; // rax
  __int64 *v7; // rax

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v2 = a1;
    if ( *(_DWORD *)(a1 + 88) <= 0x10u )
    {
      v3 = *(void (**)(void))(a1 + 144);
      if ( v3 )
        v3();
      if ( *(_BYTE *)(v2 + 224) )
      {
        v4 = *(_QWORD *)(v2 + 216);
        while ( v4 )
        {
          v5 = *(__int64 **)v4;
          v4 = *(_QWORD *)(v4 + 24);
          sub_27168(v2, (__int64)v5);
          sub_3F1DC(v5[10], v5);
        }
      }
      while ( 1 )
      {
        v6 = *(__int64 **)(v2 + 216);
        if ( !v6 )
          break;
        sub_27168(v2, *v6);
      }
      if ( *(_QWORD *)(v2 + 240) )
        (*(void (**)(void))(qword_96CD8 + 72))();
      if ( *(_BYTE *)(v2 + 200) )
      {
        v7 = *(__int64 **)(v2 + 208);
        if ( v7 )
        {
          sub_24A17(*v7);
          (*(void (__fastcall **)(_QWORD))(qword_96CD8 + 72))(*(_QWORD *)(v2 + 208));
        }
      }
      *(_DWORD *)(v2 + 88) = 1040045;
      if ( *(_QWORD *)(v2 + 16) )
        (*(void (**)(void))(qword_96CD8 + 72))();
      if ( *(_QWORD *)(v2 + 256) )
        (*(void (**)(void))(qword_96CD8 + 72))();
      (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v2);
      result = 0i64;
    }
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000027168) ----------------------------------------------------
signed __int64 __fastcall sub_27168(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax
  __int64 v3; // rdi
  __int64 v4; // rsi
  _QWORD **v5; // rdx
  _QWORD *v6; // rcx
  _QWORD *v7; // rax
  _QWORD **v8; // rdi
  _QWORD *v9; // rcx
  _QWORD *v10; // rax

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = a1;
      v5 = (_QWORD **)(a1 + 216);
      while ( 1 )
      {
        v6 = *v5;
        if ( !*v5 )
          break;
        v7 = v5;
        v5 = (_QWORD **)(v6 + 3);
        if ( *v6 == v3 )
        {
          *v7 = v6[3];
          (*(void (**)(void))(qword_96CD8 + 72))();
          v8 = (_QWORD **)(v3 + 216);
          while ( 1 )
          {
            v9 = *v8;
            if ( !*v8 )
              break;
            v10 = v8;
            v8 = (_QWORD **)(v9 + 3);
            if ( *v9 == v4 )
            {
              *v10 = v9[3];
              (*(void (**)(void))(qword_96CD8 + 72))();
              return 0i64;
            }
          }
          break;
        }
      }
      result = -9223372036854775794i64;
    }
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000271F9) ----------------------------------------------------
signed __int64 __fastcall sub_271F9(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax

  result = -9223372036854775806i64;
  if ( a1 )
  {
    if ( a2 )
    {
      *(_QWORD *)(a1 + 104) = a2;
      result = 0i64;
    }
  }
  return result;
}

//----- (0000000000027219) ----------------------------------------------------
signed __int64 __fastcall sub_27219(__int64 a1, _DWORD *a2)
{
  __int64 v2; // rax
  signed __int64 result; // rax

  if ( !a1 || !a2 )
    return -9223372036854775806i64;
  v2 = *(_QWORD *)(a1 + 240);
  if ( v2 && *(_DWORD *)(v2 + 4) )
    result = sub_32BCB(a1, a2);
  else
    result = sub_27251(a1, a2);
  return result;
}

//----- (0000000000027251) ----------------------------------------------------
signed __int64 __fastcall sub_27251(__int64 a1, _DWORD *a2)
{
  signed __int64 result; // rax
  _DWORD *v3; // rsi
  __int64 v4; // rdi
  void (*v5)(void); // rax
  __int64 v6; // rcx

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = a1;
      if ( *a2 == *(_DWORD *)(a1 + 44) && a2[1] == *(_DWORD *)(a1 + 48) )
        goto LABEL_13;
      v5 = *(void (**)(void))(a1 + 120);
      if ( v5 )
        v5();
      sub_26C52(v4 + 60, (int *)(v4 + 44), (int *)(v4 + 60));
      (*(void (__fastcall **)(__int64, _DWORD *, signed __int64))(qword_96CD8 + 352))(v4 + 44, v3, 8i64);
      *(_BYTE *)(v4 + 40) = 1;
      result = sub_272F9(v4);
      if ( !(_DWORD)result )
      {
LABEL_13:
        v6 = *(_QWORD *)(v4 + 232);
        if ( !v6 || (result = sub_27251(v6, v3), !(_DWORD)result) )
          result = 0i64;
      }
    }
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000272F9) ----------------------------------------------------
signed __int64 __fastcall sub_272F9(__int64 a1)
{
  signed __int64 v1; // r12
  __int64 *v2; // r14
  __int64 v3; // rdi
  __int64 v4; // rsi
  signed __int64 v5; // rax
  int v6; // ecx
  void (__fastcall *v7)(__int64, int *); // rax
  int v9; // [rsp+20h] [rbp-50h]
  int v10; // [rsp+24h] [rbp-4Ch]
  int v11; // [rsp+28h] [rbp-48h]
  int v12; // [rsp+2Ch] [rbp-44h]
  int v13; // [rsp+30h] [rbp-40h]
  int v14; // [rsp+34h] [rbp-3Ch]

  v1 = -9223372036854775806i64;
  if ( a1 )
  {
    v2 = *(__int64 **)(a1 + 216);
    if ( v2 )
    {
      v3 = a1 + 44;
      v1 = -9223372036854775805i64;
      while ( 1 )
      {
        v4 = *v2;
        if ( !*v2 )
          break;
        v5 = sub_26D37((__int64)&v9, v3, *((_DWORD *)v2 + 2));
        if ( (_DWORD)v5 )
          return v5;
        v5 = sub_26D37((__int64)&v13, v4 + 44, *((_DWORD *)v2 + 3));
        if ( (_DWORD)v5 )
          return v5;
        v6 = v10 + *((_DWORD *)v2 + 5) - v14;
        v11 = *(_DWORD *)(v4 + 44) + v9 + *((_DWORD *)v2 + 4) - v13;
        v12 = *(_DWORD *)(v4 + 48) + v6;
        v7 = *(void (__fastcall **)(__int64, int *))(v4 + 120);
        if ( v7 )
          v7(v4, &v11);
        sub_26C52(v4 + 60, (int *)(v4 + 44), (int *)(v4 + 60));
        (*(void (__fastcall **)(__int64, int *, signed __int64))(qword_96CD8 + 352))(v4 + 44, &v11, 8i64);
        *(_BYTE *)(v4 + 40) = 1;
        v2 = (__int64 *)v2[3];
        if ( !v2 )
          goto LABEL_10;
      }
    }
    else
    {
LABEL_10:
      v1 = 0i64;
    }
  }
  return v1;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000027402) ----------------------------------------------------
signed __int64 __fastcall sub_27402(_DWORD *a1, _DWORD *a2)
{
  signed __int64 result; // rax
  _DWORD *v3; // rdi
  __int64 v4; // rsi
  int *v5; // rbx
  _DWORD *v6; // rdx

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = (__int64)a1;
      v5 = a1 + 11;
      v6 = a2 + 2;
      if ( a1[14] == v3[3] && a1[13] == *v6 && *v5 == *v3 && a1[12] == v3[1] )
        goto LABEL_11;
      (*(void (__fastcall **)(_DWORD *, _DWORD *, signed __int64))(qword_96CD8 + 352))(a1 + 8, v6, 8i64);
      sub_26C52(v4 + 60, v5, (int *)(v4 + 60));
      (*(void (__fastcall **)(int *, _DWORD *, signed __int64))(qword_96CD8 + 352))(v5, v3, 16i64);
      *(_BYTE *)(v4 + 40) = 1;
      result = sub_272F9(v4);
      if ( !(_DWORD)result )
LABEL_11:
        result = 0i64;
    }
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000274AA) ----------------------------------------------------
signed __int64 __fastcall sub_274AA(__int64 a1)
{
  _QWORD *v1; // rcx
  signed __int64 result; // rax

  if ( !a1 )
    return -9223372036854775806i64;
  *(_BYTE *)(a1 + 40) = 1;
  v1 = *(_QWORD **)(a1 + 80);
  if ( !v1 || (result = sub_3F6AA(v1), !(_DWORD)result) )
    result = 0i64;
  return result;
}

//----- (00000000000274E1) ----------------------------------------------------
signed __int64 __fastcall sub_274E1(__int64 a1, unsigned int a2)
{
  signed __int64 result; // rax

  result = -9223372036854775806i64;
  if ( a1 )
  {
    if ( a2 <= 0x10 )
    {
      *(_DWORD *)(a1 + 88) = a2;
      result = 0i64;
    }
  }
  return result;
}

//----- (0000000000027500) ----------------------------------------------------
signed __int64 __fastcall sub_27500(__int64 a1, unsigned __int8 a2)
{
  __int64 v2; // rax
  signed __int64 result; // rax

  if ( !a1 )
    return -9223372036854775806i64;
  v2 = *(_QWORD *)(a1 + 240);
  if ( v2 && *(_DWORD *)(v2 + 4) )
    result = sub_32D82(a1, a2);
  else
    result = sub_27533(a1, a2);
  return result;
}

//----- (0000000000027533) ----------------------------------------------------
signed __int64 __fastcall sub_27533(__int64 a1, unsigned int a2)
{
  signed __int64 v2; // r14
  unsigned int v3; // ebx
  __int64 v4; // r15
  void (__fastcall *v5)(__int64, _QWORD); // rax
  __int64 *i; // rsi
  __int64 v7; // rcx
  void (__fastcall *v8)(__int64, _QWORD); // rdi

  v2 = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a2;
    v4 = a1;
    v5 = *(void (__fastcall **)(__int64, _QWORD))(a1 + 128);
    if ( v5 )
      v5(a1, a2);
    for ( i = *(__int64 **)(v4 + 216); ; i = (__int64 *)i[3] )
    {
      if ( !i )
      {
        *(_BYTE *)(v4 + 168) = v3;
        *(_BYTE *)(v4 + 40) = 1;
        return 0i64;
      }
      v7 = *i;
      if ( !*i )
        break;
      v8 = *(void (__fastcall **)(__int64, _QWORD))(v7 + 128);
      if ( v8 )
      {
        v8(v7, v3);
        v7 = *i;
      }
      *(_BYTE *)(v7 + 168) = v3;
      *(_BYTE *)(v7 + 40) = 1;
    }
    v2 = -9223372036854775805i64;
  }
  return v2;
}

//----- (00000000000275C4) ----------------------------------------------------
__int64 __fastcall sub_275C4(__int64 a1, unsigned int a2)
{
  signed __int64 v2; // rdi
  char v3; // bl
  __int64 v4; // rsi
  __int64 (__fastcall *v5)(__int64, _QWORD); // rax
  __int64 result; // rax
  __int64 *i; // rax
  __int64 v8; // rcx

  v2 = -9223372036854775806i64;
  if ( !a1 )
    return v2;
  v3 = a2;
  v4 = a1;
  v5 = *(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 152);
  if ( !v5 || (result = v5(a1, a2), !(_DWORD)result) )
  {
    if ( *(_BYTE *)(v4 + 225) == v3 )
      return 0i64;
    for ( i = *(__int64 **)(v4 + 216); ; i = (__int64 *)i[3] )
    {
      if ( !i )
      {
        *(_BYTE *)(v4 + 225) = v3;
        *(_BYTE *)(v4 + 40) = 1;
        return 0i64;
      }
      v8 = *i;
      if ( !*i )
        break;
      *(_BYTE *)(v8 + 225) = v3;
      *(_BYTE *)(v8 + 40) = 1;
    }
    return -9223372036854775805i64;
  }
  return result;
}

//----- (0000000000027643) ----------------------------------------------------
signed __int64 __fastcall sub_27643(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  if ( !a1 )
    return -9223372036854775806i64;
  if ( a2 )
    a1[12] = a2;
  if ( a3 )
    a1[18] = a3;
  if ( a4 )
    a1[19] = a4;
  if ( a5 )
    a1[20] = a5;
  return 0i64;
}

//----- (000000000002768D) ----------------------------------------------------
signed __int64 __fastcall sub_2768D(__int64 a1, int a2)
{
  if ( !a1 )
    return -9223372036854775806i64;
  *(_DWORD *)(a1 + 196) = a2;
  return 0i64;
}

//----- (00000000000276AC) ----------------------------------------------------
signed __int64 __fastcall sub_276AC(__int64 a1, _DWORD *a2)
{
  signed __int64 result; // rax

  result = -9223372036854775806i64;
  if ( a1 )
  {
    if ( a2 )
    {
      *a2 = *(_DWORD *)(a1 + 196);
      result = 0i64;
    }
  }
  return result;
}

//----- (00000000000276D0) ----------------------------------------------------
signed __int64 __fastcall sub_276D0(__int64 a1, int a2, __int64 a3, int a4, __int64 a5)
{
  signed __int64 result; // rax
  __int64 v6; // rdi
  int v7; // er14
  int v8; // er15
  __int64 v9; // r12
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 v13; // rsi
  __int64 *v14; // rcx
  __int64 *v15; // rax
  __int64 v16; // rdx
  __int64 *v17; // rdi
  __int64 *v18; // rcx
  __int64 v19; // rdx
  int v20; // [rsp+20h] [rbp-40h]
  int v21; // [rsp+24h] [rbp-3Ch]

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v6 = a3;
    if ( a3 )
    {
      if ( a5 )
      {
        v7 = a4;
        v8 = a2;
        v9 = a1;
        v10 = sub_24136(32i64);
        if ( v10 )
        {
          v11 = v10;
          *(_QWORD *)v10 = v6;
          *(_DWORD *)(v10 + 8) = v8;
          *(_DWORD *)(v10 + 12) = v7;
          *(_QWORD *)(v10 + 16) = *(_QWORD *)a5;
          *(_QWORD *)(v10 + 24) = 0i64;
          v12 = sub_24136(32i64);
          if ( v12 )
          {
            v13 = v12;
            v20 = -*(_DWORD *)a5;
            v21 = -*(_DWORD *)(a5 + 4);
            *(_QWORD *)v12 = v9;
            *(_DWORD *)(v12 + 8) = v7;
            *(_DWORD *)(v12 + 12) = v8;
            (*(void (__fastcall **)(__int64, int *, signed __int64))(qword_96CD8 + 352))(v12 + 16, &v20, 8i64);
            *(_QWORD *)(v13 + 24) = 0i64;
            v14 = (__int64 *)(v9 + 216);
            do
            {
              v15 = v14;
              v16 = *v14;
              v14 = (__int64 *)(*v14 + 24);
            }
            while ( v16 );
            v17 = (__int64 *)(v6 + 216);
            do
            {
              v18 = v17;
              v19 = *v17;
              v17 = (__int64 *)(*v17 + 24);
            }
            while ( v19 );
            *v15 = v11;
            *v18 = v13;
            result = sub_272F9(v9);
          }
          else
          {
            (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v11);
            result = -9223372036854775799i64;
          }
        }
        else
        {
          result = -9223372036854775799i64;
        }
      }
    }
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000002780F) ----------------------------------------------------
signed __int64 __fastcall sub_2780F(_QWORD *a1, __int64 a2)
{
  __int64 v2; // r14
  _QWORD *v3; // rdi
  signed __int64 v4; // rbx
  signed __int64 v5; // rsi
  __int64 v7; // rdx
  signed __int64 v8; // rax
  char v9; // [rsp+28h] [rbp-38h]
  __int64 v10; // [rsp+38h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  v4 = -9223372036854775806i64;
  (*(void (__fastcall **)(char *, signed __int64, _QWORD))(qword_96CD8 + 360))(&v9, 16i64, 0i64);
  v10 = 0i64;
  if ( v3 )
  {
    v5 = sub_26E4B(&v10, (__int64)&v9);
    if ( !(_DWORD)v5 )
    {
      v7 = v10;
      if ( !v10 )
        return v4;
      *(_DWORD *)(v10 + 88) = 10;
      *(_BYTE *)(v7 + 224) = 0;
      v8 = sub_3F340(v2, v7);
      v4 = v8;
      if ( !(_DWORD)v8 )
      {
        *v3 = v10;
        v10 = 0i64;
        return v4;
      }
      v5 = v8;
    }
    if ( v10 )
      sub_3F1DC(*(_QWORD *)(v10 + 80), (__int64 *)v10);
    v4 = v5;
  }
  return v4;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000278C3) ----------------------------------------------------
signed __int64 __fastcall sub_278C3(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbx
  __int64 v3; // r14
  __int64 v4; // rdi
  __int64 *v5; // rsi
  __int64 v6; // r8
  signed __int64 v7; // rax
  int v9; // [rsp+30h] [rbp-30h]
  int v10; // [rsp+34h] [rbp-2Ch]

  v2 = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = a1;
      v5 = *(__int64 **)(a2 + 216);
      if ( v5 )
      {
        v2 = -9223372036854775805i64;
        while ( 1 )
        {
          v6 = *v5;
          if ( !*v5 )
            break;
          v9 = *(_DWORD *)(v4 + 44) - *(_DWORD *)(v6 + 44);
          v10 = *(_DWORD *)(v4 + 48) - *(_DWORD *)(v6 + 48);
          v7 = sub_276D0(v4, 4, v6, 0, (__int64)&v9);
          if ( (_DWORD)v7 )
            goto LABEL_9;
          v5 = (__int64 *)v5[3];
          if ( !v5 )
            goto LABEL_8;
        }
      }
      else
      {
LABEL_8:
        v9 = *(_DWORD *)(v3 + 44) - *(_DWORD *)(v4 + 44);
        v10 = *(_DWORD *)(v3 + 48) - *(_DWORD *)(v4 + 48);
        v7 = sub_276D0(v4, 4, v3, 0, (__int64)&v9);
LABEL_9:
        v2 = v7;
      }
    }
  }
  return v2;
}

//----- (0000000000027987) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_27987(int a1, __int64 a2, __int64 *a3, __int64 a4)
{
  signed __int64 v4; // r13
  __int64 v5; // r15
  __int64 *v6; // r12
  __int64 v7; // r14
  int v8; // ebx
  __int64 v9; // rdi
  __int64 v10; // rax
  __int64 v11; // rsi

  v4 = -9223372036854775806i64;
  if ( !a1 )
    goto LABEL_9;
  v5 = a2;
  if ( !a2 )
    goto LABEL_9;
  v6 = a3;
  if ( !a3 )
    goto LABEL_9;
  v7 = a4;
  v8 = a1;
  v9 = 0i64;
  *a3 = 0i64;
  sub_27DE2();
  if ( qword_96D08 || (v9 = sub_2809A(), v9 >= 0) )
  {
    v10 = sub_24103(56i64);
    if ( v10 )
    {
      v11 = v10;
      *(_WORD *)(v10 + 24) = 256;
      *(_DWORD *)(v10 + 28) = v8;
      *(_QWORD *)(v10 + 32) = v5;
      *(_QWORD *)(v10 + 40) = v7;
      *(_QWORD *)(v10 + 48) = 0i64;
      ++qword_96D08;
      sub_23BF5((__int64)&off_92D40, (_QWORD *)(v10 + 8));
      *v6 = v11;
      return v9;
    }
    v4 = -9223372036854775799i64;
LABEL_9:
    v9 = v4;
  }
  return v9;
}
// 27A0D: write access to const memory at 96D08 has been detected
// 92D40: using guessed type void *off_92D40;
// 96D08: using guessed type __int64 qword_96D08;

//----- (0000000000027A48) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_27A48(__int64 a1)
{
  signed __int64 v1; // rsi
  void **v2; // rax
  signed __int64 v3; // rbx
  signed __int64 v4; // rdi
  __int64 v5; // rdi

  v1 = -9223372036854775806i64;
  v2 = &off_92D40;
  if ( &off_92D40 == &off_92D40 )
  {
LABEL_7:
    v5 = qword_96D08;
    v3 = v1;
  }
  else
  {
    v3 = 0i64;
    while ( 1 )
    {
      v4 = (signed __int64)(v2 - 1);
      if ( a1 == -1 || v4 == a1 )
      {
        *(_BYTE *)(v4 + 25) = 0;
        v5 = qword_96D08-- - 1;
        v1 = 0i64;
        if ( a1 != -1 )
          break;
      }
      v2 = (void **)*v2;
      if ( v2 == &off_92D40 )
        goto LABEL_7;
    }
  }
  if ( !v5 )
    sub_280CE();
  return v3;
}
// 27A8F: write access to const memory at 96D08 has been detected
// 92D40: using guessed type void *off_92D40;
// 96D08: using guessed type __int64 qword_96D08;

//----- (0000000000027AC9) ----------------------------------------------------
signed __int64 __fastcall sub_27AC9(_DWORD *a1)
{
  return sub_2851C(a1);
}

//----- (0000000000027AD3) ----------------------------------------------------
signed __int64 __fastcall sub_27AD3(__int64 a1, char *a2)
{
  signed __int64 v2; // rsi
  char *v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rax
  _BYTE *v6; // rax

  v2 = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = a1;
      v5 = sub_23894(a2);
      v6 = (_BYTE *)sub_24136(v5);
      *(_QWORD *)(v4 + 48) = v6;
      if ( v6 )
      {
        sub_2382D(v6, v3);
        v2 = 0i64;
      }
      else
      {
        v2 = -9223372036854775799i64;
      }
    }
  }
  return v2;
}

//----- (0000000000027B30) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_27B30(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rsi
  __int64 v3; // rax
  __int64 v5; // [rsp+28h] [rbp-18h]

  v1 = a1;
  v5 = 0i64;
  v2 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92BB0, 0i64, &qword_96D10);
  if ( v2 >= 0 && qword_96D10 && *(_DWORD *)qword_96D10 <= 6u )
  {
    v3 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64 *))(qword_96CD8 + 152))(v1, qword_92B10, &v5);
    if ( v3 < 0 )
    {
      v2 = v3;
    }
    else
    {
      *(_QWORD *)(v5 + 88) = sub_27BDC;
      sub_27E75();
      v2 = sub_27C1B();
      if ( v2 >= 0 )
      {
        qword_96D10 = 0i64;
        return v2;
      }
    }
    sub_27BDC();
  }
  return v2;
}
// 27BBC: write access to const memory at 96D10 has been detected
// 92B10: using guessed type __int64 qword_92B10[2];
// 92BB0: using guessed type __int64 qword_92BB0[2];
// 96CD8: using guessed type __int64 qword_96CD8;
// 96D10: using guessed type __int64 qword_96D10;

//----- (0000000000027BDC) ----------------------------------------------------
__int64 sub_27BDC()
{
  if ( !qword_96D10 )
  {
    if ( qword_95058 )
      (*(void (**)(void))(qword_96CD8 + 112))();
    sub_27FD3();
    sub_27CB1();
    sub_280CE();
  }
  return 0i64;
}
// 95058: using guessed type __int64 qword_95058;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96D10: using guessed type __int64 qword_96D10;

//----- (0000000000027C1B) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_27C1B()
{
  __int64 v0; // rax
  __int64 v1; // rsi

  v0 = (*(__int64 (__fastcall **)(signed __int64, signed __int64, __int64 (__fastcall *)(__int64), _QWORD, __int64 *))(qword_96CD8 + 80))(
         512i64,
         16i64,
         sub_27D1B,
         0i64,
         &qword_95058);
  if ( v0 < 0 )
    return v0;
  v1 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64 *))(qword_96CD8 + 168))(
         qword_92B50,
         qword_95058,
         &qword_95060);
  if ( v1 < 0 )
  {
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 112))(qword_95058);
    qword_95058 = 0i64;
  }
  else
  {
    sub_27D1B(0i64);
  }
  return v1;
}
// 27C9C: write access to const memory at 95058 has been detected
// 92B50: using guessed type __int64 qword_92B50[2];
// 95058: using guessed type __int64 qword_95058;
// 95060: using guessed type __int64 qword_95060;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000027CB1) ----------------------------------------------------
char sub_27CB1()
{
  char result; // al

  if ( qword_96D18 )
    (*(void (**)(void))(qword_96CD8 + 72))();
  sub_27DE2();
  result = sub_23BD5(&off_92D40);
  if ( !result )
    result = sub_27A48(-1i64);
  return result;
}
// 92D40: using guessed type void *off_92D40;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96D18: using guessed type __int64 qword_96D18;

//----- (0000000000027CFB) ----------------------------------------------------
__int64 __fastcall sub_27CFB(__int64 **a1)
{
  __int64 *v1; // rdx

  v1 = &qword_92D50;
  if ( qword_96D10 )
    v1 = (__int64 *)qword_96D10;
  *a1 = v1;
  return 0i64;
}
// 92D50: using guessed type __int64 qword_92D50;
// 96D10: using guessed type __int64 qword_96D10;

//----- (0000000000027D1B) ----------------------------------------------------
__int64 __fastcall sub_27D1B(__int64 a1)
{
  __int64 (__fastcall *v1)(signed __int64, __int64 *, __int64, unsigned __int64 *, __int64 *); // rax
  __int64 result; // rax
  __int64 v3; // rsi
  unsigned __int64 v4; // rbx
  __int64 v5; // [rsp+28h] [rbp-38h]
  unsigned __int64 v6; // [rsp+30h] [rbp-30h]
  __int64 v7; // [rsp+38h] [rbp-28h]

  v1 = *(__int64 (__fastcall **)(signed __int64, __int64 *, __int64, unsigned __int64 *, __int64 *))(qword_96CD8 + 312);
  if ( a1 )
    result = v1(1i64, 0i64, qword_95060, &v6, &v7);
  else
    result = v1(2i64, qword_92B50, 0i64, &v6, &v7);
  if ( result >= 0 )
  {
    v3 = qword_96CD8;
    if ( v6 )
    {
      v4 = 0i64;
      do
      {
        if ( (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(v3 + 152))(
               *(_QWORD *)(v7 + 8 * v4),
               qword_92B50,
               &v5) >= 0 )
          sub_2816D(*(_QWORD *)(v7 + 8 * v4), v5);
        ++v4;
        v3 = qword_96CD8;
      }
      while ( v4 < v6 );
    }
    result = (*(__int64 (__fastcall **)(__int64))(v3 + 72))(v7);
  }
  return result;
}
// 92B50: using guessed type __int64 qword_92B50[2];
// 95060: using guessed type __int64 qword_95060;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000027DE2) ----------------------------------------------------
__int64 sub_27DE2()
{
  void **v0; // rsi
  __int64 **v1; // rbx
  signed __int64 v2; // rsi
  __int64 result; // rax

  v0 = &off_92D40;
  if ( &off_92D40 != &off_92D40 )
  {
    do
    {
      v1 = (__int64 **)*v0;
      if ( !*((_BYTE *)v0 + 17) )
      {
        v2 = (signed __int64)(v0 - 1);
        if ( *(_QWORD *)(v2 + 48) )
          (*(void (**)(void))(qword_96CD8 + 72))();
        sub_23BE1(v1[1]);
        result = (*(__int64 (__fastcall **)(signed __int64))(qword_96CD8 + 72))(v2);
      }
      v0 = (void **)v1;
    }
    while ( v1 != (__int64 **)&off_92D40 );
  }
  return result;
}
// 92D40: using guessed type void *off_92D40;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000027E47) ----------------------------------------------------
void **sub_27E47()
{
  void **v0; // rcx
  void **result; // rax
  void **v2; // rdx

  v0 = &off_92D40;
  result = &off_92D40;
  if ( &off_92D40 != &off_92D40 )
  {
    do
    {
      v2 = (void **)*v0;
      if ( !*((_BYTE *)v0 + 16) )
        *((_BYTE *)v0 + 16) = 1;
      v0 = v2;
    }
    while ( v2 != &off_92D40 );
  }
  return result;
}
// 92D40: using guessed type void *off_92D40;

//----- (0000000000027E75) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_27E75()
{
  __int64 result; // rax

  sub_24098(qword_95068, 16i64);
  result = (*(__int64 (__fastcall **)(signed __int64, signed __int64, void (*)(), _QWORD, __int64 *))(qword_96CD8 + 80))(
             512i64,
             16i64,
             sub_27ECA,
             0i64,
             &qword_95080);
  if ( result >= 0 )
    byte_95088 = 1;
  return result;
}
// 27EBD: write access to const memory at 95088 has been detected
// 95068: using guessed type __int64 qword_95068[3];
// 95080: using guessed type __int64 qword_95080;
// 95088: using guessed type char byte_95088;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000027ECA) ----------------------------------------------------
void sub_27ECA()
{
  void **v0; // r15
  signed __int64 v1; // rsi
  void **i; // rdi
  __int64 v3; // rcx
  void (__fastcall *v4)(__int64, void *); // rax
  __int64 v5; // rax
  void **v6; // rdi

  if ( byte_95088 == 1 )
  {
    while ( sub_240AB(qword_95068) )
      ;
    sub_27E47();
    v0 = &off_92D80;
    if ( &off_92D80 != &off_92D80 )
    {
      do
      {
        v1 = (signed __int64)(v0 - 1);
        for ( i = &off_92D40; i != &off_92D40; i = (void **)*i )
        {
          if ( *((_BYTE *)i + 17) )
          {
            if ( *((_BYTE *)i + 16) )
            {
              v3 = *(_QWORD *)(v1 + 24);
              if ( *((_DWORD *)i + 5) & *(_DWORD *)(v3 + 8) )
              {
                v4 = (void (__fastcall *)(__int64, void *))i[3];
                if ( v4 )
                  v4(v3, i[4]);
              }
            }
          }
        }
        v5 = *(_QWORD *)(v1 + 24);
        if ( *(_BYTE *)(v5 + 9) && *(_QWORD *)(v5 + 16) )
          (*(void (**)(void))(qword_96CD8 + 72))();
        v6 = (void **)*v0;
        sub_23BE1(*((__int64 **)*v0 + 1));
        (*(void (__fastcall **)(void *))(qword_96CD8 + 72))(v0[2]);
        (*(void (__fastcall **)(void **))(qword_96CD8 + 72))(v0 - 1);
        v0 = v6;
      }
      while ( v6 != &off_92D80 );
    }
    sub_27DE2();
    sub_240E8((__int64)qword_95068);
  }
}
// 92D40: using guessed type void *off_92D40;
// 92D80: using guessed type void *off_92D80;
// 95068: using guessed type __int64 qword_95068[3];
// 95088: using guessed type char byte_95088;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000027FD3) ----------------------------------------------------
__int64 sub_27FD3()
{
  __int64 result; // rax

  result = (*(__int64 (__fastcall **)(__int64))(qword_96CD8 + 104))(qword_95080);
  if ( byte_95088 == 1 )
  {
    if ( qword_95080 )
      result = (*(__int64 (**)(void))(qword_96CD8 + 112))();
  }
  return result;
}
// 95080: using guessed type __int64 qword_95080;
// 95088: using guessed type char byte_95088;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000028017) ----------------------------------------------------
void __fastcall sub_28017(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rax

  if ( byte_95088 == 1 )
  {
    v1 = a1;
    while ( sub_240AB(qword_95068) )
      ;
    v2 = sub_24103(32i64);
    if ( v2 )
    {
      *(_DWORD *)v2 = 1366705473;
      *(_QWORD *)(v2 + 24) = v1;
      sub_23BF5((__int64)&off_92D80, (_QWORD *)(v2 + 8));
    }
    sub_240E8((__int64)qword_95068);
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 104))(qword_95080);
  }
}
// 92D80: using guessed type void *off_92D80;
// 95068: using guessed type __int64 qword_95068[3];
// 95080: using guessed type __int64 qword_95080;
// 95088: using guessed type char byte_95088;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000002809A) ----------------------------------------------------
__int64 sub_2809A()
{
  signed __int64 v0; // rax
  __int64 v1; // rsi

  v0 = sub_28202();
  if ( v0 < 0 )
    return v0;
  v1 = sub_28C1E();
  if ( v1 < 0 )
    sub_284F7();
  return v1;
}

//----- (00000000000280CE) ----------------------------------------------------
void sub_280CE()
{
  sub_284F7();
  sub_28C86();
}

//----- (00000000000280E5) ----------------------------------------------------
__int64 __fastcall sub_280E5(__int64 a1, int a2, __int64 a3, int a4)
{
  int v4; // er15
  __int64 v5; // r14
  int v6; // ebx
  __int64 v7; // rsi
  __int64 v8; // rdi
  char v10; // [rsp+20h] [rbp-40h]

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = sub_24136(40i64);
  if ( v8 )
  {
    (*(void (__fastcall **)(char *, _QWORD))(qword_96CE0 + 24))(&v10, 0i64);
    *(_DWORD *)(v8 + 8) = v6;
    *(_QWORD *)(v8 + 16) = v7;
    *(_DWORD *)(v8 + 24) = v4;
    *(_QWORD *)v8 = *(_QWORD *)&v10;
    if ( v5 )
      (*(void (__fastcall **)(__int64, __int64, signed __int64))(qword_96CD8 + 352))(v8 + 28, v5, 8i64);
  }
  return v8;
}
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000002816D) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_2816D(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // rbx
  __int64 result; // rax
  __int64 v5; // rdi
  __int64 v6; // rax

  v2 = a2;
  v3 = a1;
  result = sub_24136(24 * qword_95090 + 24);
  if ( result )
  {
    v5 = result;
    (*(void (__fastcall **)(__int64, __int64, __int64))(qword_96CD8 + 352))(result, qword_96D18, 24 * qword_95090++);
    v6 = 3 * qword_95090;
    *(_QWORD *)(v5 + 8 * v6) = v3;
    *(_QWORD *)(v5 + 8 * v6 + 8) = v2;
    *(_BYTE *)(v5 + 8 * v6 + 16) = 1;
    result = (*(__int64 (__fastcall **)(__int64))(qword_96CD8 + 72))(qword_96D18);
    qword_96D18 = v5;
  }
  return result;
}
// 281C6: write access to const memory at 95090 has been detected
// 281F0: write access to const memory at 96D18 has been detected
// 95090: using guessed type __int64 qword_95090;
// 95098: using guessed type __int64 qword_95098;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96D18: using guessed type __int64 qword_96D18;

//----- (0000000000028202) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 sub_28202()
{
  signed __int64 v0; // rsi
  unsigned __int64 v1; // rdi
  signed __int64 result; // rax

  sub_290EF(&qword_96D18, (unsigned __int64 *)&qword_95090, (__int64)qword_92B50);
  if ( qword_95090 )
  {
    v0 = 8i64;
    v1 = 0i64;
    do
    {
      (**(void (__fastcall ***)(_QWORD, _QWORD))(qword_96D18 + v0))(*(_QWORD *)(qword_96D18 + v0), 0i64);
      ++v1;
      v0 += 24i64;
    }
    while ( v1 < qword_95090 );
  }
  sub_2857A();
  (*(void (__fastcall **)(__int64 *, signed __int64, _QWORD))(qword_96CD8 + 360))(&qword_950B0, 8i64, 0i64);
  qword_95098 = sub_359AF((__int64)sub_282BE, 0i64, 20000i64, 1u);
  if ( !qword_95098 )
    return -9223372036854775799i64;
  result = 0i64;
  word_92DB0 = 0;
  word_92DE8 = 0;
  return result;
}
// 2828E: write access to const memory at 95098 has been detected
// 2829C: write access to const memory at 92DB0 has been detected
// 282A3: write access to const memory at 92DE8 has been detected
// 92B50: using guessed type __int64 qword_92B50[2];
// 92DB0: using guessed type __int16 word_92DB0;
// 92DE8: using guessed type __int16 word_92DE8;
// 95090: using guessed type __int64 qword_95090;
// 95098: using guessed type __int64 qword_95098;
// 950A0: using guessed type char byte_950A0;
// 950B0: using guessed type __int64 qword_950B0;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96D18: using guessed type __int64 qword_96D18;

//----- (00000000000282BE) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_282BE()
{
  __int64 v0; // r15
  signed __int64 v1; // r14
  unsigned __int64 v2; // r13
  __int64 v3; // rsi
  __int64 v4; // rax
  __int64 v5; // r12
  _QWORD *v6; // r15
  signed __int64 v7; // rsi
  signed __int64 v8; // rax
  signed int v9; // edx
  int v10; // edx
  signed int v11; // ecx
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  int v15; // esi
  __int64 v16; // rax
  int v17; // [rsp+28h] [rbp-58h]
  int v18; // [rsp+2Ch] [rbp-54h]
  char v19; // [rsp+34h] [rbp-4Ch]
  char v20; // [rsp+35h] [rbp-4Bh]
  int v21; // [rsp+3Ch] [rbp-44h]
  int v22; // [rsp+40h] [rbp-40h]
  int v23; // [rsp+44h] [rbp-3Ch]

  v0 = -9223372036854775805i64;
  v21 = sub_288AD();
  sub_290EF(&qword_96D18, (unsigned __int64 *)&qword_95090, (__int64)qword_92B50);
  if ( qword_95090 )
  {
    v0 = -9223372036854775802i64;
    v1 = 8i64;
    v2 = 0i64;
    while ( 1 )
    {
      v3 = *(_QWORD *)(qword_96D18 + v1);
      v4 = (*(__int64 (__fastcall **)(__int64, int *))(v3 + 8))(v3, &v17);
      if ( v4 >= 0 )
        break;
LABEL_27:
      ++v2;
      v1 += 24i64;
      if ( v2 >= qword_95090 )
        goto LABEL_28;
    }
    v5 = v4;
    v6 = *(_QWORD **)(v3 + 24);
    v7 = sub_2885A(v17);
    v8 = (signed __int64)sub_2885A(v18) / v6[1];
    v9 = -1;
    if ( v17 > 0 )
      v9 = 1;
    if ( !v17 )
      v9 = v7 / *v6;
    if ( v7 / *v6 )
      v9 = v7 / *v6;
    v10 = qword_950B0 + v9;
    v11 = -1;
    if ( v18 > 0 )
      v11 = 1;
    if ( !v18 )
      v11 = v8;
    if ( v8 )
      v11 = v8;
    v12 = HIDWORD(qword_950B0) + v11;
    v22 = v10;
    v23 = v12;
    v13 = dword_950A4;
    if ( v10 <= dword_950A4 )
    {
      if ( v10 >= 0 )
        goto LABEL_20;
      v13 = 0;
    }
    v22 = v13;
LABEL_20:
    v14 = dword_950A8;
    if ( v12 <= dword_950A8 )
    {
      if ( v12 >= 0 )
      {
LABEL_24:
        if ( sub_236BB(&v22, &qword_950B0, 8i64) )
        {
          (*(void (__fastcall **)(__int64 *, int *, signed __int64))(qword_96CD8 + 352))(&qword_950B0, &v22, 8i64);
          byte_950B8 = 1;
        }
        LOBYTE(word_92DE8) = HIBYTE(word_92DE8);
        HIBYTE(word_92DE8) = v19;
        LOBYTE(word_92DB0) = HIBYTE(word_92DB0);
        HIBYTE(word_92DB0) = v20;
        v0 = v5;
        goto LABEL_27;
      }
      v14 = 0;
    }
    v23 = v14;
    goto LABEL_24;
  }
LABEL_28:
  v15 = v21;
  sub_28665(v0, (__int64)qword_92DC8, v21);
  sub_28665(v0, (__int64)qword_92D90, v15);
  if ( v0 < 0 )
  {
    if ( v0 == -9223372036854775805i64 )
    {
      sub_35A74(qword_95098);
      qword_95098 = 0i64;
    }
  }
  else if ( byte_950B8 == 1 )
  {
    byte_950B8 = 0;
    v16 = sub_280E5(1i64, 1, (__int64)&qword_950B0, v15);
    if ( v16 )
      sub_28017(v16);
  }
}
// 28414: write access to const memory at 950B8 has been detected
// 28421: write access to const memory at 92DE8 has been detected
// 2842D: write access to const memory at 92DE9 has been detected
// 28439: write access to const memory at 92DB0 has been detected
// 2843F: write access to const memory at 92DB1 has been detected
// 28491: write access to const memory at 950B8 has been detected
// 284DB: write access to const memory at 95098 has been detected
// 92B50: using guessed type __int64 qword_92B50[2];
// 92D90: using guessed type __int64 qword_92D90[4];
// 92DB0: using guessed type __int16 word_92DB0;
// 92DC8: using guessed type __int64 qword_92DC8[4];
// 92DE8: using guessed type __int16 word_92DE8;
// 95090: using guessed type __int64 qword_95090;
// 95098: using guessed type __int64 qword_95098;
// 950A4: using guessed type int dword_950A4;
// 950A8: using guessed type int dword_950A8;
// 950B0: using guessed type __int64 qword_950B0;
// 950B8: using guessed type char byte_950B8;
// 96CD8: using guessed type __int64 qword_96CD8;
// 96D18: using guessed type __int64 qword_96D18;

//----- (00000000000284F7) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_284F7()
{
  sub_35A74(qword_95098);
  qword_95098 = 0i64;
}
// 2850B: write access to const memory at 95098 has been detected
// 95098: using guessed type __int64 qword_95098;

//----- (000000000002851C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_2851C(_DWORD *a1)
{
  _DWORD *v1; // rdi
  signed __int64 v2; // rsi
  int v3; // ecx

  v1 = a1;
  v2 = -9223372036854775806i64;
  if ( !byte_950A0 && sub_2857A() < 0 )
    return -9223372036854775802i64;
  if ( *v1 < dword_950A4 )
  {
    v3 = v1[1];
    if ( v3 < dword_950A8 )
    {
      LODWORD(qword_950B0) = *v1;
      HIDWORD(qword_950B0) = v3;
      v2 = 0i64;
    }
  }
  return v2;
}
// 2855B: write access to const memory at 950B0 has been detected
// 28561: write access to const memory at 950B4 has been detected
// 950A0: using guessed type char byte_950A0;
// 950A4: using guessed type int dword_950A4;
// 950A8: using guessed type int dword_950A8;
// 950B0: using guessed type __int64 qword_950B0;

//----- (000000000002857A) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_2857A()
{
  __int64 result; // rax
  __int64 v1; // rcx
  char v2; // [rsp+28h] [rbp-28h]
  char v3; // [rsp+2Ch] [rbp-24h]
  __int64 v4; // [rsp+30h] [rbp-20h]
  __int64 (__fastcall **v5)(_QWORD, int *, int *, char *, char *); // [rsp+38h] [rbp-18h]
  int v6; // [rsp+40h] [rbp-10h]
  int v7; // [rsp+44h] [rbp-Ch]

  result = (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
             *(_QWORD *)(qword_96CD0 + 56),
             qword_92AD0,
             &v4);
  if ( result == -9223372036854775805i64 )
  {
    dword_950A4 = 800;
    dword_950A8 = 600;
    if ( (*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 (__fastcall ***)(_QWORD, int *, int *, char *, char *)))(qword_96CD8 + 152))(
           *(_QWORD *)(qword_96CD0 + 56),
           qword_92B60,
           &v5) >= 0
      && (*v5)(v5, &v7, &v6, &v2, &v3) >= 0 )
    {
      dword_950A4 = v7;
      dword_950A8 = v6;
    }
    result = 0i64;
  }
  else if ( result >= 0 )
  {
    v1 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 8i64);
    dword_950A4 = *(_DWORD *)(v1 + 4);
    dword_950A8 = *(_DWORD *)(v1 + 8);
    if ( dword_950A8 )
      byte_950A0 = 1;
    else
      result = -9223372036854775802i64;
  }
  return result;
}
// 285B5: write access to const memory at 950A4 has been detected
// 285BF: write access to const memory at 950A8 has been detected
// 28614: write access to const memory at 950A4 has been detected
// 2861D: write access to const memory at 950A8 has been detected
// 2863B: write access to const memory at 950A4 has been detected
// 28644: write access to const memory at 950A8 has been detected
// 2864E: write access to const memory at 950A0 has been detected
// 92AD0: using guessed type __int64 qword_92AD0[2];
// 92B60: using guessed type __int64 qword_92B60[2];
// 950A0: using guessed type char byte_950A0;
// 950A4: using guessed type int dword_950A4;
// 950A8: using guessed type int dword_950A8;
// 96CD0: using guessed type __int64 qword_96CD0;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000028665) ----------------------------------------------------
char __fastcall sub_28665(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // rsi
  char result; // al
  int v5; // edi
  char v6; // cl
  __int64 v7; // rcx
  int v8; // edx
  __int64 v9; // rax
  signed __int64 v10; // rdx
  signed __int64 v11; // rbx
  signed __int64 v12; // rbx
  signed __int64 v13; // rcx
  signed __int64 v14; // rax
  __int64 v15; // rcx
  int v16; // edx
  __int64 v17; // rax
  __int64 v18; // rcx
  int v19; // edx
  __int64 v20; // rax

  v3 = a2;
  result = *(_BYTE *)(a2 + 32);
  if ( a1 >= 0 )
  {
    v5 = a3;
    v6 = *(_BYTE *)(a2 + 33);
    if ( result )
    {
      if ( !v6 )
      {
        v7 = *(_QWORD *)a2 | 4i64;
        v8 = 1;
        if ( !(*(_QWORD *)v3 & 1) )
          v8 = 110;
        v9 = sub_280E5(v7, v8, (__int64)&qword_950B0, a3);
        if ( v9 )
          sub_28017(v9);
        if ( *(_QWORD *)(v3 + 8) <= 0x4Aui64 )
        {
          v10 = (signed int)qword_950B0 - (signed __int64)*(signed int *)(v3 + 36);
          if ( *(_DWORD *)(v3 + 36) - (signed int)qword_950B0 >= 0 )
            v10 = *(signed int *)(v3 + 36) - (signed __int64)(signed int)qword_950B0;
          v11 = SHIDWORD(qword_950B0) - (signed __int64)*(signed int *)(v3 + 40);
          if ( *(_DWORD *)(v3 + 40) - HIDWORD(qword_950B0) >= 0 )
            v11 = *(signed int *)(v3 + 40) - (signed __int64)SHIDWORD(qword_950B0);
          if ( v10 <= 5 && v11 <= 5 )
          {
            v12 = 8i64;
            if ( *(_QWORD *)(v3 + 24) == 8i64 && *(_QWORD *)(v3 + 16) <= 0x176ui64 )
            {
              v13 = (signed int)qword_950B0 - (signed __int64)*(signed int *)(v3 + 44);
              if ( *(_DWORD *)(v3 + 44) - (signed int)qword_950B0 >= 0 )
                v13 = *(signed int *)(v3 + 44) - (signed __int64)(signed int)qword_950B0;
              v14 = SHIDWORD(qword_950B0) - (signed __int64)*(signed int *)(v3 + 48);
              if ( *(_DWORD *)(v3 + 48) - HIDWORD(qword_950B0) >= 0 )
                v14 = *(signed int *)(v3 + 48) - (signed __int64)SHIDWORD(qword_950B0);
              v12 = 8i64;
              if ( v13 <= 5 )
                v12 = 8i64 * (v14 < 6) + 8;
            }
            v15 = v12 | *(_QWORD *)v3;
            v16 = 1;
            if ( !(*(_QWORD *)v3 & 1) )
            {
              v16 = 110;
              if ( !(v15 & 0x6E) )
                v16 = 255;
            }
            v17 = sub_280E5(v15, v16, (__int64)&qword_950B0, v5);
            if ( v17 )
              sub_28017(v17);
            if ( *(_QWORD *)(v3 + 24) == 16i64 )
              v12 = 8i64 * (*(_QWORD *)(v3 + 16) < 0x177ui64) + 8;
            *(_QWORD *)(v3 + 24) = v12;
            *(_QWORD *)(v3 + 44) = qword_950B0;
            *(_QWORD *)(v3 + 16) = 0i64;
          }
        }
      }
    }
    else if ( v6 )
    {
      *(_QWORD *)(a2 + 8) = 0i64;
      *(_QWORD *)(a2 + 36) = qword_950B0;
      v18 = *(_QWORD *)a2 | 2i64;
      v19 = 1;
      if ( !(*(_QWORD *)v3 & 1) )
        v19 = 110;
      v20 = sub_280E5(v18, v19, (__int64)&qword_950B0, a3);
      if ( v20 )
        sub_28017(v20);
    }
    result = *(_BYTE *)(v3 + 33);
    *(_BYTE *)(v3 + 32) = result;
  }
  if ( result && *(_BYTE *)(v3 + 33) )
    ++*(_QWORD *)(v3 + 8);
  ++*(_QWORD *)(v3 + 16);
  return result;
}
// 950B0: using guessed type __int64 qword_950B0;

//----- (000000000002885A) ----------------------------------------------------
unsigned __int64 __fastcall sub_2885A(unsigned __int64 a1)
{
  unsigned __int64 v1; // rsi
  unsigned __int64 v2; // rdi
  char v3; // al
  signed __int64 v4; // rcx

  if ( !a1 )
    return 0i64;
  v1 = a1;
  v2 = -(signed __int64)a1;
  if ( -(signed __int64)a1 < 1 )
    v2 = a1;
  v3 = sub_23CCE(v2);
  v4 = 5i64;
  if ( (unsigned __int8)v3 <= 4u )
    v4 = (unsigned __int8)sub_23CCE(v2);
  return v1 * *((unsigned __int8 *)qword_8FD70 + v4);
}
// 8FD70: using guessed type __int64 qword_8FD70[2];

//----- (00000000000288AD) ----------------------------------------------------
__int64 sub_288AD()
{
  char v1; // [rsp+28h] [rbp-18h]
  __int64 v2; // [rsp+30h] [rbp-10h]
  unsigned __int16 v3; // [rsp+3Eh] [rbp-2h]

  if ( sub_288EC((__int64)&v3, &v1, &v2) < 0 )
    return 0i64;
  if ( v2 )
    (*(void (**)(void))(qword_96CD8 + 72))();
  return v3;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000288EC) ----------------------------------------------------
signed __int64 __fastcall sub_288EC(__int64 a1, _QWORD *a2, __int64 *a3)
{
  signed __int64 v3; // rsi
  __int64 v4; // rbx
  _QWORD *v5; // r15
  __int64 *v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rax

  v3 = -9223372036854775806i64;
  if ( !qword_950C0 )
    return -9223372036854775805i64;
  v4 = a1;
  if ( !a1 )
    return v3;
  v5 = a2;
  if ( !a2 )
    return v3;
  v6 = a3;
  if ( !a3 )
    return v3;
  *a2 = 0i64;
  *a3 = 0i64;
  v7 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD *, _QWORD))(qword_950C0 + 8))(qword_950C0, a1, a2, 0i64);
  if ( v7 < 0 && v7 != -9223372036854775803i64 )
    return v7;
  if ( !*v5 )
  {
    *v6 = 0i64;
    return v7;
  }
  v8 = sub_24103(2i64 * *v5);
  *v6 = v8;
  if ( !v8 )
  {
    *v5 = 0i64;
    return -9223372036854775799i64;
  }
  v7 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD *, __int64))(qword_950C0 + 8))(qword_950C0, v4, v5, v8);
  if ( v7 < 0 )
  {
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(*v6);
    *v6 = 0i64;
    *v5 = 0i64;
  }
  return v7;
}
// 950C0: using guessed type __int64 qword_950C0;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000289D6) ----------------------------------------------------
signed __int64 __fastcall sub_289D6(__int64 *a1, _DWORD *a2)
{
  signed __int64 v2; // rbx
  __int64 *v3; // r14
  _DWORD *v4; // rdi
  unsigned __int64 v5; // rsi
  bool v6; // cf
  int v7; // ecx
  signed __int64 v8; // rax
  unsigned __int64 v10; // [rsp+28h] [rbp-38h]
  _WORD *v11; // [rsp+30h] [rbp-30h]
  unsigned __int16 v12; // [rsp+3Ah] [rbp-26h]
  int v13; // [rsp+3Ch] [rbp-24h]

  v13 = 0;
  v11 = 0i64;
  v2 = -9223372036854775805i64;
  if ( !a2 )
    return v2;
  v3 = a1;
  if ( !a1 || !qword_950C0 )
    return v2;
  v4 = a2;
  v12 = 0;
  v10 = 0i64;
  sub_288EC((__int64)&v12, &v10, (__int64 *)&v11);
  if ( v10 )
  {
    v5 = 1i64;
    do
    {
      if ( (*(__int64 (__fastcall **)(_QWORD, int *))(*(_QWORD *)(qword_96CD0 + 48) + 8i64))(
             *(_QWORD *)(qword_96CD0 + 48),
             &v13) < 0 )
        break;
      v6 = v5++ < v10;
    }
    while ( v6 );
  }
  v7 = v12;
  *v4 = v12;
  v8 = sub_28D5C(v7, &v10, v11, &v13);
  if ( v8 < 0 )
    goto LABEL_11;
  if ( v10 )
  {
    v8 = sub_28AC9(v3, (__int64)v11, &v13);
LABEL_11:
    v2 = v8;
    goto LABEL_13;
  }
  v2 = 0i64;
LABEL_13:
  if ( v11 )
    (*(void (**)(void))(qword_96CD8 + 72))();
  return v2;
}
// 950C0: using guessed type __int64 qword_950C0;
// 96CD0: using guessed type __int64 qword_96CD0;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000028AC9) ----------------------------------------------------
signed __int64 __fastcall sub_28AC9(__int64 *a1, __int64 a2, _DWORD *a3)
{
  signed __int64 v3; // rsi
  __int64 v4; // r14
  _DWORD *v5; // rbx
  __int64 *v6; // r15
  __int64 v7; // rax
  __int64 v8; // rdi

  v3 = -9223372036854775806i64;
  if ( a1 )
  {
    v4 = a2;
    if ( a2 )
    {
      v5 = a3;
      if ( a3 )
      {
        v6 = a1;
        v7 = sub_24136(10i64);
        if ( v7 )
        {
          v8 = v7;
          *(_WORD *)v7 = 1;
          *(_DWORD *)(v7 + 2) = *v5;
          (*(void (__fastcall **)(__int64, __int64, signed __int64))(qword_96CD8 + 352))(v7 + 6, v4, 2i64);
          *v6 = v8;
          v3 = 0i64;
        }
        else
        {
          v3 = -9223372036854775799i64;
        }
      }
    }
  }
  return v3;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000028B4E) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 sub_28B4E()
{
  signed __int64 result; // rax
  int v1; // esi
  int v2; // er8
  __int64 v3; // [rsp+28h] [rbp-18h]
  unsigned int v4; // [rsp+34h] [rbp-Ch]

  v3 = 0i64;
  v4 = 0;
  result = sub_289D6(&v3, &v4);
  if ( result >= 0 )
  {
    if ( v3 )
      sub_28BD7(v3, 256, v4);
    result = (unsigned int)dword_950C8;
    if ( dword_950C8 != v4 )
    {
      v1 = (result ^ v4) & v4;
      v2 = result & (result ^ v4);
      if ( v2 )
        sub_28BD7(0i64, 2048, v2);
      if ( v1 )
        sub_28BD7(0i64, 1024, v1);
      result = v4;
      dword_950C8 = v4;
    }
  }
  return result;
}
// 28BCA: write access to const memory at 950C8 has been detected
// 950C8: using guessed type int dword_950C8;

//----- (0000000000028BD7) ----------------------------------------------------
signed __int64 __fastcall sub_28BD7(__int64 a1, int a2, int a3)
{
  signed __int64 v3; // rsi
  __int64 v4; // rax

  v3 = -9223372036854775806i64;
  if ( a1 || a3 )
  {
    v4 = sub_280E5(a1, a2, 0i64, a3);
    if ( v4 )
    {
      sub_28017(v4);
      v3 = 0i64;
    }
    else
    {
      v3 = -9223372036854775799i64;
    }
  }
  return v3;
}

//----- (0000000000028C1E) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_28C1E()
{
  __int64 result; // rax
  __int64 v1; // rax
  bool v2; // zf

  result = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(
             qword_92BC0,
             0i64,
             &qword_950C0);
  if ( result >= 0 )
  {
    sub_28CE6();
    v1 = sub_359AF((__int64)sub_28B4E, 0i64, (__int64)&loc_186A0, 1u);
    qword_950D0 = v1;
    v2 = v1 == 0;
    result = -9223372036854775799i64;
    if ( !v2 )
      result = 0i64;
  }
  return result;
}
// 28C67: write access to const memory at 950D0 has been detected
// 92BC0: using guessed type __int64 qword_92BC0[2];
// 950C0: using guessed type __int64 qword_950C0;
// 950D0: using guessed type __int64 qword_950D0;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000028C86) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_28C86()
{
  sub_35A74(qword_950D0);
  qword_950D0 = 0i64;
}
// 28C9A: write access to const memory at 950D0 has been detected
// 950D0: using guessed type __int64 qword_950D0;

//----- (0000000000028CAB) ----------------------------------------------------
unsigned __int64 __fastcall sub_28CAB(__int16 a1, _DWORD *a2, char a3)
{
  __int64 *v3; // r9
  unsigned __int64 result; // rax

  v3 = qword_92E00;
  result = 0i64;
  while ( *(_WORD *)v3 != a1 )
  {
    ++result;
    v3 = (__int64 *)((char *)v3 + 10);
    if ( result >= 0x5B )
    {
      *a2 = 0;
      return result;
    }
  }
  if ( a3 )
    result = *(unsigned int *)((char *)v3 + 6);
  else
    result = *(unsigned int *)((char *)v3 + 2);
  *a2 = result;
  return result;
}
// 92E00: using guessed type __int64 qword_92E00[114];

//----- (0000000000028CE6) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_28CE6()
{
  __int64 result; // rax

  if ( !byte_950E0 )
  {
    byte_950E0 = 1;
    result = (*(__int64 (__fastcall **)(__int64 *, signed __int64, _QWORD))(qword_96CD8 + 360))(
               qword_950F0,
               240i64,
               0i64);
    word_951E0 = 0;
    byte_951E2 = 0;
    byte_951E3 = 0;
  }
  return result;
}
// 28CF8: write access to const memory at 950E0 has been detected
// 28D1D: write access to const memory at 951E0 has been detected
// 28D26: write access to const memory at 951E2 has been detected
// 28D2D: write access to const memory at 951E3 has been detected
// 950E0: using guessed type char byte_950E0;
// 950F0: using guessed type __int64 qword_950F0[];
// 951E0: using guessed type __int16 word_951E0;
// 951E2: using guessed type char byte_951E2;
// 951E3: using guessed type char byte_951E3;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000028D3B) ----------------------------------------------------
signed __int64 __fastcall sub_28D3B(_BYTE *a1)
{
  if ( !a1 )
    return -9223372036854775806i64;
  *a1 = byte_951E2;
  return 0i64;
}
// 951E2: using guessed type char byte_951E2;

//----- (0000000000028D5C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_28D5C(int a1, unsigned __int64 *a2, _WORD *a3, _DWORD *a4)
{
  _WORD *v4; // r12
  unsigned __int64 *v5; // r15
  int v6; // er14
  signed __int64 v7; // rax
  unsigned __int64 v8; // rbx
  __int64 *v9; // rdi
  unsigned __int64 v10; // r13
  __int64 v11; // rsi
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rax
  __int16 *v14; // rdi
  unsigned __int64 v15; // rax
  __int64 v16; // rcx
  __int16 v17; // bx
  __int64 *v18; // rdx
  unsigned __int64 v19; // rsi
  unsigned __int16 v20; // ax
  int v21; // ebx
  bool v22; // r14
  unsigned __int64 v23; // rsi
  char v24; // r9
  unsigned __int64 *v25; // rsi
  __int16 v26; // r8
  __int64 v27; // rcx
  __int16 v28; // ax
  __int64 *v29; // rdx
  unsigned __int64 v30; // rdi
  signed __int64 v31; // rdx
  __int64 *v32; // rcx
  unsigned __int64 v33; // rdx
  __int64 *v34; // rbx
  unsigned __int64 v35; // rax
  unsigned __int64 v36; // rcx
  int v38; // ecx
  char v39; // [rsp+28h] [rbp-78h]
  unsigned __int64 *v40; // [rsp+30h] [rbp-70h]
  _DWORD *v41; // [rsp+38h] [rbp-68h]
  __int64 v42; // [rsp+40h] [rbp-60h]
  int v43; // [rsp+58h] [rbp-48h]
  int v44; // [rsp+5Ch] [rbp-44h]
  __int16 *v45; // [rsp+60h] [rbp-40h]

  v41 = a4;
  v4 = a3;
  v5 = a2;
  v6 = a1;
  if ( word_951E0 != (_WORD)a1 )
  {
    v7 = 2i64;
    do
    {
      LOBYTE(qword_950F0[v7]) = 0;
      v7 += 3i64;
    }
    while ( v7 != 32 );
  }
  v8 = *a2;
  v9 = qword_950F0;
  v10 = 0i64;
  v11 = 0i64;
  do
  {
    if ( v8 )
    {
      v12 = 0i64;
      do
      {
        if ( *(_WORD *)v9 == v4[v12] )
          break;
        ++v12;
      }
      while ( v12 < v8 );
    }
    else
    {
      v12 = 0i64;
    }
    if ( v12 == v8 )
    {
      if ( *(_WORD *)v9 )
        *((_WORD *)&v42 + v10++) = *(_WORD *)v9;
      (*(void (__fastcall **)(__int64 *, signed __int64, _QWORD))(qword_96CD8 + 360))(v9, 24i64, 0i64);
    }
    ++v11;
    v9 += 3;
  }
  while ( v11 != 10 );
  if ( byte_951E3 == 1 )
  {
    v13 = 0i64;
    if ( v8 )
    {
      do
      {
        if ( v4[v13] == 28729 )
          break;
        ++v13;
      }
      while ( v13 < v8 );
    }
    if ( v13 == v8 )
    {
      byte_951E3 = 0;
      *((_WORD *)&v42 + v10++) = 28729;
    }
  }
  if ( v10 )
  {
    v14 = (__int16 *)sub_24103(2 * v10);
    if ( v14 )
    {
      (*(void (__fastcall **)(__int16 *, __int64 *, unsigned __int64))(qword_96CD8 + 352))(v14, &v42, 2 * v10);
      v45 = v14;
    }
    else
    {
      v10 = 0i64;
      v45 = 0i64;
    }
  }
  else
  {
    v10 = 0i64;
    v45 = 0i64;
    v14 = 0i64;
  }
  if ( !v5 )
    goto LABEL_80;
  v15 = *v5;
  if ( !v4 )
  {
    if ( v15 )
      goto LABEL_80;
  }
  LOBYTE(a4) = byte_951E2;
  if ( v15 )
  {
    v16 = 0i64;
    while ( 2 )
    {
      v17 = v4[v16];
      v18 = qword_950F0;
      v19 = 0i64;
      while ( *(_WORD *)v18 != v17 )
      {
        ++v19;
        v18 += 3;
        if ( v19 > 9 )
        {
          if ( v17 == 28729 && !(byte_951E3 & 1) )
            LOBYTE(a4) = byte_951E2 == 0;
          goto LABEL_41;
        }
      }
      if ( ++v16 < v15 )
        continue;
      break;
    }
  }
LABEL_41:
  if ( (_BYTE)a4 )
  {
    v20 = v6 | 0x22;
  }
  else
  {
LABEL_80:
    LODWORD(a4) = 0;
    v20 = v6;
  }
  v44 = (signed int)a4;
  v40 = v5;
  v43 = v6;
  if ( v10 )
  {
    v21 = v20;
    v22 = (v20 & 0x22) != 0;
    v23 = 0i64;
    do
    {
      sub_28CAB(*v14, &v39, v22);
      v42 = 0i64;
      if ( (unsigned int)sub_28AC9(&v42, (__int64)v14, &v39) )
        break;
      sub_28BD7(v42, 512, v21);
      ++v23;
      ++v14;
    }
    while ( v23 < v10 );
    goto LABEL_50;
  }
  if ( v14 )
LABEL_50:
    (*(void (__fastcall **)(__int16 *))(qword_96CD8 + 72))(v45);
  v24 = v44;
  if ( byte_951E2 != (_BYTE)v44 )
  {
    byte_951E2 = v44;
    byte_951E3 = 1;
  }
  v25 = v40;
  v26 = v43;
  if ( *v40 )
  {
    v27 = 0i64;
    while ( 2 )
    {
      v28 = v4[v27];
      v29 = &qword_950F8;
      v30 = 0i64;
      while ( *((_WORD *)v29 - 4) != v28 )
      {
        ++v30;
        v29 += 3;
        if ( v30 >= 0xA )
        {
          v31 = 2i64;
          v32 = qword_950F0;
          do
          {
            LOBYTE(qword_950F0[v31]) = 0;
            v31 += 3i64;
          }
          while ( v31 != 32 );
          v33 = 0i64;
          while ( *(_WORD *)v32 )
          {
            ++v33;
            v32 += 3;
            if ( v33 > 9 )
              goto LABEL_67;
          }
          *(_WORD *)v32 = v28;
          *((_BYTE *)v32 + 16) = 1;
          v32[1] = 0i64;
          goto LABEL_67;
        }
      }
      ++*v29;
      if ( ++v27 < *v25 )
        continue;
      break;
    }
  }
LABEL_67:
  v34 = qword_95100;
  v35 = 0i64;
  do
  {
    if ( *(_BYTE *)v34 )
    {
      word_951E0 = v26;
      v36 = *(v34 - 1);
      if ( v36 >= 0x32 )
      {
        if ( v36 != 5 * ((unsigned __int64)(0xCCCCCCCCCCCCCCCDui64 * (unsigned __int128)v36 >> 64) >> 2) )
          return -9223372036854775802i64;
      }
      else if ( v36 )
      {
        return -9223372036854775802i64;
      }
      *v25 = 1i64;
      v38 = *((_DWORD *)v34 - 4);
      *v4 = v38;
      sub_28CAB(v38, v41, ((v26 & 0x22) != 0) ^ (v24 != 0 && (unsigned __int16)(v38 - 28676) < 0x1Au));
      return 0i64;
    }
    ++v35;
    v34 += 3;
  }
  while ( v35 < 0xA );
  if ( word_951E0 == v26 )
    return -9223372036854775802i64;
  word_951E0 = v26;
  *v25 = 0i64;
  return 0i64;
}
// 28E32: write access to const memory at 951E3 has been detected
// 28F97: write access to const memory at 951E2 has been detected
// 28F9E: write access to const memory at 951E3 has been detected
// 29050: write access to const memory at 951E0 has been detected
// 29061: write access to const memory at 951E0 has been detected
// 950F0: using guessed type __int64 qword_950F0[];
// 950F8: using guessed type __int64 qword_950F8;
// 95100: using guessed type __int64 qword_95100[28];
// 951E0: using guessed type __int16 word_951E0;
// 951E2: using guessed type char byte_951E2;
// 951E3: using guessed type char byte_951E3;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000290EF) ----------------------------------------------------
__int64 __fastcall sub_290EF(__int64 *a1, unsigned __int64 *a2, __int64 a3)
{
  unsigned __int64 *v3; // r15
  __int64 *v4; // r14
  unsigned __int64 v5; // r8
  __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  __int64 v8; // rbx
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // r13
  __int64 v11; // rsi
  __int64 v12; // rax
  __int64 v13; // r12
  __int64 v14; // rdi
  unsigned __int64 v15; // rax
  __int64 v16; // rbx
  unsigned __int64 v17; // rsi
  __int64 result; // rax
  unsigned __int64 v19; // [rsp+28h] [rbp-48h]
  __int64 v20; // [rsp+30h] [rbp-40h]

  v3 = a2;
  v4 = a1;
  if ( (*(__int64 (__fastcall **)(signed __int64, __int64, _QWORD, unsigned __int64 *, __int64 *))(qword_96CD8 + 312))(
         2i64,
         a3,
         0i64,
         &v19,
         &v20) < 0 )
  {
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(*v4);
    result = 0i64;
    *v4 = 0i64;
    *v3 = 0i64;
  }
  else
  {
    v5 = *v3;
    if ( *v3 )
    {
      v6 = *v4;
      v7 = v19;
      v8 = v20;
      v9 = 0i64;
      v10 = 0i64;
      do
      {
        if ( *(_BYTE *)(v6 + 16) )
        {
          if ( v7 )
          {
            v11 = 0i64;
            while ( *(_QWORD *)v6 != *(_QWORD *)(v8 + 8 * v11) )
            {
              if ( ++v11 >= v7 )
                goto LABEL_12;
            }
            ++v10;
          }
          else
          {
            v11 = 0i64;
          }
LABEL_12:
          if ( v11 == v7 )
            *(_BYTE *)(v6 + 16) = 0;
        }
        ++v9;
        v6 += 24i64;
      }
      while ( v9 < v5 );
      if ( v10 != v5 )
      {
        v12 = sub_24136(24 * v10);
        if ( v12 )
        {
          v13 = v12;
          v14 = *v4;
          v15 = *v3;
          if ( *v3 )
          {
            v16 = 0i64;
            v17 = 0i64;
            do
            {
              if ( *(_BYTE *)(v14 + 16) )
              {
                (*(void (__fastcall **)(__int64, __int64, signed __int64))(qword_96CD8 + 352))(
                  v13 + 24 * v16++,
                  v14,
                  24i64);
                v15 = *v3;
              }
              ++v17;
              v14 += 24i64;
            }
            while ( v17 < v15 );
            v14 = *v4;
          }
          (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v14);
          *v4 = v13;
          *v3 = v10;
        }
      }
    }
    result = (*(__int64 (__fastcall **)(__int64))(qword_96CD8 + 72))(v20);
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000002923D) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_2923D(__int64 a1)
{
  __int64 v1; // rsi

  v1 = a1;
  sub_1A11E();
  if ( v1 )
    qword_951E8 = v1;
}
// 29269: write access to const memory at 951E8 has been detected
// 951E8: using guessed type __int64 qword_951E8;

//----- (0000000000029277) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_29277(__int64 a1)
{
  __int64 v1; // rsi

  v1 = a1;
  sub_1A11E();
  if ( qword_951E8 == v1 )
    qword_951E8 = 0i64;
}
// 292B3: write access to const memory at 951E8 has been detected
// 951E8: using guessed type __int64 qword_951E8;

//----- (00000000000292C5) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_292C5()
{
  char *v0; // rax
  char *v1; // rsi
  bool v2; // bl

  if ( !byte_951F1 )
  {
    byte_951F1 = 1;
    v0 = (char *)sub_29350((__int64)L"loginwindowefi-log");
    if ( v0 )
    {
      v1 = v0;
      v2 = 1;
      if ( (unsigned int)sub_18A1A(v0, "yes") && (unsigned int)sub_18A1A(v1, "true") )
        v2 = (unsigned int)sub_18A1A(v1, "1") == 0;
      byte_951F0 = v2;
      (*(void (__fastcall **)(char *))(qword_96CD8 + 72))(v1);
    }
  }
  return byte_951F0;
}
// 292D8: write access to const memory at 951F1 has been detected
// 2932F: write access to const memory at 951F0 has been detected
// 416C0: using guessed type __int16 aLoginwindowefi[19];
// 951F0: using guessed type char byte_951F0;
// 951F1: using guessed type char byte_951F1;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000029350) ----------------------------------------------------
__int64 __fastcall sub_29350(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rbx
  __int64 v6; // [rsp+30h] [rbp-20h]

  v1 = a1;
  v2 = 0i64;
  v6 = 0i64;
  if ( (*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD))(qword_96CE0 + 72))(a1, qword_93650, 0i64) == -9223372036854775803i64 )
  {
    v3 = sub_24136(v6 + 1);
    if ( v3 )
    {
      v4 = v3;
      v2 = 0i64;
      if ( (*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD, __int64 *, __int64))(qword_96CE0 + 72))(
             v1,
             qword_93650,
             0i64,
             &v6,
             v3) >= 0 )
      {
        *(_BYTE *)(v4 + v6) = 0;
        sub_1A11E();
        v2 = v4;
      }
    }
    else
    {
      v2 = 0i64;
    }
  }
  return v2;
}
// 93650: using guessed type __int64 qword_93650[2];
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (0000000000029405) ----------------------------------------------------
__int64 __fastcall sub_29405(unsigned __int64 a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int8 a4, __int64 a5, __int16 a6, int *a7, __int64 a8, unsigned __int16 *a9, __int64 a10)
{
  unsigned int v10; // edi
  unsigned __int64 v11; // r15
  int v12; // eax
  unsigned __int16 v13; // r12
  unsigned __int16 v14; // r13
  unsigned __int8 v15; // si
  unsigned int v16; // ebx
  signed int v17; // er14
  unsigned int v18; // ecx
  int v19; // eax
  unsigned int *v20; // rbx
  __int64 v21; // r9
  unsigned __int64 v22; // rdi
  __int64 v23; // rax
  __int64 v25; // rcx
  unsigned __int16 v26; // r9
  unsigned __int64 v27; // rcx
  unsigned __int16 v28; // r10
  signed __int16 v29; // dx
  int v30; // esi
  signed __int16 v31; // si
  unsigned __int16 v32; // di
  unsigned int v33; // eax
  __int64 v34; // rax
  __int64 v35; // rax
  unsigned __int64 v36; // rax
  __int64 v37; // rdx
  __int64 v38; // r13
  __int16 v39; // r8
  char v40; // r10
  int v41; // edx
  __int64 v42; // rcx
  unsigned int v43; // eax
  signed __int64 v44; // r9
  __int64 v45; // rcx
  unsigned int v46; // eax
  int v47; // er13
  unsigned __int16 v48; // dx
  int v49; // er8
  unsigned __int16 v50; // r8
  __int16 v51; // ax
  unsigned __int16 v52; // r13
  int v53; // eax
  __int64 v54; // [rsp+40h] [rbp-50h]
  unsigned int v55; // [rsp+4Ch] [rbp-44h]
  bool v56; // [rsp+53h] [rbp-3Dh]
  int v57; // [rsp+54h] [rbp-3Ch]
  int v58; // [rsp+54h] [rbp-3Ch]

  v10 = -1;
  if ( a1 )
  {
    v11 = a1;
    if ( *(_WORD *)a1 == 4098 )
    {
      v12 = *(_DWORD *)(a1 + 8);
      if ( v12 )
      {
        v13 = a3;
        if ( a3 <= 3u )
        {
          if ( a7 )
          {
            v14 = a2;
            if ( a9 )
            {
              if ( a10 )
              {
                v15 = a4;
                *a9 = 0;
                v16 = (unsigned int)*a7 >> 16;
                v17 = 0;
                if ( !a3 )
                  v17 = (unsigned __int16)*a7;
                v18 = a5;
                if ( a3 == 2 )
                  v17 = (unsigned int)*a7 >> 16;
                v57 = (unsigned __int16)*a7;
                if ( a3 != 2 )
                  v16 = (unsigned __int16)*a7;
                v55 = v16;
                if ( (unsigned int)(a5 - 31) <= 0xA2 )
                  v18 = (unsigned __int8)(a5 - 1) % 3u | 0xCC;
                v19 = v12 - 1;
                if ( v19 )
                {
                  v20 = (unsigned int *)(v11 + 40);
                  while ( v18 < *v20 || v18 > v20[1] )
                  {
                    v20 += 7;
                    if ( !--v19 )
                      goto LABEL_21;
                  }
                }
                else
                {
LABEL_21:
                  v20 = (unsigned int *)(v11 + 12);
                }
                v21 = v20[2];
                v22 = v11 + v21;
                if ( v11 + v21 < v11 || (signed __int64)v20[2] >= 16385 )
                  sub_9CD8();
                if ( *(_WORD *)v22 == 12289 )
                {
                  LOWORD(v23) = (unsigned int)v15 >= *(_DWORD *)(v22 + 4) ? *(_WORD *)(v22 + 2) : *(unsigned __int8 *)(v22 + v15 + 8);
                  v25 = v20[3];
                  if ( *(_WORD *)(v11 + v25) == 16385 )
                  {
                    v26 = a8;
                    v27 = v11 + v25;
                    v28 = -1;
                    v29 = -16385;
                    if ( *(_WORD *)(v27 + 2) <= v14
                      || (v23 = (unsigned __int16)v23, *(_DWORD *)(v27 + 4) <= (unsigned int)(unsigned __int16)v23)
                      || (v28 = *(_WORD *)(v11 + *(unsigned int *)(v27 + 4 * v23 + 8) + 2i64 * v14),
                          v29 = v28 - 0x4000,
                          (unsigned __int16)(v28 - 0x4000) >= 0x4000u) )
                    {
                      v30 = v57;
                      if ( v55 )
                      {
                        v17 = 0;
                        v30 = 0;
                        if ( v13 != 3 )
                        {
                          v31 = v29;
                          v32 = v28;
                          v33 = sub_29A0D(v11, (__int64)v20, v55, a8, a9, a10);
                          v29 = v31;
                          v28 = v32;
                          v26 = a8;
                          v10 = v33;
                          v17 = 0;
                          v30 = 0;
                          if ( v33 )
                            goto LABEL_44;
                        }
                      }
                      if ( v29 >= 0 )
                      {
                        v10 = sub_29A6F(v11, (__int64)v20, v28, v26, a9, a10);
LABEL_44:
                        *a7 = v30 | (v17 << 16);
                        return v10;
                      }
                      v10 = 0;
                      if ( v28 > 0xFFFDu )
                        goto LABEL_44;
                      v34 = *a9;
                      if ( (unsigned __int16)v34 < v26 )
                      {
                        *a9 = v34 + 1;
                        *(_WORD *)(a10 + 2 * v34) = v28;
                        goto LABEL_44;
                      }
LABEL_62:
                      v10 = -1;
                      goto LABEL_44;
                    }
                    v35 = v20[4];
                    if ( !v20[4] )
                    {
                      sub_9CD8();
                      goto LABEL_42;
                    }
                    v30 = v57;
                    if ( *(_WORD *)(v11 + v35) != 20481 )
                    {
                      sub_9CD8();
                      goto LABEL_62;
                    }
                    v36 = v11 + v35;
                    v37 = v28 & 0x3FFF;
                    if ( (unsigned __int16)v37 >= *(_WORD *)(v36 + 2) )
                    {
                      sub_9CD8();
                      goto LABEL_62;
                    }
                    v38 = *(unsigned int *)(v36 + 4 * v37 + 4);
                    v56 = (a6 & 1) == 0 && v13 != 1;
                    if ( !v55 )
                    {
                      v10 = sub_29B58(v11, (__int64)v20, *(_WORD *)(v11 + v38), a8, a9, a10);
                      if ( v56 )
                        v57 = *(unsigned __int16 *)(v11 + v38 + 2);
                      if ( !v10 )
                      {
                        if ( v13 == 3 || (v10 = 0, !v56) )
                          v10 = sub_29A0D(v11, (__int64)v20, *(_WORD *)(v11 + v38 + 2), a8, a9, a10);
                      }
                      goto LABEL_43;
                    }
                    v39 = *(_WORD *)(v11 + v38 + 4);
                    v40 = byte_96D20;
                    if ( !*(_WORD *)(v11 + v38 + 4) )
                    {
                      v10 = 0;
                      v30 = v57;
LABEL_90:
                      if ( v40 )
                      {
                        if ( v30 == 0 && v13 == 3 )
                          v17 = 0x8000;
                        if ( v30 == 0 && v13 == 3 )
                          v30 = 0;
                      }
                      else
                      {
                        if ( v13 != 3 )
                          v10 = sub_29A0D(v11, (__int64)v20, v55, a8, a9, a10);
                        if ( !v10 )
                          v10 = sub_29B58(v11, (__int64)v20, *(_WORD *)(v11 + v38), a8, a9, a10);
                        v17 = 0;
                        if ( v56 )
                          v30 = *(unsigned __int16 *)(v11 + v38 + 2);
                        else
                          v30 = 0;
                      }
                      goto LABEL_44;
                    }
                    v41 = *(unsigned __int16 *)(v11 + v38 + 6);
                    if ( v41 == 2 )
                    {
                      v54 = v38;
                      v44 = v11 + v38 + 14;
                      v10 = 0;
                      v45 = 0i64;
                      while ( 1 )
                      {
                        v46 = *(unsigned __int16 *)(v44 + 8 * v45 - 6);
                        if ( v55 < v46 )
                        {
LABEL_74:
                          v30 = v57;
                          goto LABEL_90;
                        }
                        if ( v46 + *(unsigned __int8 *)(v44 + 8 * v45 - 4) >= v55 )
                          break;
                        if ( v39 == (_WORD)++v45 )
                          goto LABEL_74;
                      }
                      v47 = *(unsigned __int8 *)(v11 + v38 + 8 * v45 + 11) * (v55 - v46);
                      v48 = *(_WORD *)(v11 + v54 + 8 * v45 + 12);
                      LOWORD(v49) = 0;
                      if ( v48 < 0xFFFEu )
                        v49 = *(unsigned __int8 *)(v11 + v54 + 8 * v45 + 11) * (v55 - v46);
                      v50 = v48 + v49;
                      v51 = *(_WORD *)(v11 + v54 + 8 * v45 + 14);
                      v52 = v51 + v47;
                      if ( !v51 )
                        v52 = 0;
                      v10 = sub_29B58(v11, (__int64)v20, v50, a8, a9, a10);
                      v53 = v52;
                      if ( !v56 )
                        v53 = 0;
                      v58 = v53;
                      if ( v10 == dword_96D24 && (v13 == 3 || v13 == 1 || a6 & 1) )
                        v10 = sub_29A0D(v11, (__int64)v20, v52, a8, a9, a10);
                      v30 = v58;
                      v38 = v54;
                      v40 = 1;
                      goto LABEL_90;
                    }
                    if ( (_WORD)v41 == 1 )
                    {
                      v42 = 0i64;
                      while ( 1 )
                      {
                        v43 = *(unsigned __int16 *)(v11 + v38 + 10 + 4 * v42 - 2);
                        if ( v55 <= v43 )
                          break;
                        if ( v39 == (_WORD)++v42 )
                        {
                          v10 = 0;
                          v30 = v57;
                          goto LABEL_90;
                        }
                      }
                      v10 = 0;
                      v30 = v57;
                      if ( v55 == v43 )
                      {
                        v10 = sub_29B58(v11, (__int64)v20, *(_WORD *)(v11 + v38 + 4 * v42 + 10), a8, a9, a10);
                        v40 = 1;
                        v30 = 0;
                      }
                      goto LABEL_90;
                    }
                  }
                }
                sub_9CD8();
LABEL_42:
                v10 = -1;
LABEL_43:
                v30 = v57;
                goto LABEL_44;
              }
            }
          }
        }
      }
    }
    sub_9CD8();
  }
  return v10;
}
// 96D20: using guessed type char byte_96D20;
// 96D24: using guessed type int dword_96D24;

//----- (0000000000029A0D) ----------------------------------------------------
signed __int64 __fastcall sub_29A0D(__int64 a1, __int64 a2, __int16 a3, unsigned __int16 a4, _WORD *a5, __int64 a6)
{
  __int64 v6; // r11
  signed __int64 result; // rax
  __int64 v8; // r11
  unsigned __int16 v9; // r8

  v6 = *(unsigned int *)(a2 + 20);
  result = 0i64;
  if ( *(_DWORD *)(a2 + 20) )
  {
    if ( *(_WORD *)(a1 + v6) == 24577 )
    {
      if ( a3 )
      {
        v8 = a1 + v6;
        v9 = a3 - 1;
        if ( v9 < *(_WORD *)(v8 + 2) )
          result = sub_29B58(a1, a2, *(_WORD *)(v8 + 2i64 * v9 + 4), a4, a5, a6);
      }
    }
    else
    {
      sub_9CD8();
      result = 0xFFFFFFFFi64;
    }
  }
  return result;
}

//----- (0000000000029A6F) ----------------------------------------------------
signed __int64 __fastcall sub_29A6F(__int64 a1, __int64 a2, unsigned __int16 a3, unsigned __int16 a4, _WORD *a5, __int64 a6)
{
  __int64 v6; // rsi
  __int64 v7; // rax
  unsigned __int16 v8; // dx
  __int64 v9; // r8
  unsigned int v10; // edi
  __int64 v11; // r14
  unsigned __int16 v12; // r9
  int v13; // eax
  signed __int64 result; // rax
  __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 v17; // rcx

  v6 = *(unsigned int *)(a2 + 24);
  if ( !*(_DWORD *)(a2 + 24) )
    goto LABEL_16;
  if ( *(_WORD *)(a1 + v6) != 28673 )
  {
    sub_9CD8();
    return 0xFFFFFFFFi64;
  }
  v7 = a1 + v6;
  v8 = a3 & 0x3FFF;
  if ( (unsigned __int16)(a3 & 0x3FFF) < *(_WORD *)(a1 + v6 + 2) )
  {
    v9 = *(unsigned __int16 *)(v7 + 2i64 * v8 + 4);
    v10 = (*(unsigned __int16 *)(v7 + 2i64 * v8 + 6) - (unsigned int)v9) >> 1;
    v11 = (unsigned __int16)*a5;
    v12 = a4 - v11;
    v13 = (unsigned __int16)v10 <= (unsigned int)v12;
    LOBYTE(v13) = (unsigned __int16)v10 > (unsigned int)v12;
    if ( (unsigned __int16)v10 <= (unsigned int)v12 )
      v12 = v10;
    result = (unsigned int)-v13;
    *a5 = v11 + v12;
    if ( v12 )
    {
      v15 = v9 + v6 + a1;
      v16 = 0i64;
      do
      {
        *(_WORD *)(a6 + 2 * v11 + 2 * v16) = *(_WORD *)(v15 + 2 * v16);
        ++v16;
      }
      while ( v12 != (_WORD)v16 );
    }
  }
  else
  {
LABEL_16:
    result = 0i64;
    if ( a3 <= 0xFFFDu )
    {
      v17 = (unsigned __int16)*a5;
      result = 0xFFFFFFFFi64;
      if ( (unsigned __int16)v17 < a4 )
      {
        *a5 = v17 + 1;
        *(_WORD *)(a6 + 2 * v17) = a3;
        result = 0i64;
      }
    }
  }
  return result;
}

//----- (0000000000029B58) ----------------------------------------------------
signed __int64 __fastcall sub_29B58(__int64 a1, __int64 a2, unsigned __int16 a3, unsigned __int16 a4, _WORD *a5, __int64 a6)
{
  signed __int64 result; // rax
  __int64 v7; // rdx

  if ( (unsigned __int16)(a3 + 0x4000) > 0xBFFFu )
    return sub_29A6F(a1, a2, a3, a4, a5, a6);
  result = 0i64;
  if ( a3 <= 0xFFFDu )
  {
    v7 = (unsigned __int16)*a5;
    result = 0xFFFFFFFFi64;
    if ( (unsigned __int16)v7 < a4 )
    {
      *a5 = v7 + 1;
      *(_WORD *)(a6 + 2 * v7) = a3;
      result = 0i64;
    }
  }
  return result;
}

//----- (0000000000029BA0) ----------------------------------------------------
__int64 sub_29BA0()
{
  return sub_24136(2060i64);
}

//----- (0000000000029BAF) ----------------------------------------------------
__int64 sub_29BAF()
{
  return (*(__int64 (**)(void))(qword_96CD8 + 72))();
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000029BBF) ----------------------------------------------------
void __fastcall sub_29BBF(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r10
  int v4; // er9
  unsigned int v5; // eax
  __int64 v6; // r11
  unsigned int v7; // er10
  int v8; // er14
  unsigned int v9; // ebx
  __int64 v10; // rdi
  bool v11; // cf
  bool v12; // zf
  int v13; // eax
  __int64 v14; // rsi

  v3 = 0i64;
  while ( *(_WORD *)(a1 + 2 * v3) )
  {
    if ( (unsigned __int64)++v3 >= 0x402 )
    {
      LODWORD(v3) = 0;
      goto LABEL_6;
    }
  }
  if ( (unsigned int)v3 > 0x3FF )
    return;
LABEL_6:
  if ( (_WORD)a3 )
  {
    a3 = (unsigned __int16)a3;
    v4 = v3 - 1;
    v5 = *(_DWORD *)(a1 + 2052);
    v6 = (signed int)v3 - 1;
    v7 = v3 - 2;
    v8 = 0;
    do
    {
      if ( v8 + v4 >= 0 )
      {
        v9 = v7;
        v10 = v6;
        if ( v8 + v4 >= v5 )
        {
          do
          {
            *(_WORD *)(a1 + 2 * v10 + 2) = *(_WORD *)(a1 + 2 * v10);
            if ( v10 <= 0 )
              break;
            --v10;
            v11 = v5 < v9;
            v12 = v5 == v9--;
          }
          while ( v11 || v12 );
        }
      }
      ++v8;
      ++v6;
      ++v7;
    }
    while ( v8 != (_DWORD)a3 );
    v13 = *(_DWORD *)(a1 + 2052);
    v14 = 0i64;
    do
    {
      *(_WORD *)(a1 + 2i64 * (unsigned int)(v13 + v14)) = *(_WORD *)(a2 + 2 * v14);
      ++v14;
    }
    while ( a3 != v14 );
    *(_DWORD *)(a1 + 2052) = v14 + v13;
  }
}

//----- (0000000000029C71) ----------------------------------------------------
void __fastcall sub_29C71(unsigned __int64 a1, unsigned __int16 a2, unsigned __int8 a3, int a4, char *a5, unsigned __int64 a6, unsigned __int16 *a7)
{
  int v7; // ebx
  unsigned __int8 v8; // r14
  unsigned __int16 v9; // r15
  unsigned __int64 v10; // rsi
  __int64 v11; // [rsp+20h] [rbp-70h]
  __int64 v12; // [rsp+38h] [rbp-58h]
  int v13; // [rsp+54h] [rbp-3Ch]

  if ( a5 && a7 )
  {
    v7 = a4;
    v8 = a3;
    v9 = a2;
    v10 = a1;
    sub_F180(a5, 0, a6);
    v13 = 0;
    LOWORD(v12) = a6;
    LODWORD(v11) = v7;
    if ( (unsigned int)sub_29405(v10, v9, 0, v8, v11, 0, &v13, v12, a7, (__int64)a5) )
      sub_1A11E();
  }
  else
  {
    sub_1A11E();
  }
}

//----- (0000000000029D3C) ----------------------------------------------------
char __fastcall sub_29D3C(unsigned __int16 a1)
{
  char result; // al
  signed __int64 v2; // rdx

  result = 1;
  if ( a1 > 0x1Fu || (v2 = 4160830234i64, !_bittest64(&v2, a1)) )
  {
    if ( a1 != 127 )
      result = 0;
  }
  return result;
}

//----- (0000000000029D63) ----------------------------------------------------
void __usercall sub_29D63(__int64 a1@<rax>, unsigned __int64 a2@<rdx>, __int64 a3@<rcx>, unsigned __int16 a4@<r8w>, unsigned __int8 a5@<r9b>, int a6)
{
  unsigned __int8 v6; // r14
  unsigned __int16 v7; // r15
  unsigned __int64 v8; // rbx
  __int64 v9; // rsi
  __int64 v10; // r8
  int v11; // er9
  unsigned int v12; // er8
  int v13; // edx
  unsigned int v14; // ebx
  signed __int64 v15; // rax
  signed __int64 v16; // rcx
  __int16 v17; // di
  __int64 v18; // rax
  int v19; // ecx
  __int64 v20; // rdx
  unsigned __int64 v21; // rbx
  bool v22; // cf
  bool v23; // zf
  unsigned __int64 v24; // rdx
  unsigned int v25; // ecx
  unsigned __int64 v26; // rdx
  int v27; // edx
  __int64 v28; // [rsp+8h] [rbp-68h]
  __int64 v29; // [rsp+10h] [rbp-60h]
  __int64 v30; // [rsp+20h] [rbp-50h]
  __int64 v31; // [rsp+30h] [rbp-40h]

  v31 = a1;
  if ( a2 )
  {
    v6 = a5;
    v7 = a4;
    v8 = a2;
    v9 = a3;
    sub_F180((char *)&v29, 0, 0x20ui64);
    LODWORD(v28) = a6;
    LOWORD(v30) = 16;
    if ( (unsigned int)sub_29405(
                         v8,
                         v7,
                         0,
                         v6,
                         v28,
                         0,
                         (int *)(v9 + 2056),
                         v30,
                         (unsigned __int16 *)&v31 + 3,
                         (__int64)&v29) )
    {
      sub_1A11E();
    }
    else if ( HIWORD(v31) )
    {
      if ( *((_WORD *)&v29 + HIWORD(v31) - 1) == 8 )
      {
        if ( HIWORD(v31) == 1 )
        {
          v11 = *(_DWORD *)(v9 + 2052);
          if ( v11 )
          {
            v12 = *(_DWORD *)(v9 + 2052);
            if ( v11 != 1 )
            {
              v12 = 1;
              if ( (*(_WORD *)(v9 + 2i64 * (unsigned int)(v11 - 2)) & 0xFC00) == 55296 )
                v12 = ((*(_WORD *)(v9 + 2i64 * (unsigned int)(v11 - 1)) & 0xFC00) == 56320) + 1;
            }
            v13 = v11 - 1;
            v14 = 0;
            do
            {
              v15 = (signed __int64)v13 << 32;
              v16 = v13 + 1i64;
              --v11;
              while ( v16 - 1 <= 1023 )
              {
                if ( v16 >= 1024 )
                {
                  *(_WORD *)(v9 + (v15 >> 31)) = 0;
                  break;
                }
                v17 = *(_WORD *)(v9 + 2 * v16);
                *(_WORD *)(v9 + 2 * v16 - 2) = v17;
                v15 += 0x100000000i64;
                ++v16;
                if ( !v17 )
                  break;
              }
              ++v14;
              --v13;
            }
            while ( v14 < v12 );
            *(_DWORD *)(v9 + 2052) = v11;
          }
        }
      }
      else if ( HIWORD(v31) == 1 )
      {
        v18 = *(unsigned int *)(v9 + 2052);
        if ( (unsigned int)v18 <= 0x3FF )
        {
          switch ( (_WORD)v29 )
          {
            case 1:
            case 3:
            case 4:
            case 9:
            case 0xB:
            case 0xC:
            case 0xD:
            case 0x10:
            case 0x1B:
              return;
            case 2:
            case 5:
            case 6:
            case 7:
            case 8:
            case 0xA:
            case 0xE:
            case 0xF:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1A:
              goto LABEL_32;
            case 0x1C:
              if ( (_DWORD)v18 )
              {
                v19 = *(_DWORD *)(v9 + 2052);
                if ( (_DWORD)v18 != 1 )
                {
                  v19 = 1;
                  if ( (*(_WORD *)(v9 + 2i64 * (unsigned int)(v18 - 2)) & 0xFC00) == 55296 )
                    v19 = ((*(_WORD *)(v9 + 2i64 * (unsigned int)(v18 - 1)) & 0xFC00) == 56320) + 1;
                }
                *(_DWORD *)(v9 + 2052) = v18 - v19;
              }
              return;
            case 0x1D:
              v20 = 0i64;
              break;
            case 0x1E:
              *(_DWORD *)(v9 + 2052) = 0;
              return;
            case 0x1F:
              *(_DWORD *)(v9 + 2052) = sub_2A140((__int16 *)v9, 0x400u);
              return;
            default:
              if ( (_WORD)v29 != 128 )
              {
LABEL_32:
                LOWORD(v10) = 1;
                sub_29BBF(v9, (__int64)&v29, v10);
              }
              return;
          }
          while ( *(_WORD *)(v9 + 2 * v20) )
          {
            if ( (unsigned __int64)++v20 >= 0x402 )
              return;
          }
          v21 = (unsigned int)(2 * v20);
          v22 = (unsigned int)v20 < 0x400;
          v23 = (_DWORD)v20 == 1024;
          v24 = 2048i64;
          if ( v22 || v23 )
            v24 = v21;
          if ( 2 * v18 < v24 )
          {
            v25 = 2;
            v26 = 0i64;
            while ( *(_WORD *)(v9 + 2 * v26) )
            {
              ++v26;
              v25 += 2;
              if ( v26 >= 0x402 )
              {
                v25 = 2;
                goto LABEL_48;
              }
            }
            if ( (unsigned int)v26 > 0x400 )
              v25 = 2050;
LABEL_48:
            v27 = 1;
            if ( (unsigned int)v18 <= v25 && (*(_WORD *)(v9 + 2 * v18) & 0xFC00) == 55296 )
              v27 = ((*(_WORD *)(v9 + 2i64 * (unsigned int)(v18 + 1)) & 0xFC00) == 56320) + 1;
            *(_DWORD *)(v9 + 2052) = v18 + v27;
          }
        }
      }
    }
  }
  else
  {
    sub_1A11E();
  }
}

//----- (000000000002A128) ----------------------------------------------------
__int64 __fastcall sub_2A128(__int16 *a1)
{
  return sub_2A140(a1, 0x400u);
}

//----- (000000000002A137) ----------------------------------------------------
__int64 __fastcall sub_2A137(__int64 a1)
{
  return a1;
}

//----- (000000000002A140) ----------------------------------------------------
__int64 __fastcall sub_2A140(__int16 *a1, unsigned int a2)
{
  __int64 result; // rax
  __int16 v3; // r10
  int v4; // er8
  int v5; // er9

  result = 0i64;
  if ( a2 )
  {
    v3 = *a1;
    if ( *a1 )
    {
      v4 = 0;
      LODWORD(result) = 0;
      do
      {
        v5 = v4 + 1;
        if ( v4 + 1 < a2 && (v3 & 0xFC00) == 55296 && (a1[v5] & 0xFC00) == 56320 )
          v5 = v4 + 2;
        result = (unsigned int)(result + 1);
        if ( v5 >= a2 )
          break;
        v3 = a1[v5];
        v4 = v5;
      }
      while ( v3 );
    }
  }
  return result;
}

//----- (000000000002A1AF) ----------------------------------------------------
__int64 __fastcall sub_2A1AF(__int64 a1)
{
  return sub_2A140((__int16 *)a1, *(_DWORD *)(a1 + 2052));
}

//----- (000000000002A1BF) ----------------------------------------------------
__int64 __fastcall sub_2A1BF(char *a1)
{
  return sub_F180(a1, 0, 0x80Cui64);
}

//----- (000000000002A1D1) ----------------------------------------------------
__int64 __fastcall sub_2A1D1(_BYTE *a1, _BYTE *a2, __int16 a3)
{
  __int16 v3; // si
  __int64 v4; // rdi
  _BYTE *v5; // rbx
  __int16 v6; // ax

  v3 = a3;
  v4 = (__int64)a2;
  v5 = a1;
  v6 = sub_189FE(a2);
  return sub_2A205(v5, v3, v4, v6);
}

//----- (000000000002A205) ----------------------------------------------------
__int64 __fastcall sub_2A205(_BYTE *a1, __int16 a2, __int64 a3, __int16 a4)
{
  __int16 v4; // bx
  __int64 v5; // r14
  _BYTE *v6; // rsi
  int v7; // edi
  __int64 result; // rax
  int v9; // edi

  v4 = a4;
  v5 = a3;
  v6 = a1;
  v7 = a2;
  result = sub_189FE(a1);
  v9 = v7 - result;
  if ( v9 >= 3 )
  {
    if ( v9 <= v4 + 1 )
    {
      sub_18C7A(v6, v5, v9 - 2);
      result = (__int64)sub_18CC7(v6, (char *)&dword_46AB4);
    }
    else
    {
      result = (__int64)sub_18C7A(v6, v5, v4);
    }
  }
  return result;
}
// 46AB4: using guessed type int dword_46AB4;

//----- (000000000002A281) ----------------------------------------------------
signed __int64 __fastcall sub_2A281(_QWORD *a1, __int64 *a2, const void *a3, __int64 a4, char a5)
{
  __int64 v5; // r15
  const void *v6; // rsi
  __int64 *v7; // rdi
  _QWORD *v8; // r14
  __int64 v9; // rax
  unsigned int v10; // ebx
  __int64 v11; // rax
  _QWORD *v12; // rcx
  signed __int64 v13; // rsi
  __int64 v15; // rbx
  char v16; // al
  unsigned int v17; // edi
  char *v18; // rsi
  __int64 v19; // [rsp+28h] [rbp-68h]
  __int64 v20; // [rsp+30h] [rbp-60h]
  char v21; // [rsp+38h] [rbp-58h]
  int v22; // [rsp+3Ch] [rbp-54h]
  __int64 v23; // [rsp+40h] [rbp-50h]
  __int64 v24; // [rsp+48h] [rbp-48h]
  _QWORD *v25; // [rsp+50h] [rbp-40h]
  int v26; // [rsp+5Ch] [rbp-34h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v25 = 0i64;
  v9 = *a2;
  v24 = a2[1];
  v23 = v9;
  if ( sub_26E4B((__int64 *)&v25, (__int64)a2)
    || (v10 = 4 * *((_DWORD *)v7 + 2) * *((_DWORD *)v7 + 3),
        v11 = sub_24136(v10),
        v12 = v25,
        v25[2] = v11,
        v12[3] = v10,
        v12[4] = v7[1],
        sub_27402(v12, &v23)) )
  {
    sub_1A11E();
    v13 = 1i64;
  }
  else
  {
    v15 = sub_24136(168i64);
    qmemcpy((void *)v15, v6, 0x48ui64);
    *(_QWORD *)(v15 + 72) = sub_29BA0();
    *(_QWORD *)(v15 + 80) = sub_29BA0();
    *(_QWORD *)(v15 + 88) = sub_29BA0();
    *(_QWORD *)(v15 + 96) = *(_QWORD *)(v15 + 72);
    *(_QWORD *)(v15 + 104) = v5;
    *(_BYTE *)(v15 + 145) = 1;
    v16 = sub_3FBF3();
    sub_26AF2(
      &v21,
      2 - ((unsigned __int8)v16 < 1u),
      (2 - ((unsigned __int8)v16 < 1u)) | 16 * (2 - ((unsigned __int8)v16 < 1u)));
    v17 = 4 * *(_DWORD *)&v21 * v22;
    v18 = (char *)sub_24136(v17);
    sub_F180(v18, 100, v17);
    *(_QWORD *)(v15 + 112) = v18;
    *(_QWORD *)(v15 + 120) = *(_QWORD *)&v21;
    if ( a5 )
      sub_26E30(&v26, 255, 255, 255, 0);
    else
      sub_26E30(&v26, 100, 100, 100, 0);
    v19 = 0i64;
    v20 = *(_QWORD *)(v15 + 120);
    sub_2445C(v26, (__int64)v18, (unsigned int *)(v15 + 120), (unsigned int *)&v19);
    v13 = 0i64;
    sub_27643(v25, 0i64, (__int64)sub_2A45E, 0i64, v15);
    sub_2A4D4(v25, 0);
    *v8 = v25;
  }
  return v13;
}

//----- (000000000002A45E) ----------------------------------------------------
__int64 __fastcall sub_2A45E(__int64 a1)
{
  __int64 v1; // rsi
  _QWORD *v2; // rdi
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rcx

  v1 = a1;
  sub_1A11E();
  sub_2B2A2(v1, 0, 0);
  v2 = *(_QWORD **)(v1 + 160);
  v3 = v2[9];
  sub_29BAF();
  v4 = v2[10];
  sub_29BAF();
  v5 = v2[11];
  sub_29BAF();
  (*(void (__fastcall **)(_QWORD *))(qword_96CD8 + 72))(v2);
  *(_QWORD *)(v1 + 160) = 0i64;
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000002A4D4) ----------------------------------------------------
void __fastcall sub_2A4D4(_QWORD *a1, char a2)
{
  __int64 v2; // rdi
  __int64 v3; // r12
  __int64 v4; // rax
  unsigned int v5; // er15
  int v6; // esi
  __int64 *v7; // rsi
  bool v8; // zf
  __int64 v9; // r15
  __int64 v10; // rax
  __int64 v11; // rdi
  int v12; // esi
  __int64 v13; // rdi
  __int64 v14; // rbx
  __int64 v15; // r8
  const char *v16; // rdx
  __int64 v17; // r9
  char v18; // al
  __int64 v19; // rax
  unsigned int v20; // er14
  unsigned int v21; // er13
  int v22; // esi
  bool v23; // r12
  int v24; // eax
  unsigned int v25; // edi
  int v26; // er14
  __int64 v27; // rsi
  __int64 v28; // r12
  int v29; // eax
  char v30; // al
  __int64 v31; // rsi
  unsigned int v32; // eax
  __int64 v33; // rbx
  int v34; // edi
  _QWORD *v35; // rcx
  signed __int64 v36; // rax
  __int64 v37; // [rsp+48h] [rbp-C8h]
  __int64 v38; // [rsp+50h] [rbp-C0h]
  char v39; // [rsp+58h] [rbp-B8h]
  int v40; // [rsp+5Ch] [rbp-B4h]
  __int64 v41; // [rsp+60h] [rbp-B0h]
  __int64 v42; // [rsp+68h] [rbp-A8h]
  int v43; // [rsp+70h] [rbp-A0h]
  __int64 v44; // [rsp+78h] [rbp-98h]
  __int64 v45; // [rsp+80h] [rbp-90h]
  __int64 v46; // [rsp+88h] [rbp-88h]
  __int64 v47; // [rsp+98h] [rbp-78h]
  __int64 v48; // [rsp+A0h] [rbp-70h]
  __int64 v49; // [rsp+A8h] [rbp-68h]
  __int64 v50; // [rsp+B0h] [rbp-60h]
  __int64 v51; // [rsp+B8h] [rbp-58h]
  __int64 v52; // [rsp+C0h] [rbp-50h]
  int v53; // [rsp+C8h] [rbp-48h]
  int v54; // [rsp+CCh] [rbp-44h]
  char v55; // [rsp+D7h] [rbp-39h]

  v55 = a2;
  v2 = (__int64)a1;
  v3 = a1[20];
  v4 = *(_QWORD *)((char *)a1 + 44);
  v48 = *(_QWORD *)((char *)a1 + 52);
  v47 = 0i64;
  v5 = sub_2A128(*(__int16 **)(v3 + 96));
  v37 = 0i64;
  v38 = *(_QWORD *)(v2 + 32);
  sub_2445C(-1, *(_QWORD *)(v2 + 16), (unsigned int *)(v2 + 32), (unsigned int *)&v37);
  if ( !v5 && *(_QWORD *)(v3 + 48) )
  {
    v52 = v48;
    v51 = v47;
    sub_3FBF3();
    v53 = -20;
    v54 = (*(_DWORD *)(v2 + 52) - *(_DWORD *)(v3 + 56)) / 2;
    sub_244D1(*(_QWORD *)(v2 + 16), v2 + 52, (int *)&v51, *(_QWORD *)(v3 + 48), (int *)(v3 + 56), &v53, 0, v2 + 176);
  }
  sub_27CFB((__int64 **)&v51);
  LOBYTE(v45) = 0;
  (*(void (__fastcall **)(__int64 *))(v51 + 40))(&v45);
  if ( (_BYTE)v45 && *(_BYTE *)(*(_QWORD *)(v2 + 160) + 144i64) && !*(_BYTE *)(v3 + 149) )
  {
    v52 = v48;
    v51 = v47;
    HIDWORD(v52) = *(_DWORD *)(v3 + 44) + HIDWORD(v48);
    v6 = *(_DWORD *)(v2 + 56);
    v53 = v6 - 16 * (sub_3FBF3() != 0) - 16;
    v54 = (*(_DWORD *)(v2 + 52) - *(_DWORD *)(v3 + 40)) / 2;
    if ( !sub_3FBF3() )
      ++v54;
    if ( sub_244D1(
           *(_QWORD *)(v2 + 16),
           v2 + 52,
           (int *)&v51,
           *(_QWORD *)(v3 + 32),
           (int *)(v3 + 40),
           &v53,
           0,
           v2 + 176) )
    {
      sub_1A11E();
    }
  }
  sub_26AE1(&v53, 0, 0);
  if ( *(_BYTE *)(v3 + 146) )
  {
    LODWORD(v52) = v48;
    v51 = v47;
    HIDWORD(v52) = sub_2B4F7(v2, v5, *(_BYTE *)(v3 + 147));
    sub_244D1(*(_QWORD *)(v2 + 16), v2 + 52, (int *)&v51, *(_QWORD *)(v3 + 16), (int *)(v3 + 24), &v53, 0, v2 + 176);
  }
  v7 = (__int64 *)(v2 + 44);
  sub_26AE1(&v53, 0, 0);
  v42 = v3;
  v8 = *(_BYTE *)(v3 + 147) == 0;
  v9 = *(_QWORD *)(v2 + 160);
  v50 = v2;
  if ( v8 )
  {
    v19 = *v7;
    v52 = *(_QWORD *)(v2 + 52);
    v51 = 0i64;
    v20 = sub_2A128(*(__int16 **)(v9 + 96));
    v21 = 0;
    sub_26AE1(&v45, 0, 0);
    v22 = 0;
    v23 = sub_3FBF3() != 0;
    v44 = *(unsigned int *)(v9 + 12);
    v24 = *(_DWORD *)(v2 + 52);
    v25 = v20;
    HIDWORD(v45) = (v24 - *(_DWORD *)(v9 + 8)) / 2;
    HIDWORD(v45) = HIDWORD(v45) - ((unsigned __int8)sub_3FBF3() < 1u) + 2;
    if ( v20 )
    {
      LOBYTE(v22) = v23;
      v26 = v44 + 2 * v22 + 2;
      v27 = v50 + 52;
      v28 = v50 + 176;
      v29 = v45;
      do
      {
        if ( v29 > *(_DWORD *)(v50 + 56) )
          break;
        v30 = 0;
        if ( !*(_BYTE *)(*(_QWORD *)(v50 + 160) + 145i64) )
          v30 = 120;
        if ( sub_244D1(*(_QWORD *)(v50 + 16), v27, (int *)&v51, *(_QWORD *)v9, (int *)(v9 + 8), (int *)&v45, v30, v28) )
          sub_1A11E();
        v29 = v26 + v45;
        LODWORD(v45) = v26 + v45;
        ++v21;
      }
      while ( v21 < v25 );
    }
  }
  else
  {
    v10 = *v7;
    v52 = *(_QWORD *)(v2 + 52);
    v51 = 0i64;
    v11 = *(_QWORD *)(v9 + 96);
    v12 = sub_2A128(*(__int16 **)(v9 + 96));
    v13 = sub_2A137(v11);
    sub_26AE1(&v43, 0, 0);
    if ( v12 )
    {
      v44 = v50 + 52;
      v41 = v50 + 176;
      v14 = 0i64;
      do
      {
        v15 = *(unsigned __int16 *)(v13 + 2 * v14);
        v46 = 0i64;
        v45 = 0i64;
        v16 = "%d_sel.png";
        if ( !*(_BYTE *)(v9 + 146) )
          v16 = "%d.png";
        sub_18905((unsigned __int64)&v45, (__int64)v16, v15);
        v49 = 0i64;
        sub_2BE2F(*(unsigned __int64 **)(v9 + 64), (char *)&v45, &v49, (unsigned __int64 *)&v39, 0i64, 0);
        v17 = v49;
        if ( v49
          || (sub_2BE2F(*(unsigned __int64 **)(v9 + 64), "?.png", &v49, (unsigned __int64 *)&v39, 0i64, 1),
              (v17 = v49) != 0) )
        {
          v18 = 0;
          if ( !*(_BYTE *)(*(_QWORD *)(v50 + 160) + 145i64) )
            v18 = 120;
          sub_244D1(*(_QWORD *)(v50 + 16), v44, (int *)&v51, v17, (int *)&v39, &v43, v18, v41);
          v43 += v40;
          (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v49);
        }
        ++v14;
      }
      while ( v12 != v14 );
    }
  }
  v31 = v42;
  v32 = sub_2A1AF(*(_QWORD *)(v42 + 96));
  v33 = v50;
  v34 = sub_2B4F7(v50, v32, *(_BYTE *)(v31 + 147));
  sub_26AE1(&v53, 0, 0);
  v53 += v34;
  if ( *(_BYTE *)(v31 + 128) )
  {
    if ( !*(_BYTE *)(v31 + 146) )
    {
      v36 = sub_244D1(
              *(_QWORD *)(v33 + 16),
              v33 + 52,
              (int *)&v47,
              *(_QWORD *)(v31 + 112),
              (int *)(v31 + 120),
              &v53,
              0,
              v33 + 176);
      if ( v36 != -9223372036854775794i64 )
      {
        if ( v36 )
          sub_1A11E();
      }
    }
  }
  *(_BYTE *)(v33 + 40) = 1;
  if ( v55 )
  {
    v35 = *(_QWORD **)(v33 + 80);
    if ( v35 )
    {
      if ( sub_3F6AA(v35) )
        sub_1A11E();
    }
  }
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000002AB36) ----------------------------------------------------
void __fastcall sub_2AB36(_QWORD *a1)
{
  *(_BYTE *)(a1[20] + 146i64) = 1;
  sub_2A4D4(a1, 1);
  sub_1A11E();
}

//----- (000000000002AB71) ----------------------------------------------------
__int64 __fastcall sub_2AB71(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax

  v3 = *(_QWORD *)(a1 + 160);
  *(_QWORD *)(v3 + 152) = a2;
  *(_QWORD *)(v3 + 160) = a3;
  return 0i64;
}

//----- (000000000002AB8E) ----------------------------------------------------
__int64 __fastcall sub_2AB8E(__int64 a1, __int16 a2, char a3)
{
  char v3; // bl
  char v4; // al
  _QWORD *v5; // r15
  unsigned __int8 v6; // bl
  __int64 v7; // rsi
  unsigned __int16 v8; // di
  unsigned __int16 v9; // r12
  _QWORD *v10; // r15
  int v11; // er14
  int v12; // edi
  int v13; // ebx
  int v14; // eax
  _QWORD *v15; // rcx
  unsigned __int16 *v16; // rax
  __int64 v17; // rsi
  void (__fastcall *v18)(_QWORD *, _QWORD); // rax
  __int64 *v20[3]; // [rsp+40h] [rbp-60h]
  _QWORD *v21; // [rsp+58h] [rbp-48h]
  unsigned __int16 v22[29]; // [rsp+66h] [rbp-3Ah]

  v3 = (16 * a3 & 0x10) + 2;
  if ( !(a3 & 0x22) )
    v3 = 16 * a3 & 0x10;
  v4 = v3 + 8;
  if ( !(a3 & 0x44) )
    v4 = v3;
  v5 = (_QWORD *)a1;
  v6 = v4 | ((a3 & 0x88) != 0);
  v7 = *(_QWORD *)(a1 + 160);
  v8 = a2 - 28672;
  if ( (unsigned __int16)(a2 - 28672) >= 0xFFu )
    v8 = 255;
  v9 = *((_WORD *)qword_93190 + 2 * v8);
  if ( v6 & 1 )
  {
    sub_F180((char *)v20, 0, 8ui64);
    v22[0] = 0;
    sub_29C71(*(_QWORD *)(v7 + 104), v9, 0, 46, (char *)v20, 8ui64, v22);
    if ( LOWORD(v20[0]) == 97
      || (sub_29C71(*(_QWORD *)(v7 + 104), v9, 0, 45, (char *)v20, 8ui64, v22), LOWORD(v20[0]) == 97)
      || ((_BYTE)v8 == 53 ? (v16 = (unsigned __int16 *)qword_93320) : (_BYTE)v8 != 100 ? (v16 = (unsigned __int16 *)((char *)qword_93190 + 4 * v8)) : (v16 = (unsigned __int16 *)&dword_93264),
          sub_29C71(*(_QWORD *)(v7 + 104), *v16, 0, 47, (char *)v20, 8ui64, v22),
          LOWORD(v20[0]) == 97) )
    {
      *(_BYTE *)(v5[20] + 146i64) = 1;
      sub_2A4D4(v5, 1);
      sub_1A11E();
    }
  }
  else
  {
    if ( *(_BYTE *)(v7 + 146) )
    {
      sub_2AE83(a1);
      *(_BYTE *)(v7 + 146) = 0;
    }
    v21 = v5;
    sub_27CFB(v20);
    LOBYTE(v22[0]) = 0;
    (*((void (__fastcall **)(unsigned __int16 *))v20[0] + 5))(v22);
    if ( LOBYTE(v22[0]) || *(_BYTE *)(v7 + 149) )
      v6 |= 4u;
    v10 = v21;
    v11 = sub_2A128(*(__int16 **)(v7 + 96));
    sub_2AF13((__int64)v10, *(__int16 **)(v7 + 72), *(_QWORD *)(v7 + 104), v8, v9, v6, 0x2Eu);
    sub_2AF13((__int64)v10, *(__int16 **)(v7 + 88), *(_QWORD *)(v7 + 104), v8, v9, v6, 0x2Du);
    sub_2AF13((__int64)v10, *(__int16 **)(v7 + 80), *(_QWORD *)(v7 + 104), v8, v9, v6, 0x2Fu);
    v12 = sub_2A128(*(__int16 **)(v7 + 72));
    v13 = sub_2A128(*(__int16 **)(v7 + 80));
    v14 = sub_2A128(*(__int16 **)(v7 + 88));
    if ( v13 > v12 || v14 > v12 )
    {
      v15 = (_QWORD *)(v7 + 88);
      if ( v13 > v14 )
        v15 = (_QWORD *)(v7 + 80);
      if ( v13 >= v14 )
        v14 = v13;
    }
    else
    {
      v15 = (_QWORD *)(v7 + 72);
      v14 = v12;
    }
    *(_QWORD *)(v7 + 96) = *v15;
    *(_BYTE *)(v7 + 128) = 1;
    if ( v11 != v14 )
      *(_BYTE *)(v7 + 151) = 1;
    v17 = v10[20];
    v18 = *(void (__fastcall **)(_QWORD *, _QWORD))(v17 + 152);
    if ( v18 )
      v18(v10, *(_QWORD *)(v17 + 160));
    *(_BYTE *)(v17 + 151) = 0;
    sub_2A4D4(v10, 1);
  }
  return 0i64;
}
// 93190: using guessed type __int64 qword_93190[26];
// 93264: using guessed type int dword_93264;
// 93320: using guessed type __int64 qword_93320[80];

//----- (000000000002AE83) ----------------------------------------------------
signed __int64 __fastcall sub_2AE83(__int64 a1)
{
  _QWORD *v1; // rsi
  char **v2; // rdi
  __int64 v3; // rdi
  void (__fastcall *v4)(_QWORD *, _QWORD); // rax
  signed __int64 v5; // rdi

  if ( a1 )
  {
    v1 = (_QWORD *)a1;
    v2 = *(char ***)(a1 + 160);
    sub_2A1BF(v2[9]);
    sub_2A1BF(v2[10]);
    sub_2A1BF(v2[11]);
    v3 = v1[20];
    v4 = *(void (__fastcall **)(_QWORD *, _QWORD))(v3 + 152);
    if ( v4 )
      v4(v1, *(_QWORD *)(v3 + 160));
    *(_BYTE *)(v3 + 151) = 0;
    v5 = 0i64;
    sub_2A4D4(v1, 0);
  }
  else
  {
    sub_1A11E();
    v5 = 1i64;
  }
  return v5;
}

//----- (000000000002AF13) ----------------------------------------------------
void __fastcall sub_2AF13(__int64 a1, __int16 *a2, unsigned __int64 a3, unsigned __int16 a4, unsigned __int16 a5, unsigned __int8 a6, unsigned int a7)
{
  unsigned __int64 v7; // rsi
  __int16 *v8; // r13
  __int64 v9; // rbx
  __int64 *v10; // rax
  unsigned __int16 v11; // ax
  signed int v12; // edi
  bool v13; // r14
  __int64 v14; // r12
  unsigned __int64 v15; // rcx
  unsigned __int16 v16; // si
  unsigned __int16 v17; // r15
  bool v18; // al
  unsigned int v19; // er14
  __int64 v20; // r8
  signed int v21; // eax
  unsigned __int16 v22; // [rsp+10h] [rbp-70h]
  unsigned __int16 v23[4]; // [rsp+20h] [rbp-60h]
  __int64 v24; // [rsp+28h] [rbp-58h]
  unsigned __int64 v25; // [rsp+30h] [rbp-50h]
  __int64 v26; // [rsp+38h] [rbp-48h]
  int v27; // [rsp+40h] [rbp-40h]
  unsigned __int16 v28; // [rsp+46h] [rbp-3Ah]

  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( a7 == 47 )
  {
    if ( a4 == 53 )
    {
      v10 = qword_93320;
    }
    else if ( a4 == 100 )
    {
      v10 = (__int64 *)&dword_93264;
    }
    else
    {
      v10 = (__int64 *)((char *)qword_93190 + 4 * a4);
    }
    v11 = *(_WORD *)v10;
  }
  else
  {
    v11 = a5;
  }
  v28 = v11;
  v12 = sub_2A128(a2);
  v13 = (unsigned int)sub_2A1AF((__int64)v8) == v12 && v12 > 0;
  if ( v13 == 1 )
    v27 = *(unsigned __int16 *)(sub_2A137((__int64)v8) + 2i64 * v12 - 2);
  else
    v27 = 0;
  v24 = v9;
  v14 = *(_QWORD *)(v9 + 160);
  v25 = v7;
  v15 = v7;
  v16 = v28;
  sub_29C71(v15, v28, a6, a7, (char *)&v22, v25, (unsigned __int16 *)&v26 + 3);
  v17 = v22;
  if ( sub_29D3C(v22) || !*(_BYTE *)(v14 + 148) )
    goto LABEL_33;
  if ( (_WORD)v27 != 45 || v17 != 45 )
  {
    v18 = 0;
    if ( v17 != 45 && (unsigned __int16)(v17 - 48) >= 0xAu )
      v18 = (unsigned __int16)(v17 - 65) > 0x19u;
    if ( v12 <= 28 && !v18 )
    {
LABEL_33:
      sub_29D63(a7, v25, (__int64)v8, v16, a6, a7);
      if ( v13 && *(_BYTE *)(*(_QWORD *)(v24 + 160) + 148i64) )
      {
        v19 = sub_2A128(v8);
        sub_29C71(8ui64, v16, a6, a7, (char *)v23, 8ui64, (unsigned __int16 *)&v26 + 1);
        if ( (_WORD)v27 != 45 || v23[0] != 8 )
        {
          if ( v23[0] != 8 && v23[0] != 45 && v19 <= 0x18 )
          {
            v21 = 17318416;
            if ( _bittest(&v21, v19) )
            {
              LOWORD(v20) = 1;
              sub_29BBF((__int64)v8, (__int64)&v26 + 4, v20);
            }
          }
        }
        else
        {
          sub_29D63(v23[0], 8ui64, (__int64)v8, v28, a6, a7);
        }
      }
    }
  }
}
// 93190: using guessed type __int64 qword_93190[26];
// 93264: using guessed type int dword_93264;
// 93320: using guessed type __int64 qword_93320[80];

//----- (000000000002B19E) ----------------------------------------------------
__int64 __fastcall sub_2B19E(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  int v3; // er14
  __int16 v4; // bx
  __int64 v5; // rdi
  __int64 v6; // rcx

  if ( *(_BYTE *)(a2 + 9) & 1 )
  {
    v2 = a1;
    v3 = *(_DWORD *)(a2 + 24);
    v4 = *(_WORD *)(*(_QWORD *)(a2 + 16) + 6i64);
    v5 = *(_QWORD *)(a1 + 160);
    v6 = *(_QWORD *)(v5 + 136);
    if ( v6 )
    {
      sub_35A74(v6);
      *(_QWORD *)(v5 + 136) = 0i64;
    }
    *(_BYTE *)(v5 + 128) = 1;
    sub_2AB8E(v2, v4, v3);
    sub_2B20C(v2);
  }
  return 0i64;
}

//----- (000000000002B20C) ----------------------------------------------------
void __fastcall sub_2B20C(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rax

  v1 = *(_QWORD *)(a1 + 160);
  if ( !*(_QWORD *)(v1 + 136) )
  {
    v2 = sub_359AF((__int64)sub_2B63E, a1, 5750000i64, 1u);
    *(_QWORD *)(v1 + 136) = v2;
    if ( !v2 )
      sub_1A11E();
  }
}

//----- (000000000002B269) ----------------------------------------------------
__int64 __fastcall sub_2B269(__int64 a1, char a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 160);
  *(_BYTE *)(result + 149) = a2;
  return result;
}

//----- (000000000002B27C) ----------------------------------------------------
__int64 __fastcall sub_2B27C(__int64 a1, char a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 160);
  *(_BYTE *)(result + 147) = a2;
  return result;
}

//----- (000000000002B28F) ----------------------------------------------------
__int64 __fastcall sub_2B28F(__int64 a1, char a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 160);
  *(_BYTE *)(result + 148) = a2;
  return result;
}

//----- (000000000002B2A2) ----------------------------------------------------
__int64 __fastcall sub_2B2A2(__int64 a1, char a2, char a3)
{
  __int64 v3; // rdi
  char v4; // r14
  char v5; // bl
  _QWORD *v6; // rsi
  __int64 v7; // rcx
  __int64 v8; // r15
  __int64 v9; // rcx

  v3 = *(_QWORD *)(a1 + 160);
  if ( *(_BYTE *)(v3 + 144) != a2 )
  {
    v4 = a3;
    v5 = a2;
    v6 = (_QWORD *)a1;
    if ( a2 )
    {
      if ( v3 )
      {
        v7 = *(_QWORD *)(a1 + 80);
        if ( v7 && !sub_3F3B4(v7, (__int64)v6, 65280, (__int64)sub_2B19E, 0i64) )
          sub_2923D((__int64)v6);
        else
          sub_1A11E();
      }
      sub_2B20C((__int64)v6);
    }
    else
    {
      if ( !*(_QWORD *)(a1 + 80) || (sub_29277(a1), sub_3F58B(v6[10], (__int64)v6)) )
        sub_1A11E();
      v8 = v6[20];
      v9 = *(_QWORD *)(v8 + 136);
      if ( v9 )
      {
        sub_35A74(v9);
        *(_QWORD *)(v8 + 136) = 0i64;
      }
    }
    *(_BYTE *)(v3 + 128) = v5;
    *(_BYTE *)(v3 + 144) = v5;
    sub_2A4D4(v6, v4);
  }
  return 0i64;
}

//----- (000000000002B3C8) ----------------------------------------------------
__int64 __fastcall sub_2B3C8(__int64 a1, char a2)
{
  sub_2B2A2(a1, a2, 1);
  return 0i64;
}

//----- (000000000002B3E0) ----------------------------------------------------
char __fastcall sub_2B3E0(__int64 a1)
{
  return *(_BYTE *)(*(_QWORD *)(a1 + 160) + 144i64);
}

//----- (000000000002B3F3) ----------------------------------------------------
__int64 __fastcall sub_2B3F3(_QWORD *a1, char a2)
{
  *(_BYTE *)(a1[20] + 145i64) = a2;
  sub_2A4D4(a1, 1);
  return 0i64;
}

//----- (000000000002B417) ----------------------------------------------------
__int64 __fastcall sub_2B417(__int64 a1)
{
  return sub_2A137(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 72i64));
}

//----- (000000000002B42C) ----------------------------------------------------
__int64 __fastcall sub_2B42C(__int64 a1)
{
  return sub_2A137(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 80i64));
}

//----- (000000000002B441) ----------------------------------------------------
__int64 __fastcall sub_2B441(__int64 a1)
{
  return sub_2A137(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 88i64));
}

//----- (000000000002B456) ----------------------------------------------------
bool __fastcall sub_2B456(__int64 a1)
{
  __int16 **v1; // rbx
  int v2; // esi
  int v3; // edi

  v1 = *(__int16 ***)(a1 + 160);
  v2 = sub_2A128(v1[9]);
  v3 = v2 + (unsigned __int64)sub_2A128(v1[10]);
  return v3 + (unsigned int)sub_2A128(v1[11]) == 0;
}

//----- (000000000002B497) ----------------------------------------------------
char __fastcall sub_2B497(__int64 a1)
{
  return *(_BYTE *)(*(_QWORD *)(a1 + 160) + 151i64);
}

//----- (000000000002B4AA) ----------------------------------------------------
signed __int64 __fastcall sub_2B4AA(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax

  if ( a1 && a2 )
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 104i64) = a2;
    result = 0i64;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}

//----- (000000000002B4F7) ----------------------------------------------------
__int64 __fastcall sub_2B4F7(__int64 a1, unsigned int a2, char a3)
{
  char v3; // r14
  signed int v4; // ebx
  __int64 v5; // rsi
  __int64 v6; // rdi
  unsigned int v7; // edi
  __int64 v8; // r14
  __int64 v9; // r8
  const char *v10; // rdx
  __int64 v12; // [rsp+30h] [rbp-60h]
  __int64 v13; // [rsp+38h] [rbp-58h]
  __int64 v14; // [rsp+48h] [rbp-48h]
  __int64 v15; // [rsp+50h] [rbp-40h]

  v3 = a3;
  v4 = a2;
  v5 = *(_QWORD *)(a1 + 160);
  v6 = *(_QWORD *)(v5 + 96);
  if ( (unsigned int)sub_2A128(*(__int16 **)(v5 + 96)) >= a2 )
  {
    if ( v3 )
    {
      v14 = sub_2A137(v6);
      if ( v4 <= 0 )
      {
        v7 = 0;
      }
      else
      {
        v8 = 0i64;
        v7 = 0;
        do
        {
          v9 = *(unsigned __int16 *)(v14 + 2 * v8);
          v13 = 0i64;
          v12 = 0i64;
          v10 = "%d_sel.png";
          if ( !*(_BYTE *)(v5 + 146) )
            v10 = "%d.png";
          sub_18905((unsigned __int64)&v12, (__int64)v10, v9);
          v15 = 0i64;
          if ( sub_2BE2F(*(unsigned __int64 **)(v5 + 64), (char *)&v12, 0i64, (unsigned __int64 *)&v15, 0i64, 0) )
            sub_2BE2F(*(unsigned __int64 **)(v5 + 64), "?.png", 0i64, (unsigned __int64 *)&v15, 0i64, 1);
          v7 += HIDWORD(v15);
          ++v8;
        }
        while ( v4 != v8 );
      }
    }
    else
    {
      v7 = v4 * (*(_DWORD *)(v5 + 12) + 2 * (sub_3FBF3() != 0) + 2);
    }
  }
  else
  {
    sub_1A11E();
    v7 = -1;
  }
  return v7;
}

//----- (000000000002B63E) ----------------------------------------------------
void __fastcall sub_2B63E(__int64 a1, _QWORD *a2)
{
  *(_BYTE *)(a2[20] + 128i64) = *(_BYTE *)(a2[20] + 128i64) == 0;
  sub_2A4D4(a2, 1);
}

//----- (000000000002B665) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_2B665(__int64 a1, __int64 a2, _QWORD *a3, unsigned __int64 *a4, _QWORD *a5)
{
  unsigned __int64 *v5; // r15
  _QWORD *v6; // r14
  __int64 v7; // rbx
  __int64 v8; // rsi
  _QWORD *v9; // r12
  __int64 v10; // rdi
  __int64 v11; // rdi
  __int64 v12; // r13
  char v14; // [rsp+30h] [rbp-50h]
  __int64 v15; // [rsp+38h] [rbp-48h]
  unsigned __int64 v16; // [rsp+40h] [rbp-40h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( a3 )
    *a3 = 0i64;
  v9 = a5;
  if ( a4 )
    sub_26AF2(a4, 0, 0);
  if ( a5 )
    *a5 = 0i64;
  v15 = 0i64;
  if ( !qword_951F8 )
    goto LABEL_15;
  if ( (*(__int64 (__fastcall **)(__int64, __int64))(qword_951F8 + 16))(v8, v7) < 0 )
  {
    qword_951F8 = 0i64;
    if ( !qword_95200 )
      goto LABEL_15;
    (*(void (**)(void))(qword_96CD8 + 72))();
    qword_95200 = 0i64;
  }
  v10 = qword_951F8;
  if ( qword_951F8 )
  {
LABEL_12:
    v11 = (*(__int64 (__fastcall **)(__int64, __int64, char *, unsigned __int64 *))(v10 + 24))(
            v8,
            v7,
            (char *)&v16 + 4,
            &v16);
    if ( (_DWORD)v11
      || v6
      && (v11 = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, char *))(qword_951F8 + 32))(v8, v7, &v15, &v14),
          (_DWORD)v11) )
    {
LABEL_13:
      if ( v15 )
        (*(void (**)(void))(qword_96CD8 + 72))();
    }
    else
    {
      if ( v5 )
        *v5 = v16;
      if ( v9 )
        *v9 = 0i64;
      if ( v6 )
        *v6 = v15;
      v15 = 0i64;
    }
    return v11;
  }
LABEL_15:
  if ( (*(__int64 (__fastcall **)(signed __int64, __int64 *, _QWORD, unsigned __int64 *, __int64 *))(qword_96CD8 + 312))(
         2i64,
         qword_92CA0,
         0i64,
         &v16,
         &qword_95200) )
  {
    sub_1A11E();
  }
  else
  {
    if ( v16 )
    {
      v12 = 0i64;
      while ( !(*(__int64 (__fastcall **)(_QWORD, __int64 *, __int64 *))(qword_96CD8 + 152))(
                 *(_QWORD *)(qword_95200 + 8 * v12),
                 qword_92CA0,
                 &qword_951F8) )
      {
        if ( !(*(__int64 (__fastcall **)(__int64, __int64))(qword_951F8 + 16))(v8, v7) )
        {
          v10 = qword_951F8;
          v9 = a5;
          if ( qword_951F8 )
            goto LABEL_12;
          v11 = -9223372036854775805i64;
          goto LABEL_13;
        }
        if ( v16 <= ++v12 )
          break;
      }
    }
    sub_1A11E();
  }
  return 1i64;
}
// 2B6D5: write access to const memory at 951F8 has been detected
// 2B6F6: write access to const memory at 95200 has been detected
// 92CA0: using guessed type __int64 qword_92CA0[2];
// 951F8: using guessed type __int64 qword_951F8;
// 95200: using guessed type __int64 qword_95200;
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000002B8B8) ----------------------------------------------------
signed __int64 __fastcall sub_2B8B8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  signed __int64 result; // rax

  if ( a1 && a2 && *(_DWORD *)(a1 + 36) == *(_DWORD *)(a3 + 4) && *(_DWORD *)(a1 + 32) == *(_DWORD *)a3 )
  {
    *(_QWORD *)(a1 + 16) = a2;
    *(_QWORD *)(a1 + 24) = a4;
    *(_QWORD *)(a1 + 32) = *(_QWORD *)a3;
    *(_BYTE *)(a1 + 40) = 1;
    result = 0i64;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}

//----- (000000000002B927) ----------------------------------------------------
__int64 __fastcall sub_2B927(__int64 a1, unsigned int a2)
{
  unsigned int v2; // ebx
  __int64 v3; // rsi
  __int64 v4; // r14
  __int64 v5; // rdi
  __int64 v6; // rcx
  __int64 v7; // rax

  v2 = a2;
  v3 = a1;
  v4 = 0i64;
  v5 = 0i64;
  while ( 1 )
  {
    v6 = *(_QWORD *)(v3 + 8 * v4);
    if ( !v6 )
      goto LABEL_8;
    if ( v6 == 1 )
      return v5;
    if ( (_DWORD)v6 != 1 )
    {
      v7 = sub_275C4(v6, v2);
      if ( v7 )
      {
        v5 = v7;
        sub_1A11E();
      }
      else
      {
        v5 = 0i64;
      }
    }
LABEL_8:
    ++v4;
  }
}

//----- (000000000002B9C3) ----------------------------------------------------
signed __int64 __fastcall sub_2B9C3(unsigned int a1, __int64 a2, unsigned __int8 a3)
{
  unsigned __int8 v3; // r13
  __int64 v4; // rsi
  __int64 v5; // r14
  __int64 v6; // r15
  signed __int64 v7; // rbx
  __int64 v8; // rcx
  signed __int64 v9; // rax
  signed __int64 v10; // rdi

  if ( (signed int)a1 <= 0 )
    return 0i64;
  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = 0i64;
  v7 = 0i64;
  do
  {
    v8 = *(_QWORD *)(v4 + 8 * v6);
    if ( v8 )
    {
      v9 = sub_27500(v8, v3);
      if ( v9 )
      {
        v10 = v9;
        sub_1A11E();
        v7 = v10;
      }
    }
    ++v6;
  }
  while ( v5 != v6 );
  return v7;
}

//----- (000000000002BA6A) ----------------------------------------------------
__int64 __fastcall sub_2BA6A(unsigned __int64 *a1, char *a2)
{
  char *v2; // rsi
  unsigned __int64 *v3; // rdi
  signed __int64 v4; // rax
  __int64 result; // rax
  char v6; // [rsp+18h] [rbp-48h]
  __int64 v7; // [rsp+28h] [rbp-38h]
  __int64 v8; // [rsp+30h] [rbp-30h]
  __int64 v9; // [rsp+38h] [rbp-28h]
  __int64 v10; // [rsp+40h] [rbp-20h]
  _QWORD *savedregs; // [rsp+60h] [rbp+0h]

  savedregs = &savedregs;
  v2 = a2;
  v3 = a1;
  v9 = 0i64;
  if ( sub_3FBF3() )
    v4 = sub_2BB74(v3, v2, &v9, (unsigned __int64 *)&v10, &v8);
  else
    v4 = sub_2BCF0(v3, v2, &v9, (unsigned __int64 *)&v10, &v8, 0);
  if ( v4 || (sub_26B03(&v6, 0, 0, SHIDWORD(v10), v10), v7 = 0i64, sub_26E4B(&v7, (__int64)&v6)) || (result = v7) == 0 )
  {
    sub_1A11E();
    result = 0i64;
  }
  else
  {
    *(_QWORD *)(v7 + 16) = v9;
    *(_QWORD *)(result + 24) = v8;
    *(_QWORD *)(result + 32) = v10;
  }
  return result;
}

//----- (000000000002BB74) ----------------------------------------------------
signed __int64 __fastcall sub_2BB74(unsigned __int64 *a1, char *a2, _QWORD *a3, unsigned __int64 *a4, _QWORD *a5)
{
  unsigned __int64 *v5; // r14
  _QWORD *v6; // r15
  char *v7; // rsi
  unsigned __int64 *v8; // r12
  _QWORD *v9; // r13
  signed int v10; // eax
  __int64 v11; // rdi
  signed __int64 v12; // rbx
  char v14[72]; // [rsp+30h] [rbp-A0h]
  __int64 v15; // [rsp+78h] [rbp-58h]
  __int64 v16; // [rsp+80h] [rbp-50h]
  __int64 v17; // [rsp+88h] [rbp-48h]
  unsigned __int64 v18; // [rsp+90h] [rbp-40h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = a5;
  v10 = sub_189FE(a2);
  if ( v10 < 5 || v7[v10 - 4] != 46 )
  {
    sub_1A11E();
  }
  else
  {
    v11 = v10 - 4i64;
    sub_18A90((__int64)v14, (__int64)v7, v11);
    v12 = 0i64;
    v14[v11] = 0;
    sub_18CC7(v14, "@2x.png");
    v9 = a5;
    if ( !sub_2BCF0(v8, v14, v6, v5, a5, 0) )
      return v12;
  }
  v17 = 0i64;
  v15 = 0i64;
  v12 = sub_2BCF0(v8, v7, &v17, (unsigned __int64 *)&v15, 0i64, 0);
  if ( !v12 )
  {
    v12 = sub_3FC0B(v17, (signed int *)&v15, &v16, (__int64)&v18);
    if ( v12 )
    {
      sub_1A11E();
    }
    else
    {
      if ( v17 )
        (*(void (**)(void))(qword_96CD8 + 72))();
      if ( v6 )
        *v6 = v16;
      if ( v5 )
        *v5 = v18;
      if ( v9 )
        *v9 = 4 * SHIDWORD(v18) * (signed __int64)(signed int)v18;
    }
  }
  return v12;
}
// 96CD8: using guessed type __int64 qword_96CD8;
// 2BB74: using guessed type char var_A0[72];

//----- (000000000002BCF0) ----------------------------------------------------
signed __int64 __fastcall sub_2BCF0(unsigned __int64 *a1, char *a2, _QWORD *a3, unsigned __int64 *a4, _QWORD *a5, char a6)
{
  unsigned __int64 *v6; // rsi
  _QWORD *v7; // rdi
  signed __int64 v8; // rax
  signed __int64 v9; // rsi
  __int64 v11; // [rsp+30h] [rbp-30h]
  __int64 v12; // [rsp+38h] [rbp-28h]

  v6 = a4;
  v7 = a3;
  if ( a3 )
    *a3 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v8 = sub_2C719(a1, a2, 0, (char **)&v11, (unsigned __int64 *)&v12, a6);
  if ( v8 == 1000 )
  {
    v9 = 1i64;
    if ( a6 )
      sub_1A11E();
  }
  else if ( v8 )
  {
    sub_1A11E();
    v9 = 1i64;
  }
  else
  {
    v9 = sub_2B665(v11, v12, v7, v6, a5);
  }
  return v9;
}

//----- (000000000002BDBE) ----------------------------------------------------
signed __int64 __fastcall sub_2BDBE(unsigned __int64 *a1, __int64 a2, char *a3)
{
  __int64 v3; // rdi
  __int64 v5; // [rsp+38h] [rbp-28h]
  __int64 v6; // [rsp+40h] [rbp-20h]
  char v7; // [rsp+48h] [rbp-18h]

  v3 = a2;
  if ( !sub_2BE2F(a1, a3, &v5, (unsigned __int64 *)&v7, &v6, 1) )
    return sub_2B8B8(v3, v5, (__int64)&v7, v6);
  sub_1A11E();
  return 1i64;
}

//----- (000000000002BE2F) ----------------------------------------------------
signed __int64 __fastcall sub_2BE2F(unsigned __int64 *a1, char *a2, _QWORD *a3, unsigned __int64 *a4, _QWORD *a5, char a6)
{
  unsigned __int64 *v6; // r14
  _QWORD *v7; // rdi
  char *v8; // rbx
  unsigned __int64 *v9; // rsi
  signed __int64 result; // rax

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  if ( a3 )
    *a3 = 0i64;
  if ( sub_3FBF3() )
    result = sub_2BB74(v9, v8, v7, v6, a5);
  else
    result = sub_2BCF0(v9, v8, v7, v6, a5, a6);
  return result;
}

//----- (000000000002BEB3) ----------------------------------------------------
__int64 __fastcall sub_2BEB3(unsigned __int64 *a1, char *a2, char *a3, char *a4, __int64 a5, __int64 a6)
{
  char *v6; // r14
  char *v7; // r12
  unsigned __int64 *v8; // rbx
  __int64 result; // rax
  char v10; // [rsp+38h] [rbp-68h]
  __int64 v11; // [rsp+40h] [rbp-60h]
  __int64 v12; // [rsp+48h] [rbp-58h]
  __int64 v13; // [rsp+50h] [rbp-50h]
  __int64 v14; // [rsp+58h] [rbp-48h]
  unsigned __int64 v15; // [rsp+60h] [rbp-40h]
  __int64 v16; // [rsp+68h] [rbp-38h]

  v6 = a4;
  v7 = a3;
  v8 = a1;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  if ( sub_2BE2F(a1, a2, &v12, &v15, &v10, 1)
    || sub_2BE2F(v8, v7, &v13, &v15, &v10, 1)
    || sub_2BE2F(v8, v6, &v14, &v15, &v10, 1)
    || (v11 = 0i64, v16 = 0i64, sub_35AB4(&v16, v12, v13, v14, (signed int *)&v15, &v11)) )
  {
    sub_1A11E();
    result = 0i64;
  }
  else
  {
    if ( sub_3661D(v16, a5, a6) )
      sub_1A11E();
    result = v16;
  }
  return result;
}

//----- (000000000002C02D) ----------------------------------------------------
char __fastcall sub_2C02D(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // r9
  __int64 v4; // rax
  __int64 v5; // r8
  char result; // al
  __int64 v7; // r9

  if ( a3 <= 0 )
  {
    LODWORD(v3) = a3;
  }
  else
  {
    v3 = 0i64;
    while ( *(_BYTE *)(a1 + v3) )
    {
      if ( ++v3 >= a3 )
      {
        LODWORD(v3) = a3;
        break;
      }
    }
    v4 = 0i64;
    while ( *(_BYTE *)(a2 + v4) )
    {
      if ( ++v4 >= a3 )
        goto LABEL_12;
    }
    a3 = v4;
LABEL_12:
    if ( (_DWORD)v3 != a3 )
      return 0;
  }
  v5 = (signed int)v3;
  if ( *(_BYTE *)(a1 + (signed int)v3) || *(_BYTE *)(a2 + (signed int)v3) )
    return 0;
  result = 1;
  if ( (signed int)v3 > 0 )
  {
    v7 = 0i64;
    while ( (*(_BYTE *)(a1 + v7) | 0x20) == (*(_BYTE *)(a2 + v7) | 0x20) )
    {
      if ( ++v7 >= v5 )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (000000000002C0AB) ----------------------------------------------------
char __fastcall sub_2C0AB(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r9
  __int64 v4; // rax
  char result; // al
  __int64 v6; // r9

  if ( (signed int)a3 <= 0 )
  {
    LODWORD(v3) = a3;
  }
  else
  {
    v3 = 0i64;
    while ( *(_BYTE *)(a2 + v3) )
    {
      if ( ++v3 >= (signed int)a3 )
      {
        LODWORD(v3) = a3;
        break;
      }
    }
    v4 = 0i64;
    while ( *(_BYTE *)(a1 + v4) )
    {
      if ( ++v4 >= (signed int)a3 )
        goto LABEL_12;
    }
    LODWORD(a3) = v4;
  }
LABEL_12:
  result = 0;
  if ( (_DWORD)a3 )
  {
    if ( (signed int)a3 <= (signed int)v3 )
    {
      result = 1;
      if ( (signed int)a3 > 0 )
      {
        a3 = (signed int)a3;
        v6 = 0i64;
        while ( (*(_BYTE *)(a2 + v6) | 0x20) == (*(_BYTE *)(a1 + v6) | 0x20) )
        {
          if ( ++v6 >= a3 )
            return result;
        }
        result = 0;
      }
    }
  }
  return result;
}

//----- (000000000002C122) ----------------------------------------------------
signed __int64 sub_2C122()
{
  return 1i64;
}

//----- (000000000002C12E) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_2C12E(signed int a1)
{
  signed int v1; // esi

  v1 = 30;
  if ( a1 < 31 )
    v1 = a1;
  sub_1A11E();
  dword_935C4 = v1;
}
// 2C15D: write access to const memory at 935C4 has been detected
// 935C4: using guessed type int dword_935C4;

//----- (000000000002C16A) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_2C16A()
{
  sub_1A11E();
  dword_935C4 = 1;
}
// 2C190: write access to const memory at 935C4 has been detected
// 935C4: using guessed type int dword_935C4;

//----- (000000000002C1A0) ----------------------------------------------------
signed __int64 __fastcall sub_2C1A0(__int64 a1, __int16 *a2, _QWORD *a3)
{
  char v4; // [rsp+2Fh] [rbp-1h]

  return sub_2C1B7(a1, a2, a3, &v4);
}

//----- (000000000002C1B7) ----------------------------------------------------
signed __int64 __fastcall sub_2C1B7(__int64 a1, __int16 *a2, _QWORD *a3, _BYTE *a4)
{
  __int16 *v4; // rsi
  _BYTE *v5; // r14
  _QWORD *v6; // rbx
  __int64 v7; // rdi
  signed __int64 result; // rax
  char v9; // [rsp+30h] [rbp-230h]
  char v10; // [rsp+130h] [rbp-130h]

  if ( a3 && (v4 = a2) != 0i64 )
  {
    v5 = a4;
    v6 = a3;
    v7 = a1;
    sub_F1B0(&v9, 256i64);
    sub_237BC(&v9, (__int16 *)"/");
    sub_237BC(&v9, v4);
    if ( sub_2C45B(v7, (__int64)&v9, v6) )
    {
      sub_1A11E();
      sub_F1B0(&v10, 256i64);
      sub_237BC(&v10, (__int16 *)"/");
      sub_237BC(&v10, v4);
      if ( sub_2C45B(v7, (__int64)&v10, v6) )
      {
        sub_1A11E();
        return 2i64;
      }
      *v5 = 0;
    }
    else
    {
      sub_1A11E();
      *v5 = 1;
    }
    result = 0i64;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}
// F1B0: using guessed type __int64 __fastcall sub_F1B0(_QWORD, _QWORD);

//----- (000000000002C317) ----------------------------------------------------
signed __int64 __fastcall sub_2C317(unsigned __int64 *a1, char *a2, _QWORD *a3, unsigned __int64 *a4, _QWORD *a5, char a6)
{
  return sub_2BCF0(a1, a2, a3, a4, a5, a6);
}

//----- (000000000002C321) ----------------------------------------------------
__int64 __fastcall sub_2C321(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *v3; // r14
  __int64 v4; // rsi
  __int64 v5; // r12
  _QWORD *v6; // r15
  _DWORD *v7; // rsi
  char *v8; // rbx
  unsigned __int64 v9; // rdi

  if ( a3 )
  {
    v3 = a3;
    v4 = a2;
    v5 = a1;
    v6 = (_QWORD *)sub_24136(24i64);
    v6[1] = v5;
    *v6 = v4;
    v7 = (_DWORD *)sub_3FFD2(2 * (unsigned int)*(unsigned __int16 *)(v5 + 2));
    if ( *(_WORD *)(v5 + 2) )
    {
      v8 = (char *)(v5 + 72);
      v9 = 0i64;
      do
      {
        if ( !*(_DWORD *)v8 )
          break;
        sub_40008(v7, (__int64)(v8 - 68), v8 - 68);
        ++v9;
        v8 += 72;
      }
      while ( v9 < *(unsigned __int16 *)(v5 + 2) );
    }
    v6[2] = v7;
    *v3 = v6;
  }
  return 0i64;
}

//----- (000000000002C3B2) ----------------------------------------------------
signed __int64 __fastcall sub_2C3B2(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *v3; // rsi
  signed __int64 v4; // rax
  signed __int64 v5; // rdi
  __int64 v7; // [rsp+20h] [rbp-20h]
  __int64 v8; // [rsp+28h] [rbp-18h]

  v3 = a3;
  v7 = 0i64;
  v8 = 0i64;
  v4 = sub_3FED1(a2, &v7, &v8);
  if ( v4 )
  {
    v5 = v4;
    sub_1A11E();
  }
  else if ( v7 )
  {
    sub_1A11E();
    sub_2C321(v7, v8, v3);
    v5 = 0i64;
  }
  else
  {
    sub_1A11E();
    v5 = 1i64;
  }
  return v5;
}

//----- (000000000002C45B) ----------------------------------------------------
signed __int64 __fastcall sub_2C45B(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *v3; // rsi
  __int64 v4; // rcx
  __int64 v6; // [rsp+30h] [rbp-20h]
  __int64 v7; // [rsp+38h] [rbp-18h]

  if ( !a3 )
    goto LABEL_14;
  v3 = a3;
  v7 = 0i64;
  if ( sub_3FD8F(*(_QWORD *)(qword_96A98 + 24), a1, a2, &v7) )
  {
    sub_1A11E();
    return 1i64;
  }
  v6 = 0i64;
  if ( sub_2C3B2(v4, v7, &v6) )
  {
LABEL_14:
    sub_1A11E();
    return 1i64;
  }
  if ( (*(__int64 (**)(void))(v7 + 16))() )
    sub_1A11E();
  *v3 = v6;
  return 0i64;
}
// 96A98: using guessed type __int64 qword_96A98;

//----- (000000000002C52E) ----------------------------------------------------
signed __int64 __fastcall sub_2C52E(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *v3; // r14
  __int64 v4; // r15
  __int64 v5; // rbx
  __int64 v6; // rcx
  int v7; // edi
  int v8; // eax
  __int64 v9; // rsi
  __int64 v10; // rcx
  __int64 v11; // rsi
  int v12; // edi
  _QWORD *v13; // rsi
  __int64 v14; // rcx
  _WORD *v15; // rax
  signed __int64 result; // rax

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = 0;
  v8 = 0;
  if ( *(_WORD *)(v6 + 2) )
  {
    v9 = 0i64;
    v8 = 0;
    do
    {
      v8 += *(_DWORD *)(v6 + v9 + 72);
      v9 += 72i64;
    }
    while ( 72i64 * *(unsigned __int16 *)(v6 + 2) != v9 );
  }
  v10 = *(_QWORD *)(a2 + 8);
  if ( *(_WORD *)(v10 + 2) )
  {
    v11 = 0i64;
    v7 = 0;
    do
    {
      v7 += *(_DWORD *)(v10 + v11 + 72);
      v11 += 72i64;
    }
    while ( 72i64 * *(unsigned __int16 *)(v10 + 2) != v11 );
  }
  v12 = v8 + v7;
  v13 = (_QWORD *)sub_24136(24i64);
  v14 = v12 + 73732i64;
  *v13 = v14;
  v15 = (_WORD *)sub_24136(v14);
  v13[1] = v15;
  *v15 = **(_WORD **)(v5 + 8);
  v15[1] = 0;
  if ( sub_2C62D((__int64)v13, v5) || sub_2C62D((__int64)v13, v4) )
  {
    sub_1A11E();
    result = 1i64;
  }
  else
  {
    if ( v3 )
      *v3 = v13;
    result = 0i64;
  }
  return result;
}

//----- (000000000002C62D) ----------------------------------------------------
signed __int64 __fastcall sub_2C62D(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rax
  int v5; // esi
  signed __int64 v6; // rax
  signed __int64 v7; // r12
  __int64 v8; // r14
  unsigned __int64 v9; // r15
  unsigned __int16 v10; // ax
  signed __int64 v12; // [rsp+30h] [rbp-40h]

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(unsigned __int16 *)(v3 + 2);
  if ( *(_WORD *)(v3 + 2) )
    v5 = *(_DWORD *)(v3 + 72 * v4 - 4) + *(_DWORD *)(v3 + 72 * v4);
  else
    v5 = 73732;
  if ( !*(_WORD *)(v2 + 2) )
    return 0i64;
  v6 = 9 * v4;
  v7 = v3 + 8 * v6 + 72;
  v12 = v3 + 8 * v6 + 4;
  v8 = 0i64;
  v9 = 0i64;
  while ( 1 )
  {
    sub_1B930((char *)(v3 + v5), (char *)(v2 + *(unsigned int *)(v2 + v8 + 68)), *(unsigned int *)(v2 + v8 + 72));
    sub_1B930((char *)(v12 + v8), (char *)(v2 + 4 + v8), 0x40ui64);
    *(_DWORD *)(v7 + v8) = *(_DWORD *)(v2 + v8 + 72);
    *(_DWORD *)(v7 + v8 - 4) = v5;
    v10 = *(_WORD *)(v3 + 2) + 1;
    *(_WORD *)(v3 + 2) = v10;
    if ( v10 > 0x3FFu )
      break;
    v5 += *(_DWORD *)(v2 + v8 + 72);
    ++v9;
    v8 += 72i64;
    if ( v9 >= *(unsigned __int16 *)(v2 + 2) )
      return 0i64;
  }
  return 1i64;
}

//----- (000000000002C719) ----------------------------------------------------
signed __int64 __fastcall sub_2C719(unsigned __int64 *a1, char *a2, char a3, char **a4, unsigned __int64 *a5, char a6)
{
  char **v6; // rsi
  char v7; // r14
  unsigned __int64 *v8; // rbx
  __int64 v9; // rax
  unsigned __int64 v10; // r13
  unsigned __int64 v11; // r15
  unsigned __int64 v12; // rdi
  char *v13; // rax
  signed __int64 v14; // rsi

  if ( a1 )
  {
    v6 = a4;
    if ( a4 )
    {
      v7 = a3;
      v8 = a1;
      *a4 = 0i64;
      if ( a5 )
        *a5 = 0i64;
      v9 = sub_401FA(a1[2], a2);
      if ( v9 )
      {
        v10 = v8[1];
        v11 = *(unsigned int *)(v9 + 68);
        if ( a5 )
          *a5 = v11;
        v12 = *(unsigned int *)(v9 + 64);
        if ( *v8 <= v12 )
        {
          sub_1A11E();
          v14 = 1i64;
        }
        else
        {
          if ( v7 )
          {
            v13 = (char *)sub_24103(v11);
            *v6 = v13;
            sub_1B930(v13, (char *)(v12 + v10), v11);
          }
          else
          {
            *v6 = (char *)(v12 + v10);
          }
          v14 = 0i64;
        }
      }
      else
      {
        v14 = 1000i64;
        if ( a6 )
          sub_1A11E();
      }
    }
    else
    {
      sub_1A11E();
      v14 = 3i64;
    }
  }
  else
  {
    sub_1A11E();
    v14 = 2i64;
  }
  return v14;
}

//----- (000000000002C860) ----------------------------------------------------
__int64 __fastcall sub_2C860(int a1)
{
  return (unsigned int)(a1 << 16);
}

//----- (000000000002C86B) ----------------------------------------------------
__int64 __fastcall sub_2C86B(unsigned int a1)
{
  __int64 result; // rax

  if ( (a1 & 0x80000000) != 0 )
    result = (unsigned int)-sub_2C86B(-a1);
  else
    result = a1 >> 16;
  return result;
}

//----- (000000000002C88C) ----------------------------------------------------
__int64 __fastcall sub_2C88C(unsigned int a1, int a2)
{
  return sub_2C899(a1, a2 << 16);
}

//----- (000000000002C899) ----------------------------------------------------
__int64 __fastcall sub_2C899(unsigned int a1, unsigned int a2)
{
  __int64 v2; // r8
  BOOL v3; // ecx
  int v4; // esi
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax

  v2 = -a1;
  if ( (signed int)-a1 < 1 )
    v2 = a1;
  v3 = (a1 & 0x80000000) == 0;
  v4 = 1 - 2 * v3;
  v5 = -a2;
  if ( (signed int)-a2 < 1 )
    v5 = a2;
  if ( (a2 & 0x80000000) == 0 )
    v4 = 2 * v3 - 1;
  v6 = sub_23C92(v2, v5);
  v7 = sub_23C9F(v6, 16);
  return sub_23C92(v7, v4);
}

//----- (000000000002C8F8) ----------------------------------------------------
__int64 __fastcall sub_2C8F8(unsigned int a1, int a2)
{
  return sub_2C905(a1, a2 << 16);
}

//----- (000000000002C905) ----------------------------------------------------
__int64 __fastcall sub_2C905(unsigned int a1, unsigned int a2)
{
  __int64 v2; // rax
  BOOL v3; // ecx
  int v4; // edi
  unsigned __int64 v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rax

  if ( !a2 )
    return 0xFFFFFFFFi64;
  v2 = -a1;
  if ( (signed int)-a1 < 1 )
    v2 = a1;
  v3 = (a1 & 0x80000000) == 0;
  v4 = 1 - 2 * v3;
  v5 = -a2;
  if ( (signed int)-a2 < 1 )
    v5 = a2;
  if ( (a2 & 0x80000000) == 0 )
    v4 = 2 * v3 - 1;
  v6 = sub_23C84(v2, 16);
  v7 = sub_23CAD(v6, v5, 0i64);
  return sub_23C92(v7, v4);
}

//----- (000000000002C972) ----------------------------------------------------
__int64 __fastcall sub_2C972(int a1, int a2)
{
  return sub_2C905(a1 << 16, a2 << 16);
}

//----- (000000000002C982) ----------------------------------------------------
void __fastcall sub_2C982(__int64 a1, int a2)
{
  int v2; // edi
  __int64 v3; // rsi
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // r9
  int v7; // ST20_4
  __int64 v8; // rbx
  __int64 v9[8]; // [rsp+30h] [rbp-80h]
  __int64 v10; // [rsp+70h] [rbp-40h]

  v2 = a2;
  v3 = a1;
  if ( *(_DWORD *)(a1 + 72) != a2 || !**(_QWORD **)(a1 + 64) )
  {
    *(_DWORD *)(a1 + 72) = a2;
    v4 = *(_QWORD *)(a1 + 80);
    if ( v4 && (v5 = *(_QWORD *)(v4 + 40)) != 0 )
    {
      v6 = *(_QWORD *)(v5 + 8);
      v7 = *(_DWORD *)(v5 + 16);
      sub_1A11E();
      if ( !*(_QWORD *)(v3 + 88) )
      {
        sub_18905(
          (unsigned __int64)v9,
          (__int64)"%d_%s_button_%s.png",
          *(unsigned int *)(v5 + 16),
          *(_QWORD *)(v5 + 8),
          "up");
        sub_2BE2F(
          *(unsigned __int64 **)(v3 + 8),
          (char *)v9,
          (_QWORD *)(v3 + 88),
          (unsigned __int64 *)(v3 + 104),
          0i64,
          1);
      }
      if ( !*(_QWORD *)(v3 + 96) )
      {
        sub_18905(
          (unsigned __int64)v9,
          (__int64)"%d_%s_button_%s.png",
          *(unsigned int *)(v5 + 16),
          *(_QWORD *)(v5 + 8),
          "down");
        sub_2BE2F(
          *(unsigned __int64 **)(v3 + 8),
          (char *)v9,
          (_QWORD *)(v3 + 96),
          (unsigned __int64 *)(v3 + 104),
          0i64,
          1);
      }
      if ( v2 == 2 )
      {
        v8 = *(_QWORD *)(v3 + 96);
      }
      else if ( v2 )
      {
        sub_1A11E();
        v8 = 0i64;
      }
      else
      {
        v8 = *(_QWORD *)(v3 + 88);
      }
      if ( **(_QWORD **)(v3 + 64) )
      {
        sub_1A11E();
        sub_35F37(**(_QWORD **)(v3 + 64), v8, v8, v8, (signed int *)(v3 + 104));
        sub_3F6AA(*(_QWORD **)v3);
      }
      else
      {
        sub_1A11E();
        v9[0] = 0i64;
        v10 = 0i64;
        if ( sub_35AB4(&v10, v8, v8, v8, (signed int *)(v3 + 104), v9) )
          sub_1A11E();
        sub_3661D(v10, (__int64)sub_2D4C8, v3);
        sub_3664E(v10, 1);
        **(_QWORD **)(v3 + 64) = v10;
      }
    }
    else
    {
      sub_1A11E();
    }
  }
}

//----- (000000000002CBDA) ----------------------------------------------------
void __fastcall sub_2CBDA(__int64 a1)
{
  __int64 v1; // r14
  int v2; // eax
  __int64 v3; // rcx
  __int64 v4; // rax
  bool v5; // dl
  char *i; // rdx
  char v7; // al
  char *v8; // rcx
  char v9; // bl
  int v10; // edx
  char *v11; // rcx
  int v12; // ecx
  __int64 *v13; // rax
  unsigned __int64 v14; // rdi
  __int64 v15; // rax
  __int64 v16; // rsi
  char *v17; // [rsp+20h] [rbp-C0h]
  char v18; // [rsp+30h] [rbp-B0h]
  __int64 v19; // [rsp+78h] [rbp-68h]
  __int64 v20; // [rsp+80h] [rbp-60h]
  __int64 v21; // [rsp+88h] [rbp-58h]
  char v22[80]; // [rsp+90h] [rbp-50h]

  v1 = a1;
  v20 = -9034400514174975832i64;
  v19 = 5457143572451254544i64;
  v21 = 32i64;
  sub_F180(v22, 0, 0x20ui64);
  v17 = v22;
  if ( (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD, __int64 *, char *))(qword_96CE0 + 72))(
         L"prev-lang:kbd",
         &v19,
         0i64,
         &v21,
         v22) )
  {
    sub_1A11E();
  }
  else
  {
    sub_1A11E();
    v2 = sub_189FE(v22);
    if ( v2 > 0 )
    {
      v3 = v2;
      v4 = 0i64;
      v5 = 0;
      while ( !v5 )
      {
        v5 = v22[v4++] == 58;
        if ( v4 >= v3 )
          return;
      }
      for ( i = &v22[v4]; ; ++i )
      {
        v7 = *i;
        if ( *i != 32 && v7 != 9 )
          break;
      }
      v8 = i + 1;
      if ( v7 != 45 )
        v8 = i;
      v9 = *v8;
      v10 = 0;
      if ( (unsigned __int8)(*v8 - 48) <= 9u )
      {
        v11 = v8 + 1;
        v10 = 0;
        do
        {
          v10 = v9 + 10 * v10 - 48;
          v9 = *v11++;
        }
        while ( (unsigned __int8)(v9 - 48) < 0xAu );
      }
      v12 = -v10;
      if ( v7 != 45 )
        v12 = v10;
      v13 = qword_8FD80;
      v14 = 0i64;
      while ( *(_DWORD *)v13 != v12 )
      {
        ++v14;
        v13 = (__int64 *)((char *)v13 + 4);
        if ( v14 >= 0x48 )
          return;
      }
      sub_F180(&v18, 0, 0x40ui64);
      sub_18905((unsigned __int64)&v18, (__int64)"%d_flag_other", (unsigned int)v14);
      v15 = sub_2CDAA(*(_QWORD *)(v1 + 24), (__int64)&v18);
      if ( v15 )
      {
        v16 = v15;
        (*(void (__fastcall **)(__int64))(v15 + 32))(v15);
        v17 = (char *)(*(_QWORD *)(v16 + 40) + 20i64);
        sub_1A11E();
      }
    }
  }
}
// 417E0: using guessed type __int16 aPrevLangKbd[14];
// 8FD80: using guessed type __int64 qword_8FD80[36];
// 96CE0: using guessed type __int64 qword_96CE0;
// 2CBDA: using guessed type char var_50[80];

//----- (000000000002CDAA) ----------------------------------------------------
__int64 __fastcall sub_2CDAA(__int64 a1, __int64 a2)
{
  __int64 v2; // r13
  __int64 v3; // rdi
  signed int v4; // eax
  signed int v5; // ebx
  unsigned int v6; // esi
  __int64 v7; // rax
  __int64 v8; // r12
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // r14
  _BYTE *v12; // r14

  v2 = a2;
  if ( !a1 )
  {
    sub_1A11E();
    return 0i64;
  }
  if ( !a2 )
  {
    sub_1A11E();
    return 0i64;
  }
  v3 = a1;
  v4 = sub_2EEC1(a1);
  if ( v4 <= 0 )
    return 0i64;
  v5 = v4;
  v6 = 0;
  while ( 1 )
  {
    v7 = sub_2E3C8(v3, v6);
    if ( !v7 )
    {
LABEL_9:
      sub_1A11E();
      goto LABEL_10;
    }
    v8 = v7;
    v9 = *(_QWORD *)(v7 + 48);
    if ( v9 )
      break;
    v11 = *(_QWORD *)(v7 + 40);
    if ( !v11 )
      goto LABEL_10;
    v12 = (_BYTE *)(v11 + 20);
    if ( (signed int)sub_189FE(v12) > 0 )
      goto LABEL_9;
    if ( !(unsigned int)sub_18A43((__int64)v12, v2, 32) )
      return v8;
LABEL_10:
    if ( (signed int)++v6 >= v5 )
      return 0i64;
  }
  v10 = sub_2CDAA(v9, v2);
  if ( !v10 )
    goto LABEL_10;
  return v10;
}

//----- (000000000002CEC9) ----------------------------------------------------
char __fastcall sub_2CEC9(__int64 a1, char a2)
{
  char v2; // r15
  __int64 v3; // r14
  __int64 v5; // rax
  __int64 v6; // rsi
  int *v7; // [rsp+20h] [rbp-90h]
  char v8; // [rsp+30h] [rbp-80h]
  __int64 v9; // [rsp+58h] [rbp-58h]
  __int64 v10; // [rsp+60h] [rbp-50h]
  __int64 v11; // [rsp+68h] [rbp-48h]
  __int64 v12; // [rsp+70h] [rbp-40h]
  int v13; // [rsp+7Ch] [rbp-34h]

  v2 = a2;
  v3 = a1;
  v10 = -9034400514174975832i64;
  v9 = 5457143572451254544i64;
  v11 = 32i64;
  sub_F180(&v8, 0, 0x20ui64);
  v7 = (int *)&v8;
  if ( (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD, __int64 *, char *))(qword_96CE0 + 72))(
         L"flagstate",
         &v9,
         0i64,
         &v11,
         &v8) )
  {
    goto LABEL_2;
  }
  sub_1A11E();
  v13 = 0;
  v12 = 4i64;
  v7 = &v13;
  if ( (*(__int64 (__fastcall **)(const __int16 *, __int64 *, _QWORD))(qword_96CE0 + 72))(L"flagarchiveID", &v9, 0i64) )
    sub_1A11E();
  else
    sub_1A11E();
  if ( !v2 && v13 != *(_DWORD *)(v3 + 16) )
  {
    sub_1A11E();
LABEL_2:
    sub_1A11E();
    return 0;
  }
  v5 = sub_2CDAA(*(_QWORD *)(v3 + 24), (__int64)&v8);
  if ( !v5 )
    return 0;
  v6 = v5;
  (*(void (__fastcall **)(__int64))(v5 + 32))(v5);
  v7 = (int *)(*(_QWORD *)(v6 + 40) + 20i64);
  sub_1A11E();
  return 1;
}
// 417B0: using guessed type __int16 aFlagstate[10];
// 417C4: using guessed type __int16 aFlagarchiveid[14];
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000002D085) ----------------------------------------------------
__int64 __fastcall sub_2D085(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r15
  unsigned __int64 *v6; // r14
  __int64 v7; // r12
  __int64 v8; // rbx
  __int64 v9; // rsi
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rax
  _QWORD *v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rcx
  __int64 v21; // rax
  __int64 v22; // rcx
  __int64 v23; // rdx
  _DWORD *v25; // [rsp+30h] [rbp-70h]
  __int64 v26; // [rsp+38h] [rbp-68h]
  __int64 v27; // [rsp+40h] [rbp-60h]
  __int64 v28; // [rsp+48h] [rbp-58h]
  __int64 v29; // [rsp+50h] [rbp-50h]
  __int64 v30; // [rsp+58h] [rbp-48h]
  __int64 v31; // [rsp+60h] [rbp-40h]

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = sub_24136(120i64);
  *(_QWORD *)(v9 + 64) = v8;
  *(_QWORD *)v9 = v7;
  *(_QWORD *)(v9 + 8) = v6;
  v10 = sub_2D570(v9, v7, v6, (__int64)"flag", (__int64)sub_2DBD3);
  v25 = 0i64;
  v29 = 0i64;
  if ( sub_2BE2F(v6, "aquamenu_base_selection.png", &v25, (unsigned __int64 *)&v29, 0i64, 1) )
    sub_1A11E();
  v26 = 0i64;
  v27 = 0i64;
  if ( sub_2BE2F(v6, "aquamenu_divider_selection.png", &v26, (unsigned __int64 *)&v27, 0i64, 1) )
    sub_1A11E();
  v11 = sub_2EF20(v26, v27);
  v12 = *(_QWORD *)(v10 + 16);
  v13 = *(signed int *)(v10 + 8);
  *(_DWORD *)(v10 + 8) = v13 + 1;
  *(_QWORD *)(v12 + 8 * v13) = v11;
  v28 = 0i64;
  v30 = 0i64;
  v31 = 0i64;
  if ( sub_2BE2F(v6, "flag_others_submenu_item.png", &v28, (unsigned __int64 *)&v31, 0i64, 1) )
    sub_1A11E();
  if ( sub_2BE2F(v6, "flag_others_submenu_item_sel.png", &v30, (unsigned __int64 *)&v31, 0i64, 1) )
    sub_1A11E();
  v14 = sub_2D570(v9, v7, v6, (__int64)"flag_other", (__int64)sub_2DC3D);
  v15 = sub_2EECA(v28, v30, v31, 0i64, 0i64, v14);
  v16 = *(_QWORD *)(v10 + 16);
  v17 = *(signed int *)(v10 + 8);
  *(_DWORD *)(v10 + 8) = v17 + 1;
  *(_QWORD *)(v16 + 8 * v17) = v15;
  *(_QWORD *)(v9 + 24) = v10;
  *(_QWORD *)(v9 + 40) = v5;
  *(_QWORD *)(v9 + 48) = a5;
  v18 = sub_2E3C8(v10, 0);
  *(_QWORD *)(v9 + 32) = sub_2D39E(v18);
  v19 = sub_2E3C8(*(_QWORD *)(v9 + 24), 0);
  *(_QWORD *)(v9 + 80) = v19;
  if ( !v19 )
    sub_1A11E();
  sub_2E405(*(_QWORD *)(v9 + 24), (__int64)sub_2D438, v9);
  *(_DWORD *)(v9 + 72) = -1;
  sub_2C982(v9, 0);
  v20 = *(_QWORD *)(v9 + 24);
  v21 = *(signed int *)(v20 + 8);
  if ( v21 > 0 )
  {
    v22 = *(_QWORD *)(v20 + 16);
    v23 = 0i64;
    do
      *(_BYTE *)(*(_QWORD *)(v22 + 8 * v23++) + 56i64) = 0;
    while ( v21 != v23 );
  }
  *(_BYTE *)(*(_QWORD *)(v9 + 80) + 56i64) = 1;
  v25 = 0i64;
  sub_2C719(v6, "flag_picker_indetifier.int32", 0, (char **)&v25, (unsigned __int64 *)&v29, 1);
  if ( v25 && v29 == 4 )
  {
    *(_DWORD *)(v9 + 16) = *v25;
    sub_1A11E();
  }
  else
  {
    *(_DWORD *)(v9 + 16) = 181;
    sub_1A11E();
  }
  return v9;
}

//----- (000000000002D39E) ----------------------------------------------------
__int64 __fastcall sub_2D39E(__int64 a1)
{
  __int64 *v1; // rax
  __int64 v2; // rdi
  char v4; // [rsp+30h] [rbp-60h]
  __int64 v5; // [rsp+78h] [rbp-18h]

  v1 = *(__int64 **)(a1 + 40);
  v2 = *v1;
  sub_18905((unsigned __int64)&v4, (__int64)"%d_%s.uchr", *((unsigned int *)v1 + 4), v1[1]);
  v5 = 0i64;
  sub_2C719(*(unsigned __int64 **)(v2 + 8), &v4, 0, (char **)&v5, 0i64, 1);
  sub_1A11E();
  return v5;
}

//----- (000000000002D438) ----------------------------------------------------
__int64 __fastcall sub_2D438(__int64 a1, __int64 a2)
{
  *(_BYTE *)(a2 + 112) = 0;
  sub_2C982(a2, 0);
  sub_1A11E();
  return 0i64;
}

//----- (000000000002D46E) ----------------------------------------------------
signed __int64 __fastcall sub_2D46E(__int64 *a1)
{
  __int64 *v1; // rsi
  __int64 v2; // rcx
  signed __int64 result; // rax

  if ( a1 )
  {
    v1 = a1;
    v2 = *a1;
    if ( v2 )
      sub_3F1DC(v2, *(__int64 **)v1[8]);
    (*(void (__fastcall **)(__int64 *))(qword_96CD8 + 72))(v1);
    result = 0i64;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000002D4C8) ----------------------------------------------------
__int64 __fastcall sub_2D4C8(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi

  v2 = a2;
  v3 = a1;
  sub_2C982(a2, 2);
  sub_2FACD((__int64)sub_2D508, v3, v2, (__int64)"_flagButtonMouseDown_deferred");
  return 0i64;
}

//----- (000000000002D508) ----------------------------------------------------
__int64 __fastcall sub_2D508(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  char v5; // [rsp+28h] [rbp-18h]

  v3 = a3;
  sub_26AE1(
    &v5,
    *(_DWORD *)(**(_QWORD **)(a3 + 64) + 44i64),
    *(_DWORD *)(**(_QWORD **)(a3 + 64) + 48i64) + *(_DWORD *)(**(_QWORD **)(a3 + 64) + 52i64) + 5);
  *(_BYTE *)(v3 + 112) = 1;
  if ( sub_2E45B(*(_QWORD *)(v3 + 24), (__int64)&v5) )
    sub_1A11E();
  return 0i64;
}

//----- (000000000002D570) ----------------------------------------------------
__int64 __fastcall sub_2D570(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r15
  unsigned __int64 *v6; // r14
  unsigned __int64 v7; // rdi
  __int64 v8; // r12
  __int64 v9; // rbx
  __int64 v10; // r13
  _QWORD *v11; // rax
  __int64 v12; // rdi
  char v14; // [rsp+30h] [rbp-100h]
  char v15; // [rsp+80h] [rbp-B0h]
  __int64 v16; // [rsp+C8h] [rbp-68h]
  __int64 v17; // [rsp+D0h] [rbp-60h]
  __int64 v18; // [rsp+D8h] [rbp-58h]
  __int64 v19; // [rsp+E0h] [rbp-50h]
  __int64 v20; // [rsp+E8h] [rbp-48h]
  __int64 v21; // [rsp+F0h] [rbp-40h]

  v5 = a4;
  v6 = a3;
  v20 = a2;
  v19 = a1;
  v21 = sub_24136(4096i64);
  v7 = 0i64;
  while ( 1 )
  {
    sub_18905((unsigned __int64)&v14, (__int64)"%d_%s_menu_item.png", (unsigned int)v7, v5);
    if ( sub_2BE2F(v6, &v14, &v16, (unsigned __int64 *)&v17, 0i64, 0) )
      break;
    sub_18905((unsigned __int64)&v15, (__int64)"%d_%s_menu_item_sel.png", (unsigned int)v7, v5);
    if ( sub_2BE2F(v6, &v15, &v18, (unsigned __int64 *)&v17, 0i64, 0) )
      break;
    v8 = v16;
    v9 = v18;
    v10 = sub_24136(56i64);
    *(_QWORD *)v10 = v19;
    *(_DWORD *)(v10 + 16) = v7;
    *(_QWORD *)(v10 + 8) = v5;
    sub_18905(v10 + 20, (__int64)"%d_%s", (unsigned int)v7, v5);
    v11 = sub_2EECA(v8, v9, v17, a5, v10, 0i64);
    *(_QWORD *)(v21 + 8 * v7++) = v11;
    if ( v7 >= 0x200 )
      goto LABEL_7;
  }
  sub_1A11E();
LABEL_7:
  v12 = sub_2E413(v20, v7, v21);
  if ( sub_2BE2F(
         v6,
         "aquamenu_base_selection.png",
         *(_QWORD **)(v12 + 112),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 8i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_triangle_left.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 16i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 32i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_triangle_left_sel.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 24i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 32i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_triangle_down.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 64i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 80i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_triangle_down_sel.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 72i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 80i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_triangle_up.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 40i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 56i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_triangle_up_sel.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 48i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 56i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_tick.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 88i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 104i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_tick_sel.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 96i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 104i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_shadow_left.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 128i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 136i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_shadow_right.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 112i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 120i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_shadow_bottom_left.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 192i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 200i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_shadow_bottom_center.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 208i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 216i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_shadow_bottom_right.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 224i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 232i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_shadow_top_left.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 144i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 152i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_shadow_top_center.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 160i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 168i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  if ( sub_2BE2F(
         v6,
         "aquamenu_shadow_top_right.png",
         (_QWORD *)(*(_QWORD *)(v12 + 112) + 176i64),
         (unsigned __int64 *)(*(_QWORD *)(v12 + 112) + 184i64),
         0i64,
         1) )
  {
    sub_1A11E();
  }
  return v12;
}

//----- (000000000002DBD3) ----------------------------------------------------
__int64 __fastcall sub_2DBD3(__int64 a1)
{
  __int64 *v1; // rax
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rax
  __int64 v7; // r9

  v1 = *(__int64 **)(a1 + 40);
  if ( v1 )
  {
    v2 = *v1;
    *(_QWORD *)(v2 + 80) = a1;
    v3 = *(_QWORD *)(v2 + 24);
    v4 = *(signed int *)(v3 + 8);
    if ( v4 > 0 )
    {
      v5 = *(_QWORD *)(v3 + 16);
      v6 = 0i64;
      do
        *(_BYTE *)(*(_QWORD *)(v5 + 8 * v6++) + 56i64) = 0;
      while ( v4 != v6 );
    }
    *(_BYTE *)(a1 + 56) = 1;
    sub_2DD3B(a1);
  }
  else
  {
    v7 = *(unsigned int *)(a1 + 60);
    sub_1A11E();
  }
  return 0i64;
}

//----- (000000000002DC3D) ----------------------------------------------------
__int64 __fastcall sub_2DC3D(__int64 *a1)
{
  __int64 *v1; // r15
  __int64 v2; // r9
  __int64 v3; // r14
  __int64 v4; // rbx
  __int64 v5; // rdx
  __int64 v6; // rdi
  __int64 v7; // rcx
  __int64 v8; // rax
  _QWORD *v9; // rax
  __int64 v10; // r8
  _QWORD *v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rdi
  unsigned __int8 v14; // of
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rbx
  __int64 v19; // rax

  v1 = a1;
  v2 = a1[5];
  v3 = *(_QWORD *)v2;
  v4 = *(_QWORD *)(*(_QWORD *)v2 + 24i64);
  v5 = *(signed int *)(v4 + 8);
  if ( v5 <= 0 )
  {
    v7 = a1[1];
LABEL_7:
    v9 = sub_2EECA(v7, v1[2], v1[3], (__int64)sub_2DBD3, v2, v1[6]);
    v10 = *(signed int *)(v4 + 8);
    v11 = *(_QWORD **)(v4 + 16);
    if ( v10 > 0 )
    {
      v12 = *(signed int *)(v4 + 8);
      v13 = *(signed int *)(v4 + 8);
      do
      {
        v11[v12] = v11[v12 - 1];
        v11 = *(_QWORD **)(v4 + 16);
        v14 = __OFSUB__(v13--, 1i64);
        v12 = v13;
      }
      while ( !((unsigned __int8)((v13 < 0) ^ v14) | (v13 == 0)) );
    }
    *v11 = v9;
    *(_DWORD *)(v4 + 8) = v10 + 1;
    *(_QWORD *)(v3 + 80) = v9;
    v15 = *(_QWORD *)(v3 + 24);
    v16 = *(signed int *)(v15 + 8);
    if ( v16 > 0 )
    {
      v17 = *(_QWORD *)(v15 + 16);
      v18 = 0i64;
      do
        *(_BYTE *)(*(_QWORD *)(v17 + 8 * v18++) + 56i64) = 0;
      while ( v16 != v18 );
    }
    *((_BYTE *)v9 + 56) = 1;
    sub_2DD3B((__int64)v1);
  }
  else
  {
    v6 = *(_QWORD *)(v4 + 16);
    v7 = a1[1];
    v8 = 0i64;
    while ( *(_QWORD *)(*(_QWORD *)(v6 + 8 * v8) + 8i64) != v7 )
    {
      if ( ++v8 >= v5 )
        goto LABEL_7;
    }
    v19 = 0i64;
    do
      *(_BYTE *)(*(_QWORD *)(v6 + 8 * v19++) + 56i64) = 0;
    while ( v5 != v19 );
    *(_BYTE *)(*(_QWORD *)(v3 + 80) + 56i64) = 1;
  }
  return 0i64;
}

//----- (000000000002DD3B) ----------------------------------------------------
void __fastcall sub_2DD3B(__int64 a1)
{
  __int64 v1; // r15
  __int64 v2; // r14
  __int64 v3; // rsi
  __int64 v4; // rdi
  int v5; // er12
  int v6; // er13
  _QWORD *v7; // rbx
  _DWORD **v8; // rax
  _DWORD *v9; // rdi
  int v10; // er12
  void (__fastcall *v11)(__int64, _QWORD); // rax
  __int64 v12; // r9
  __int64 v13; // [rsp-10h] [rbp-70h]
  __int64 *v14; // [rsp+0h] [rbp-60h]
  __int64 v15; // [rsp+10h] [rbp-50h]
  __int64 v16; // [rsp+18h] [rbp-48h]
  int v17; // [rsp+24h] [rbp-3Ch]

  v1 = *(_QWORD *)(a1 + 40);
  if ( v1 )
  {
    v2 = a1;
    v3 = *(_QWORD *)v1;
    v4 = **(_QWORD **)(*(_QWORD *)v1 + 64i64);
    if ( v4 )
    {
      v5 = *(_DWORD *)(v4 + 44);
      v17 = *(_DWORD *)(v4 + 48);
      v6 = *(_DWORD *)(v4 + 56) / 2;
      v7 = *(_QWORD **)(v4 + 80);
    }
    else
    {
      sub_1A11E();
      v6 = 0;
      v5 = 0;
      v17 = 0;
      v7 = 0i64;
    }
    if ( *(_QWORD *)(v3 + 88) )
      (*(void (**)(void))(qword_96CD8 + 72))();
    if ( *(_QWORD *)(v3 + 96) )
      (*(void (**)(void))(qword_96CD8 + 72))();
    *(_QWORD *)(v3 + 88) = 0i64;
    *(_QWORD *)(v3 + 96) = 0i64;
    if ( v7 )
    {
      sub_27500(v4, 0);
      sub_3F6AA(v7);
      sub_3F1DC((__int64)v7, (__int64 *)v4);
    }
    **(_QWORD **)(v3 + 64) = 0i64;
    sub_2C982(v3, 0);
    v8 = *(_DWORD ***)(v3 + 64);
    v9 = *v8;
    if ( *v8 )
    {
      v10 = v6 + v5 - v9[14] / 2;
      v9[12] = v17;
      v9[11] = v10;
      if ( v7 )
      {
        sub_3F340((__int64)v7, (__int64)v9);
        sub_1A11E();
        v8 = *(_DWORD ***)(v3 + 64);
      }
      *v8 = v9;
    }
    else
    {
      sub_1A11E();
    }
    *(_QWORD *)(v3 + 32) = sub_2D39E(v2);
    v11 = *(void (__fastcall **)(__int64, _QWORD))(v3 + 40);
    if ( v11 )
      v11(v3, *(_QWORD *)(v3 + 48));
    v12 = *(_QWORD *)(v1 + 8);
    sub_1A11E();
    v16 = -9034400514174975832i64;
    v15 = 5457143572451254544i64;
    sub_F180((char *)&v13, 0, 0x20ui64);
    sub_18905((unsigned __int64)&v13, (__int64)"%d_%s", *(unsigned int *)(v1 + 16), *(_QWORD *)(v1 + 8));
    v14 = &v13;
    (*(void (__fastcall **)(const __int16 *, __int64 *, signed __int64, signed __int64, __int64 *))(qword_96CE0 + 88))(
      L"flagstate",
      &v15,
      1i64,
      32i64,
      &v13);
    v14 = (__int64 *)(v3 + 16);
    (*(void (__fastcall **)(const __int16 *, __int64 *, signed __int64, signed __int64, __int64))(qword_96CE0 + 88))(
      L"flagarchiveID",
      &v15,
      1i64,
      4i64,
      v3 + 16);
  }
  else
  {
    sub_1A11E();
  }
}
// 417B0: using guessed type __int16 aFlagstate[10];
// 417C4: using guessed type __int16 aFlagarchiveid[14];
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (000000000002E005) ----------------------------------------------------
signed __int64 __fastcall sub_2E005(__int64 *a1)
{
  __int64 *v1; // rsi
  __int64 v3; // [rsp+30h] [rbp-10h]

  if ( a1[7] )
  {
    sub_1A11E();
    return 1i64;
  }
  v1 = a1;
  v3 = 0i64;
  if ( sub_27CFB((__int64 **)&v3)
    || (*(__int64 (__fastcall **)(signed __int64, void (__fastcall *)(__int64, __int64), __int64 *, __int64 *))(v3 + 8))(
         3i64,
         sub_2E0D9,
         v1 + 7,
         v1) )
  {
    sub_1A11E();
    return 1i64;
  }
  if ( sub_3F3B4(*v1, v1[3], 255, (__int64)sub_2E144, 0i64) )
    sub_1A11E();
  return 0i64;
}

//----- (000000000002E0D9) ----------------------------------------------------
void __fastcall sub_2E0D9(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  int v4; // eax
  __int64 v5; // [rsp+28h] [rbp-18h]

  v2 = a2;
  v3 = a1;
  sub_26AE1(&v5, *(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 32));
  v4 = *(_DWORD *)(v3 + 16) & 0x1F;
  if ( v4 == 2 )
  {
    sub_2EF5F(v2, v5);
    sub_2FACD((__int64)sub_2F2DC, v2, 0i64, (__int64)"aquaMenu_mouseDown_deferred");
  }
  else if ( v4 == 1 )
  {
    sub_2EF5F(v2, v5);
  }
}

//----- (000000000002E144) ----------------------------------------------------
char sub_2E144()
{
  return 1;
}

//----- (000000000002E14C) ----------------------------------------------------
void __fastcall sub_2E14C(__int64 a1, char a2)
{
  __int64 *v2; // r15
  __int64 v3; // rax
  unsigned __int64 v4; // r12
  __int64 *v5; // r14
  __int64 v6; // rcx
  _QWORD **v7; // rbx
  unsigned __int64 v8; // rdi
  __int64 *v9; // rsi
  void (__fastcall *v10)(__int64 *, __int64); // rax
  unsigned __int64 v11; // rdi
  __int64 v12; // rbx
  __int64 *v13; // rdx
  __int64 *v14; // [rsp+0h] [rbp-50h]
  __int64 v15; // [rsp+8h] [rbp-48h]
  __int64 v16; // [rsp+10h] [rbp-40h]

  if ( *(_QWORD *)(a1 + 24) )
  {
    v14 = (__int64 *)&v14;
    v2 = (__int64 *)(&v14 - 8);
    v3 = 0i64;
    v15 = a1;
    do
    {
      v2[v3++] = a1;
      if ( !a2 )
        break;
      a1 = *(_QWORD *)(a1 + 80);
    }
    while ( a1 );
    v2[(unsigned int)v3] = 0i64;
    v4 = 0i64;
    do
    {
      v5 = (__int64 *)v2[v4];
      if ( !v5 )
        break;
      if ( v5[7] )
      {
        v16 = 0i64;
        if ( sub_27CFB((__int64 **)&v16)
          || (*(__int64 (__fastcall **)(__int64))(v16 + 16))(v5[7])
          || (v5[7] = 0i64, sub_3F58B(*v5, v5[3])) )
        {
          sub_1A11E();
        }
      }
      else
      {
        sub_1A11E();
      }
      v6 = v5[6];
      if ( v6 )
      {
        sub_35A74(v6);
        v5[6] = 0i64;
      }
      ++v4;
    }
    while ( v4 < 8 );
    v7 = (_QWORD **)v15;
    if ( *(_QWORD *)(*(_QWORD *)(v15 + 24) + 80i64) )
    {
      v8 = 0i64;
      do
      {
        v9 = (__int64 *)v2[v8];
        if ( !v9 )
          break;
        sub_275C4(v9[3], 0);
        sub_275C4(v9[4], 0);
        v10 = (void (__fastcall *)(__int64 *, __int64))v9[11];
        if ( v10 )
          v10(v9, v9[12]);
        ++v8;
      }
      while ( v8 < 8 );
      sub_3F6AA(*v7);
      v11 = 0i64;
      do
      {
        v12 = v2[v11];
        if ( !v12 )
          break;
        v13 = *(__int64 **)(v12 + 24);
        if ( v13 )
        {
          sub_3F1DC(*(_QWORD *)v12, v13);
          sub_3F1DC(*(_QWORD *)v12, *(__int64 **)(v12 + 32));
          *(_QWORD *)(v12 + 24) = 0i64;
          *(_QWORD *)(v12 + 32) = 0i64;
        }
        ++v11;
      }
      while ( v11 < 8 );
    }
  }
}

//----- (000000000002E379) ----------------------------------------------------
__int64 __fastcall sub_2E379(__int64 a1)
{
  __int64 v1; // rsi
  unsigned int v2; // eax

  v1 = a1;
  v2 = sub_31FAA(*(_QWORD *)(a1 + 24));
  if ( v2 != -1 )
  {
    if ( *(_DWORD *)(v1 + 8) > v2 )
      return *(_QWORD *)(*(_QWORD *)(v1 + 16) + 8i64 * v2);
    sub_1A11E();
  }
  return 0i64;
}

//----- (000000000002E3C8) ----------------------------------------------------
__int64 __fastcall sub_2E3C8(__int64 a1, unsigned int a2)
{
  if ( *(_DWORD *)(a1 + 8) > a2 )
    return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8i64 * a2);
  sub_1A11E();
  return 0i64;
}

//----- (000000000002E405) ----------------------------------------------------
void __fastcall sub_2E405(__int64 a1, __int64 a2, __int64 a3)
{
  *(_QWORD *)(a1 + 88) = a2;
  *(_QWORD *)(a1 + 96) = a3;
}

//----- (000000000002E413) ----------------------------------------------------
__int64 __fastcall sub_2E413(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // r14
  int v4; // edi
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rsi

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = sub_24136(120i64);
  v7 = v6;
  *(_DWORD *)(v6 + 8) = v4;
  *(_QWORD *)(v6 + 16) = v3;
  *(_QWORD *)v6 = v5;
  *(_QWORD *)(v6 + 112) = sub_24136(240i64);
  return v7;
}

//----- (000000000002E45B) ----------------------------------------------------
signed __int64 __fastcall sub_2E45B(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // r13
  __int64 v6; // r15
  __int64 v7; // rax
  __int64 *v8; // rsi
  int *v9; // r12
  bool v10; // zf
  bool v11; // sf
  __int64 v12; // rcx
  signed __int64 v13; // rax
  int v14; // er14
  signed int v15; // edi
  __int64 v16; // rdx
  __int64 v17; // rbx
  __int64 v18; // rbx
  int v19; // eax
  int v20; // ecx
  __int64 v21; // ST20_8
  signed __int64 v22; // r15
  signed __int64 v23; // rsi
  __int64 *v24; // rdi
  __int64 v25; // rax
  __int64 v26; // rcx
  _DWORD *v27; // rbx
  int v28; // esi
  char v29; // al
  __int64 *v30; // r8
  __int64 v31; // rcx
  int v32; // edi
  int v33; // eax
  int v34; // eax
  __int64 v35; // rcx
  int v36; // eax
  __int64 *v37; // rsi
  signed __int64 result; // rax
  signed __int64 v39; // rbx
  __int64 v40; // rcx
  __int64 v41; // rax
  __int64 v42; // rax
  __int64 v43; // rcx
  __int64 v44; // rax
  __int64 v45; // rax
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 *v48; // rax
  __int64 v49; // rdx
  __int64 *v50; // rsi
  unsigned int v51[4]; // [rsp+40h] [rbp-90h]
  _DWORD *v52; // [rsp+50h] [rbp-80h]
  __int64 v53; // [rsp+58h] [rbp-78h]
  __int64 v54; // [rsp+60h] [rbp-70h]
  __int64 *v55; // [rsp+68h] [rbp-68h]
  char v56; // [rsp+70h] [rbp-60h]
  int v57; // [rsp+78h] [rbp-58h]
  int v58; // [rsp+7Ch] [rbp-54h]
  int j; // [rsp+80h] [rbp-50h]
  int i; // [rsp+84h] [rbp-4Ch]
  __int64 v61; // [rsp+90h] [rbp-40h]

  v2 = a2;
  v3 = a1;
  v4 = 8i64 * *(signed int *)(a1 + 8);
  v5 = sub_24103(8i64 * *(signed int *)(a1 + 8));
  v6 = sub_24103(v4);
  v7 = sub_24103(v4);
  v8 = (__int64 *)v3;
  v9 = (int *)v7;
  v10 = *(_DWORD *)(v3 + 8) == 0;
  v11 = *(_DWORD *)(v3 + 8) < 0;
  v52 = (_DWORD *)v2;
  if ( v11 || v10 )
  {
    v15 = 0;
    v14 = 0;
  }
  else
  {
    v12 = *(_QWORD *)(v3 + 16);
    v13 = 0i64;
    v14 = 0;
    v15 = 0;
    do
    {
      *(_QWORD *)(v5 + 8 * v13) = *(_QWORD *)(*(_QWORD *)(v12 + 8 * v13) + 8i64);
      *(_QWORD *)(v6 + 8 * v13) = *(_QWORD *)(*(_QWORD *)(v8[2] + 8 * v13) + 16i64);
      v16 = *(_QWORD *)(*(_QWORD *)(v8[2] + 8 * v13) + 24i64);
      *(_QWORD *)&v9[2 * v13] = v16;
      v12 = v8[2];
      v17 = *(_QWORD *)(v12 + 8 * v13);
      if ( !*(_BYTE *)v17 && v9[2 * v13 + 1] >= v14 )
        v14 = v9[2 * v13 + 1];
      v15 += v16;
      *(_DWORD *)(v17 + 60) = v13++;
    }
    while ( v13 < *((signed int *)v8 + 2) );
  }
  v55 = v8;
  v18 = (__int64)v8;
  v19 = 2 - ((unsigned __int8)sub_3FBF3() < 1u);
  v20 = *(_DWORD *)(*v8 + 8);
  if ( 800 * v19 <= v20 )
    v20 = 800 * v19;
  if ( v15 > v20 )
  {
    *((_BYTE *)v55 + 40) = 1;
    v15 = v20 - (v19 << 6);
  }
  sub_26B03(&v56, 32, 32, v14, v15);
  v21 = v6;
  v22 = (signed __int64)(v8 + 3);
  v23 = sub_319E8(v8 + 3, (__int64)&v56, *((_DWORD *)v8 + 2), v5, v21, v9);
  sub_321F6(*(_QWORD *)(v18 + 24), (__int64)sub_2F3F7, v18);
  sub_32215(*(_QWORD *)(v18 + 24), (__int64)sub_2F563, v18);
  *(_BYTE *)(*(_QWORD *)(v18 + 24) + 40i64) = 1;
  if ( v23 )
    sub_1A11E();
  sub_26E30(v51, 255, 255, 255, 13);
  v24 = v55;
  sub_3205B(v55[3], v51[0]);
  sub_3217A(v24[3], *(_QWORD *)v24[14], (_QWORD *)(v24[14] + 8));
  sub_26FF5(v24[3], 8000);
  v25 = v24[3];
  v26 = *(_QWORD *)(v25 + 44);
  v54 = *(_QWORD *)(v25 + 52);
  v53 = v26;
  v27 = v52;
  v28 = v52[1] + v54;
  v53 = *(_QWORD *)v52;
  v29 = sub_3FBF3();
  v30 = v24;
  v31 = *v24;
  if ( v28 > *(_DWORD *)(*v24 + 8) )
  {
    v32 = 32 * (v29 != 0);
    sub_1A11E();
    v30 = v55;
    v31 = *v55;
    v33 = HIDWORD(v53) + *(_DWORD *)(*v55 + 8) - (v32 + v28 + 32);
    if ( v33 < v32 + 32 )
      v33 = v32 + 32;
    HIDWORD(v53) = v33;
  }
  v34 = *(_DWORD *)(v31 + 12);
  if ( HIDWORD(v54) + *v27 > v34 )
  {
    v35 = v30[10];
    if ( v35 )
      v36 = *(_DWORD *)(*(_QWORD *)(v35 + 24) + 44i64) - HIDWORD(v54);
    else
      v36 = v34 - HIDWORD(v54) - 16;
    LODWORD(v53) = v36;
  }
  v37 = v30;
  sub_27402((_DWORD *)v30[3], &v53);
  if ( sub_3F340(*v37, v37[3]) )
  {
    sub_1A11E();
    result = 1i64;
  }
  else
  {
    v39 = (signed __int64)(v37 + 14);
    v61 = 0i64;
    sub_26B03(
      &v56,
      *(_DWORD *)(*(_QWORD *)v22 + 44i64) - *(_DWORD *)(*(_QWORD *)v39 + 140i64),
      *(_DWORD *)(*(_QWORD *)v22 + 48i64) - *(_DWORD *)(v37[14] + 168),
      *(_DWORD *)(*(_QWORD *)v39 + 124i64) + *(_DWORD *)(*(_QWORD *)v22 + 56i64) + *(_DWORD *)(*(_QWORD *)v39 + 140i64),
      *(_DWORD *)(v37[14] + 216) + *(_DWORD *)(*(_QWORD *)v22 + 52i64) + *(_DWORD *)(v37[14] + 168));
    sub_26E4B(&v61, (__int64)&v56);
    sub_26FF5(v61, 8000);
    v40 = 4 * v58 * (signed __int64)v57;
    v41 = v61;
    *(_QWORD *)(v61 + 24) = v40;
    *(_QWORD *)(v41 + 32) = *(_QWORD *)&v57;
    v42 = sub_24103(v40);
    v43 = v61;
    *(_QWORD *)(v61 + 16) = v42;
    sub_26B03(v51, 0, 0, *(_DWORD *)(v43 + 36), *(_DWORD *)(v43 + 32));
    sub_2445C(-1, *(_QWORD *)(v61 + 16), (unsigned int *)(v61 + 32), v51);
    if ( *(_QWORD *)(v37[14] + 128) )
    {
      sub_26B03(&j, 0, 0, *(_DWORD *)(v37[14] + 140), *(_DWORD *)(v37[14] + 136));
      v44 = *(_QWORD *)v39;
      for ( i = *(_DWORD *)(*(_QWORD *)v39 + 152i64);
            i < v57 - *(_DWORD *)(v44 + 200);
            i += *(_DWORD *)(*(_QWORD *)v39 + 136i64) )
      {
        if ( sub_244D1(
               *(_QWORD *)(v61 + 16),
               v61 + 32,
               &j,
               *(_QWORD *)(v44 + 128),
               (int *)(v44 + 136),
               &j,
               0,
               v61 + 176) )
        {
          sub_1A11E();
        }
        v44 = *(_QWORD *)v39;
      }
    }
    else
    {
      sub_1A11E();
      v44 = *(_QWORD *)v39;
    }
    if ( *(_QWORD *)(v44 + 112) )
    {
      sub_26B03(&j, v58 - *(_DWORD *)(v44 + 124), 0, *(_DWORD *)(v44 + 124), *(_DWORD *)(v44 + 120));
      v45 = *(_QWORD *)v39;
      for ( i = *(_DWORD *)(*(_QWORD *)v39 + 184i64);
            i < v57 - *(_DWORD *)(v45 + 200);
            i += *(_DWORD *)(*(_QWORD *)v39 + 120i64) )
      {
        if ( sub_244D1(
               *(_QWORD *)(v61 + 16),
               v61 + 32,
               &j,
               *(_QWORD *)(v45 + 112),
               (int *)(v45 + 120),
               &j,
               0,
               v61 + 176) )
        {
          sub_1A11E();
        }
        v45 = *(_QWORD *)v39;
      }
    }
    else
    {
      sub_1A11E();
      v45 = *(_QWORD *)v39;
    }
    if ( !*(_QWORD *)(v45 + 144)
      || (sub_26B03(&j, 0, 0, *(_DWORD *)(v45 + 156), *(_DWORD *)(v45 + 152)),
          sub_2445C(-1, *(_QWORD *)(v61 + 16), (unsigned int *)(v61 + 32), (unsigned int *)&j),
          sub_244D1(
            *(_QWORD *)(v61 + 16),
            v61 + 32,
            &j,
            *(_QWORD *)(*(_QWORD *)v39 + 144i64),
            (int *)(*(_QWORD *)v39 + 152i64),
            &j,
            0,
            v61 + 176)) )
    {
      sub_1A11E();
    }
    if ( *(_QWORD *)(*(_QWORD *)v39 + 160i64) )
    {
      sub_26B03(&j, 0, 0, *(_DWORD *)(*(_QWORD *)v39 + 172i64), *(_DWORD *)(*(_QWORD *)v39 + 168i64));
      v46 = *(_QWORD *)v39;
      for ( j = *(_DWORD *)(*(_QWORD *)v39 + 156i64);
            j < v58 - *(_DWORD *)(v46 + 188);
            j += *(_DWORD *)(*(_QWORD *)v39 + 172i64) )
      {
        if ( sub_244D1(
               *(_QWORD *)(v61 + 16),
               v61 + 32,
               &j,
               *(_QWORD *)(v46 + 160),
               (int *)(v46 + 168),
               &j,
               0,
               v61 + 176) )
        {
          sub_1A11E();
        }
        v46 = *(_QWORD *)v39;
      }
    }
    else
    {
      sub_1A11E();
      v46 = *(_QWORD *)v39;
    }
    if ( !*(_QWORD *)(v46 + 176)
      || (sub_26B03(&j, v58 - *(_DWORD *)(v46 + 188), 0, *(_DWORD *)(v46 + 188), *(_DWORD *)(v46 + 184)),
          sub_2445C(-1, *(_QWORD *)(v61 + 16), (unsigned int *)(v61 + 32), (unsigned int *)&j),
          sub_244D1(
            *(_QWORD *)(v61 + 16),
            v61 + 32,
            &j,
            *(_QWORD *)(*(_QWORD *)v39 + 176i64),
            (int *)(*(_QWORD *)v39 + 184i64),
            &j,
            0,
            v61 + 176)) )
    {
      sub_1A11E();
    }
    if ( !*(_QWORD *)(*(_QWORD *)v39 + 192i64)
      || (sub_26B03(
            &j,
            0,
            v57 - *(_DWORD *)(*(_QWORD *)v39 + 200i64),
            *(_DWORD *)(*(_QWORD *)v39 + 204i64),
            *(_DWORD *)(*(_QWORD *)v39 + 200i64)),
          sub_2445C(-1, *(_QWORD *)(v61 + 16), (unsigned int *)(v61 + 32), (unsigned int *)&j),
          sub_244D1(
            *(_QWORD *)(v61 + 16),
            v61 + 32,
            &j,
            *(_QWORD *)(*(_QWORD *)v39 + 192i64),
            (int *)(*(_QWORD *)v39 + 200i64),
            &j,
            0,
            v61 + 176)) )
    {
      sub_1A11E();
    }
    if ( *(_QWORD *)(*(_QWORD *)v39 + 208i64) )
    {
      sub_26B03(
        &j,
        0,
        v57 - *(_DWORD *)(*(_QWORD *)v39 + 200i64),
        *(_DWORD *)(*(_QWORD *)v39 + 220i64),
        *(_DWORD *)(*(_QWORD *)v39 + 216i64));
      v47 = *(_QWORD *)v39;
      for ( j = *(_DWORD *)(*(_QWORD *)v39 + 204i64);
            j < v58 - *(_DWORD *)(v47 + 236);
            j += *(_DWORD *)(*(_QWORD *)v39 + 220i64) )
      {
        if ( sub_244D1(
               *(_QWORD *)(v61 + 16),
               v61 + 32,
               &j,
               *(_QWORD *)(v47 + 208),
               (int *)(v47 + 216),
               &j,
               0,
               v61 + 176) )
        {
          sub_1A11E();
        }
        v47 = *(_QWORD *)v39;
      }
    }
    else
    {
      sub_1A11E();
      v47 = *(_QWORD *)v39;
    }
    if ( !*(_QWORD *)(v47 + 224)
      || (sub_26B03(
            &j,
            v58 - *(_DWORD *)(v47 + 236),
            v57 - *(_DWORD *)(v47 + 200),
            *(_DWORD *)(v47 + 236),
            *(_DWORD *)(v47 + 232)),
          sub_2445C(-1, *(_QWORD *)(v61 + 16), (unsigned int *)(v61 + 32), (unsigned int *)&j),
          sub_244D1(
            *(_QWORD *)(v61 + 16),
            v61 + 32,
            &j,
            *(_QWORD *)(*(_QWORD *)v39 + 224i64),
            (int *)(*(_QWORD *)v39 + 232i64),
            &j,
            0,
            v61 + 176)) )
    {
      sub_1A11E();
    }
    v48 = v55;
    v49 = v61;
    v55[4] = v61;
    if ( v49 )
    {
      if ( sub_3F340(*v48, v49) )
        sub_1A11E();
    }
    else
    {
      sub_1A11E();
    }
    v50 = v55;
    sub_2E005(v55);
    result = sub_3F6AA((_QWORD *)*v50);
  }
  return result;
}

//----- (000000000002EEC1) ----------------------------------------------------
__int64 __fastcall sub_2EEC1(__int64 a1)
{
  return *(unsigned int *)(a1 + 8);
}

//----- (000000000002EECA) ----------------------------------------------------
_QWORD *__fastcall sub_2EECA(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rbx
  __int64 v9; // rsi
  _QWORD *result; // rax

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  result = (_QWORD *)sub_24136(64i64);
  result[1] = v9;
  result[2] = v8;
  result[3] = v7;
  result[4] = v6;
  result[5] = a5;
  result[6] = a6;
  return result;
}

//----- (000000000002EF20) ----------------------------------------------------
__int64 __fastcall sub_2EF20(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = a2;
  v3 = a1;
  result = sub_24136(64i64);
  *(_QWORD *)(result + 8) = v3;
  *(_QWORD *)(result + 16) = v3;
  *(_QWORD *)(result + 24) = v2;
  *(_QWORD *)(result + 32) = 0i64;
  *(_QWORD *)(result + 40) = 0i64;
  *(_QWORD *)(result + 48) = 0i64;
  *(_BYTE *)result = 1;
  return result;
}

//----- (000000000002EF5F) ----------------------------------------------------
void __fastcall sub_2EF5F(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rdi
  __int64 v3; // r14
  _DWORD *v4; // r15
  signed int v5; // edx
  int v6; // er9
  int v7; // ecx
  __int64 v8; // rcx
  __int64 v9; // rcx
  int v10; // edx
  int v11; // eax
  int v12; // er9
  int v13; // ecx
  unsigned __int64 v14; // rdi
  __int64 v15; // rcx
  unsigned int v16; // eax
  signed int v17; // edx
  signed int v18; // ecx
  signed int v19; // eax
  __int64 v20; // [rsp+28h] [rbp-38h]
  char v21; // [rsp+36h] [rbp-2Ah]
  char v22; // [rsp+37h] [rbp-29h]

  v2 = a2;
  v3 = a1;
  v20 = a2;
  v4 = *(_DWORD **)(a1 + 24);
  sub_2F139(a1, (bool *)&v21, (bool *)&v22);
  v5 = v4[11];
  v6 = 0;
  v7 = 0;
  if ( v5 <= (signed int)v2 && v4[14] + v5 >= (signed int)v2 )
  {
    v11 = v4[12];
    LOBYTE(v6) = v21 != 0;
    v12 = v11 + 16 * v6;
    LOBYTE(v7) = v22 == 0;
    v13 = 16 * v7 + v4[13] + v11 - 16;
    v14 = v2 >> 32;
    if ( v12 > (signed int)v14 || v13 < (signed int)v14 )
    {
      v17 = v12 - v14;
      if ( v12 <= (signed int)v14 )
        v17 = v14 - v13;
      v18 = -12;
      if ( v12 > (signed int)v14 )
        v18 = 12;
      if ( v17 > 15 )
      {
        *(_DWORD *)(v3 + 68) = 4 * (v12 > (signed int)v14) - 2;
        v19 = *(_DWORD *)(v3 + 64);
        if ( v12 <= (signed int)v14 )
        {
          if ( v19 <= v18 )
            v18 = *(_DWORD *)(v3 + 64);
        }
        else if ( v19 >= v18 )
        {
          v18 = *(_DWORD *)(v3 + 64);
        }
        *(_DWORD *)(v3 + 64) = v18;
      }
      else
      {
        *(_DWORD *)(v3 + 64) = v18;
        *(_DWORD *)(v3 + 68) = 0;
      }
      if ( *(_BYTE *)(v3 + 40) && !*(_QWORD *)(v3 + 48) )
        *(_QWORD *)(v3 + 48) = sub_359AF((__int64)sub_2F273, v3, (__int64)qword_7A120, 1u);
    }
    else
    {
      v15 = *(_QWORD *)(v3 + 48);
      if ( v15 )
      {
        sub_35A74(v15);
        *(_QWORD *)(v3 + 48) = 0i64;
      }
      v16 = sub_3213A((__int64)v4, &v20);
      if ( v16 != -1 )
      {
        v10 = v16;
        v9 = *(_QWORD *)(v3 + 24);
        if ( (v16 & 0x80000000) == 0 )
        {
          if ( *(_DWORD *)(v3 + 8) <= v16 )
            sub_402B7();
          v10 = -(**(_BYTE **)(*(_QWORD *)(v3 + 16) + 8i64 * v16) >= 1u) | v16;
        }
        goto LABEL_7;
      }
    }
  }
  else
  {
    v8 = *(_QWORD *)(v3 + 48);
    if ( v8 )
    {
      sub_35A74(v8);
      *(_QWORD *)(v3 + 48) = 0i64;
    }
  }
  if ( *(_QWORD *)(v3 + 72) )
    return;
  v9 = *(_QWORD *)(v3 + 24);
  v10 = -1;
LABEL_7:
  if ( sub_320A3(v9, v10) )
    sub_1A11E();
  sub_2FACD((__int64)sub_2F190, v3, 0i64, (__int64)"aquaMenu_mouseMoved_deferred");
}
// 7A120: using guessed type __int64 qword_7A120[512];

//----- (000000000002F139) ----------------------------------------------------
unsigned __int64 __fastcall sub_2F139(__int64 a1, bool *a2, bool *a3)
{
  bool *v3; // rsi
  bool *v4; // rbx
  __int64 v5; // rdi
  int v6; // er14
  unsigned __int64 result; // rax
  char v8; // [rsp+20h] [rbp-30h]
  int v9; // [rsp+24h] [rbp-2Ch]
  int v10; // [rsp+28h] [rbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = sub_3201C(*(_QWORD *)(a1 + 24));
  result = (unsigned __int64)sub_31FE6(&v8, *(_QWORD *)(v5 + 24));
  if ( v4 )
    *v4 = v9 != 0;
  if ( v3 )
  {
    result = (unsigned int)(v9 + v10);
    *v3 = (_DWORD)result != v6;
  }
  return result;
}

//----- (000000000002F190) ----------------------------------------------------
__int64 __fastcall sub_2F190(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // r15
  __int64 v4; // rax
  __int64 v5; // rsi
  __int64 v6; // rcx
  _QWORD *v7; // rbx
  __int64 v8; // rax
  int v9; // eax
  __int64 v10; // rcx
  __int64 v11; // r9
  char v13; // [rsp+20h] [rbp-40h]
  int v14; // [rsp+24h] [rbp-3Ch]
  int v15; // [rsp+2Ch] [rbp-34h]
  char v16; // [rsp+30h] [rbp-30h]

  v2 = a2;
  v3 = *(_QWORD *)(a2 + 24);
  v4 = sub_2E379(a2);
  v5 = v4;
  if ( v4 )
  {
    v6 = *(_QWORD *)(v2 + 72);
    if ( *(_QWORD *)(v4 + 48) == v6 )
      return 0i64;
    v7 = (_QWORD *)(v2 + 72);
  }
  else
  {
    v7 = (_QWORD *)(v2 + 72);
    v6 = *(_QWORD *)(v2 + 72);
  }
  if ( v6 )
  {
    sub_2E14C(v6, 0);
    *v7 = 0i64;
  }
  if ( v5 )
  {
    if ( v3 )
    {
      v8 = *(_QWORD *)(v5 + 48);
      if ( v8 )
      {
        *(_QWORD *)(v2 + 72) = v8;
        v9 = sub_31FAA(v3);
        sub_32195(&v13, v3, v9);
        sub_26AE1(&v16, *(_DWORD *)&v13 + v15, v14);
        v10 = *(_QWORD *)(v5 + 48);
        *(_QWORD *)(v2 + 72) = v10;
        *(_QWORD *)(v10 + 80) = v2;
        --*(_DWORD *)&v16;
        if ( sub_2E45B(v10, (__int64)&v16) )
        {
          v11 = *(_QWORD *)(v5 + 48);
          sub_1A11E();
        }
      }
    }
  }
  return 0i64;
}

//----- (000000000002F273) ----------------------------------------------------
void __fastcall sub_2F273(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  int v4; // eax
  signed __int64 v5; // rax
  _QWORD *v6; // rcx

  v2 = a2;
  v3 = *(_QWORD *)(a2 + 24);
  v4 = sub_31F31(*(_QWORD *)(a2 + 24));
  v5 = sub_31F4D(v3, *(_DWORD *)(v2 + 64) + v4);
  *(_DWORD *)(v2 + 64) += *(_DWORD *)(v2 + 68);
  if ( v5 )
  {
    sub_1A11E();
  }
  else
  {
    v6 = *(_QWORD **)(v3 + 80);
    if ( v6 )
      sub_3F6AA(v6);
  }
}

//----- (000000000002F2DC) ----------------------------------------------------
__int64 __fastcall sub_2F2DC(__int64 a1, __int64 a2)
{
  __int64 v2; // r12
  __int64 v3; // rax
  __int64 v4; // rdi
  __int64 v6; // rbx
  signed int v7; // er13
  __int64 v8; // rax
  __int64 v9; // r15
  __int64 v10; // rsi
  signed int v11; // er14
  void (__fastcall *v12)(__int64); // rax
  __int64 v13; // [rsp+20h] [rbp-40h]

  v2 = a2;
  v3 = sub_2E379(a2);
  if ( v3 )
  {
    v4 = v3;
    if ( !*(_BYTE *)v3 )
    {
      if ( *(_QWORD *)(v3 + 48) )
        return 0i64;
      v6 = *(_QWORD *)(v2 + 24);
      if ( v6 )
      {
        v7 = sub_31FAA(*(_QWORD *)(v2 + 24));
        v8 = *(_QWORD *)(v6 + 160);
        v13 = *(_QWORD *)(v8 + 104);
        v9 = *(_QWORD *)(v8 + 112);
        sub_321E1(v6, 0i64, 0i64);
        v10 = (unsigned __int64)(0x3E8 * (unsigned __int128)0x8888888888888889ui64 >> 64) >> 3;
        v11 = 2;
        do
        {
          sub_320A3(v6, -1);
          sub_2FB5E(*(_QWORD **)(v6 + 80), v10);
          sub_320A3(v6, v7);
          sub_2FB5E(*(_QWORD **)(v6 + 80), v10);
          --v11;
        }
        while ( v11 );
        sub_321E1(v6, v13, v9);
      }
      else
      {
        sub_1A11E();
      }
      v12 = *(void (__fastcall **)(__int64))(v4 + 32);
      if ( v12 )
        v12(v4);
    }
  }
  sub_2E14C(v2, 1);
  return 0i64;
}

//----- (000000000002F3F7) ----------------------------------------------------
signed __int64 __fastcall sub_2F3F7(__int64 a1, __int64 a2, unsigned int a3, _DWORD *a4)
{
  _DWORD *v4; // rdi
  __int64 v5; // rbx
  __int64 v6; // rsi
  __int64 v7; // r14
  __int64 v8; // rax
  __int64 v9; // rdx
  signed __int64 v10; // rsi
  __int64 v11; // rdx
  int v13; // [rsp+40h] [rbp-30h]
  int v14; // [rsp+44h] [rbp-2Ch]
  __int64 v15; // [rsp+48h] [rbp-28h]

  v4 = a4;
  v5 = a2;
  v6 = a1;
  if ( *(_DWORD *)(a2 + 8) <= a3 )
  {
    sub_1A11E();
    v7 = 0i64;
  }
  else
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8i64 * a3);
  }
  v8 = sub_2E379(v5);
  if ( *(_QWORD *)(v7 + 48) )
  {
    v9 = *(_QWORD *)(v5 + 112);
    v13 = v4[3] + *v4 - *(_DWORD *)(v9 + 36) - 10;
    v14 = v4[1] + (v4[2] - *(_DWORD *)(v9 + 32)) / 2;
    v15 = *(_QWORD *)(v9 + 32);
    v10 = sub_244D1(
            *(_QWORD *)(v6 + 16),
            v6 + 52,
            &v13,
            *(_QWORD *)(v9 + 8i64 * (v8 == v7) + 16),
            (int *)(v9 + 32),
            &v13,
            0,
            v6 + 176);
    if ( v10 )
    {
LABEL_9:
      sub_1A11E();
      return v10;
    }
  }
  else
  {
    if ( !*(_BYTE *)(v7 + 56) )
      return 0i64;
    v13 = 4;
    v14 = v4[1];
    v11 = *(_QWORD *)(v5 + 112);
    v15 = *(_QWORD *)(v11 + 104);
    v10 = sub_244D1(
            *(_QWORD *)(v6 + 16),
            v6 + 52,
            &v13,
            *(_QWORD *)(v11 + 8i64 * (v8 == v7) + 88),
            (int *)(v11 + 104),
            &v13,
            0,
            v6 + 176);
    if ( v10 )
      goto LABEL_9;
  }
  return v10;
}

//----- (000000000002F563) ----------------------------------------------------
signed __int64 __fastcall sub_2F563(__int64 a1, __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // rsi
  char v4; // al
  int v5; // edi
  __int64 v6; // rax
  signed __int64 v7; // rbx
  __int64 v8; // rax
  int v10; // [rsp+40h] [rbp-50h]
  int v11; // [rsp+44h] [rbp-4Ch]
  __int64 v12; // [rsp+48h] [rbp-48h]
  __int64 v13; // [rsp+50h] [rbp-40h]
  int v14; // [rsp+58h] [rbp-38h]
  int v15; // [rsp+5Ch] [rbp-34h]
  char v16; // [rsp+66h] [rbp-2Ah]
  char v17; // [rsp+67h] [rbp-29h]

  v2 = a2;
  v3 = a1;
  sub_2F139(a2, (bool *)&v16, (bool *)&v17);
  v4 = sub_3FBF3();
  v5 = 16 * (v4 != 0) + 16;
  if ( v16 )
  {
    v13 = 0i64;
    v14 = 16 * (v4 != 0) + 16;
    v15 = *(_DWORD *)(v3 + 56);
    if ( sub_2445C(
           *(_DWORD *)(*(_QWORD *)(v3 + 160) + 76i64),
           *(_QWORD *)(v3 + 16),
           (unsigned int *)(v3 + 32),
           (unsigned int *)&v13) )
    {
      sub_1A11E();
    }
    v6 = *(_QWORD *)(v2 + 112);
    v12 = *(_QWORD *)(v6 + 56);
    v10 = v13 + v15 / 2 - *(_DWORD *)(v6 + 60) / 2;
    v11 = 0;
    v7 = sub_244D1(*(_QWORD *)(v3 + 16), v3 + 32, &v10, *(_QWORD *)(v6 + 40), (int *)(v6 + 56), &v10, 0, v3 + 176);
    if ( v7 )
      sub_1A11E();
  }
  else
  {
    v7 = 0i64;
  }
  if ( v17 )
  {
    LODWORD(v13) = 0;
    HIDWORD(v13) = *(_DWORD *)(v3 + 52) - v5;
    v14 = v5;
    v15 = *(_DWORD *)(v3 + 56);
    if ( sub_2445C(
           *(_DWORD *)(*(_QWORD *)(v3 + 160) + 76i64),
           *(_QWORD *)(v3 + 16),
           (unsigned int *)(v3 + 32),
           (unsigned int *)&v13) )
    {
      sub_1A11E();
    }
    v8 = *(_QWORD *)(v2 + 112);
    v12 = *(_QWORD *)(v8 + 80);
    v10 = v13 + v15 / 2 - *(_DWORD *)(v8 + 84) / 2;
    v11 = HIDWORD(v13) + v5 - v12;
    v7 = sub_244D1(*(_QWORD *)(v3 + 16), v3 + 32, &v10, *(_QWORD *)(v8 + 64), (int *)(v8 + 80), &v10, 0, v3 + 176);
    if ( v7 )
      sub_1A11E();
  }
  return v7;
}

//----- (000000000002F778) ----------------------------------------------------
signed __int64 __fastcall sub_2F778(__int64 a1)
{
  __int64 v1; // rsi
  signed __int64 v2; // rax
  signed __int64 result; // rax

  if ( a1 )
  {
    v1 = a1;
    do
    {
      if ( *(_BYTE *)(v1 + 12) )
      {
        v2 = sub_3F6AA(*(_QWORD **)(v1 + 16));
        *(_BYTE *)(v1 + 12) = 0;
      }
      else
      {
        v2 = 0i64;
      }
      while ( *(_DWORD *)(v1 + 8) > 0 )
      {
        v2 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(v1 + 8i64 * *(signed int *)(v1 + 4) + 24))(
               v1,
               *(_QWORD *)(v1 + 8i64 * *(signed int *)(v1 + 4) + 1048),
               *(_QWORD *)(v1 + 8i64 * *(signed int *)(v1 + 4) + 2072));
        *(_QWORD *)(v1 + 8i64 * *(signed int *)(v1 + 4) + 24) = 0i64;
        --*(_DWORD *)(v1 + 8);
        *(_DWORD *)(v1 + 4) = *(_DWORD *)(v1 + 4)
                            - ((*(_DWORD *)(v1 + 4) + ((unsigned int)((*(_DWORD *)(v1 + 4) + 1) >> 31) >> 25) + 1) & 0xFFFFFF80)
                            + 1;
      }
      if ( v2 )
        sub_1A11E();
    }
    while ( !*(_BYTE *)v1 );
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v1);
    result = 0i64;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000002F868) ----------------------------------------------------
signed __int64 __fastcall sub_2F868(_BYTE *a1)
{
  _BYTE *v1; // rsi
  signed __int64 result; // rax

  v1 = a1;
  sub_1A11E();
  if ( v1 )
  {
    *v1 = 1;
    result = 0i64;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}

//----- (000000000002F8BC) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_2F8BC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rsi
  __int64 v6; // rcx
  signed __int64 result; // rax
  __int64 v8; // r9

  if ( a1 )
  {
    v5 = a1;
    if ( *(_DWORD *)(a1 + 8) > 127 )
    {
      ++dword_95208;
      sub_1A11E();
      v8 = *(unsigned int *)(v5 + 8);
      sub_1A11E();
      result = -1i64;
    }
    else
    {
      v6 = (*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 4)) % 128;
      *(_QWORD *)(v5 + 8 * v6 + 24) = a2;
      *(_QWORD *)(v5 + 8 * v6 + 1048) = a3;
      *(_QWORD *)(v5 + 8 * v6 + 2072) = a4;
      *(_QWORD *)(v5 + 8 * v6 + 3096) = a5;
      ++*(_DWORD *)(v5 + 8);
      result = 0i64;
    }
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}
// 2F941: write access to const memory at 95208 has been detected
// 95208: using guessed type int dword_95208;

//----- (000000000002F98D) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_2F98D()
{
  dword_9520C = 1;
}
// 2F991: write access to const memory at 9520C has been detected
// 9520C: using guessed type int dword_9520C;

//----- (000000000002F99D) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_2F99D(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rsi
  signed __int64 result; // rax

  v2 = a1;
  dword_9520C = 0;
  if ( sub_359AF((__int64)sub_2F98D, 0i64, 10000 * a2, 0) )
  {
    if ( v2 )
      sub_3F6AA(v2);
    result = 0i64;
    while ( !dword_9520C )
      ;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}
// 2F9A9: write access to const memory at 9520C has been detected
// 9520C: using guessed type int dword_9520C;

//----- (000000000002FA0E) ----------------------------------------------------
signed __int64 __fastcall sub_2FA0E(__int64 a1, __int64 a2)
{
  if ( a1 )
    return sub_2F99D(0i64, a2);
  sub_1A11E();
  return 1i64;
}

//----- (000000000002FA45) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 sub_2FA45()
{
  __int64 v0; // rcx

  v0 = qword_96D28;
  if ( !qword_96D28 )
  {
    v0 = sub_24136(4120i64);
    qword_96D28 = v0;
  }
  return sub_2F778(v0);
}
// 2FA66: write access to const memory at 96D28 has been detected
// 96D28: using guessed type __int64 qword_96D28;

//----- (000000000002FA77) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 sub_2FA77()
{
  _BYTE *v0; // rcx
  signed __int64 result; // rax

  sub_1A11E();
  v0 = (_BYTE *)qword_96D28;
  if ( !qword_96D28 )
  {
    v0 = (_BYTE *)sub_24136(4120i64);
    qword_96D28 = (__int64)v0;
  }
  result = sub_2F868(v0);
  qword_96D28 = 0i64;
  return result;
}
// 2FAB0: write access to const memory at 96D28 has been detected
// 2FABC: write access to const memory at 96D28 has been detected
// 96D28: using guessed type __int64 qword_96D28;

//----- (000000000002FACD) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_2FACD(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // r14
  __int64 v6; // rdi
  __int64 v7; // rsi
  __int64 v8; // rcx

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = qword_96D28;
  if ( !qword_96D28 )
  {
    v8 = sub_24136(4120i64);
    qword_96D28 = v8;
  }
  return sub_2F8BC(v8, v7, v6, v5, v4);
}
// 2FAFF: write access to const memory at 96D28 has been detected
// 96D28: using guessed type __int64 qword_96D28;

//----- (000000000002FB24) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_2FB24(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rcx

  v1 = a1;
  v2 = qword_96D28;
  if ( !qword_96D28 )
  {
    v2 = sub_24136(4120i64);
    qword_96D28 = v2;
  }
  return sub_2FA0E(v2, v1);
}
// 2FB49: write access to const memory at 96D28 has been detected
// 96D28: using guessed type __int64 qword_96D28;

//----- (000000000002FB5E) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_2FB5E(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rsi
  _QWORD *v3; // rdi

  v2 = a2;
  v3 = a1;
  if ( !qword_96D28 )
    qword_96D28 = sub_24136(4120i64);
  return sub_2F99D(v3, v2);
}
// 2FB82: write access to const memory at 96D28 has been detected
// 96D28: using guessed type __int64 qword_96D28;

//----- (000000000002FB9B) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_2FB9B(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rax

  v1 = a1;
  v2 = qword_96D28;
  if ( !qword_96D28 )
  {
    v2 = sub_24136(4120i64);
    qword_96D28 = v2;
  }
  *(_BYTE *)(v2 + 12) = 1;
  *(_QWORD *)(v2 + 16) = v1;
  return 0i64;
}
// 2FBBD: write access to const memory at 96D28 has been detected
// 96D28: using guessed type __int64 qword_96D28;

//----- (000000000002FBD8) ----------------------------------------------------
signed __int64 __fastcall sub_2FBD8(__int64 a1)
{
  int *v1; // rdx
  signed __int64 result; // rax
  int v3; // er9
  int v4; // er8
  int v5; // er10
  int v6; // er9

  v1 = *(int **)(a1 + 160);
  result = (signed __int64)(v1 + 46);
  if ( !v1[49] && !v1[48] )
  {
    v3 = v1[7];
    v4 = v1[4];
    if ( *v1 <= v3 )
      v3 = *v1;
    v5 = (v3 + 1) * (v1[5] + v1[6]);
    v6 = *(_DWORD *)(a1 + 52);
    v1[46] = (*(_DWORD *)(a1 + 56) - v5) / 2;
    v1[47] = v6 / 2 - v4 / 2;
    v1[48] = v4;
    v1[49] = v5;
  }
  return result;
}

//----- (000000000002FC6B) ----------------------------------------------------
_DWORD *__fastcall sub_2FC6B(_DWORD *a1, __int64 a2)
{
  _DWORD *v2; // r14
  __int64 v3; // rbx
  _DWORD *v4; // rdi
  char v5; // al
  signed int v6; // edx
  int v7; // esi

  v2 = a1;
  v3 = *(_QWORD *)(a2 + 160);
  v4 = (_DWORD *)sub_2FBD8(a2);
  v5 = sub_3FBF3();
  v6 = 72;
  if ( !v5 )
    v6 = 36;
  v7 = *(_DWORD *)(v3 + 20) - v6;
  v2[3] = v7;
  v2[2] = *(_DWORD *)(v3 + 16) - v6;
  *v2 = v4[3] / 2 + *v4 - v7 / 2;
  v2[1] = v4[2] / 2 + v4[1] - v7 / 2;
  return v2;
}

//----- (000000000002FCF6) ----------------------------------------------------
signed __int64 __fastcall sub_2FCF6(_QWORD *a1, _DWORD *a2, __int64 *a3)
{
  _DWORD *v3; // rsi
  __int64 *v4; // r14
  _QWORD *v5; // rbx
  char v6; // al
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // rcx
  _QWORD *v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  signed __int64 v13; // rsi
  char v15; // [rsp+30h] [rbp-40h]
  int v16; // [rsp+38h] [rbp-38h]
  int v17; // [rsp+3Ch] [rbp-34h]
  __int64 v18; // [rsp+40h] [rbp-30h]

  if ( !a1 )
    goto LABEL_10;
  v3 = a2;
  if ( !a2 )
    goto LABEL_10;
  v4 = a3;
  v5 = a1;
  v6 = sub_3FBF3();
  sub_26B03(
    &v15,
    0,
    0,
    (v3[7] + 1) * (v3[5] + v3[6]) + 200 * (2 - ((unsigned __int8)v6 < 1u)),
    214 * (2 - ((unsigned __int8)v6 < 1u)));
  v18 = 0i64;
  if ( sub_26E4B(&v18, (__int64)&v15) < 0 )
    goto LABEL_10;
  v7 = (unsigned int)(4 * v16 * v17);
  v8 = sub_24103(v7);
  v9 = v18;
  *(_QWORD *)(v18 + 16) = v8;
  *(_QWORD *)(v9 + 24) = v7;
  *(_QWORD *)(v9 + 32) = *(_QWORD *)&v16;
  *(_DWORD *)(v9 + 88) = 0;
  *(_QWORD *)(v9 + 144) = sub_2FE89;
  if ( sub_27402((_DWORD *)v9, &v15) >= 0 )
  {
    v10 = (_QWORD *)sub_24136(208i64);
    v11 = v18;
    *(_QWORD *)(v18 + 160) = v10;
    qmemcpy(v10, v3, 0x80ui64);
    v10[19] = v4[3];
    v10[18] = v4[2];
    v12 = *v4;
    v10[17] = v4[1];
    v10[16] = v12;
    v10[21] = -1i64;
    v13 = 0i64;
    sub_2FED5(v11, 0, 0, 0);
    *v5 = v18;
  }
  else
  {
LABEL_10:
    sub_1A11E();
    v13 = 1i64;
  }
  return v13;
}

//----- (000000000002FE89) ----------------------------------------------------
signed __int64 __fastcall sub_2FE89(__int64 a1)
{
  __int64 v1; // rsi

  v1 = a1;
  sub_1A11E();
  if ( !*(_QWORD *)(v1 + 160) )
    return -1i64;
  (*(void (**)(void))(qword_96CD8 + 72))();
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000002FED5) ----------------------------------------------------
void __fastcall sub_2FED5(__int64 a1, unsigned int a2, int a3, int a4)
{
  int v4; // esi
  unsigned int v5; // er15
  __int64 v6; // r12
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // r13
  _DWORD *v10; // rax
  int v11; // ebx
  int v12; // edx
  int *v13; // rax
  int v14; // edi
  int v15; // er14
  int v16; // esi
  int v17; // ebx
  int v18; // esi
  int v19; // edi
  int i; // edi
  int *v21; // rdi
  int v22; // er14
  signed int v23; // eax
  __int64 v24; // rdi
  int *v25; // r13
  __int64 v26; // rax
  char v27; // bl
  _DWORD *v28; // rax
  __int64 v29; // rbx
  char v30; // r14
  _DWORD *v31; // rax
  int v32; // [rsp+40h] [rbp-80h]
  int v33; // [rsp+44h] [rbp-7Ch]
  unsigned int *v34; // [rsp+48h] [rbp-78h]
  int *v35; // [rsp+50h] [rbp-70h]
  int v36; // [rsp+58h] [rbp-68h]
  int v37; // [rsp+5Ch] [rbp-64h]
  int v38; // [rsp+60h] [rbp-60h]
  int v39; // [rsp+64h] [rbp-5Ch]
  int v40; // [rsp+68h] [rbp-58h]
  unsigned int v41; // [rsp+6Ch] [rbp-54h]
  __int64 v42; // [rsp+70h] [rbp-50h]
  __int64 v43; // [rsp+78h] [rbp-48h]
  int v44; // [rsp+84h] [rbp-3Ch]

  v4 = a4;
  v44 = a3;
  v5 = a2;
  v6 = a1;
  v7 = *(_QWORD *)(a1 + 44);
  v43 = *(_QWORD *)(a1 + 52);
  v42 = 0i64;
  v8 = *(_QWORD *)(a1 + 16);
  v34 = (unsigned int *)(a1 + 32);
  sub_2445C(-1, v8, (unsigned int *)(a1 + 32), (unsigned int *)&v42);
  v9 = *(_QWORD *)(v6 + 160);
  v10 = (_DWORD *)sub_2FBD8(v6);
  v43 = *(_QWORD *)(v9 + 16);
  LODWORD(v42) = *v10 + v10[3] / 2 - *(_DWORD *)(v9 + 20) / 2;
  v11 = (signed int)v43 / 2;
  HIDWORD(v42) = v10[2] / 2 + v10[1] - (signed int)v43 / 2;
  v12 = *(_DWORD *)(v9 + 168);
  if ( v12 < 0 )
  {
    v11 = 0;
    v13 = (int *)v9;
  }
  else
  {
    LOBYTE(v11) = v12 < *(_DWORD *)v9;
    v13 = (int *)v9;
    if ( v12 < *(_DWORD *)v9 )
      v13 = (int *)(v9 + 168);
  }
  v35 = (int *)(v9 + 168);
  if ( (v5 | 1) == 5 )
  {
    if ( *(_DWORD *)v9 <= 0 )
      goto LABEL_23;
    v41 = 5;
    v40 = v11;
    v14 = 0;
    v15 = v4;
    v16 = v44;
    do
      sub_311C5(v6, v14++, v5, (int *)&v42, v16, v15);
    while ( v14 < *(_DWORD *)v9 );
  }
  else
  {
    v41 = v5 | 1;
    v40 = v11;
    v15 = v4;
    if ( v5 != 6 )
    {
      if ( v5 == 7 )
      {
        sub_311C5(v6, v12, 7u, (int *)&v42, v44, v4);
        goto LABEL_23;
      }
      v17 = *v13;
      v18 = v44;
      if ( v5 - 1 > 1 || v15 )
      {
        if ( v17 > 0 )
        {
          v19 = 0;
          do
            sub_311C5(v6, v19++, v5, (int *)&v42, v18, v15);
          while ( v17 != v19 );
        }
        for ( i = *(_DWORD *)v9 - 1; i > v17; --i )
          sub_311C5(v6, i, v5, (int *)&v42, v18, v15);
      }
    }
  }
  v4 = v15;
  if ( !((v41 == 5) | (unsigned __int8)(v40 ^ 1)) )
    sub_311C5(v6, *v35, v5, (int *)&v42, v44, v15);
LABEL_23:
  v21 = (int *)sub_2FBD8(v6);
  sub_26B03(&v42, 0, 0, *v21, *(_DWORD *)(v6 + 52));
  sub_26B03(&v36, *v21 + v21[3], 0, *(_DWORD *)(v6 + 56) - (*v21 + v21[3]), *(_DWORD *)(v6 + 52));
  sub_2445C(-1, *(_QWORD *)(v6 + 16), v34, (unsigned int *)&v42);
  sub_2445C(-1, *(_QWORD *)(v6 + 16), v34, (unsigned int *)&v36);
  v22 = v44;
  if ( v5 <= 5 )
  {
    v23 = 57;
    if ( _bittest(&v23, v5) )
    {
      v24 = *(_QWORD *)(v6 + 160);
      v25 = (int *)sub_2FBD8(v6);
      v26 = *(_QWORD *)(v6 + 44);
      v43 = *(_QWORD *)(v6 + 52);
      v42 = 0i64;
      v27 = sub_31513(v5, v22, v4);
      v28 = *(_DWORD **)(v6 + 160);
      if ( v28[41] < 0 && *v28 > v28[7] )
      {
        v36 = *v25;
        v37 = v25[1] + *(_DWORD *)(v24 + 136) / 2 - v25[2] / 2 + 20;
        if ( sub_244D1(
               *(_QWORD *)(v6 + 16),
               v6 + 52,
               (int *)&v42,
               *(_QWORD *)(v24 + 128),
               (int *)(v24 + 136),
               &v36,
               v27,
               v6 + 176) )
        {
          sub_1A11E();
        }
      }
      if ( sub_306BD(v6) )
      {
        v36 = *v25 + v25[3] - *(_DWORD *)(v24 + 156);
        v37 = v25[1] + *(_DWORD *)(v24 + 152) / 2 - v25[2] / 2 + 20;
        if ( sub_244D1(
               *(_QWORD *)(v6 + 16),
               v6 + 52,
               (int *)&v42,
               *(_QWORD *)(v24 + 144),
               (int *)(v24 + 152),
               &v36,
               v27,
               v6 + 176) )
        {
          sub_1A11E();
        }
      }
      v29 = *(_QWORD *)(v6 + 160);
      if ( !*(_DWORD *)(v29 + 160) )
      {
        v42 = 0i64;
        v43 = *(_QWORD *)(v6 + 32);
        v30 = sub_31513(v5, v22, v4);
        v31 = *(_DWORD **)(v6 + 160);
        if ( v31[41] < 0 && *v31 > v31[7] )
        {
          if ( *(_QWORD *)(v29 + 56) )
          {
            sub_31687(&v36, v6);
            v32 = v36 + (v39 - *(_DWORD *)(v29 + 76)) / 2;
            v33 = v37 + (v38 - *(_DWORD *)(v29 + 72)) / 2;
            sub_244D1(
              *(_QWORD *)(v6 + 16),
              v6 + 52,
              (int *)&v42,
              *(_QWORD *)(v29 + 8i64 * (*(_DWORD *)(v29 + 176) == 3) + 56),
              (int *)(v29 + 72),
              &v32,
              v30,
              v6 + 176);
          }
          else
          {
            sub_1A11E();
          }
        }
        if ( sub_306BD(v6) )
        {
          if ( *(_QWORD *)(v29 + 32) )
          {
            sub_31718(&v36, v6);
            v32 = v36 + (v39 - *(_DWORD *)(v29 + 52)) / 2;
            v33 = v37 + (v38 - *(_DWORD *)(v29 + 48)) / 2;
            sub_244D1(
              *(_QWORD *)(v6 + 16),
              v6 + 52,
              (int *)&v42,
              *(_QWORD *)(v29 + 8i64 * (*(_DWORD *)(v29 + 176) == 4) + 32),
              (int *)(v29 + 48),
              &v32,
              v30,
              v6 + 176);
          }
          else
          {
            sub_1A11E();
          }
        }
      }
    }
  }
  *(_BYTE *)(v6 + 40) = 1;
}

//----- (00000000000304D0) ----------------------------------------------------
signed __int64 __fastcall sub_304D0(__int64 a1)
{
  _DWORD *v1; // rax
  int v2; // er8
  int v3; // er9
  signed __int64 result; // rax

  v1 = *(_DWORD **)(a1 + 160);
  if ( v1[40] || (v2 = v1[41], v2 >= 0) || (v3 = v1[7], *v1 <= v3) )
  {
    sub_1A11E();
    result = 1i64;
  }
  else
  {
    sub_3054D(a1, v2 + v3 * (v1[5] + v1[6]));
    result = 0i64;
  }
  return result;
}

//----- (000000000003054D) ----------------------------------------------------
void __fastcall sub_3054D(__int64 a1, int a2)
{
  __int64 v2; // r13
  _DWORD *v3; // rax
  int v4; // er14
  int v5; // ecx
  int v6; // ebx
  int v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // eax
  int v10; // eax
  _QWORD *v11; // rsi
  int v12; // eax
  int v13; // [rsp+24h] [rbp-3Ch]

  v2 = a1;
  v3 = *(_DWORD **)(a1 + 160);
  v4 = v3[41];
  v13 = 0;
  if ( a2 <= 0 )
  {
    v5 = v3[50];
    if ( !v5 )
    {
      v5 = -((v3[5] + v3[6]) * (*v3 - v3[7]));
      v3[50] = v5;
    }
    if ( v5 >= a2 )
      a2 = v5;
    v13 = a2;
  }
  v6 = 10 * (unsigned __int64)sub_2C122();
  if ( v6 >= 2 )
  {
    v7 = 1;
    do
    {
      v8 = sub_2C972(v7, v6);
      v9 = sub_2C88C(v8, v13 - v4);
      v10 = sub_2C86B(v9);
      sub_317A8(v2, v10 + v4, 0);
      v11 = *(_QWORD **)(v2 + 80);
      v12 = sub_2C122();
      sub_2FB5E(v11, 0x3E8ui64 / (15 * v12));
      ++v7;
    }
    while ( v6 != v7 );
  }
  sub_317A8(v2, v13, 1);
}

//----- (0000000000030638) ----------------------------------------------------
signed __int64 __fastcall sub_30638(__int64 a1)
{
  __int64 v1; // rdi
  signed __int64 result; // rax
  __int64 v3; // rsi

  v1 = *(_QWORD *)(a1 + 160);
  if ( *(_DWORD *)(v1 + 160) || (v3 = a1, !sub_306BD(a1)) )
  {
    sub_1A11E();
    result = 1i64;
  }
  else
  {
    sub_3054D(
      v3,
      *(_DWORD *)(v1 + 164)
    - *(_DWORD *)(*(_QWORD *)(v3 + 160) + 28i64)
    * (*(_DWORD *)(*(_QWORD *)(v3 + 160) + 20i64) + *(_DWORD *)(*(_QWORD *)(v3 + 160) + 24i64)));
    result = 0i64;
  }
  return result;
}

//----- (00000000000306BD) ----------------------------------------------------
bool __fastcall sub_306BD(__int64 a1)
{
  _DWORD *v1; // rax
  int v2; // ecx
  bool result; // al

  v1 = *(_DWORD **)(a1 + 160);
  v2 = v1[50];
  if ( !v2 )
  {
    v2 = -((v1[5] + v1[6]) * (*v1 - v1[7]));
    v1[50] = v2;
  }
  if ( v1[41] <= v2 )
    result = 0;
  else
    result = *v1 > v1[7];
  return result;
}

//----- (00000000000306FE) ----------------------------------------------------
signed __int64 __fastcall sub_306FE(__int64 a1)
{
  __int64 v1; // rdx
  __int64 v2; // rcx
  signed __int64 v3; // rax
  signed __int64 v4; // rsi

  if ( a1 )
  {
    v1 = a1;
    if ( *(_QWORD *)(a1 + 160) )
    {
      v2 = *(_QWORD *)(a1 + 80);
      if ( v2 && (v3 = sub_3F3B4(v2, v1, 111, (__int64)sub_30799, 0i64)) != 0 )
      {
        v4 = v3;
        sub_1A11E();
      }
      else
      {
        v4 = 0i64;
      }
    }
    else
    {
      v4 = -9223372036854775806i64;
    }
  }
  else
  {
    sub_1A11E();
    v4 = 1i64;
  }
  return v4;
}

//----- (0000000000030799) ----------------------------------------------------
__int64 __usercall sub_30799@<rax>(__int64 a1@<rdx>, __int64 a2@<rcx>, char *a3@<rdi>)
{
  __int64 v3; // rsi
  __int64 v5; // rbx
  __int64 v6; // r14
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  bool v12; // al
  int v13; // ecx
  int v14; // eax
  int v15; // eax
  int v16; // eax
  __int64 (__fastcall *v17)(__int64, __int64); // rcx
  const char *v18; // r9
  char v19; // al
  bool v20; // al
  signed int v21; // ecx
  bool v22; // al
  _DWORD *v23; // rsi
  __int64 v24; // rax
  int v25; // eax
  __int64 v26; // rbx
  _DWORD *v27; // rax
  bool v28; // zf
  bool v29; // al
  int v30; // ecx
  int v31; // [rsp+30h] [rbp-50h]
  int v32; // [rsp+34h] [rbp-4Ch]
  int v33[4]; // [rsp+38h] [rbp-48h]
  unsigned int v34; // [rsp+48h] [rbp-38h]
  int v35; // [rsp+4Ch] [rbp-34h]
  __int64 v36; // [rsp+50h] [rbp-30h]
  int v37; // [rsp+58h] [rbp-28h]
  int v38; // [rsp+5Ch] [rbp-24h]

  v3 = *(_QWORD *)(a2 + 160);
  LOBYTE(a3) = 1;
  if ( *(_BYTE *)(v3 + 182) )
    return (unsigned int)a3;
  v5 = a1;
  v6 = a2;
  v7 = *(_DWORD *)(a1 + 28);
  v8 = *(_DWORD *)(a1 + 28) - *(_DWORD *)(a2 + 44);
  v9 = *(_DWORD *)(v5 + 32);
  v37 = v8;
  v38 = v9 - *(_DWORD *)(v6 + 48);
  if ( !*(_DWORD *)(v3 + 160) )
  {
    *(_BYTE *)(v3 + 180) = 0;
    v31 = v7;
    v32 = v9;
    v12 = sub_26AB0((int *)(v6 + 44), &v31);
    v13 = *(_DWORD *)(v5 + 16) & 0x1F;
    if ( v12 && v13 == 2 )
      goto LABEL_65;
    if ( v13 == 2 || (v15 = *(_DWORD *)(v3 + 176)) == 0 )
    {
      LODWORD(a3) = 0;
      return (unsigned int)a3;
    }
    if ( v13 == 1 )
    {
      LOBYTE(a3) = 1;
      if ( (unsigned int)(v15 - 3) < 2 || v15 == 1 )
      {
        sub_31718(&v34, v6);
        sub_31687(v33, v6);
        if ( sub_26AB0(v33, &v37) )
        {
          v28 = *(_DWORD *)(v3 + 176) == 3;
          *(_DWORD *)(v3 + 176) = 3;
          if ( v28 )
            return (unsigned int)a3;
        }
        else
        {
          v29 = sub_26AB0((int *)&v34, &v37);
          v30 = *(_DWORD *)(v3 + 176);
          if ( v29 )
          {
            *(_DWORD *)(v3 + 176) = 4;
            if ( v30 == 4 )
              return (unsigned int)a3;
          }
          else
          {
            *(_DWORD *)(v3 + 176) = 1;
            if ( (unsigned int)(v30 - 3) >= 2 )
              return (unsigned int)a3;
          }
        }
        goto LABEL_35;
      }
      if ( v15 != 2 )
        return (unsigned int)a3;
      v14 = sub_31814(v6, &v37);
      if ( v14 == *(_DWORD *)(v3 + 168) )
        return (unsigned int)a3;
LABEL_14:
      *(_DWORD *)(v3 + 168) = v14;
LABEL_35:
      sub_2FED5(v6, 0, 0, 0);
      sub_3F6AA(*(_QWORD **)(v6 + 80));
      LOBYTE(a3) = 1;
      return (unsigned int)a3;
    }
    if ( v13 == 2 )
    {
LABEL_65:
      *(_DWORD *)(v3 + 176) = 0;
      v3 = *(_QWORD *)(v6 + 160);
      v14 = sub_31814(v6, &v37);
      if ( v14 < 0 || v14 >= *(_DWORD *)v3 )
      {
        *(_DWORD *)(v3 + 168) = -1;
        a3 = (char *)&v34;
        sub_31687(&v34, v6);
        sub_31718(v33, v6);
        v20 = sub_26AB0((int *)&v34, &v37);
        v21 = 3;
        if ( v20 || (v22 = sub_26AB0(v33, &v37), v21 = 4, v22) )
          *(_DWORD *)(v3 + 176) = v21;
        goto LABEL_35;
      }
      *(_DWORD *)(v3 + 176) = 2;
      goto LABEL_14;
    }
    switch ( v15 )
    {
      case 4:
        *(_BYTE *)(v3 + 182) = 1;
        v17 = sub_3196B;
        v18 = "_UICarouselViewGoNextDeferred";
        break;
      case 3:
        *(_BYTE *)(v3 + 182) = 1;
        v17 = sub_31933;
        v18 = "_UICarouselViewGoPrevDeferred";
        break;
      case 2:
        v16 = *(_DWORD *)(v3 + 168);
        if ( v16 < 0 || v16 >= *(_DWORD *)v3 )
          goto LABEL_57;
        *(_BYTE *)(v3 + 182) = 1;
        v17 = sub_318AE;
        v18 = "_UICarouselViewClickDeferred";
        break;
      default:
        goto LABEL_57;
    }
    sub_2FACD((__int64)v17, v6, 0i64, (__int64)v18);
LABEL_57:
    *(_DWORD *)(v3 + 176) = 0;
    goto LABEL_35;
  }
  sub_2FC6B(v33, v6);
  LOBYTE(v10) = sub_26AB0(v33, &v37);
  LODWORD(a3) = v10;
  v11 = *(_DWORD *)(v5 + 16) & 0x1F;
  if ( v11 == 1 )
  {
    if ( !*(_BYTE *)(v3 + 180) )
      return (unsigned int)a3;
    v19 = *(_BYTE *)(v3 + 181);
    if ( (_BYTE)a3 )
    {
      if ( v19 )
        return (unsigned int)a3;
      *(_BYTE *)(v3 + 181) = 1;
    }
    else
    {
      if ( !v19 )
        return (unsigned int)a3;
      *(_BYTE *)(v3 + 181) = 0;
    }
    sub_1A11E();
  }
  else if ( v11 == 4 )
  {
    if ( !(_BYTE)a3 || !*(_BYTE *)(v3 + 180) )
    {
      *(_WORD *)(v3 + 180) = 0;
      return (unsigned int)a3;
    }
    *(_BYTE *)(v3 + 182) = 1;
    sub_2FACD((__int64)sub_319A4, v6, 0i64, (__int64)"_UICarouselViewCenterTileClickedDeferred");
    *(_WORD *)(v3 + 180) = 0;
  }
  else
  {
    if ( v11 != 2 || !(_BYTE)a3 )
      return (unsigned int)a3;
    *(_WORD *)(v3 + 180) = 257;
  }
  v23 = *(_DWORD **)(v6 + 160);
  v24 = *(_QWORD *)(v6 + 44);
  v36 = *(_QWORD *)(v6 + 52);
  *(_QWORD *)&v34 = 0i64;
  sub_2445C(-1, *(_QWORD *)(v6 + 16), (unsigned int *)(v6 + 32), &v34);
  v25 = v23[42];
  if ( v25 < 0 || v25 >= *v23 )
  {
    sub_1A11E();
  }
  else
  {
    v26 = *(_QWORD *)(v6 + 160);
    v27 = (_DWORD *)sub_2FBD8(v6);
    v36 = *(_QWORD *)(v26 + 16);
    v34 = *v27 + v27[3] / 2 - *(_DWORD *)(v26 + 20) / 2;
    v35 = v27[2] / 2 + v27[1] - (signed int)v36 / 2;
    sub_311C5(v6, v23[42], 1u, (int *)&v34, 0, 0);
    *(_BYTE *)(v6 + 40) = 1;
  }
  sub_3F6AA(*(_QWORD **)(v6 + 80));
  return (unsigned int)a3;
}

//----- (0000000000030C41) ----------------------------------------------------
signed __int64 __fastcall sub_30C41(__int64 a1)
{
  signed __int64 v1; // rax
  signed __int64 v2; // rsi

  if ( a1 )
  {
    v1 = sub_3F58B(*(_QWORD *)(a1 + 80), a1);
    if ( v1 )
    {
      v2 = v1;
      sub_1A11E();
    }
    else
    {
      v2 = 0i64;
    }
  }
  else
  {
    sub_1A11E();
    v2 = 1i64;
  }
  return v2;
}

//----- (0000000000030CAB) ----------------------------------------------------
__int64 __fastcall sub_30CAB(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rsi
  void (__fastcall *v3)(__int64, _QWORD); // rax

  v1 = *(_QWORD *)(a1 + 160);
  *(_BYTE *)(v1 + 182) = 1;
  if ( *(_DWORD *)(v1 + 160) )
  {
    v2 = a1;
    v3 = *(void (__fastcall **)(__int64, _QWORD))(v1 + 96);
    if ( v3 )
      v3(a1, *(_QWORD *)(v1 + 104));
    *(_DWORD *)(v1 + 160) = 0;
    sub_30D10(v2, 0);
    *(_DWORD *)(v1 + 168) = -1;
  }
  *(_BYTE *)(v1 + 182) = 0;
  return 0i64;
}

//----- (0000000000030D10) ----------------------------------------------------
signed __int64 __fastcall sub_30D10(__int64 a1, unsigned __int8 a2)
{
  unsigned __int8 v2; // r15
  __int64 v3; // rsi
  signed __int64 result; // rax
  unsigned int v5; // er12
  __int64 v6; // r13
  int v7; // ecx
  _DWORD *v8; // rax
  __int64 v9; // r14
  int v10; // ebx
  int v11; // ebx
  int v12; // er14
  int v13; // edi
  bool v14; // sf
  unsigned __int8 v15; // of
  int v16; // er14
  int v17; // edi
  int v18; // [rsp+20h] [rbp-60h]
  int v19; // [rsp+24h] [rbp-5Ch]
  __int64 v20; // [rsp+28h] [rbp-58h]
  int v21; // [rsp+34h] [rbp-4Ch]
  int v22; // [rsp+38h] [rbp-48h]
  int v23; // [rsp+3Ch] [rbp-44h]
  __int64 v24; // [rsp+40h] [rbp-40h]

  v2 = a2;
  v3 = a1;
  result = sub_2C122();
  v5 = 2 * (v2 == 0) + 5;
  v6 = *(_QWORD *)(v3 + 160);
  v7 = *(_DWORD *)(v6 + 168);
  v24 = result;
  if ( v7 >= 0 && v7 < *(_DWORD *)v6 )
  {
    v8 = (_DWORD *)sub_2FBD8(v3);
    v9 = *(_QWORD *)(v6 + 16);
    v10 = *v8 + v8[3] / 2;
    v21 = *(_DWORD *)(v6 + 20);
    v22 = v8[1];
    v23 = v8[2];
    sub_3146C((__int64)&v18, v3, *(_DWORD *)(v6 + 168));
    if ( v20 == v9 )
    {
      result = v24;
      if ( v18 == v10 - v21 / 2 && v19 == v23 / 2 + v22 - (signed int)v9 / 2 )
        v5 = (v2 < 1u) + 2;
    }
    else
    {
      result = v24;
    }
  }
  if ( (signed int)result > 0 )
  {
    v11 = 8 * result;
    v12 = 3 * result;
    v13 = 1;
    do
    {
      sub_2FED5(v3, v5, v13, v11);
      if ( v5 == 2 && v12 == v13 )
        (*(void (__fastcall **)(__int64, _QWORD))(v6 + 112))(v3, *(_QWORD *)(v6 + 120));
      sub_3F6AA(*(_QWORD **)(v3 + 80));
      result = (unsigned int)(v13 + 1);
      v15 = __OFSUB__(v13, v11);
      v14 = v13++ - v11 < 0;
    }
    while ( v14 ^ v15 );
    if ( (v5 | 2) == 7 )
    {
      v16 = 3 * v24;
      v17 = 1;
      do
      {
        if ( v2 )
        {
          if ( v16 == v17 )
            (*(void (__fastcall **)(__int64, _QWORD))(v6 + 112))(v3, *(_QWORD *)(v6 + 120));
        }
        sub_2FED5(v3, 2 * (v2 != 0) + 4, v17, v11);
        sub_3F6AA(*(_QWORD **)(v3 + 80));
        result = (unsigned int)(v17 + 1);
        v15 = __OFSUB__(v17, v11);
        v14 = v17++ - v11 < 0;
      }
      while ( v14 ^ v15 );
    }
  }
  return result;
}

//----- (0000000000030ECA) ----------------------------------------------------
__int64 __fastcall sub_30ECA(__int64 a1, int a2, char a3)
{
  __int64 v3; // rdi
  __int64 v4; // rsi
  void (__fastcall *v5)(__int64, _QWORD); // rax

  v3 = *(_QWORD *)(a1 + 160);
  if ( *(_DWORD *)(v3 + 160) != 1 )
  {
    v4 = a1;
    *(_DWORD *)(v3 + 168) = a2;
    if ( a3 && *(_DWORD *)v3 >= 2 )
      sub_30D10(a1, 1u);
    else
      sub_2FED5(a1, 2u, 0, 0);
    v5 = *(void (__fastcall **)(__int64, _QWORD))(v3 + 80);
    if ( v5 )
      v5(v4, *(_QWORD *)(v3 + 88));
    *(_DWORD *)(v3 + 160) = 1;
  }
  return 0i64;
}

//----- (0000000000030F3C) ----------------------------------------------------
__int64 __fastcall sub_30F3C(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 160) + 168i64);
}

//----- (0000000000030F4F) ----------------------------------------------------
signed __int64 __fastcall sub_30F4F(__int64 a1, signed int a2)
{
  signed int *v2; // rdi
  signed __int64 result; // rax
  signed int v4; // er9
  __int64 v5; // rsi

  v2 = *(signed int **)(a1 + 160);
  if ( v2[43] == a2 )
  {
    sub_1A11E();
    result = 0i64;
  }
  else
  {
    v4 = a2;
    v5 = a1;
    if ( a2 < -1 || *v2 <= a2 )
    {
      sub_1A11E();
      v4 = -1;
    }
    v2[43] = v4;
    sub_30FE7(v5);
    sub_2FED5(v5, 0, 0, 0);
    result = sub_3F6AA(*(_QWORD **)(v5 + 80));
  }
  return result;
}

//----- (0000000000030FE7) ----------------------------------------------------
__int64 __fastcall sub_30FE7(__int64 a1)
{
  int *v1; // r14
  int v2; // ebx
  int v3; // edi
  int v4; // esi
  int v5; // edi
  __int64 result; // rax
  int v7; // edi
  unsigned __int8 v8; // of
  int v9; // esi

  v1 = *(int **)(a1 + 160);
  v2 = v1[43];
  if ( v2 >= 0 )
  {
    v3 = *v1;
    v4 = 0;
    if ( *v1 > v1[7] )
    {
      v5 = v1[5] + v1[6];
      result = (unsigned int)(v1[41] / v5);
      v4 = -(v1[41] / v5);
      v3 = v1[7];
    }
    v7 = v4 + v3;
    if ( v4 > v2 || v2 >= v7 )
    {
      v8 = __OFSUB__(v4, v2);
      v9 = v4 - v2;
      if ( (unsigned __int8)((v9 < 0) ^ v8) | (v9 == 0) )
      {
        sub_1A11E();
        result = (unsigned int)(v1[5] + v1[6]);
        v1[41] -= result * (v2 - v7 + 1);
      }
      else
      {
        sub_1A11E();
        result = (unsigned int)(v9 * (v1[5] + v1[6]));
        v1[41] += result;
      }
    }
  }
  return result;
}

//----- (00000000000310A2) ----------------------------------------------------
signed __int64 __fastcall sub_310A2(__int64 a1)
{
  __int64 v1; // rsi
  _DWORD *v2; // rcx
  int v3; // eax
  int v4; // eax

  v1 = a1;
  v2 = *(_DWORD **)(a1 + 160);
  v3 = v2[43];
  if ( v3 <= 0 )
  {
    v4 = 0;
    if ( *v2 > v2[7] )
      v4 = -(v2[41] / (v2[5] + v2[6]));
  }
  else
  {
    v4 = v3 - 1;
  }
  v2[43] = v4;
  sub_30FE7(v1);
  sub_2FED5(v1, 0, 0, 0);
  return sub_3F6AA(*(_QWORD **)(v1 + 80));
}

//----- (000000000003110D) ----------------------------------------------------
signed __int64 __fastcall sub_3110D(__int64 a1)
{
  __int64 v1; // rsi
  int *v2; // rcx
  int v3; // eax
  int v4; // eax
  int v5; // er8
  int v6; // edx

  v1 = a1;
  v2 = *(int **)(a1 + 160);
  v3 = v2[43];
  if ( v3 < 0 )
  {
    v5 = *v2;
    v4 = 0;
    if ( *v2 > v2[7] )
      v4 = -(v2[41] / (v2[5] + v2[6]));
  }
  else
  {
    v4 = v3 + 1;
    v5 = *v2;
  }
  v6 = v5 - 1;
  if ( v4 < v5 )
    v6 = v4;
  v2[43] = v6;
  sub_30FE7(v1);
  sub_2FED5(v1, 0, 0, 0);
  return sub_3F6AA(*(_QWORD **)(v1 + 80));
}

//----- (0000000000031187) ----------------------------------------------------
__int64 __fastcall sub_31187(__int64 a1)
{
  int v1; // edx

  v1 = *(_DWORD *)(*(_QWORD *)(a1 + 160) + 172i64);
  if ( v1 >= 0 )
    sub_30ECA(a1, v1, 1);
  return 0i64;
}

//----- (00000000000311B0) ----------------------------------------------------
__int64 __fastcall sub_311B0(__int64 a1)
{
  sub_30CAB(a1);
  return 0i64;
}

//----- (00000000000311C5) ----------------------------------------------------
void __fastcall sub_311C5(__int64 a1, int a2, unsigned int a3, int *a4, int a5, int a6)
{
  int *v6; // rbx
  unsigned int v7; // edi
  int v8; // esi
  __int64 v9; // r14
  __int64 v10; // r15
  int v11; // er8
  int v12; // esi
  int v13; // er12
  __int64 v14; // rbx
  int v15; // esi
  signed int v16; // eax
  signed int v17; // eax
  int v18; // eax
  unsigned int v19; // eax
  unsigned int v20; // eax
  int v21; // esi
  signed int *v22; // rax
  signed int v23; // ecx
  signed int v24; // edx
  int v25; // eax
  __int64 v26; // r12
  char v27; // r13
  int v28; // eax
  bool v29; // cl
  __int64 *v30; // rax
  signed __int64 v31; // rdx
  __int64 v32; // rsi
  char v33; // cl
  int v34; // [rsp+2Ch] [rbp-64h]
  __int64 v35; // [rsp+30h] [rbp-60h]
  __int64 v36; // [rsp+38h] [rbp-58h]
  __int64 v37; // [rsp+40h] [rbp-50h]
  __int64 v38; // [rsp+48h] [rbp-48h]
  int v39; // [rsp+54h] [rbp-3Ch]

  v6 = a4;
  v7 = a3;
  v8 = a2;
  v9 = a1;
  v10 = *(_QWORD *)(a1 + 160);
  sub_3146C((__int64)&v35, a1, a2);
  v11 = *(_DWORD *)(v10 + 168);
  v39 = v8;
  if ( v11 < 0 || v11 == v8 )
  {
    if ( v6 )
    {
      v15 = *v6;
      v13 = v6[1];
      v14 = *((_QWORD *)v6 + 1);
    }
    else
    {
      v15 = 0;
      v13 = 0;
      v14 = 0i64;
    }
  }
  else
  {
    sub_3146C((__int64)&v37, v9, v11);
    v12 = *v6 - v37;
    v13 = HIDWORD(v35);
    v14 = v36;
    v15 = v35 + v12;
  }
  if ( v7 > 7 )
  {
    sub_1A11E();
  }
  else
  {
    v16 = 53;
    if ( _bittest(&v16, v7) )
    {
      v38 = v36;
      v37 = v35;
    }
    else
    {
      v17 = 194;
      if ( _bittest(&v17, v7) )
      {
        LODWORD(v37) = v15;
      }
      else
      {
        if ( a5 <= a6 )
        {
          if ( a5 == a6 )
          {
            v13 = HIDWORD(v35);
            v18 = v35;
            v14 = v36;
          }
          else
          {
            v19 = sub_2C972(a5, a6);
            v20 = sub_2C88C(v19, (signed int)v35 - v15);
            v18 = v15 + (unsigned __int64)sub_2C86B(v20);
          }
        }
        else
        {
          sub_1A11E();
          v18 = 0;
          v13 = 0;
          v14 = 0i64;
        }
        LODWORD(v37) = v18;
      }
      HIDWORD(v37) = v13;
      v38 = v14;
    }
  }
  v21 = v39;
  v22 = (signed int *)sub_2FBD8(v9);
  v23 = v37 + HIDWORD(v38);
  v24 = *v22;
  v25 = *v22 + v22[3];
  if ( (signed int)v37 >= v24 && (signed int)v37 <= v25 || v23 >= v24 && v23 <= v25 )
  {
    v26 = *(_QWORD *)(*(_QWORD *)(v10 + 8) + 8i64 * v21);
    v27 = sub_31513(v7, a5, a6);
    v28 = *(_DWORD *)(v10 + 168);
    v34 = *(_DWORD *)(v10 + 168);
    if ( v7 )
    {
      v29 = 0;
      if ( a6 / 2 <= a5 && v7 == 2 && v28 == v21 )
      {
        if ( *(_BYTE *)(v10 + 180) && *(_BYTE *)(v10 + 181) )
          v30 = (__int64 *)(v26 + 48);
        else
          v30 = (__int64 *)(v26 + 40);
LABEL_40:
        v32 = *v30;
        sub_2445C(-16777216, *(_QWORD *)(v9 + 16), (unsigned int *)(v9 + 32), (unsigned int *)&v37);
        sub_31598(v9, v32, (int *)v26, (int *)&v37, v27);
        if ( v7 != 4 && v7 != 7 && v7 - 5 >= 2 && a6 > 0 && v34 == v39 )
        {
          v33 = ~v27;
          if ( v7 - 1 < 3 )
            v33 = 0;
          sub_31598(v9, *(_QWORD *)(v26 + 40), (int *)v26, (int *)&v37, v33);
        }
        return;
      }
    }
    else
    {
      v29 = (v21 ^ v28 | *(_DWORD *)(v10 + 176) ^ 2) == 0;
    }
    if ( (v7 | 1) == 7 || *(_DWORD *)(v10 + 172) != v21 )
    {
      v31 = v26 + 16;
      v30 = (__int64 *)(v26 + 8);
    }
    else
    {
      v31 = v26 + 32;
      v30 = (__int64 *)(v26 + 24);
    }
    if ( v29 )
      v30 = (__int64 *)v31;
    goto LABEL_40;
  }
}

//----- (000000000003146C) ----------------------------------------------------
_DWORD *__fastcall sub_3146C(__int64 a1, __int64 a2, int a3)
{
  int v3; // edi
  _DWORD *v4; // r14
  __int64 v5; // rbx
  __int64 v6; // rax

  v3 = a3;
  v4 = (_DWORD *)a1;
  v5 = *(_QWORD *)(a2 + 160);
  if ( a3 < 0 || *(_DWORD *)v5 <= a3 )
  {
    sub_1A11E();
    sub_26B03(v4, 0, 0, 0, 0);
  }
  else
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(v5 + 16);
    v6 = *(_QWORD *)sub_2FBD8(a2);
    *(_QWORD *)v4 = v6;
    *v4 = *(_DWORD *)(v5 + 164)
        + *(_DWORD *)(v5 + 24)
        + *(_DWORD *)(v5 + 20) / 2
        + v6
        + v3 * (*(_DWORD *)(v5 + 20) + *(_DWORD *)(v5 + 24));
  }
  return v4;
}

//----- (0000000000031513) ----------------------------------------------------
__int64 __fastcall sub_31513(int a1, int a2, int a3)
{
  unsigned int v3; // edx
  __int64 result; // rax

  if ( a3 <= 0 )
    return 0i64;
  v3 = 255 * a2 / a3;
  result = 0i64;
  switch ( a1 )
  {
    case 1:
      return result;
    case 2:
    case 5:
    case 7:
      return v3;
    case 3:
    case 4:
    case 6:
      LOBYTE(v3) = ~(_BYTE)v3;
      break;
    default:
      sub_1A11E();
      return 0i64;
  }
  return v3;
}

//----- (0000000000031598) ----------------------------------------------------
void __fastcall sub_31598(__int64 a1, __int64 a2, int *a3, int *a4, char a5)
{
  __int64 v5; // r15
  int *v6; // rbx
  int *v7; // r14
  __int64 *v8; // rdi
  int *v9; // rax
  int v10; // ecx
  int v11; // edx
  int v12; // eax
  __int64 v13; // rdx
  __int64 v14; // [rsp+48h] [rbp-38h]
  __int64 v15; // [rsp+50h] [rbp-30h]

  if ( a1 && (v5 = a2) != 0 )
  {
    v6 = a4;
    v7 = a3;
    v8 = (__int64 *)a1;
    v9 = (int *)sub_2FBD8(a1);
    v10 = *v6 + v6[3];
    v11 = *v9;
    v12 = *v9 + v9[3];
    if ( *v6 >= v11 && *v6 <= v12 || v10 >= v11 && v10 <= v12 )
    {
      v13 = *(__int64 *)((char *)v8 + 52);
      v14 = *(__int64 *)((char *)v8 + 44);
      v15 = v13;
      v14 = 0i64;
      if ( sub_244D1(v8[2], (__int64)v8 + 52, (int *)&v14, v5, v7, v6, a5, (__int64)(v8 + 22)) )
        sub_1A11E();
    }
  }
  else
  {
    sub_1A11E();
  }
}

//----- (0000000000031687) ----------------------------------------------------
_DWORD *__fastcall sub_31687(_DWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _DWORD *v3; // rsi
  int *v4; // rbx
  __int64 v5; // r14
  int v6; // eax
  int v7; // ecx
  int v8; // edx
  __int64 v9; // rcx

  v2 = a2;
  v3 = a1;
  v4 = (int *)sub_2FBD8(a2);
  v5 = *(_QWORD *)(v2 + 160);
  v6 = 2 - ((unsigned __int8)sub_3FBF3() < 1u);
  v7 = *v4;
  v8 = v4[1] + v4[2] / 2;
  LODWORD(v4) = 31 * v6;
  LODWORD(v2) = 32 * v6;
  v6 *= 10;
  *v3 = v7 - *(_DWORD *)(v5 + 76) - v2 - v6;
  v3[1] = v8 - (_DWORD)v4 - v6;
  v9 = *(_QWORD *)(v5 + 72);
  v3[3] = HIDWORD(v9) + 2 * v6;
  v3[2] = v9 + 2 * v6;
  return v3;
}

//----- (0000000000031718) ----------------------------------------------------
_DWORD *__fastcall sub_31718(_DWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  _DWORD *v3; // rsi
  _DWORD *v4; // rbx
  __int64 v5; // r14
  int v6; // eax
  int v7; // ecx
  __int64 v8; // rcx

  v2 = a2;
  v3 = a1;
  v4 = (_DWORD *)sub_2FBD8(a2);
  v5 = *(_QWORD *)(v2 + 160);
  v6 = 2 - ((unsigned __int8)sub_3FBF3() < 1u);
  v7 = v4[1] + v4[2] / 2 - 31 * v6;
  LODWORD(v4) = *v4 + v4[3] + 32 * v6;
  v6 *= 10;
  *v3 = (_DWORD)v4 - v6;
  v3[1] = v7 - v6;
  v8 = *(_QWORD *)(v5 + 48);
  v3[3] = HIDWORD(v8) + 2 * v6;
  v3[2] = v8 + 2 * v6;
  return v3;
}

//----- (00000000000317A8) ----------------------------------------------------
void __fastcall sub_317A8(__int64 a1, int a2, char a3)
{
  __int64 v3; // rax
  char v4; // bl
  __int64 v5; // rsi

  v3 = *(_QWORD *)(a1 + 160);
  if ( *(_DWORD *)(v3 + 164) == a2 )
  {
    sub_1A11E();
  }
  else
  {
    v4 = a3;
    v5 = a1;
    *(_DWORD *)(v3 + 164) = a2;
    sub_2FED5(a1, 0, 0, 0);
    if ( v4 )
      sub_3F6AA(*(_QWORD **)(v5 + 80));
  }
}

//----- (0000000000031814) ----------------------------------------------------
signed __int64 __fastcall sub_31814(__int64 a1, int *a2)
{
  int *v2; // r15
  __int64 v3; // rdi
  _DWORD *v4; // r14
  _DWORD *v5; // rax
  _DWORD *v6; // rdx
  int v7; // esi
  signed __int64 result; // rax
  int v9; // ebx
  int v10; // er8
  int v11; // ecx
  int v12; // ebx
  char v13; // [rsp+28h] [rbp-38h]

  v2 = a2;
  v3 = a1;
  v4 = *(_DWORD **)(a1 + 160);
  v5 = (_DWORD *)sub_2FBD8(a1);
  v6 = v5;
  v7 = *v5;
  result = 0xFFFFFFFFi64;
  if ( *v2 >= v7 && *v2 <= v6[3] + v7 )
  {
    v9 = v4[5];
    v10 = v4[6];
    v11 = *v2 - v7 - v4[41] - v10 - v9 / 2;
    if ( v11 >= 0 )
    {
      v12 = v11 / (v9 + v10);
      sub_3146C((__int64)&v13, v3, v12);
      result = v12 | (unsigned int)-((unsigned __int8)sub_26AB0((int *)&v13, v2) < 1u);
    }
  }
  return result;
}

//----- (00000000000318AE) ----------------------------------------------------
__int64 __fastcall sub_318AE(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // r9
  int v5; // er9

  v2 = a2;
  v3 = *(_QWORD *)(a2 + 160);
  v4 = *(unsigned int *)(v3 + 168);
  sub_1A11E();
  v5 = *(_DWORD *)(v3 + 168);
  if ( v5 < 0 || v5 >= *(_DWORD *)v3 )
    sub_1A11E();
  else
    sub_30ECA(v2, v5, 1);
  *(_BYTE *)(v3 + 182) = 0;
  return 0i64;
}

//----- (0000000000031933) ----------------------------------------------------
__int64 __fastcall sub_31933(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = *(_QWORD *)(a2 + 160);
  if ( *(_DWORD *)(v2 + 164) < 0 && *(_DWORD *)v2 > *(_DWORD *)(v2 + 28) )
    sub_304D0(a2);
  *(_BYTE *)(v2 + 182) = 0;
  return 0i64;
}

//----- (000000000003196B) ----------------------------------------------------
__int64 __fastcall sub_3196B(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi

  v2 = a2;
  v3 = *(_QWORD *)(a2 + 160);
  if ( sub_306BD(a2) )
    sub_30638(v2);
  *(_BYTE *)(v3 + 182) = 0;
  return 0i64;
}

//----- (00000000000319A4) ----------------------------------------------------
__int64 __fastcall sub_319A4(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = a2;
  sub_1A11E();
  sub_30CAB(v2);
  *(_BYTE *)(*(_QWORD *)(v2 + 160) + 182i64) = 0;
  return 0i64;
}

//----- (00000000000319E8) ----------------------------------------------------
signed __int64 __fastcall sub_319E8(_QWORD *a1, __int64 a2, int a3, __int64 a4, __int64 a5, int *a6)
{
  __int64 v6; // r14
  int v7; // esi
  _DWORD *v8; // rbx
  _QWORD *v9; // r15
  unsigned int v10; // edi
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rdi
  int v14; // ecx
  int v15; // eax
  __int64 v16; // r12
  int v17; // esi
  unsigned __int8 v18; // bl
  unsigned int v20[2]; // [rsp+28h] [rbp-68h]
  int v21; // [rsp+30h] [rbp-60h]
  int v22; // [rsp+34h] [rbp-5Ch]
  __int64 v23; // [rsp+38h] [rbp-58h]
  _DWORD v24[3]; // [rsp+40h] [rbp-50h]
  int v25; // [rsp+4Ch] [rbp-44h]
  __int64 v26; // [rsp+50h] [rbp-40h]

  if ( !a1 )
    return 1i64;
  v6 = a4;
  v7 = a3;
  v8 = (_DWORD *)a2;
  v9 = a1;
  v26 = 0i64;
  if ( sub_26E4B(&v26, a2) < 0 )
    goto LABEL_13;
  v10 = 4 * v8[2] * v8[3];
  v11 = sub_24103(v10);
  v12 = v26;
  *(_QWORD *)(v26 + 16) = v11;
  *(_QWORD *)(v12 + 24) = v10;
  *(_QWORD *)(v12 + 32) = *((_QWORD *)v8 + 1);
  *(_DWORD *)(v12 + 88) = 0;
  *(_QWORD *)(v12 + 144) = sub_31BFA;
  if ( sub_27402((_DWORD *)v12, v8) < 0 )
  {
LABEL_13:
    sub_1A11E();
    return 1i64;
  }
  v13 = sub_24136(176i64);
  *(_QWORD *)(v26 + 160) = v13;
  *(_DWORD *)(v13 + 8) = v7;
  *(_QWORD *)(v13 + 16) = v6;
  *(_QWORD *)(v13 + 24) = a5;
  *(_QWORD *)(v13 + 32) = a6;
  *(_DWORD *)(v13 + 72) = -1;
  v14 = *a6;
  *(_DWORD *)(v13 + 4) = v8[3];
  *(_DWORD *)v13 = v14 * v7;
  *(_DWORD *)(v13 + 76) = 0xFFFFFF;
  v15 = v8[3];
  *(_DWORD *)(v13 + 52) = v15;
  *(_DWORD *)(v13 + 48) = v14;
  v16 = sub_24103((unsigned int)(4 * v15 * v14));
  sub_26E30(&v25, 100, 100, 100, 235);
  v17 = (BYTE2(v25) << 16) | (unsigned __int16)v25;
  v18 = HIBYTE(v25) - 30;
  sub_26B03(v20, 0, 0, *(_DWORD *)(v13 + 52), *(_DWORD *)(v13 + 48));
  v23 = 4294967297i64;
  v24[1] = v22 - 2;
  v24[0] = v21 - 2;
  if ( sub_2445C(v17 | ((unsigned int)v18 << 24), v16, (unsigned int *)(v13 + 48), v20) < 0 )
    sub_1A11E();
  if ( sub_2445C(v25, v16, (unsigned int *)(v13 + 48), (unsigned int *)&v23) < 0 )
    sub_1A11E();
  *(_QWORD *)(v13 + 40) = v16;
  sub_31C46(v26);
  *v9 = v26;
  return 0i64;
}

//----- (0000000000031BFA) ----------------------------------------------------
signed __int64 __fastcall sub_31BFA(__int64 a1)
{
  __int64 v1; // rsi

  v1 = a1;
  sub_1A11E();
  if ( !*(_QWORD *)(v1 + 160) )
    return -1i64;
  (*(void (**)(void))(qword_96CD8 + 72))();
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000031C46) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_31C46(__int64 a1))(__int64, _QWORD)
{
  __int64 v1; // rsi
  __int64 v2; // r15
  __int64 v3; // rax
  unsigned int *v4; // rbx
  int v5; // eax
  __int64 v6; // r14
  _DWORD *v7; // rdx
  int v8; // ebx
  __int64 v9; // rsi
  __int64 v10; // r12
  __int64 v11; // rdi
  __int64 v12; // r14
  __int64 v13; // rax
  __int64 v14; // r9
  _DWORD *v15; // r13
  _DWORD *v16; // r13
  __int64 v17; // r9
  __int64 v18; // r9
  __int64 (__fastcall *result)(__int64, _QWORD); // rax
  __int64 v20; // rsi
  char v21; // [rsp+40h] [rbp-90h]
  __int64 v22; // [rsp+50h] [rbp-80h]
  __int64 v23; // [rsp+58h] [rbp-78h]
  int *v24; // [rsp+60h] [rbp-70h]
  int *v25; // [rsp+68h] [rbp-68h]
  __int64 v26; // [rsp+70h] [rbp-60h]
  __int64 v27; // [rsp+78h] [rbp-58h]
  __int64 v28; // [rsp+80h] [rbp-50h]
  __int64 v29; // [rsp+88h] [rbp-48h]
  int v30; // [rsp+90h] [rbp-40h]
  int v31; // [rsp+94h] [rbp-3Ch]

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 160);
  v3 = *(_QWORD *)(a1 + 44);
  v23 = *(_QWORD *)(a1 + 52);
  v22 = 0i64;
  v4 = (unsigned int *)(a1 + 32);
  sub_2445C(-1, *(_QWORD *)(a1 + 16), (unsigned int *)(a1 + 32), (unsigned int *)&v22);
  v29 = v1;
  sub_2445C(*(_DWORD *)(v2 + 76), *(_QWORD *)(v1 + 16), v4, (unsigned int *)&v22);
  if ( *(_QWORD *)(v2 + 16) )
  {
    v30 = 0;
    v5 = *(_DWORD *)(v2 + 12);
    v31 = *(_DWORD *)(v2 + 12);
    v6 = v29;
    if ( *(_DWORD *)(v2 + 8) > 0 )
    {
      v7 = *(_DWORD **)(v2 + 32);
      v8 = *v7;
      v27 = v29 + 52;
      v24 = (int *)(v2 + 48);
      v28 = v29 + 176;
      v25 = (int *)(v2 + 64);
      v9 = 0i64;
      v10 = 0i64;
      while ( 1 )
      {
        v11 = *(unsigned int *)(v2 + 72);
        if ( !((unsigned __int8)((v8 + v5 < 0) ^ __OFADD__(v8, v5)) | (v8 + v5 == 0)) && v8 + v5 < *(_DWORD *)(v6 + 52)
          || v5 >= 0 && v5 < *(_DWORD *)(v6 + 52) )
        {
          v26 = v9;
          v12 = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 8 * v10);
          if ( v10 == v11 )
          {
            v13 = *(_QWORD *)(v2 + 24);
            if ( v13 )
              v12 = *(_QWORD *)(v13 + 8 * v10);
            v14 = *(_QWORD *)(v2 + 40);
            if ( v14 )
            {
              v15 = v7;
              if ( sub_244D1(*(_QWORD *)(v29 + 16), v27, (int *)&v22, v14, v24, &v30, 0, v28) < 0 )
                sub_1A11E();
              v7 = v15;
            }
          }
          if ( v12 )
          {
            v16 = v7;
            v17 = v12;
            v6 = v29;
            if ( sub_244D1(*(_QWORD *)(v29 + 16), v27, (int *)&v22, v17, (_DWORD *)((char *)v7 + v26), &v30, 0, v28) < 0 )
              sub_1A11E();
          }
          else
          {
            v16 = v7;
            sub_1A11E();
            v6 = v29;
          }
          if ( v10 == v11 )
          {
            v18 = *(_QWORD *)(v2 + 56);
            if ( v18 )
              sub_244D1(*(_QWORD *)(v6 + 16), v27, (int *)&v22, v18, v25, &v30, 0, v28);
          }
          v9 = v26;
          if ( *(_QWORD *)(v2 + 136) )
          {
            sub_26B03(&v21, v30, v31, *(_DWORD *)(v6 + 56), v16[2 * v10]);
            if ( (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, char *))(v2 + 136))(
                   v6,
                   *(_QWORD *)(v2 + 144),
                   (unsigned int)v10,
                   &v21) )
            {
              sub_1A11E();
            }
          }
        }
        v5 = v8 + v31;
        v31 += v8;
        if ( ++v10 >= *(signed int *)(v2 + 8) )
          break;
        v7 = *(_DWORD **)(v2 + 32);
        v9 += 8i64;
      }
    }
  }
  result = *(__int64 (__fastcall **)(__int64, _QWORD))(v2 + 152);
  v20 = v29;
  if ( result )
    result = (__int64 (__fastcall *)(__int64, _QWORD))result(v29, *(_QWORD *)(v2 + 160));
  *(_BYTE *)(v20 + 40) = 1;
  return result;
}

//----- (0000000000031F31) ----------------------------------------------------
signed __int64 __fastcall sub_31F31(__int64 a1)
{
  __int64 v1; // rax
  signed __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 160);
  if ( v1 )
    result = *(unsigned int *)(v1 + 12);
  else
    result = 0xFFFFFFFFi64;
  return result;
}

//----- (0000000000031F4D) ----------------------------------------------------
signed __int64 __fastcall sub_31F4D(__int64 a1, int a2)
{
  signed __int64 v2; // rsi
  __int64 v3; // rdi
  int v4; // eax
  unsigned __int8 v5; // of
  int v6; // eax
  __int64 v7; // rcx

  v2 = -1i64;
  if ( a1 )
  {
    v3 = *(_QWORD *)(a1 + 160);
    if ( v3 )
    {
      v4 = *(_DWORD *)(a1 + 52);
      v5 = __OFSUB__(v4, *(_DWORD *)v3);
      v6 = v4 - *(_DWORD *)v3;
      if ( (v6 < 0) ^ v5 )
      {
        if ( v6 < a2 )
          v6 = a2;
        v2 = 0i64;
        if ( a2 > 0 )
          v6 = 0;
        *(_DWORD *)(v3 + 12) = v6;
        sub_31C46(a1);
        v7 = *(_QWORD *)(v3 + 168);
        if ( v7 )
        {
          sub_34D13(v7);
          v2 = 0i64;
        }
      }
    }
  }
  return v2;
}

//----- (0000000000031FAA) ----------------------------------------------------
signed __int64 __fastcall sub_31FAA(__int64 a1)
{
  if ( a1 )
    return *(unsigned int *)(*(_QWORD *)(a1 + 160) + 72i64);
  sub_1A11E();
  return 0xFFFFFFFFi64;
}

//----- (0000000000031FE6) ----------------------------------------------------
_DWORD *__fastcall sub_31FE6(_DWORD *a1, __int64 a2)
{
  _DWORD *v2; // rsi

  v2 = a1;
  sub_26B03(a1, 0, -*(_DWORD *)(*(_QWORD *)(a2 + 160) + 12i64), *(_DWORD *)(a2 + 56), *(_DWORD *)(a2 + 52));
  return v2;
}

//----- (000000000003201C) ----------------------------------------------------
__int64 __fastcall sub_3201C(__int64 a1)
{
  __int64 v1; // rax
  int v2; // er8
  int v3; // er8
  _QWORD v5[2]; // [rsp+20h] [rbp-10h]

  v1 = *(_QWORD *)(a1 + 160);
  v2 = *(_DWORD *)(v1 + 8);
  if ( v2 <= 0 )
    v3 = 0;
  else
    v3 = **(_DWORD **)(v1 + 32) * v2;
  sub_26AF2(v5, *(_DWORD *)(a1 + 56), v3);
  return v5[0];
}

//----- (000000000003205B) ----------------------------------------------------
signed __int64 __fastcall sub_3205B(__int64 a1, int a2)
{
  __int64 v2; // rax

  if ( a1 )
  {
    v2 = *(_QWORD *)(a1 + 160);
    if ( v2 )
    {
      *(_DWORD *)(v2 + 76) = a2;
      sub_31C46(a1);
      return 0i64;
    }
  }
  else
  {
    sub_1A11E();
  }
  return 1i64;
}

//----- (00000000000320A3) ----------------------------------------------------
__int64 __fastcall sub_320A3(__int64 a1, signed int a2)
{
  __int64 v2; // r14
  __int64 v3; // rbx
  unsigned int v4; // edi
  int v5; // eax
  unsigned __int8 (__fastcall *v6)(__int64, _QWORD, _QWORD); // rsi
  __int64 v7; // rsi

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 160);
  v4 = -1;
  if ( a2 >= -1 )
  {
    if ( *(_DWORD *)(v3 + 8) <= a2 )
      a2 = *(_DWORD *)(v3 + 8);
    v4 = a2;
  }
  v5 = *(_DWORD *)(v3 + 72);
  if ( v5 != v4 )
  {
    v6 = *(unsigned __int8 (__fastcall **)(__int64, _QWORD, _QWORD))(v3 + 120);
    if ( v6 )
    {
      v4 |= -(v6(a1, v4, *(_QWORD *)(v3 + 128)) < 1u);
      v5 = *(_DWORD *)(v3 + 72);
    }
    if ( v5 != v4 )
    {
      v7 = *(_QWORD *)(v2 + 160);
      *(_DWORD *)(v7 + 72) = v4;
      sub_31C46(v2);
      if ( *(_QWORD *)(v7 + 104) )
        sub_2FACD((__int64)sub_32235, v2, 0i64, (__int64)"_selectionDidChangeDeferred");
    }
  }
  return 0i64;
}

//----- (000000000003213A) ----------------------------------------------------
signed __int64 __fastcall sub_3213A(__int64 a1, __int64 *a2)
{
  __int64 v2; // rdx
  int v3; // eax
  bool v4; // sf
  int v5; // er8
  signed __int64 result; // rax
  int v7; // edx

  v2 = *a2;
  v3 = *(_DWORD *)(a1 + 44);
  v4 = (signed int)v2 - v3 < 0;
  v5 = v2 - v3;
  result = 0xFFFFFFFFi64;
  if ( !v4 )
  {
    v7 = HIDWORD(v2) - *(_DWORD *)(a1 + 48);
    if ( v7 >= 0 && v5 < *(_DWORD *)(a1 + 56) && v7 < *(_DWORD *)(a1 + 52) )
      result = (unsigned int)((v7 - *(_DWORD *)(*(_QWORD *)(a1 + 160) + 12i64))
                            / **(_DWORD **)(*(_QWORD *)(a1 + 160) + 32i64));
  }
  return result;
}

//----- (000000000003217A) ----------------------------------------------------
__int64 __fastcall sub_3217A(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 160);
  *(_QWORD *)(result + 40) = a2;
  *(_QWORD *)(result + 48) = *a3;
  return result;
}

//----- (0000000000032195) ----------------------------------------------------
_DWORD *__fastcall sub_32195(_DWORD *a1, __int64 a2, int a3)
{
  _DWORD *v3; // rsi
  __int64 v4; // rcx
  int v5; // er9

  v3 = a1;
  v4 = *(_QWORD *)(a2 + 160);
  v5 = **(_DWORD **)(v4 + 32);
  *v3 = *(_DWORD *)(a2 + 44);
  v3[1] = *(_DWORD *)(v4 + 12) + *(_DWORD *)(a2 + 48) + v5 * a3;
  sub_26AF2(v3 + 2, *(_DWORD *)(a2 + 56), v5);
  return v3;
}

//----- (00000000000321E1) ----------------------------------------------------
__int64 __fastcall sub_321E1(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 160);
  *(_QWORD *)(result + 104) = a2;
  *(_QWORD *)(result + 112) = a3;
  return result;
}

//----- (00000000000321F6) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_321F6(__int64 a1, __int64 a2, __int64 a3))(__int64, _QWORD)
{
  __int64 v3; // rax

  v3 = *(_QWORD *)(a1 + 160);
  *(_QWORD *)(v3 + 136) = a2;
  *(_QWORD *)(v3 + 144) = a3;
  return sub_31C46(a1);
}

//----- (0000000000032215) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_32215(__int64 a1, __int64 a2, __int64 a3))(__int64, _QWORD)
{
  __int64 v3; // rax

  v3 = *(_QWORD *)(a1 + 160);
  *(_QWORD *)(v3 + 152) = a2;
  *(_QWORD *)(v3 + 160) = a3;
  return sub_31C46(a1);
}

//----- (0000000000032235) ----------------------------------------------------
__int64 __fastcall sub_32235(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a2 + 160) + 104i64))(
           a2,
           *(_QWORD *)(*(_QWORD *)(a2 + 160) + 112i64));
}

//----- (0000000000032250) ----------------------------------------------------
signed __int64 __fastcall sub_32250(_QWORD *a1, int *a2)
{
  int *v2; // rdi
  _QWORD *v3; // r15
  signed __int64 v4; // rbx
  int v5; // esi
  __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v9; // rbx
  __int64 v10; // rcx
  char v12; // [rsp+30h] [rbp-40h]
  __int64 v13; // [rsp+38h] [rbp-38h]
  __int64 v14; // [rsp+40h] [rbp-30h]

  v2 = a2;
  v3 = a1;
  sub_1A11E();
  v4 = 1i64;
  if ( v3 )
  {
    if ( *v2 <= 0 )
    {
      sub_1A11E();
    }
    else
    {
      v14 = 0i64;
      v5 = 2 - ((unsigned __int8)sub_3FBF3() < 1u);
      sub_26B03(&v12, 200, 200, *v2, 500 * v5);
      if ( sub_26E4B(&v14, (__int64)&v12) < 0 )
      {
        sub_1A11E();
        v4 = 1i64;
      }
      else
      {
        v6 = (unsigned int)(4 * v13 * HIDWORD(v13));
        v7 = sub_24103(v6);
        v8 = v14;
        *(_QWORD *)(v14 + 16) = v7;
        *(_QWORD *)(v8 + 24) = v6;
        *(_QWORD *)(v8 + 32) = v13;
        *(_DWORD *)(v8 + 88) = 0;
        *(_DWORD *)(v8 + 248) = 10000;
        *(_QWORD *)(v8 + 144) = sub_323D1;
        v9 = sub_24136(832i64);
        sub_1B930((char *)v9, (char *)v2, 0x328ui64);
        *(_DWORD *)(v9 + 820) = 30 * v5;
        *(_DWORD *)(v9 + 824) = 26 * v5;
        *(_DWORD *)(v9 + 828) = 25 * v5;
        v10 = v14;
        *(_QWORD *)(v14 + 160) = v9;
        sub_32436(v10);
        *v3 = v14;
        v4 = 0i64;
      }
    }
  }
  return v4;
}

//----- (00000000000323D1) ----------------------------------------------------
signed __int64 __fastcall sub_323D1(__int64 a1)
{
  __int64 v1; // rsi

  v1 = a1;
  sub_1A11E();
  sub_1A11E();
  if ( !*(_QWORD *)(v1 + 160) )
    return -1i64;
  (*(void (**)(void))(qword_96CD8 + 72))();
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000032436) ----------------------------------------------------
__int64 __fastcall sub_32436(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rax
  __int64 v3; // r13
  unsigned int *v4; // rbx
  int v5; // esi
  int v6; // er12
  char v7; // al
  signed int v8; // ecx
  int v9; // eax
  int v10; // er12
  int v11; // er12
  signed int *v12; // rbx
  __int64 result; // rax
  signed int v14; // er15
  __int64 v15; // rcx
  int v16; // edx
  int v17; // edx
  int v18; // er15
  int *v19; // rdi
  __int64 v20; // r14
  int v21; // eax
  __int64 v22; // r9
  __int64 v23; // [rsp+40h] [rbp-50h]
  __int64 v24; // [rsp+48h] [rbp-48h]
  __int64 v25; // [rsp+50h] [rbp-40h]

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 160);
  v3 = a1;
  if ( *(_QWORD *)(v2 + 32) && *(_QWORD *)(v2 + 16) && *(_QWORD *)(v2 + 48) )
  {
    v23 = 0i64;
    v4 = (unsigned int *)(a1 + 32);
    v24 = *(_QWORD *)(a1 + 32);
    v5 = *(_DWORD *)(v2 + 28);
    v6 = *(_DWORD *)(v2 + 4) + *(_DWORD *)(v2 + 76) - *(_DWORD *)(v2 + 76) / 2;
    v7 = sub_3FBF3();
    v8 = 60;
    if ( !v7 )
      v8 = 30;
    v9 = v5 / 2;
    v10 = v6 - v5;
    v1 = v3;
    v11 = v8 + v9 + v10;
    if ( v11 < 0 )
      v11 = 0;
    sub_2445C(-1, *(_QWORD *)(v3 + 16), v4, (unsigned int *)&v23);
    *(_BYTE *)(v3 + 40) = 1;
  }
  else
  {
    sub_1A11E();
    v11 = 0;
  }
  v12 = *(signed int **)(v1 + 160);
  v23 = 0i64;
  v24 = *(_QWORD *)(v1 + 32);
  v25 = 0i64;
  HIDWORD(v25) = v12[205];
  result = v12[20];
  if ( result > 0 )
  {
    v14 = 0x7FFFFFFF;
    v15 = 0i64;
    do
    {
      if ( !*((_BYTE *)v12 + v15 + 472) )
      {
        v16 = *(_DWORD *)(v1 + 36) / 2;
        v1 = v3;
        v17 = v16 - v12[2 * v15 + 87] / 2;
        if ( v14 > v17 )
          v14 = v17;
      }
      ++v15;
    }
    while ( result != v15 );
    v18 = v11 + v14;
    v19 = v12 + 86;
    v20 = 0i64;
    do
    {
      v21 = v18;
      if ( *((_BYTE *)v12 + v20 + 472) )
        v21 = *(_DWORD *)(v1 + 36) / 2 - v19[1] / 2;
      LODWORD(v25) = v21;
      if ( v20 != v12[203] || (v22 = *((_QWORD *)v19 - 16)) == 0 )
        v22 = *((_QWORD *)v19 - 32);
      sub_244D1(*(_QWORD *)(v1 + 16), v1 + 52, (int *)&v23, v22, v19, (int *)&v25, 0, v1 + 176);
      HIDWORD(v25) += *v19 + v12[v20++ + 122];
      result = v12[20];
      v19 += 2;
    }
    while ( v20 < result );
  }
  return result;
}

//----- (000000000003264C) ----------------------------------------------------
signed __int64 __fastcall sub_3264C(__int64 a1)
{
  __int64 v1; // rdx
  __int64 v2; // rcx
  signed __int64 v3; // rax
  signed __int64 v4; // rsi

  if ( a1 )
  {
    v1 = a1;
    if ( *(_QWORD *)(a1 + 160) )
    {
      v2 = *(_QWORD *)(a1 + 80);
      if ( v2 && (v3 = sub_3F3B4(v2, v1, 255, (__int64)sub_326E7, 0i64)) != 0 )
      {
        v4 = v3;
        sub_1A11E();
      }
      else
      {
        v4 = 0i64;
      }
    }
    else
    {
      v4 = -9223372036854775806i64;
    }
  }
  else
  {
    sub_1A11E();
    v4 = 1i64;
  }
  return v4;
}

//----- (00000000000326E7) ----------------------------------------------------
__int64 __fastcall sub_326E7(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // r14
  __int64 v4; // r15
  __int64 v5; // rax
  int v6; // eax
  int v7; // ecx
  bool v8; // al
  int v9; // ecx
  int v10; // er13
  __int64 v11; // r12
  int v12; // esi
  signed int v13; // ebx
  __int64 v14; // r8
  __int64 v15; // rcx
  signed int v16; // eax
  int v17; // esi
  int v18; // ebx
  int v19; // edx
  __int64 v21; // [rsp+20h] [rbp-50h]
  __int64 v22; // [rsp+28h] [rbp-48h]
  int v23; // [rsp+30h] [rbp-40h]
  int v24; // [rsp+34h] [rbp-3Ch]

  v2 = a2;
  v3 = (__int64)a1;
  v4 = a1[20];
  v23 = *(_DWORD *)(a2 + 28);
  v24 = *(_DWORD *)(a2 + 32);
  v5 = *(_QWORD *)((char *)a1 + 44);
  v22 = *(_QWORD *)((char *)a1 + 52);
  v21 = v5;
  v6 = sub_32952((__int64)a1);
  v7 = *(_DWORD *)(v4 + 820);
  LODWORD(v22) = v6 - *(_DWORD *)(v4 + 828) - v7;
  HIDWORD(v21) += v7;
  v8 = sub_26AB0((int *)&v21, &v23);
  v9 = *(_DWORD *)(v2 + 16) & 0x1F;
  if ( !v8 )
  {
    *(_DWORD *)(v4 + 812) = -1;
    switch ( __ROR4__(v9 - 2, 1) )
    {
      case 0:
        if ( !*(_BYTE *)(v4 + 8) )
        {
          sub_275C4(v3, 0);
          sub_3F6AA(*(_QWORD **)(v3 + 80));
        }
        break;
      case 1:
      case 3:
      case 7:
        *(_BYTE *)(v4 + 808) = 0;
        break;
      default:
        break;
    }
    if ( *(_BYTE *)(v4 + 8) )
      LODWORD(v2) = 0;
    else
      LOBYTE(v2) = v24 >= *(_DWORD *)(v3 + 48);
    return (unsigned int)v2;
  }
  v10 = v23 - *(_DWORD *)(v3 + 44);
  LODWORD(v2) = v24 - *(_DWORD *)(v3 + 48);
  if ( v9 != 1 )
  {
    if ( v9 == 4 )
    {
      *(_DWORD *)(v4 + 816) = *(_DWORD *)(v4 + 812);
      *(_DWORD *)(v4 + 812) = -1;
      *(_BYTE *)(v4 + 808) = 0;
      sub_3299E(v3);
      sub_2FACD((__int64)sub_329D9, v3, 0i64, (__int64)"_UIPopoverFireDeferredCallback");
    }
    else
    {
      if ( v9 == 2 )
      {
        *(_BYTE *)(v4 + 808) = 1;
        goto LABEL_11;
      }
      *(_DWORD *)(v4 + 812) = -1;
      *(_BYTE *)(v4 + 808) = 0;
    }
LABEL_23:
    LOBYTE(v2) = 1;
    return (unsigned int)v2;
  }
  if ( !*(_BYTE *)(v4 + 808) )
    goto LABEL_23;
LABEL_11:
  v11 = *(_QWORD *)(v3 + 160);
  v12 = *(_DWORD *)(v11 + 820);
  v13 = -1;
  if ( (signed int)v2 > v12 && (signed int)v2 <= (signed int)sub_32952(v3) )
  {
    v14 = *(signed int *)(v11 + 80);
    if ( v14 > 0 )
    {
      v15 = 0i64;
      while ( 1 )
      {
        v16 = v12;
        v17 = v12 + *(_DWORD *)(v11 + 8 * v15 + 344);
        if ( (signed int)v2 >= v16 && (signed int)v2 <= v17 )
        {
          v18 = *(_DWORD *)(v11 + 8 * v15 + 348);
          v19 = *(_DWORD *)(v3 + 36) / 2 - v18 / 2;
          if ( v10 >= v19 && v10 <= v18 + v19 )
            break;
        }
        v12 = *(_DWORD *)(v11 + 4 * v15++ + 488) + v17;
        if ( v15 >= v14 )
        {
          v13 = -1;
          goto LABEL_28;
        }
      }
      v13 = v15;
    }
  }
LABEL_28:
  LOBYTE(v2) = 1;
  if ( *(_DWORD *)(v4 + 812) != v13 )
  {
    *(_DWORD *)(v4 + 812) = v13;
    sub_3299E(v3);
  }
  return (unsigned int)v2;
}

//----- (0000000000032952) ----------------------------------------------------
__int64 __fastcall sub_32952(__int64 a1)
{
  _DWORD *v1; // rcx
  signed __int64 v2; // r8
  signed __int64 v3; // rdx
  int v4; // eax

  v1 = *(_DWORD **)(a1 + 160);
  v2 = (signed int)v1[20];
  if ( v2 <= 0 )
  {
    v4 = 0;
  }
  else
  {
    v3 = 0i64;
    v4 = 0;
    do
    {
      v4 += v1[2 * v3 + 86];
      if ( v3 < (signed int)v2 - 1 )
        v4 += v1[v3 + 122];
      ++v3;
    }
    while ( v3 < v2 );
  }
  return (unsigned int)(v1[14] + v1[6] + v4 - v1[206]);
}

//----- (000000000003299E) ----------------------------------------------------
signed __int64 __fastcall sub_3299E(__int64 a1)
{
  __int64 v1; // rsi

  v1 = a1;
  sub_1A11E();
  sub_32436(v1);
  return sub_3F6AA(*(_QWORD **)(v1 + 80));
}

//----- (00000000000329D9) ----------------------------------------------------
__int64 __fastcall sub_329D9(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  void (__fastcall *v4)(__int64, _QWORD); // rax
  __int64 v5; // ST20_8

  v2 = *(_QWORD *)(a2 + 160);
  v3 = *(signed int *)(v2 + 816);
  if ( v3 >= 0 && (signed int)v3 < *(_DWORD *)(v2 + 80) )
  {
    v4 = *(void (__fastcall **)(__int64, _QWORD))(v2 + 8 * v3 + 552);
    if ( v4 )
    {
      v4(a2, *(_QWORD *)(v2 + 8 * v3 + 680));
      v5 = *(_QWORD *)(v2 + 8 * v3 + 552);
      sub_1A11E();
    }
  }
  return 0i64;
}

//----- (0000000000032A4A) ----------------------------------------------------
__int64 __fastcall sub_32A4A(unsigned int a1)
{
  signed int v1; // esi
  int v2; // eax
  int v3; // er9
  int v4; // er10
  int v5; // edx
  bool v6; // sf
  int v7; // eax
  __int64 result; // rax
  int v9; // ecx
  __int64 v10; // r9
  int v11; // edx
  int v12; // ecx

  v1 = a1;
  v2 = sub_2C86B(a1);
  v3 = v2;
  v4 = -v1;
  if ( -v1 < 1 )
    LOWORD(v4) = v1;
  v5 = v2 % 360;
  v6 = v2 < 0;
  v7 = v2 % 360 + 360;
  if ( !v6 )
    v7 = v5;
  result = *((unsigned int *)qword_8FEC0 + v7);
  v4 = (unsigned __int16)v4;
  if ( (_WORD)v4 )
  {
    v9 = v3 + 2 * (v1 >= 0);
    v10 = v9 - 1;
    v11 = v10
        - 360
        * (((unsigned int)(((unsigned __int64)(-1240768329 * v10) >> 32) + v9 - 1) >> 31)
         + ((signed int)(((unsigned __int64)(-1240768329 * v10) >> 32) + v9 - 1) >> 8));
    v12 = v11 + 360;
    if ( (signed int)v10 >= 0 )
      v12 = v11;
    result = (unsigned int)((v4 * (*((_DWORD *)qword_8FEC0 + v12) - (signed int)result) >> 16) + result);
  }
  return result;
}
// 8FEC0: using guessed type __int64 qword_8FEC0[552];

//----- (0000000000032B0C) ----------------------------------------------------
__int64 __fastcall sub_32B0C(int a1)
{
  unsigned int v1; // esi

  if ( a1 < 0 )
    v1 = (unsigned __int64)sub_2C860(90) + a1;
  else
    v1 = a1 - (unsigned __int64)sub_2C860(270);
  return sub_32A4A(v1);
}

//----- (0000000000032B42) ----------------------------------------------------
__int64 __fastcall sub_32B42(unsigned int a1, int a2)
{
  unsigned int v2; // esi
  unsigned int v3; // eax
  unsigned int v4; // edx
  unsigned int v5; // eax

  v2 = a1;
  if ( !(a1 & 0xFFFEFFFF) )
    return v2;
  if ( a2 < 0 )
  {
    v5 = sub_32B42(a1, (unsigned int)(a2 + 1));
    return sub_2C905(v5, v2);
  }
  switch ( a2 )
  {
    case 0:
      return 0x10000;
    case 2:
      v4 = a1;
      return sub_2C899(a1, v4);
    case 1:
      return v2;
  }
  v3 = sub_32B42(a1, (unsigned int)(a2 - 1));
  a1 = v2;
  v4 = v3;
  return sub_2C899(a1, v4);
}

//----- (0000000000032BA9) ----------------------------------------------------
__int64 __fastcall sub_32BA9(signed int a1)
{
  signed int v1; // esi
  int v2; // eax

  v1 = a1 >> 31;
  v2 = sub_2C86B(a1);
  return sub_2C860(v2 + v1);
}

//----- (0000000000032BCB) ----------------------------------------------------
signed __int64 __fastcall sub_32BCB(__int64 a1, _DWORD *a2)
{
  _DWORD *v2; // rdi
  __int64 v3; // rsi
  _DWORD *v4; // rax
  int v5; // ecx
  signed __int64 result; // rax
  int v7; // edx
  int v8; // eax
  __int64 v9; // rcx
  int v10; // eax
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rbx
  _BYTE *v15; // rax
  __int64 v16; // rax
  __int64 v17; // rcx
  _QWORD *savedregs; // [rsp+40h] [rbp+0h]

  if ( !a1 )
    return -9223372036854775806i64;
  v2 = a2;
  if ( !a2 )
    return -9223372036854775806i64;
  v3 = a1;
  v4 = *(_DWORD **)(a1 + 240);
  if ( !v4 )
    return -9223372036854775806i64;
  v5 = *a2 - *(_DWORD *)(a1 + 44);
  if ( *a2 == *(_DWORD *)(v3 + 44) && *(_DWORD *)(v3 + 48) == a2[1] )
    return -9223372036854775806i64;
  v4[8] = 0;
  v7 = v4[1];
  v4[6] = v4[1] / 0x22u;
  v4[7] = v7;
  *(_DWORD *)(*(_QWORD *)(v3 + 240) + 36i64) = sub_2C860(v5);
  v8 = sub_2C860(v2[1] - *(_DWORD *)(v3 + 48));
  v9 = *(_QWORD *)(v3 + 240);
  *(_DWORD *)(v9 + 40) = v8;
  (*(void (__fastcall **)(__int64, __int64, signed __int64))(qword_96CD8 + 352))(v9 + 44, v3 + 44, 8i64);
  *(_DWORD *)(*(_QWORD *)(v3 + 240) + 52i64) = sub_2C860(*(_DWORD *)(v3 + 44));
  v10 = sub_2C860(*(_DWORD *)(v3 + 48));
  v11 = *(_QWORD *)(v3 + 240);
  *(_DWORD *)(v11 + 56) = v10;
  (*(void (__fastcall **)(__int64, _DWORD *, signed __int64))(qword_96CD8 + 352))(v11 + 60, v2, 8i64);
  v12 = *(_QWORD *)(v3 + 240);
  *(_DWORD *)(v12 + 68) = *(_DWORD *)(v12 + 8);
  *(_BYTE *)(v12 + 72) = 1;
  v13 = *(_QWORD *)(v3 + 80);
  savedregs = &savedregs;
  result = -9223372036854775806i64;
  if ( v13 && v3 )
  {
    v14 = v13;
    v15 = *(_BYTE **)(v3 + 240);
    if ( v15 || (v15 = (_BYTE *)sub_24136(152i64), (*(_QWORD *)(v3 + 240) = v15) != 0i64) )
    {
      if ( !*(_QWORD *)(v14 + 56) )
      {
        v16 = sub_359AF((__int64)sub_32E65, v14, (__int64)qword_53020, 1u);
        v17 = v16;
        *(_QWORD *)(v14 + 56) = v16;
        result = -9223372036854775799i64;
        if ( !v17 )
          return result;
        v15 = *(_BYTE **)(v3 + 240);
      }
      *v15 = 1;
      result = 0i64;
    }
    else
    {
      result = -9223372036854775799i64;
    }
  }
  return result;
}
// 53020: using guessed type __int64 qword_53020[120];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000032D82) ----------------------------------------------------
signed __int64 __fastcall sub_32D82(__int64 a1, unsigned __int8 a2)
{
  __int64 v2; // rsi
  _DWORD *v3; // rax
  int v4; // er8
  unsigned __int8 v5; // di
  int v6; // eax
  __int64 v7; // rdx
  int v8; // ecx
  int v9; // eax
  __int64 v10; // rcx
  __int64 v11; // rcx

  if ( a1 )
  {
    v2 = a1;
    v3 = *(_DWORD **)(a1 + 240);
    if ( v3 )
    {
      v3[26] = 0;
      v4 = v3[1];
      v3[24] = v3[1] / 0x22u;
      v3[25] = v4;
      v5 = a2;
      v6 = sub_2C860(a2 - (unsigned int)*(unsigned __int8 *)(a1 + 168));
      v7 = *(_QWORD *)(v2 + 240);
      *(_DWORD *)(v7 + 108) = v6;
      v8 = *(unsigned __int8 *)(v2 + 168);
      *(_BYTE *)(v7 + 112) = v8;
      v9 = sub_2C860(v8);
      v10 = *(_QWORD *)(v2 + 240);
      *(_DWORD *)(v10 + 116) = v9;
      *(_BYTE *)(v10 + 120) = v5;
      *(_DWORD *)(v10 + 124) = *(_DWORD *)(v10 + 8);
      *(_BYTE *)(v10 + 128) = 1;
      v11 = *(_QWORD *)(v2 + 80);
      JUMPOUT(&loc_32CDF);
    }
  }
  return -9223372036854775806i64;
}

//----- (0000000000032E34) ----------------------------------------------------
signed __int64 __fastcall sub_32E34(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax
  __int64 v4; // rcx

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v4 = *(_QWORD *)(a1 + 240);
    if ( v4 )
    {
      *(_QWORD *)(v4 + 136) = a2;
      *(_QWORD *)(v4 + 144) = a3;
      result = 0i64;
    }
  }
  return result;
}

//----- (0000000000032E65) ----------------------------------------------------
void __fastcall sub_32E65(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rsi
  _QWORD *v3; // rdi
  _QWORD *v4; // rbx
  __int64 v5; // rcx
  _QWORD *v6; // rcx
  char v7; // al
  _BYTE *v8; // rdi
  __int64 v9; // rcx
  _BYTE *v10; // rcx

  if ( a2 )
  {
    v2 = a2;
    if ( a2[7] )
    {
      v3 = (_QWORD *)a2[2];
      if ( v3 )
      {
        v4 = a2 + 2;
        while ( v3 != v4 )
        {
          if ( !v3 || (unsigned int)sub_32F35((__int64)v3, 0i64) )
            return;
          v3 = (_QWORD *)*v3;
        }
        v5 = v2[5];
        if ( (!v5 || !(unsigned int)sub_32F35(v5, 0i64)) && !(unsigned int)sub_3F6AA(v2) )
        {
          v6 = (_QWORD *)*v4;
          v7 = 0;
          if ( (_QWORD *)*v4 == v4 )
          {
LABEL_19:
            v9 = v2[5];
            if ( v9 && (v10 = *(_BYTE **)(v9 + 240)) != 0i64 )
            {
              if ( *v10 | (unsigned __int8)v7 )
                return;
            }
            else if ( v7 )
            {
              return;
            }
            sub_35A74(v2[7]);
            v2[7] = 0i64;
          }
          else
          {
            while ( v6 )
            {
              v8 = (_BYTE *)v6[30];
              if ( v8 && *v8 )
                v7 = 1;
              v6 = (_QWORD *)*v6;
              if ( v6 == v4 )
                goto LABEL_19;
            }
          }
        }
      }
    }
  }
}

//----- (0000000000032F35) ----------------------------------------------------
signed __int64 __fastcall sub_32F35(__int64 a1, _BYTE *a2)
{
  _BYTE *v2; // r12
  __int64 v3; // r15
  __int64 v4; // rsi
  BOOL v5; // ebx
  int v6; // edi
  _DWORD *v7; // rcx
  int v8; // ebx
  int v9; // er13
  int v10; // eax
  int v11; // er14
  int v12; // ecx
  int v13; // esi
  int v14; // eax
  _DWORD *v15; // rbx
  int v16; // eax
  int v17; // eax
  bool v19; // r13
  __int64 v20; // rcx
  int v21; // edx
  int v22; // er8
  char v23; // al
  char v24; // r13
  int v25; // edi
  int v26; // eax
  int v27; // ecx
  int v28; // edi
  int v29; // er14
  int v30; // eax
  __int64 v31; // rsi
  int v32; // eax
  int v33; // ecx
  BOOL v34; // esi
  __int64 v35; // rcx
  int v36; // edx
  int v37; // er8
  bool v38; // al
  int v39; // eax
  int v40; // esi
  int v41; // er14
  int v42; // eax
  _DWORD *v43; // rcx
  int v44; // eax
  int v45; // eax
  int v46; // eax
  _DWORD *v47; // rax
  int v48; // eax
  unsigned int v49; // ecx
  unsigned int v50; // eax
  __int64 v51; // rcx
  int v52; // esi
  char v53; // r14
  int v54; // edi
  int v55; // eax
  __int64 v56; // rcx
  bool v57; // zf
  bool v58; // al
  __int64 v59; // rcx
  void (__fastcall *v60)(__int64, _QWORD); // rax
  __int64 v61; // rcx
  void (__fastcall *v62)(__int64, _QWORD); // rax
  __int64 v63; // rax
  unsigned __int8 (__fastcall *v64)(__int64); // rdx
  bool v65; // al
  __int64 v66; // rax
  int v67; // [rsp+20h] [rbp-50h]
  int v68; // [rsp+24h] [rbp-4Ch]
  unsigned int v69; // [rsp+28h] [rbp-48h]
  unsigned int v70; // [rsp+2Ch] [rbp-44h]
  int v71; // [rsp+34h] [rbp-3Ch]

  if ( !a1 )
    return -9223372036854775806i64;
  v2 = a2;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 240);
  v5 = 0;
  if ( v4 && *(_BYTE *)v4 )
  {
    v6 = *(_DWORD *)(v4 + 24);
    if ( v6 )
    {
      v7 = (_DWORD *)(v4 + 24);
      v8 = *(_DWORD *)(v4 + 68);
      switch ( *(_DWORD *)(v4 + 68) & 7 )
      {
        case 1:
          v9 = *(_DWORD *)(v4 + 52);
          v69 = *(_DWORD *)(v4 + 52);
          v10 = *(_DWORD *)(v4 + 56);
          v71 = v10;
          v70 = v10;
          v11 = *(_DWORD *)(v4 + 36);
          v12 = *(_DWORD *)(v4 + 60);
          v13 = *(_DWORD *)(v4 + 36) / v6;
          v14 = sub_2C860(v12);
          v15 = *(_DWORD **)(v3 + 240);
          v16 = v14 - v15[13];
          if ( v11 <= 0 )
          {
            if ( v13 > v16 )
              goto LABEL_8;
          }
          else if ( v13 < v16 )
          {
LABEL_8:
            v17 = v15[9] / v15[6];
            goto LABEL_44;
          }
          v39 = sub_2C860(v15[15]);
          v15 = *(_DWORD **)(v3 + 240);
          v17 = v39 - v15[13];
LABEL_44:
          v69 = v9 + v17;
          v40 = v15[10];
          v41 = v15[10] / v15[6];
          v42 = sub_2C860(v15[16]);
          v43 = *(_DWORD **)(v3 + 240);
          v44 = v42 - v43[14];
          if ( v40 <= 0 )
          {
            if ( v41 > v44 )
              goto LABEL_46;
          }
          else if ( v41 < v44 )
          {
LABEL_46:
            v45 = v43[10] / v43[6];
LABEL_49:
            v70 = v71 + v45;
            (*(void (__fastcall **)(_DWORD *, unsigned int *, signed __int64))(qword_96CD8 + 352))(v43 + 13, &v69, 8i64);
            v67 = sub_2C86B(v69);
            v68 = sub_2C86B(v70);
            v23 = 0;
            if ( !(unsigned int)sub_27251(v3, &v67) )
            {
              v47 = *(_DWORD **)(v3 + 240);
              ++v47[8];
              if ( *(_DWORD *)(v3 + 44) != v47[15] || *(_DWORD *)(v3 + 48) != v47[16] )
                v23 = 1;
            }
            goto LABEL_16;
          }
          v46 = sub_2C860(v43[16]);
          v43 = *(_DWORD **)(v3 + 240);
          v45 = v46 - v43[14];
          goto LABEL_49;
        case 2:
          v20 = v3;
          v21 = 0;
          v22 = 90;
          goto LABEL_15;
        case 4:
          v20 = v3;
          v21 = 90;
          goto LABEL_14;
        case 6:
          v20 = v3;
          v21 = 0;
LABEL_14:
          v22 = 180;
LABEL_15:
          v23 = sub_334E0(v20, v21, v22);
LABEL_16:
          v4 = *(_QWORD *)(v3 + 240);
          if ( v23 )
            goto LABEL_27;
          v7 = (_DWORD *)(v4 + 24);
          if ( !*(_DWORD *)(v4 + 24) )
            goto LABEL_22;
          v8 = *(_DWORD *)(v4 + 68);
          goto LABEL_19;
        default:
LABEL_19:
          if ( v8 & 8 )
          {
            v24 = *(_BYTE *)(v4 + 72);
          }
          else if ( !(v8 & 0x10) || (v24 = *(_BYTE *)(v4 + 72)) == 0 )
          {
LABEL_22:
            v23 = 0;
            *(_DWORD *)(v4 + 32) = 0;
            *v7 = 0;
            goto LABEL_27;
          }
          v25 = *(_DWORD *)(v4 + 4);
          *(_DWORD *)(v4 + 4) = *(_DWORD *)(v4 + 28);
          (*(void (__fastcall **)(unsigned int *, __int64, signed __int64))(qword_96CD8 + 352))(&v69, v4 + 44, 8i64);
          v26 = sub_32BCB(v3, &v69);
          v4 = *(_QWORD *)(v3 + 240);
          *(_DWORD *)(v4 + 4) = v25;
          if ( v26 )
          {
            v23 = 0;
          }
          else
          {
            *(_BYTE *)(v4 + 72) = v24 == 0;
            *(_DWORD *)(v4 + 68) = v8;
            v23 = 1;
          }
LABEL_27:
          v19 = v23 != 0;
          v5 = v23 == 0;
          goto LABEL_28;
      }
    }
    v19 = 0;
LABEL_28:
    v27 = *(_DWORD *)(v4 + 96);
    if ( v27 )
    {
      if ( v4 )
      {
        switch ( *(_DWORD *)(v4 + 124) & 7 )
        {
          case 1:
            v28 = *(_DWORD *)(v4 + 108);
            v71 = *(_DWORD *)(v4 + 116);
            v29 = v28 / v27;
            v30 = sub_2C860(*(unsigned __int8 *)(v4 + 120));
            v31 = *(_QWORD *)(v3 + 240);
            v32 = v30 - *(_DWORD *)(v31 + 116);
            if ( v28 <= 0 )
            {
              if ( v29 > v32 )
                goto LABEL_33;
            }
            else if ( v29 < v32 )
            {
LABEL_33:
              v33 = *(_DWORD *)(v31 + 108) / *(_DWORD *)(v31 + 96);
LABEL_56:
              v49 = v71 + v33;
              *(_DWORD *)(v31 + 116) = v49;
              v50 = sub_2C86B(v49);
              if ( (unsigned int)sub_27533(v3, v50) )
                goto LABEL_57;
              v66 = *(_QWORD *)(v3 + 240);
              ++*(_DWORD *)(v66 + 104);
              v38 = *(_BYTE *)(v3 + 168) != *(_BYTE *)(v66 + 120);
              goto LABEL_40;
            }
            v48 = sub_2C860(*(unsigned __int8 *)(v31 + 120));
            v31 = *(_QWORD *)(v3 + 240);
            v33 = v48 - *(_DWORD *)(v31 + 116);
            goto LABEL_56;
          case 2:
            v35 = v3;
            v36 = 0;
            v37 = 90;
            goto LABEL_39;
          case 4:
            v35 = v3;
            v36 = 90;
            goto LABEL_38;
          case 6:
            v35 = v3;
            v36 = 0;
LABEL_38:
            v37 = 180;
LABEL_39:
            v38 = sub_336BB(v35, v36, v37);
LABEL_40:
            if ( !v38 )
              goto LABEL_57;
            goto LABEL_65;
          default:
LABEL_57:
            v51 = *(_QWORD *)(v3 + 240);
            if ( !*(_DWORD *)(v51 + 96) )
              goto LABEL_61;
            v52 = *(_DWORD *)(v51 + 124);
            if ( v52 & 8 )
            {
              v53 = *(_BYTE *)(v51 + 128);
            }
            else if ( !(v52 & 0x10) || (v53 = *(_BYTE *)(v51 + 128)) == 0 )
            {
LABEL_61:
              v38 = 0;
              *(_DWORD *)(v51 + 104) = 0;
              *(_DWORD *)(v51 + 96) = 0;
              goto LABEL_65;
            }
            v54 = *(_DWORD *)(v51 + 4);
            *(_DWORD *)(v51 + 4) = *(_DWORD *)(v51 + 100);
            v55 = sub_32D82(v3, *(_BYTE *)(v51 + 112));
            v56 = *(_QWORD *)(v3 + 240);
            *(_DWORD *)(v56 + 4) = v54;
            if ( v55 )
              break;
            *(_BYTE *)(v56 + 128) = v53 == 0;
            *(_DWORD *)(v56 + 124) = v52;
            v38 = 1;
            goto LABEL_65;
        }
      }
      v38 = 0;
LABEL_65:
      v57 = v38 == 0;
      v34 = v38 == 0;
      v58 = v19;
      v19 = 1;
      if ( v57 )
        v19 = v58;
    }
    else
    {
      v34 = 0;
    }
    if ( v5 )
    {
      v59 = *(_QWORD *)(v3 + 240);
      v60 = *(void (__fastcall **)(__int64, _QWORD))(v59 + 80);
      if ( v60 )
        v60(v3, *(_QWORD *)(v59 + 88));
    }
    if ( v34 )
    {
      v61 = *(_QWORD *)(v3 + 240);
      v62 = *(void (__fastcall **)(__int64, _QWORD))(v61 + 136);
      if ( v62 )
        v62(v3, *(_QWORD *)(v61 + 144));
    }
    v63 = *(_QWORD *)(v3 + 240);
    LOBYTE(v5) = 1;
    if ( !*(_DWORD *)(v63 + 24) )
      LOBYTE(v5) = *(_DWORD *)(v63 + 96) != 0 || v19 != 0;
    v64 = *(unsigned __int8 (__fastcall **)(__int64))(v63 + 16);
    if ( v64 )
    {
      v57 = v64(v3) == 0;
      v65 = v5;
      LOBYTE(v5) = 1;
      if ( v57 )
        LOBYTE(v5) = v65;
      v63 = *(_QWORD *)(v3 + 240);
    }
    *(_BYTE *)v63 = v5;
  }
  if ( v2 )
    *v2 = v5;
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003340E) ----------------------------------------------------
signed __int64 __fastcall sub_3340E(__int64 a1, unsigned __int8 a2, int a3, int a4)
{
  signed __int64 v4; // r15
  int v5; // ebx
  int v6; // edi
  unsigned __int8 v7; // r14
  __int64 v8; // rsi
  __int64 v9; // rax
  int v10; // er12
  signed __int64 result; // rax
  __int64 v12; // rcx
  __int64 v13; // rax

  v4 = -9223372036854775799i64;
  if ( !a1 )
    return -9223372036854775806i64;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = *(_QWORD *)(a1 + 240);
  if ( v9 )
  {
    v10 = *(_DWORD *)(v9 + 4);
    goto LABEL_8;
  }
  v9 = sub_24136(152i64);
  *(_QWORD *)(v8 + 240) = v9;
  if ( !v9 )
    return v4;
  *(_DWORD *)(v9 + 8) = 1;
  v10 = 0;
LABEL_8:
  *(_DWORD *)(v9 + 4) = v5;
  *(_DWORD *)(v9 + 8) = v6 & 0x7FFFFFFF | *(_DWORD *)(v9 + 8) & 0x80000000;
  result = sub_27500(v8, v7);
  if ( (_DWORD)result )
    return result;
  v12 = *(_QWORD *)(v8 + 240);
  if ( !v12 )
  {
    v13 = sub_24136(152i64);
    v12 = v13;
    *(_QWORD *)(v8 + 240) = v13;
    result = -9223372036854775799i64;
    if ( !v12 )
      return result;
    *(_DWORD *)(v12 + 8) = 1;
  }
  *(_DWORD *)(v12 + 4) = v10;
  return 0i64;
}

//----- (00000000000334E0) ----------------------------------------------------
char __fastcall sub_334E0(__int64 a1, int a2, int a3)
{
  int v3; // er15
  __int64 v4; // r14
  int v5; // edi
  unsigned int v6; // eax
  __int64 v7; // rcx
  int v8; // eax
  int v9; // esi
  int v10; // ebx
  int v11; // eax
  int v12; // esi
  int v13; // ebx
  int v14; // eax
  int v15; // ebx
  unsigned int *v16; // rax
  unsigned int v17; // er12
  unsigned int v18; // er15
  signed int v19; // esi
  int v20; // edi
  int v21; // eax
  _DWORD *v22; // rcx
  int v23; // eax
  int v24; // eax
  signed int v25; // esi
  int v26; // edi
  int v27; // eax
  _DWORD *v28; // rcx
  int v29; // eax
  int v30; // eax
  _DWORD *v32; // rax
  int v33; // [rsp+20h] [rbp-40h]
  int v34; // [rsp+24h] [rbp-3Ch]
  unsigned int v35; // [rsp+28h] [rbp-38h]
  unsigned int v36; // [rsp+2Ch] [rbp-34h]

  if ( !*(_DWORD *)(*(_QWORD *)(a1 + 240) + 24i64) )
    return 0;
  v3 = a2;
  v4 = a1;
  v5 = a3 - a2;
  v6 = sub_2C860(a3 - a2);
  v7 = *(_QWORD *)(v4 + 240);
  v8 = v6 / *(_DWORD *)(v7 + 24);
  v9 = v8;
  v10 = v8 * *(_DWORD *)(v7 + 32);
  v11 = v10 + (unsigned __int64)sub_2C860(v3);
  v12 = v11 + v9;
  v13 = sub_32B0C(v11);
  v14 = (signed int)(v13 - (unsigned __int64)sub_32B0C(v12)) / (v5 / 90);
  v15 = -v14;
  if ( -v14 < 1 )
    v15 = v14;
  v16 = *(unsigned int **)(v4 + 240);
  v17 = v16[13];
  v35 = v16[13];
  v18 = v16[14];
  v36 = v16[14];
  v19 = v16[9];
  v20 = v15 * (unsigned __int64)sub_2C86B(v16[9]);
  v21 = sub_2C860(*(_DWORD *)(*(_QWORD *)(v4 + 240) + 60i64));
  v22 = *(_DWORD **)(v4 + 240);
  v23 = v21 - v22[13];
  if ( v19 <= 0 )
  {
    if ( v20 > v23 )
      goto LABEL_6;
  }
  else if ( v20 < v23 )
  {
LABEL_6:
    v24 = v15 * (unsigned __int64)sub_2C86B(v22[9]);
    goto LABEL_9;
  }
  v24 = (unsigned __int64)sub_2C860(v22[15]) - *(_DWORD *)(*(_QWORD *)(v4 + 240) + 52i64);
LABEL_9:
  v35 = v24 + v17;
  v25 = *(_DWORD *)(*(_QWORD *)(v4 + 240) + 40i64);
  v26 = v15 * (unsigned __int64)sub_2C86B(v25);
  v27 = sub_2C860(*(_DWORD *)(*(_QWORD *)(v4 + 240) + 64i64));
  v28 = *(_DWORD **)(v4 + 240);
  v29 = v27 - v28[14];
  if ( v25 <= 0 )
  {
    if ( v26 > v29 )
      goto LABEL_11;
LABEL_13:
    v30 = (unsigned __int64)sub_2C860(v28[16]) - *(_DWORD *)(*(_QWORD *)(v4 + 240) + 56i64);
    goto LABEL_14;
  }
  if ( v26 >= v29 )
    goto LABEL_13;
LABEL_11:
  v30 = v15 * (unsigned __int64)sub_2C86B(v28[10]);
LABEL_14:
  v36 = v30 + v18;
  (*(void (__fastcall **)(signed __int64, unsigned int *, signed __int64))(qword_96CD8 + 352))(
    *(_QWORD *)(v4 + 240) + 52i64,
    &v35,
    8i64);
  v33 = sub_2C86B(v35);
  v34 = sub_2C86B(v36);
  if ( (unsigned int)sub_27251(v4, &v33) )
    return 0;
  v32 = *(_DWORD **)(v4 + 240);
  ++v32[8];
  if ( *(_DWORD *)(v4 + 44) == v32[15] && *(_DWORD *)(v4 + 48) == v32[16] )
    return 0;
  return 1;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (00000000000336BB) ----------------------------------------------------
bool __fastcall sub_336BB(__int64 a1, int a2, int a3)
{
  int v3; // er15
  __int64 v4; // r14
  int v5; // edi
  unsigned int v6; // eax
  __int64 v7; // rcx
  int v8; // eax
  int v9; // esi
  int v10; // ebx
  int v11; // eax
  int v12; // esi
  int v13; // ebx
  int v14; // eax
  int v15; // ebx
  __int64 v16; // rax
  int v17; // esi
  int v18; // er15
  int v19; // edi
  int v20; // eax
  __int64 v21; // rcx
  int v22; // eax
  int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // eax
  __int64 v27; // rax

  if ( !*(_DWORD *)(*(_QWORD *)(a1 + 240) + 96i64) )
    return 0;
  v3 = a2;
  v4 = a1;
  v5 = a3 - a2;
  v6 = sub_2C860(a3 - a2);
  v7 = *(_QWORD *)(v4 + 240);
  v8 = v6 / *(_DWORD *)(v7 + 96);
  v9 = v8;
  v10 = v8 * *(_DWORD *)(v7 + 104);
  v11 = v10 + (unsigned __int64)sub_2C860(v3);
  v12 = v11 + v9;
  v13 = sub_32B0C(v11);
  v14 = (signed int)(v13 - (unsigned __int64)sub_32B0C(v12)) / (v5 / 90);
  v15 = -v14;
  if ( -v14 < 1 )
    v15 = v14;
  v16 = *(_QWORD *)(v4 + 240);
  v17 = *(_DWORD *)(v16 + 108);
  v18 = *(_DWORD *)(v16 + 116);
  v19 = v15 * (unsigned __int64)sub_2C86B(*(_DWORD *)(v16 + 108));
  v20 = sub_2C860(*(unsigned __int8 *)(*(_QWORD *)(v4 + 240) + 120i64));
  v21 = *(_QWORD *)(v4 + 240);
  v22 = v20 - *(_DWORD *)(v21 + 116);
  if ( v17 <= 0 )
  {
    if ( v19 > v22 )
      goto LABEL_6;
  }
  else if ( v19 < v22 )
  {
LABEL_6:
    v23 = v15 * (unsigned __int64)sub_2C86B(*(_DWORD *)(v21 + 108));
    goto LABEL_9;
  }
  v23 = (unsigned __int64)sub_2C860(*(unsigned __int8 *)(v21 + 120)) - *(_DWORD *)(*(_QWORD *)(v4 + 240) + 116i64);
LABEL_9:
  v24 = v18 + v23;
  *(_DWORD *)(*(_QWORD *)(v4 + 240) + 116i64) = v24;
  v25 = sub_2C86B(v24);
  if ( (unsigned int)sub_27533(v4, v25) )
    return 0;
  v27 = *(_QWORD *)(v4 + 240);
  ++*(_DWORD *)(v27 + 104);
  return *(_BYTE *)(v4 + 168) != *(_BYTE *)(v27 + 120);
}

//----- (00000000000337EF) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_337EF(_QWORD *a1, __int64 a2)
{
  unsigned int v2; // ebx
  __int64 v3; // rax
  __int64 v4; // r15
  __int64 v5; // rcx
  __int64 v7; // [rsp+28h] [rbp-108h]
  __int64 v8; // [rsp+30h] [rbp-100h]
  __int64 v9; // [rsp+38h] [rbp-F8h]
  __int64 v10; // [rsp+40h] [rbp-F0h]
  __int64 v11; // [rsp+48h] [rbp-E8h]
  __int64 v12; // [rsp+50h] [rbp-E0h]
  __int64 v13; // [rsp+58h] [rbp-D8h]
  __int64 v14; // [rsp+60h] [rbp-D0h]
  __int64 v15; // [rsp+68h] [rbp-C8h]
  __int64 v16; // [rsp+70h] [rbp-C0h]
  __int64 v17; // [rsp+78h] [rbp-B8h]
  __int64 v18; // [rsp+80h] [rbp-B0h]
  __int64 v19; // [rsp+88h] [rbp-A8h]
  __int64 v20; // [rsp+90h] [rbp-A0h]
  __int64 v21; // [rsp+98h] [rbp-98h]
  __int64 v22; // [rsp+A0h] [rbp-90h]
  __int64 v23; // [rsp+A8h] [rbp-88h]
  __int64 v24; // [rsp+B0h] [rbp-80h]
  char v25; // [rsp+B8h] [rbp-78h]
  int v26; // [rsp+BCh] [rbp-74h]
  int v27; // [rsp+C0h] [rbp-70h]
  int v28; // [rsp+C4h] [rbp-6Ch]
  int v29; // [rsp+C8h] [rbp-68h]
  int v30; // [rsp+CCh] [rbp-64h]
  int v31; // [rsp+D0h] [rbp-60h]
  int v32; // [rsp+D4h] [rbp-5Ch]
  int v33; // [rsp+D8h] [rbp-58h]
  int v34; // [rsp+DCh] [rbp-54h]
  __int64 v35; // [rsp+E0h] [rbp-50h]
  _QWORD *v36; // [rsp+E8h] [rbp-48h]
  __int64 v37; // [rsp+F0h] [rbp-40h]

  v36 = a1;
  v35 = 0i64;
  v23 = 0i64;
  v24 = *(_QWORD *)(a2 + 8);
  dword_9360C = 2 - ((unsigned __int8)sub_3FBF3() < 1u);
  v37 = sub_26E4B(&v35, (__int64)&v23);
  v2 = 4 * v24 * HIDWORD(v24);
  v3 = sub_24103(v2);
  v4 = v35;
  *(_QWORD *)(v35 + 16) = v3;
  *(_QWORD *)(v4 + 24) = v2;
  v5 = v24;
  *(_QWORD *)(v4 + 32) = v24;
  *(_DWORD *)(v4 + 88) = 0;
  v21 = 0i64;
  v22 = v5;
  sub_2445C(-1, v3, (unsigned int *)(v4 + 32), (unsigned int *)&v21);
  v31 = 0;
  v32 = *(_DWORD *)(v4 + 32) / 2;
  v34 = *(_DWORD *)(v4 + 36);
  v33 = 1;
  sub_2445C(-939523841, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v31);
  v27 = *(_DWORD *)(v4 + 36) / 2;
  v28 = 0;
  v30 = 1;
  v29 = *(_DWORD *)(v4 + 32);
  sub_2445C(-939523841, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v27);
  v31 = 0;
  v32 = 16;
  v34 = *(_DWORD *)(v4 + 36);
  v33 = 1;
  sub_2445C(-922812416, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v31);
  v31 = 0;
  v32 = *(_DWORD *)(v4 + 32) - 42;
  v34 = *(_DWORD *)(v4 + 36);
  v33 = 1;
  sub_2445C(-922812416, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v31);
  *(_QWORD *)&v29 = *(_QWORD *)&v33;
  *(_QWORD *)&v27 = *(_QWORD *)&v31;
  v28 = *(_DWORD *)(v4 + 32) - 135;
  sub_2445C(-922812416, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v27);
  sub_26B03(&v31, 0, 0, *(_DWORD *)(v4 + 36), 1u);
  sub_26AE1(&v25, *(_DWORD *)(v4 + 36) / 2, *(_DWORD *)(v4 + 32) / 2);
  *(_QWORD *)&v27 = *(_QWORD *)&v31;
  *(_QWORD *)&v29 = *(_QWORD *)&v33;
  v28 = v26 - 116;
  sub_2445C(-922812416, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v27);
  v7 = *(_QWORD *)&v31;
  v8 = *(_QWORD *)&v33;
  HIDWORD(v7) = v28 - 92;
  sub_2445C(-922812416, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v7);
  v9 = *(_QWORD *)&v31;
  v10 = *(_QWORD *)&v33;
  HIDWORD(v9) = v26 + 70;
  sub_2445C(-922812416, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v9);
  v11 = *(_QWORD *)&v31;
  v12 = *(_QWORD *)&v33;
  HIDWORD(v11) = HIDWORD(v9) - 81;
  sub_2445C(-922812416, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v11);
  v13 = *(_QWORD *)&v31;
  v14 = *(_QWORD *)&v33;
  HIDWORD(v13) = HIDWORD(v11) + (HIDWORD(v9) - HIDWORD(v11)) / 2;
  sub_2445C(-922812416, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v13);
  v15 = *(_QWORD *)&v31;
  v16 = *(_QWORD *)&v33;
  HIDWORD(v15) = HIDWORD(v9) + 23;
  sub_2445C(-922812416, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v15);
  v17 = *(_QWORD *)&v31;
  v18 = *(_QWORD *)&v33;
  HIDWORD(v17) = HIDWORD(v15) + 16;
  sub_2445C(-922812416, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v17);
  v19 = *(_QWORD *)&v31;
  v20 = *(_QWORD *)&v33;
  HIDWORD(v19) = HIDWORD(v17) + 16;
  sub_2445C(-922812416, *(_QWORD *)(v4 + 16), (unsigned int *)(v4 + 32), (unsigned int *)&v19);
  if ( v36 )
    *v36 = v35;
  return v37;
}
// 33834: write access to const memory at 9360C has been detected
// 9360C: using guessed type int dword_9360C;

//----- (0000000000033BD0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_33BD0(__int64 a1, _WORD *a2)
{
  _WORD *v2; // rsi
  __int64 v3; // rdi
  __int16 v4; // bx
  signed int v5; // edx
  void (__fastcall *v6)(__int64, _WORD *); // r14
  void (__fastcall *v7)(__int64, _WORD *); // r15
  int v8; // eax
  signed int v9; // ecx
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r9
  void (__fastcall *v14)(__int64, _WORD *); // r9
  __int64 v15; // r9
  __int64 v16; // r9

  if ( !a1 )
    return;
  v2 = a2;
  if ( !a2 )
    return;
  v3 = a1;
  v4 = *a2;
  v5 = (signed __int16)a2[1];
  v6 = *(void (__fastcall **)(__int64, _WORD *))(a1 + 144);
  v7 = *(void (__fastcall **)(__int64, _WORD *))(a1 + 152);
  v8 = (unsigned __int16)v2[1];
  v9 = (signed __int16)v2[1];
  if ( v5 <= 28729 )
  {
    if ( v9 > 28687 )
    {
      switch ( (_WORD)v5 )
      {
        case 0x7028:
          goto LABEL_13;
        case 0x7029:
          sub_1A11E();
          v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 32);
          goto LABEL_62;
        case 0x702A:
          goto LABEL_62;
        case 0x702B:
          sub_1A11E();
          v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 48);
          goto LABEL_62;
        case 0x702C:
          if ( !(v4 & 0x88) )
            goto LABEL_39;
          sub_1A11E();
          v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 128);
          goto LABEL_62;
        default:
          if ( v8 != 28688 && v8 != 28693 )
            goto LABEL_62;
          break;
      }
      goto LABEL_46;
    }
    if ( v8 != 45056 )
    {
      if ( v8 != 28681 && v8 != 28684 )
        goto LABEL_62;
LABEL_46:
      if ( v4 & 0x44 && v4 & 0x11 && v4 & 0x88 && v4 & 0x22 )
      {
        if ( v9 > 28687 )
        {
          if ( v8 == 28688 )
          {
            sub_1A11E();
            v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 104);
          }
          else if ( v8 == 28693 )
          {
            sub_1A11E();
            v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 112);
          }
        }
        else if ( v8 == 28681 )
        {
          sub_1A11E();
          v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 80);
        }
        else if ( v8 == 28684 )
        {
          sub_1A11E();
          v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 120);
        }
      }
      goto LABEL_62;
    }
LABEL_18:
    if ( qword_95210 )
    {
      if ( ++byte_95218 == 2 )
      {
        sub_35A74(qword_95210);
        qword_95210 = 0i64;
        v11 = *(_QWORD *)(v3 + 56);
        sub_1A11E();
LABEL_29:
        v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 56);
        goto LABEL_62;
      }
    }
    else
    {
      byte_95218 = 1;
      qword_95210 = sub_359AF((__int64)sub_34302, 0i64, 30000000i64, 0);
    }
    if ( v4 & 0x88 )
    {
      if ( v4 & 0x11 && v4 & 0x44 )
      {
        v15 = *(_QWORD *)(v3 + 88);
        sub_1A11E();
        v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 88);
      }
      else if ( v4 & 0x11 )
      {
        v16 = *(_QWORD *)(v3 + 96);
        sub_1A11E();
        v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 96);
      }
    }
    goto LABEL_62;
  }
  if ( v9 > 28750 )
  {
    switch ( (_WORD)v5 )
    {
      case 0x704F:
        v10 = *(_QWORD *)(v3 + 24);
        sub_1A11E();
        v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 24);
        break;
      case 0x7050:
        v12 = *(_QWORD *)(v3 + 16);
        sub_1A11E();
        v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 16);
        break;
      case 0x7051:
        v13 = *(_QWORD *)(v3 + 8);
        sub_1A11E();
        v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 8);
        break;
      case 0x7052:
        v14 = *(void (__fastcall **)(__int64, _WORD *))v3;
        sub_1A11E();
        v6 = *(void (__fastcall **)(__int64, _WORD *))v3;
        break;
      case 0x7058:
LABEL_13:
        if ( !*(_BYTE *)(v3 + 160) )
        {
          sub_1A11E();
          *(_BYTE *)(v3 + 160) = 1;
          v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 40);
        }
        break;
      default:
        goto LABEL_62;
    }
    goto LABEL_62;
  }
  if ( (unsigned __int16)(v5 - 28730) < 2u )
  {
LABEL_39:
    if ( v4 & 0x44 && v4 & 0x11 && v4 & 0x88 && v4 & 0x22 )
    {
      if ( v8 == 28731 )
      {
        sub_1A11E();
        v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 72);
      }
      else if ( v8 == 28730 )
      {
        sub_1A11E();
        v6 = *(void (__fastcall **)(__int64, _WORD *))(v3 + 64);
      }
      goto LABEL_62;
    }
    goto LABEL_46;
  }
  if ( v8 == 28734 )
  {
    if ( v4 & 0x88 )
    {
      sub_1A11E();
      goto LABEL_29;
    }
    goto LABEL_39;
  }
  if ( v8 == 28741 )
    goto LABEL_18;
LABEL_62:
  if ( v6 )
    v6(v3, v2);
  if ( v7 )
    v7(v3, v2);
}
// 33D32: write access to const memory at 95218 has been detected
// 33D45: write access to const memory at 95210 has been detected
// 33E23: write access to const memory at 95218 has been detected
// 33E41: write access to const memory at 95210 has been detected
// 95210: using guessed type __int64 qword_95210;
// 95218: using guessed type char byte_95218;

//----- (00000000000340E9) ----------------------------------------------------
signed __int64 __fastcall sub_340E9(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 *v3; // rsi
  __int64 v4; // rax
  signed __int64 result; // rax

  if ( a1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = sub_24136(200i64);
    *(_QWORD *)(v4 + 168) = v2;
    *v3 = v4;
    result = 0i64;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}

//----- (000000000003413D) ----------------------------------------------------
signed __int64 __fastcall sub_3413D(__int64 a1)
{
  __int64 v1; // rsi
  signed __int64 result; // rax
  __int64 v3; // rax

  if ( a1 && (v1 = a1, !*(_QWORD *)(a1 + 184)) )
  {
    v3 = sub_34446();
    if ( (*(__int64 (__fastcall **)(signed __int64, void (__fastcall *)(__int64, __int64), __int64, __int64))(v3 + 8))(
           3840i64,
           sub_34327,
           v1 + 184,
           v1) )
    {
      sub_1A11E();
    }
    result = 0i64;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}

//----- (00000000000341CC) ----------------------------------------------------
signed __int64 __fastcall sub_341CC(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rax
  signed __int64 result; // rax

  if ( a1 && (v1 = a1, *(_QWORD *)(a1 + 184)) )
  {
    v2 = sub_34446();
    if ( (*(__int64 (__fastcall **)(_QWORD))(v2 + 16))(*(_QWORD *)(v1 + 184)) )
      sub_1A11E();
    result = 0i64;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}

//----- (0000000000034247) ----------------------------------------------------
__int64 __fastcall sub_34247(__int64 a1)
{
  return *(unsigned int *)(a1 + 176);
}

//----- (0000000000034253) ----------------------------------------------------
signed __int64 __fastcall sub_34253(char *a1)
{
  char *v1; // rsi
  signed __int64 v2; // rdi

  if ( a1 )
  {
    v1 = a1;
    sub_1A11E();
    v2 = 0i64;
    sub_F180(v1, 0, 0xA0ui64);
    sub_F180(v1 + 160, 0, 1ui64);
  }
  else
  {
    sub_1A11E();
    v2 = 1i64;
  }
  return v2;
}

//----- (00000000000342D0) ----------------------------------------------------
__int64 __fastcall sub_342D0(__int64 a1)
{
  if ( a1 )
    return a1;
  sub_1A11E();
  return 0i64;
}

//----- (0000000000034302) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_34302()
{
  sub_35A74(qword_95210);
  qword_95210 = 0i64;
}
// 34316: write access to const memory at 95210 has been detected
// 95210: using guessed type __int64 qword_95210;

//----- (0000000000034327) ----------------------------------------------------
void __fastcall sub_34327(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // rax
  signed __int16 v5; // ax
  signed __int16 v6; // ax
  int v7; // eax
  __int64 (__fastcall *v8)(__int64, __int64); // rcx
  const char *v9; // r9

  if ( !a2 )
  {
    sub_1A11E();
    return;
  }
  v2 = a2;
  v3 = a1;
  ++*(_DWORD *)(a2 + 176);
  if ( a1 )
  {
    v4 = *(_QWORD *)(a1 + 16);
    if ( v4 )
      v5 = *(_WORD *)(v4 + 6);
    else
      v5 = -1;
    *(_WORD *)(a2 + 194) = v5;
    v6 = *(_WORD *)(a1 + 24);
  }
  else
  {
    sub_1A11E();
    *(_WORD *)(v2 + 194) = 1;
    sub_1A11E();
    v6 = 1;
  }
  *(_WORD *)(v2 + 192) = v6;
  v7 = *(_DWORD *)(v3 + 8);
  if ( _bittest(&v7, 8u) )
  {
    *(_BYTE *)(v2 + 196) = 1;
    v8 = sub_34497;
    v9 = "_KA_defferred_KeyboardEventHandler_keyDown";
LABEL_19:
    sub_2FACD((__int64)v8, v2, 0i64, (__int64)v9);
    return;
  }
  if ( _bittest(&v7, 9u) )
  {
    *(_BYTE *)(v2 + 196) = 0;
    v8 = sub_344BE;
    v9 = "_KA_defferred_KeyboardEventHandler_keyUp";
    goto LABEL_19;
  }
  if ( _bittest(&v7, 0xAu) )
  {
    *(_BYTE *)(v2 + 196) = 1;
    goto LABEL_18;
  }
  if ( _bittest(&v7, 0xBu) )
  {
    *(_BYTE *)(v2 + 196) = 0;
LABEL_18:
    v8 = sub_3450F;
    v9 = "_KA_defferred_KeyboardEventHandler_modifiers";
    goto LABEL_19;
  }
}

//----- (0000000000034446) ----------------------------------------------------
__int64 sub_34446()
{
  __int64 result; // rax

  result = qword_95220;
  if ( !qword_95220 )
  {
    if ( sub_27CFB((__int64 **)&qword_95220) || (result = qword_95220) == 0 )
    {
      sub_1A11E();
      result = 0i64;
    }
  }
  return result;
}
// 95220: using guessed type __int64 qword_95220;

//----- (0000000000034497) ----------------------------------------------------
__int64 __fastcall sub_34497(__int64 a1, __int64 a2)
{
  if ( a2 )
    sub_33BD0(a2, (_WORD *)(a2 + 192));
  return 0i64;
}

//----- (00000000000344BE) ----------------------------------------------------
__int64 __fastcall sub_344BE(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  int v3; // eax

  if ( a2 )
  {
    v2 = a2;
    v3 = *(unsigned __int16 *)(a2 + 194);
    if ( v3 == 28760 || (unsigned __int16)v3 == 28712 )
    {
      sub_1A11E();
      *(_BYTE *)(v2 + 160) = 0;
    }
  }
  return 0i64;
}

//----- (000000000003450F) ----------------------------------------------------
__int64 __fastcall sub_3450F(__int64 a1, __int64 a2)
{
  void (__fastcall *v2)(__int64, signed __int64); // rax

  if ( a2 )
  {
    v2 = *(void (__fastcall **)(__int64, signed __int64))(a2 + 136);
    if ( v2 )
      v2(a2, a2 + 192);
  }
  return 0i64;
}

//----- (000000000003453F) ----------------------------------------------------
__int64 __fastcall sub_3453F(__int64 a1, int a2)
{
  int v2; // edi
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // r9
  __int64 v6; // rcx

  v2 = a2;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 160);
  v5 = *(unsigned int *)(v4 + 24);
  sub_1A11E();
  if ( *(_DWORD *)(v4 + 24) != v2 )
  {
    *(_DWORD *)(v4 + 24) = v2;
    v6 = *(_QWORD *)(v3 + 80);
    if ( v6 )
    {
      if ( v2 )
        sub_3F3B4(v6, v3, 255, (__int64)sub_345BE, 0i64);
      else
        sub_3F58B(v6, v3);
    }
  }
  return 0i64;
}

//----- (00000000000345BE) ----------------------------------------------------
__int64 __fastcall sub_345BE(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // r14
  __int64 v5; // rax
  bool v6; // al
  int v7; // ecx
  unsigned int v8; // edi
  bool v9; // zf
  __int64 v11; // [rsp+28h] [rbp-38h]
  __int64 v12; // [rsp+30h] [rbp-30h]
  int v13; // [rsp+38h] [rbp-28h]
  int v14; // [rsp+3Ch] [rbp-24h]

  v2 = a2;
  v3 = (__int64)a1;
  v4 = a1[20];
  v13 = *(_DWORD *)(a2 + 28);
  v14 = *(_DWORD *)(a2 + 32);
  v5 = *(_QWORD *)((char *)a1 + 44);
  v12 = *(_QWORD *)((char *)a1 + 52);
  v11 = v5;
  v6 = sub_26AB0((int *)&v11, &v13);
  v7 = *(_DWORD *)(v2 + 16) & 0x1F;
  v8 = 0;
  if ( v7 == 1 )
    goto LABEL_6;
  if ( v7 == 4 )
  {
    if ( *(_BYTE *)(v4 + 28) )
    {
      LOBYTE(v8) = 1;
      if ( *(_BYTE *)(v4 + 29) )
        sub_2FACD((__int64)sub_34829, v3, 0i64, (__int64)"_UISingleTileView_deferred_buttonClicked");
    }
    else
    {
      v8 = 0;
    }
    goto LABEL_15;
  }
  if ( v7 != 2 )
  {
LABEL_15:
    if ( *(_BYTE *)(v4 + 28) )
      *(_WORD *)(v4 + 28) = 0;
    LOBYTE(v7) = v8;
    goto LABEL_18;
  }
  if ( v6 )
  {
    *(_BYTE *)(v4 + 28) = 1;
    LOBYTE(v7) = 1;
    goto LABEL_7;
  }
LABEL_6:
  v7 = 0;
LABEL_7:
  if ( *(_BYTE *)(v4 + 28) )
  {
    LOBYTE(v8) = 1;
    v9 = *(_BYTE *)(v4 + 29) == v6;
    *(_BYTE *)(v4 + 29) = v6;
    if ( !v9 )
      goto LABEL_19;
  }
  else
  {
    v8 = v7;
  }
LABEL_18:
  if ( (_BYTE)v7 )
  {
LABEL_19:
    sub_34774(v3);
    sub_3F6AA(*(_QWORD **)(v3 + 80));
  }
  return v8;
}

//----- (000000000003469F) ----------------------------------------------------
signed __int64 __fastcall sub_3469F(_QWORD *a1, __int64 **a2)
{
  __int64 **v2; // rbx
  _QWORD *v3; // r15
  signed __int64 v4; // rsi
  _QWORD *v5; // rax
  int v6; // ecx
  __int64 v7; // rcx
  __int64 v8; // rax
  _QWORD *v9; // rax
  __int64 *v10; // rdx
  __int64 v11; // rcx
  __int64 v13; // [rsp+20h] [rbp-40h]
  __int64 v14; // [rsp+28h] [rbp-38h]
  _QWORD *v15; // [rsp+30h] [rbp-30h]

  if ( a1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = 0i64;
    v14 = 0i64;
    v13 = 0i64;
    v14 = **a2;
    v15 = 0i64;
    sub_26E4B((__int64 *)&v15, (__int64)&v13);
    v5 = v15;
    v6 = v14;
    v15[4] = v14;
    v7 = 4 * SHIDWORD(v14) * (signed __int64)v6;
    v5[3] = v7;
    v8 = sub_24103(v7);
    v15[2] = v8;
    v9 = (_QWORD *)sub_24136(32i64);
    v10 = v2[1];
    *v9 = *v2;
    v9[1] = v10;
    v9[2] = v2[2];
    v11 = (__int64)v15;
    v15[20] = v9;
    sub_34774(v11);
    *v3 = v15;
  }
  else
  {
    sub_1A11E();
    v4 = 1i64;
  }
  return v4;
}

//----- (0000000000034774) ----------------------------------------------------
int **__fastcall sub_34774(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rcx
  __int64 *v3; // rax
  __int64 *v4; // rax
  __int64 v5; // rdi
  __int64 v6; // rax
  int **result; // rax
  __int64 v8; // [rsp+40h] [rbp-30h]
  __int64 v9; // [rsp+48h] [rbp-28h]
  __int64 v10; // [rsp+50h] [rbp-20h]

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 160);
  v3 = *(__int64 **)v2;
  if ( *(_DWORD *)(v2 + 24) == 1 )
  {
    if ( *(_BYTE *)(v2 + 29) )
      v4 = v3 + 6;
    else
      v4 = v3 + 5;
  }
  else
  {
    v4 = v3 + 1;
  }
  v5 = *v4;
  v6 = *(_QWORD *)(v1 + 44);
  v9 = *(_QWORD *)(v1 + 52);
  v8 = 0i64;
  sub_2445C(-1, *(_QWORD *)(v1 + 16), (unsigned int *)(v1 + 32), (unsigned int *)&v8);
  result = *(int ***)(v1 + 160);
  v10 = 0i64;
  if ( v5 )
    result = (int **)sub_244D1(*(_QWORD *)(v1 + 16), v1 + 52, (int *)&v8, v5, *result, (int *)&v10, 0, v1 + 176);
  *(_BYTE *)(v1 + 40) = 1;
  return result;
}

//----- (0000000000034829) ----------------------------------------------------
__int64 __fastcall sub_34829(__int64 a1, __int64 a2)
{
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a2 + 160) + 8i64))(
    a2,
    *(_QWORD *)(*(_QWORD *)(a2 + 160) + 16i64));
  return 0i64;
}

//----- (000000000003484A) ----------------------------------------------------
signed __int64 __fastcall sub_3484A(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rsi
  _QWORD *v4; // rax
  _QWORD *v5; // rdi
  signed __int64 result; // rax

  if ( a1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = (_QWORD *)sub_24136(16i64);
    if ( v4 )
    {
      v5 = v4;
      if ( sub_2C1A0(v2, L"preferences.efires", v4) )
        sub_1A11E();
      *v3 = v5;
      result = 0i64;
    }
    else
    {
      sub_1A11E();
      result = 100i64;
    }
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}
// 417FC: using guessed type __int16 aPreferencesEfi[19];

//----- (00000000000348ED) ----------------------------------------------------
unsigned __int64 *__fastcall sub_348ED(unsigned __int64 **a1)
{
  unsigned __int64 **v1; // rsi
  unsigned __int64 *v2; // rcx

  if ( !a1 )
    return 0i64;
  v1 = a1;
  v2 = *a1;
  if ( !v2 )
    return 0i64;
  sub_2C719(v2, "preferences_systemLanguage.utf8", 1, (char **)v1 + 1, 0i64, 0);
  return v1[1];
}

//----- (0000000000034936) ----------------------------------------------------
char __fastcall sub_34936(unsigned __int64 **a1)
{
  char *v1; // rax
  char result; // al

  v1 = (char *)sub_3495B(a1, "preferences_isIMEnabled.int32");
  if ( v1 )
    result = *v1;
  else
    result = 1;
  return result;
}

//----- (000000000003495B) ----------------------------------------------------
__int64 __fastcall sub_3495B(unsigned __int64 **a1, char *a2)
{
  unsigned __int64 *v2; // rcx
  __int64 v3; // rdi
  __int64 v5; // [rsp+30h] [rbp-20h]
  __int64 v6; // [rsp+38h] [rbp-18h]

  v2 = *a1;
  if ( !v2 )
    return 0i64;
  v3 = 0i64;
  if ( !sub_2C719(v2, a2, 0, (char **)&v5, (unsigned __int64 *)&v6, 1) )
  {
    if ( v6 != 4 )
      sub_1A11E();
    v3 = v5;
  }
  return v3;
}

//----- (00000000000349C6) ----------------------------------------------------
char __fastcall sub_349C6(unsigned __int64 **a1)
{
  char *v1; // rax
  char result; // al

  v1 = (char *)sub_3495B(a1, "preferences_isVOEnabled.int32");
  if ( v1 )
    result = *v1;
  else
    result = 0;
  return result;
}

//----- (00000000000349EB) ----------------------------------------------------
__int64 __fastcall sub_349EB(unsigned __int64 **a1)
{
  unsigned __int64 *v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 )
    result = sub_2BA6A(v1, "preferences_good_samaritan_message_ribbon.png");
  else
    result = 0i64;
  return result;
}

//----- (0000000000034A08) ----------------------------------------------------
char __fastcall sub_34A08(unsigned __int64 **a1)
{
  char *v1; // rax
  char result; // al

  v1 = (char *)sub_3495B(a1, "preferences_showGuest.int32");
  if ( v1 )
    result = *v1;
  else
    result = 0;
  return result;
}

//----- (0000000000034A2F) ----------------------------------------------------
signed __int64 __fastcall sub_34A2F(__int64 a1)
{
  __int64 v1; // r13
  __int64 v2; // r12
  __int64 v3; // rbx
  __int64 v4; // r15
  __int64 v5; // r14
  unsigned int v7[4]; // [rsp+48h] [rbp-A8h]
  unsigned int v8[4]; // [rsp+58h] [rbp-98h]
  int v9[4]; // [rsp+68h] [rbp-88h]
  unsigned int v10[2]; // [rsp+78h] [rbp-78h]
  __int64 v11; // [rsp+80h] [rbp-70h]
  __int64 v12; // [rsp+88h] [rbp-68h]
  int *v13; // [rsp+90h] [rbp-60h]
  __int64 v14; // [rsp+98h] [rbp-58h]
  int v15; // [rsp+A0h] [rbp-50h]
  int v16; // [rsp+A4h] [rbp-4Ch]
  __int64 v17; // [rsp+A8h] [rbp-48h]
  int v18; // [rsp+B0h] [rbp-40h]
  int v19; // [rsp+B4h] [rbp-3Ch]

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 160);
  v3 = a1 + 32;
  sub_26B03(v9, 0, 0, *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 32));
  v14 = 0i64;
  if ( *(_DWORD *)(v1 + 32) > 0 )
  {
    do
    {
      sub_244D1(*(_QWORD *)(v1 + 16), v3, v9, *(_QWORD *)(v2 + 48), (int *)(v2 + 56), (int *)&v14, 0, v1 + 176);
      HIDWORD(v14) += *(_DWORD *)(v2 + 56);
    }
    while ( SHIDWORD(v14) < *(_DWORD *)(v1 + 32) );
  }
  sub_34D38(v1, &v15);
  if ( !*(_QWORD *)(v2 + 112) )
  {
    v12 = v3;
    sub_26AE1(v10, 0, 0);
    v11 = v17;
    v4 = sub_24103(4 * SHIDWORD(v17) * (signed __int64)(signed int)v17);
    sub_2445C(-1, v4, (unsigned int *)&v17, v10);
    v5 = *(_QWORD *)(v1 + 160);
    sub_26AE1(&v18, 0, 0);
    *(_QWORD *)&v18 = 0i64;
    if ( (signed int)v17 > 0 )
    {
      do
      {
        sub_244D1(v4, (__int64)&v17, (int *)v10, *(_QWORD *)(v5 + 16), (int *)(v5 + 24), &v18, 0, v1 + 176);
        v19 += *(_DWORD *)(v5 + 24);
      }
      while ( v19 < (signed int)v17 );
    }
    v13 = (int *)(v5 + 8);
    sub_26B03(v7, 0, 0, *(_DWORD *)(v5 + 12), *(_DWORD *)(v5 + 8));
    sub_2445C(-1, v4, (unsigned int *)&v17, v7);
    sub_26AE1(&v18, 0, 0);
    sub_244D1(v4, (__int64)&v17, (int *)v10, *(_QWORD *)v5, v13, &v18, 0, v1 + 176);
    sub_26B03(v8, 0, v17 - *(_DWORD *)(v5 + 40), *(_DWORD *)(v5 + 44), *(_DWORD *)(v5 + 40));
    sub_2445C(-1, v4, (unsigned int *)&v17, v8);
    sub_26AE1(&v18, 0, v17 - *(_DWORD *)(v5 + 40));
    sub_244D1(v4, (__int64)&v17, (int *)v10, *(_QWORD *)(v5 + 32), (int *)(v5 + 40), &v18, 0, v1 + 176);
    *(_QWORD *)(v2 + 112) = v4;
    *(_QWORD *)(v2 + 120) = v17;
    v3 = v12;
  }
  sub_26AE1(&v14, v15, v16);
  return sub_244D1(*(_QWORD *)(v1 + 16), v3, v9, *(_QWORD *)(v2 + 112), (int *)(v2 + 120), (int *)&v14, 0, v1 + 176);
}

//----- (0000000000034D13) ----------------------------------------------------
signed __int64 __fastcall sub_34D13(__int64 a1)
{
  __int64 v1; // rsi

  v1 = a1;
  sub_34A2F(a1);
  *(_BYTE *)(v1 + 40) = 1;
  return sub_3F6AA(*(_QWORD **)(v1 + 80));
}

//----- (0000000000034D38) ----------------------------------------------------
void __fastcall sub_34D38(__int64 a1, _DWORD *a2)
{
  _DWORD *v2; // r14
  __int64 v3; // rdi
  __int64 v4; // rbx
  int v5; // er12
  unsigned int v6; // esi
  int v7; // er13
  unsigned int v8; // eax
  unsigned int v9; // eax
  signed int v10; // eax
  signed int v11; // edi
  unsigned int v12; // esi
  unsigned int v13; // eax
  unsigned int v14; // eax
  int v15; // eax
  char v16; // [rsp+28h] [rbp-48h]
  int v17; // [rsp+2Ch] [rbp-44h]
  int v18; // [rsp+30h] [rbp-40h]

  if ( a1 )
  {
    v2 = a2;
    v3 = a1;
    v4 = *(_QWORD *)(a1 + 160);
    sub_31FE6(&v16, *(_QWORD *)(v4 + 80));
    v5 = sub_3201C(*(_QWORD *)(v4 + 80));
    v6 = sub_2C972(v18, v5);
    v7 = *(_DWORD *)(v3 + 32);
    v8 = sub_2C860(*(_DWORD *)(v3 + 32));
    v9 = sub_2C899(v6, v8);
    v10 = sub_2C86B(v9);
    v11 = *(_DWORD *)(v4 + 8) + *(_DWORD *)(v4 + 40);
    if ( v10 >= v11 )
      v11 = v10;
    v12 = sub_2C972(v17, v5 + v18 % 2 - v18);
    v13 = sub_2C860(v7 + v11 % 2 - v11);
    v14 = sub_2C899(v12, v13);
    v15 = sub_2C86B(v14);
    if ( v2 )
      sub_26B03(v2, 0, v15, *(_DWORD *)(v4 + 60), v11);
  }
}

//----- (0000000000034E27) ----------------------------------------------------
__int64 __fastcall sub_34E27(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r14
  __int64 v6; // r15
  __int64 v7; // rdi
  _QWORD *v8; // rbx
  __int64 v9; // rsi

  v5 = a4;
  v6 = a3;
  v7 = a2;
  v8 = a1;
  if ( (unsigned int)sub_3511E() )
  {
    v9 = sub_24136(56i64);
    *(_QWORD *)(v9 + 40) = sub_359AF((__int64)sub_34EC2, v9, 20000000i64, 1u);
    *(_QWORD *)(v9 + 16) = v8;
    *(_QWORD *)v9 = v7;
    *(_QWORD *)(v9 + 8) = v6;
    *(_QWORD *)(v9 + 24) = v5;
    *(_QWORD *)(v9 + 32) = a5;
    *(_BYTE *)(v9 + 48) = -1;
    *(_DWORD *)(v9 + 52) = -1;
    sub_34F2B(v9);
  }
  else
  {
    if ( v8 )
      *v8 = 0i64;
    v9 = 0i64;
  }
  return v9;
}

//----- (0000000000034EC2) ----------------------------------------------------
void __fastcall sub_34EC2(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  char v3; // bl
  int v4; // eax
  void (__fastcall *v5)(__int64, _QWORD); // rax

  v2 = a2;
  v3 = sub_351CC();
  v4 = sub_3511E();
  if ( v4 )
  {
    if ( *(_BYTE *)(v2 + 48) != v3 || *(_DWORD *)(v2 + 52) != v4 )
    {
      sub_34F2B(v2);
      v5 = *(void (__fastcall **)(__int64, _QWORD))(v2 + 24);
      if ( v5 )
        v5(v2, *(_QWORD *)(v2 + 32));
    }
  }
  else
  {
    sub_1A11E();
  }
}

//----- (0000000000034F2B) ----------------------------------------------------
void __fastcall sub_34F2B(__int64 a1)
{
  __int64 v1; // rsi
  unsigned int v2; // eax
  __int64 v3; // rbx
  char *v4; // rdi
  unsigned __int8 v5; // al
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 *v8; // rax
  __int64 v9; // rdx
  unsigned __int8 v10; // r14
  char v11; // [rsp+20h] [rbp-60h]

  v1 = a1;
  v2 = sub_3511E();
  *(_DWORD *)(v1 + 52) = v2;
  if ( v2 > 4 )
  {
    v3 = 0i64;
    v4 = 0i64;
  }
  else
  {
    v3 = qword_91E80[v2];
    v4 = (&off_91EA8)[v2];
  }
  v5 = sub_351CC();
  *(_BYTE *)(v1 + 48) = v5;
  if ( !v4 )
  {
    v4 = &v11;
    sub_18905((unsigned __int64)&v11, (__int64)"battery_%s_%d.png", v3, v5);
  }
  v6 = sub_2BA6A(*(unsigned __int64 **)(v1 + 8), v4);
  if ( v6 )
  {
    v7 = v6;
    v8 = *(__int64 **)(v1 + 16);
    v9 = *v8;
    if ( *v8 && *(_QWORD *)(v9 + 80) )
    {
      v10 = *(_BYTE *)(v9 + 168);
      sub_3F1DC(*(_QWORD *)v1, (__int64 *)v9);
      sub_27500(v7, v10);
      sub_3F340(*(_QWORD *)v1, v7);
      v8 = *(__int64 **)(v1 + 16);
    }
    *v8 = v7;
  }
  sub_1A11E();
}
// 91E80: using guessed type __int64 qword_91E80[];
// 91EA8: using guessed type char *off_91EA8;

//----- (0000000000035006) ----------------------------------------------------
__int64 __fastcall sub_35006(__int64 a1)
{
  __int64 v1; // rsi

  if ( a1 )
  {
    v1 = a1;
    sub_35A74(*(_QWORD *)(a1 + 40));
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v1);
  }
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000035036) ----------------------------------------------------
signed __int64 __fastcall sub_35036(unsigned int a1, _BYTE *a2)
{
  _BYTE *v2; // rdi
  signed __int64 result; // rax
  char v4; // [rsp+3Fh] [rbp-11h]

  v2 = a2;
  v4 = 0;
  LOBYTE(a2) = 1;
  if ( sub_350AF(a1, (unsigned int)a2, (__int64)&v4) )
  {
    sub_1A11E();
    result = 1i64;
  }
  else
  {
    if ( v2 )
      *v2 = v4;
    result = 0i64;
  }
  return result;
}

//----- (00000000000350AF) ----------------------------------------------------
__int64 __fastcall sub_350AF(unsigned int a1, unsigned int a2, __int64 a3)
{
  __int64 v3; // rsi
  unsigned int v4; // ebx
  unsigned int v5; // edi
  __int64 v7; // [rsp+20h] [rbp-20h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v7 = 0i64;
  if ( !(*(__int64 (__fastcall **)(__int64 *, _QWORD))(qword_96CD8 + 320))(qword_92C40, 0i64) )
    return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, __int64))(v7 + 8))(v7, v5, v4, v3);
  sub_1A11E();
  return 0i64;
}
// 92C40: using guessed type __int64 qword_92C40[2];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003511E) ----------------------------------------------------
signed __int64 sub_3511E()
{
  signed __int64 v0; // rcx
  signed __int64 result; // rax
  char v2; // [rsp+25h] [rbp-Bh]
  char v3; // [rsp+26h] [rbp-Ah]
  char v4; // [rsp+27h] [rbp-9h]

  v4 = 0;
  v0 = sub_35036(0x4242494Eu, &v4);
  result = 0i64;
  if ( !v0 )
  {
    if ( v4 )
    {
      v2 = 0;
      sub_35036(0x42424144u, &v2);
      result = 4i64;
      if ( v2 != 1 )
      {
        v3 = 0;
        sub_35036(0x4253496Eu, &v3);
        result = 2i64;
      }
    }
    else
    {
      result = 3i64;
    }
  }
  return result;
}

//----- (000000000003518C) ----------------------------------------------------
char sub_3518C()
{
  char v1; // [rsp+2Fh] [rbp-1h]

  v1 = 0;
  if ( sub_35036(0x42415450u, &v1) )
    sub_1A11E();
  return v1;
}

//----- (00000000000351CC) ----------------------------------------------------
__int64 sub_351CC()
{
  unsigned __int64 v0; // rax
  __int16 v2; // [rsp+26h] [rbp-Ah]

  v2 = 0;
  v0 = sub_350AF(0x42525343u, 2u, (__int64)&v2);
  return (unsigned __int8)(HIBYTE(v2) | -(v0 >= 1));
}

//----- (0000000000035204) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 sub_35204()
{
  const char *v0; // rsi
  char *v1; // r14
  int v2; // ebx
  signed __int64 i; // rdi
  const char *v5; // [rsp+30h] [rbp-C0h]
  const char *v6; // [rsp+38h] [rbp-B8h]
  const char *v7; // [rsp+40h] [rbp-B0h]
  const char *v8; // [rsp+48h] [rbp-A8h]
  const char *v9; // [rsp+50h] [rbp-A0h]
  const char *v10; // [rsp+58h] [rbp-98h]
  const char *v11; // [rsp+60h] [rbp-90h]
  const char *v12; // [rsp+68h] [rbp-88h]
  const char *v13; // [rsp+70h] [rbp-80h]
  const char *v14; // [rsp+78h] [rbp-78h]
  const char *v15; // [rsp+80h] [rbp-70h]
  const char *v16; // [rsp+88h] [rbp-68h]
  const char *v17; // [rsp+90h] [rbp-60h]
  const char *v18; // [rsp+98h] [rbp-58h]
  const char *v19; // [rsp+A0h] [rbp-50h]
  const char *v20; // [rsp+A8h] [rbp-48h]
  const char *v21; // [rsp+B0h] [rbp-40h]
  const char *v22; // [rsp+B8h] [rbp-38h]
  const char *v23; // [rsp+C0h] [rbp-30h]
  const char *v24; // [rsp+C8h] [rbp-28h]

  dword_9362C = 0;
  v0 = "MacBookPro1,1";
  v5 = "MacBookPro1,1";
  v6 = "MacBookPro1,2";
  v7 = "MacBookPro2,1";
  v8 = "MacBookPro2,2";
  v9 = "MacBookP1,1";
  v10 = "MacBookP1,2";
  v11 = "MacBookP2,1";
  v12 = "MacBookP2,2";
  v13 = "MacBook1,1";
  v14 = "MacBook2,1";
  v15 = "Macmini1,1";
  v16 = "Macmini2,1";
  v17 = "iMac4,1";
  v18 = "iMac4,2";
  v19 = "iMac5,1";
  v20 = "iMac5,2";
  v21 = "iMac6,1";
  v22 = "MacPro1,1";
  v23 = "MacPro2,1";
  v24 = "XServe1,1";
  v1 = sub_98E2();
  v2 = sub_189FE(v1);
  for ( i = 1i64; ; ++i )
  {
    if ( !(unsigned int)sub_18A43((__int64)v1, (__int64)v0, v2) )
      dword_9362C = 1;
    if ( i == 20 )
      break;
    v0 = (&v5)[i];
  }
  sub_1A11E();
  return 0xFFFFFFFFi64;
}
// 35222: write access to const memory at 9362C has been detected
// 3534A: write access to const memory at 9362C has been detected
// 9362C: using guessed type int dword_9362C;

//----- (00000000000353A0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_353A0(__int64 a1, unsigned __int64 a2, char a3)
{
  char v3; // r13
  unsigned __int64 v4; // rsi
  __int64 v5; // r14
  __int64 v6; // rbx
  signed __int64 v7; // rdi
  __int64 v8; // rax
  signed __int64 v9; // rbx
  int v10; // edx
  __int16 v11; // cx
  signed __int64 v12; // rbx
  int v13; // edx
  __int16 v14; // cx
  signed __int64 v15; // rbx
  int v16; // edx
  __int16 v17; // cx
  __int16 v19[1024]; // [rsp+30h] [rbp-1850h]
  __int16 v20[1024]; // [rsp+830h] [rbp-1050h]
  __int16 v21[1024]; // [rsp+1030h] [rbp-850h]
  __int64 v22; // [rsp+1830h] [rbp-50h]
  unsigned __int64 v23; // [rsp+1838h] [rbp-48h]
  __int64 v24; // [rsp+1840h] [rbp-40h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_93610, 0i64, &v22);
  if ( v6 >= 0 )
  {
    if ( !byte_95230 )
    {
      sub_3560A();
      byte_95230 = 1;
    }
    v24 = v6;
    if ( v3 )
    {
      (*(void (__fastcall **)(__int16 *, signed __int64, _QWORD))(qword_96CD8 + 360))(v19, 2048i64, 0i64);
      (*(void (__fastcall **)(__int16 *, signed __int64, _QWORD))(qword_96CD8 + 360))(v20, 2048i64, 0i64);
      (*(void (__fastcall **)(__int16 *, signed __int64, _QWORD))(qword_96CD8 + 360))(v21, 2048i64, 0i64);
    }
    else
    {
      (*(void (__fastcall **)(__int16 *, __int64 *, signed __int64))(qword_96CD8 + 352))(v19, qword_95240, 2048i64);
      (*(void (__fastcall **)(__int16 *, __int64 *, signed __int64))(qword_96CD8 + 352))(v20, qword_95A40, 2048i64);
      (*(void (__fastcall **)(__int16 *, __int64 *, signed __int64))(qword_96CD8 + 352))(v21, qword_96240, 2048i64);
    }
    if ( v4 < 2 )
    {
LABEL_23:
      if ( v3 )
        sub_357DF();
      else
        sub_35852();
      v6 = v24;
    }
    else
    {
      v23 = 1000 * v5;
      v7 = 1i64;
      while ( 1 )
      {
        v8 = (*(__int64 (__fastcall **)(__int64, signed __int64, signed __int64, __int16 *, __int16 *, __int16 *))(v22 + 8))(
               v22,
               2i64,
               1024i64,
               v19,
               v20,
               v21);
        v6 = v8;
        if ( v8 < 0 )
          break;
        v24 = v8;
        v9 = 1023i64;
        do
        {
          v10 = *((unsigned __int16 *)qword_95240 + v9) / v4 * v7;
          v11 = *((_WORD *)qword_95240 + v9) - v10;
          if ( v3 )
            v11 = *((unsigned __int16 *)qword_95240 + v9) / v4 * v7;
          v19[v9--] = v11;
        }
        while ( v9 != -1 );
        v12 = 1023i64;
        do
        {
          v13 = *((unsigned __int16 *)qword_95A40 + v12) / v4 * v7;
          v14 = *((_WORD *)qword_95A40 + v12) - v13;
          if ( v3 )
            v14 = *((unsigned __int16 *)qword_95A40 + v12) / v4 * v7;
          v20[v12--] = v14;
        }
        while ( v12 != -1 );
        v15 = 1023i64;
        do
        {
          v16 = *((unsigned __int16 *)qword_96240 + v15) / v4 * v7;
          v17 = *((_WORD *)qword_96240 + v15) - v16;
          if ( v3 )
            v17 = *((unsigned __int16 *)qword_96240 + v15) / v4 * v7;
          v21[v15--] = v17;
        }
        while ( v15 != -1 );
        (*(void (__fastcall **)(unsigned __int64, unsigned __int64, __int64 *))(qword_96CD8 + 248))(
          v23 / v4,
          v23 % v4,
          qword_95240);
        if ( ++v7 >= v4 )
          goto LABEL_23;
      }
    }
  }
  return v6;
}
// 353F3: write access to const memory at 95230 has been detected
// 93610: using guessed type __int64 qword_93610[2];
// 95230: using guessed type char byte_95230;
// 95240: using guessed type __int64 qword_95240[256];
// 95A40: using guessed type __int64 qword_95A40[256];
// 96240: using guessed type __int64 qword_96240[256];
// 96CD8: using guessed type __int64 qword_96CD8;
// 353A0: using guessed type __int16 var_1850[1024];
// 353A0: using guessed type __int16 var_1050[1024];
// 353A0: using guessed type __int16 var_850[1024];

//----- (000000000003560A) ----------------------------------------------------
signed __int64 sub_3560A()
{
  __int64 v0; // rax
  signed __int64 v1; // rcx
  __int64 v2; // rax
  __int64 v3; // r14
  __int64 v4; // rax
  __int64 v5; // rax
  signed __int64 v6; // rdx
  __int64 v7; // rbx
  unsigned __int16 *v8; // rdi
  unsigned __int16 *v9; // rbx
  signed __int64 result; // rax
  __int64 v11; // [rsp+28h] [rbp-28h]

  v11 = 0i64;
  v0 = (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD))(qword_96CE0 + 72))("b", qword_93650, 0i64);
  WORD1(v1) = 0;
  if ( v0 == -9223372036854775803i64 )
  {
    v2 = sub_24136(v11);
    if ( !v2 )
    {
LABEL_5:
      v3 = 0i64;
      goto LABEL_15;
    }
    v3 = v2;
    if ( (*(__int64 (__fastcall **)(const char *, __int64 *, _QWORD, __int64 *, __int64))(qword_96CE0 + 72))(
           "b",
           qword_93650,
           0i64,
           &v11,
           v2) < 0 )
    {
      (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v3);
      goto LABEL_5;
    }
  }
  else
  {
    v3 = 0i64;
    if ( v0 < 0 )
      goto LABEL_15;
  }
  if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_92AB0, 0i64, &v11) >= 0 )
  {
    if ( v3 )
    {
      v4 = *(_QWORD *)(v11 + 8);
      LODWORD(v1) = *(unsigned __int8 *)(v4 + 8) << 8;
      if ( *(_DWORD *)v3 == ((unsigned int)v1 | *(unsigned __int8 *)(v4 + 9)) )
      {
        LODWORD(v1) = *(unsigned __int8 *)(v4 + 11) << 8;
        if ( *(_DWORD *)(v3 + 4) == *(unsigned __int16 *)(v4 + 10) )
        {
          LODWORD(v1) = *(_DWORD *)(v3 + 8);
          if ( !(_DWORD)v1 || (_DWORD)v1 == *(_DWORD *)(v4 + 12) )
          {
            v5 = *(unsigned __int16 *)(v3 + 20);
            v6 = v3 + 4 * v5;
            v7 = *(unsigned __int16 *)(v6 + 22);
            v1 = 4 * v5 + 4 * v7 + 22 + 4i64 * *(unsigned __int16 *)(v3 + 4 * v5 + 4 * v7 + 24) + 4;
            if ( v1 == *(unsigned __int16 *)(v3 + 12) )
            {
              v8 = (unsigned __int16 *)(v3 + 4 * v5 + 22);
              v9 = (unsigned __int16 *)(v6 + 4 * v7 + 24);
              sub_35907((unsigned __int16 *)(v3 + 20), (__int64)qword_95240);
              sub_35907(v8, (__int64)qword_95A40);
              sub_35907(v9, (__int64)qword_96240);
              return (*(__int64 (__fastcall **)(__int64))(qword_96CD8 + 72))(v3);
            }
          }
        }
      }
    }
  }
LABEL_15:
  result = 1023i64;
  LOWORD(v1) = -64;
  do
  {
    *((_WORD *)qword_96240 + result) = v1;
    *((_WORD *)qword_95A40 + result) = v1;
    *((_WORD *)qword_95240 + result--) = v1;
    LODWORD(v1) = v1 - 64;
  }
  while ( result != -1 );
  if ( v3 )
    return (*(__int64 (__fastcall **)(__int64))(qword_96CD8 + 72))(v3);
  return result;
}
// 92AB0: using guessed type __int64 qword_92AB0[2];
// 93650: using guessed type __int64 qword_93650[2];
// 95240: using guessed type __int64 qword_95240[256];
// 95A40: using guessed type __int64 qword_95A40[256];
// 96240: using guessed type __int64 qword_96240[256];
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CE0: using guessed type __int64 qword_96CE0;

//----- (00000000000357DF) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_357DF()
{
  __int64 result; // rax
  __int64 v1; // [rsp+38h] [rbp-8h]

  result = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_93610, 0i64, &v1);
  if ( result >= 0 )
  {
    if ( !byte_95230 )
    {
      sub_3560A();
      byte_95230 = 1;
    }
    result = (*(__int64 (__fastcall **)(__int64, signed __int64, signed __int64, __int64 *, __int64 *, __int64 *))(v1 + 8))(
               v1,
               2i64,
               1024i64,
               qword_95240,
               qword_95A40,
               qword_96240);
  }
  return result;
}
// 35814: write access to const memory at 95230 has been detected
// 93610: using guessed type __int64 qword_93610[2];
// 95230: using guessed type char byte_95230;
// 95240: using guessed type __int64 qword_95240[256];
// 95A40: using guessed type __int64 qword_95A40[256];
// 96240: using guessed type __int64 qword_96240[256];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000035852) ----------------------------------------------------
__int64 sub_35852()
{
  __int64 result; // rax
  char v1; // [rsp+30h] [rbp-1820h]
  char v2; // [rsp+830h] [rbp-1020h]
  char v3; // [rsp+1030h] [rbp-820h]
  __int64 v4; // [rsp+1830h] [rbp-20h]

  result = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64 *))(qword_96CD8 + 320))(qword_93610, 0i64, &v4);
  if ( result >= 0 )
  {
    (*(void (__fastcall **)(char *, signed __int64, _QWORD))(qword_96CD8 + 360))(&v1, 2048i64, 0i64);
    (*(void (__fastcall **)(char *, signed __int64, _QWORD))(qword_96CD8 + 360))(&v2, 2048i64, 0i64);
    (*(void (__fastcall **)(char *, signed __int64, _QWORD))(qword_96CD8 + 360))(&v3, 2048i64, 0i64);
    result = (*(__int64 (__fastcall **)(__int64, signed __int64, signed __int64, char *, char *, char *))(v4 + 8))(
               v4,
               2i64,
               1024i64,
               &v1,
               &v2,
               &v3);
  }
  return result;
}
// 93610: using guessed type __int64 qword_93610[2];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000035907) ----------------------------------------------------
__int64 __fastcall sub_35907(unsigned __int16 *a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // r9
  unsigned __int16 v4; // bx
  unsigned __int16 v5; // di
  int v6; // er10
  int v7; // er12
  unsigned __int16 v8; // r11
  unsigned __int16 v9; // r15
  unsigned __int16 v10; // r14
  unsigned int v11; // eax
  unsigned int v12; // ett
  __int64 result; // rax

  v2 = a2;
  v3 = 0i64;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  do
  {
    if ( v3 == v8 && v3 != 1023 )
    {
      if ( v10 >= *a1 )
      {
        LOWORD(a2) = -1;
        LOWORD(v11) = 1023;
      }
      else
      {
        v11 = (unsigned int)a1[2 * v10 + 1] >> 6;
        LODWORD(a2) = a1[2 * v10++ + 2];
      }
      v5 = v11 - v8;
      v4 = a2 - v6;
      v9 = v8;
      v8 = v11;
      v7 = v6;
      v6 = a2;
    }
    v12 = v4 * (v3 - v9);
    LODWORD(a2) = v12 % v5;
    result = v7 + v12 / v5;
    *(_WORD *)(v2 + 2 * v3++) = v7 + v12 / v5;
  }
  while ( v3 != 1024 );
  return result;
}

//----- (00000000000359AF) ----------------------------------------------------
__int64 __fastcall sub_359AF(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  return sub_359CB(a1, a2, a3, a4, 16i64);
}

//----- (00000000000359CB) ----------------------------------------------------
__int64 __fastcall sub_359CB(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4, __int64 a5)
{
  unsigned __int8 v5; // bl
  __int64 v6; // rdi
  __int64 v8; // [rsp+30h] [rbp-20h]

  v5 = a4;
  v6 = a3;
  v8 = 0i64;
  if ( (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64, __int64 *))(qword_96CD8 + 80))(
         ((a1 != 0) << 9) | 0x80000000,
         a5,
         a1,
         a2,
         &v8) >= 0
    && (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(qword_96CD8 + 88))(v8, (unsigned int)(v5 < 1u) + 1, v6) < 0 )
  {
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 112))(v8);
    v8 = 0i64;
  }
  return v8;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000035A58) ----------------------------------------------------
__int64 __fastcall sub_35A58(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  return sub_359CB(a1, a2, a3, a4, 8i64);
}

//----- (0000000000035A74) ----------------------------------------------------
void __fastcall sub_35A74(__int64 a1)
{
  __int64 v1; // rsi

  if ( a1 )
  {
    v1 = a1;
    if ( (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(qword_96CD8 + 88))(a1, 0i64, 0i64) >= 0 )
      (*(void (__fastcall **)(__int64))(qword_96CD8 + 112))(v1);
  }
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000035AB4) ----------------------------------------------------
signed __int64 __fastcall sub_35AB4(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, signed int *a5, __int64 *a6)
{
  __int64 v6; // rsi
  signed __int64 v7; // rdi
  __int64 v8; // rbx
  __int64 v9; // r12
  __int64 v10; // r15
  _QWORD *v11; // r14
  __int64 v13; // rax
  __int64 v14; // [rsp+30h] [rbp-50h]
  __int64 v15; // [rsp+38h] [rbp-48h]
  _QWORD *v16; // [rsp+40h] [rbp-40h]

  v6 = 0i64;
  v16 = 0i64;
  v7 = -9223372036854775806i64;
  if ( !a1 )
    goto LABEL_9;
  v8 = a2;
  if ( !a2 )
    goto LABEL_9;
  v9 = a3;
  if ( !a3 )
    goto LABEL_9;
  v10 = a4;
  if ( !a4 || !a5 || !a6 )
    goto LABEL_9;
  v11 = a1;
  v14 = *a6;
  v15 = *(_QWORD *)a5;
  v7 = sub_26E4B((__int64 *)&v16, (__int64)&v14);
  if ( !(_DWORD)v7 )
  {
    if ( !v16 )
      return -9223372036854775799i64;
    v7 = sub_274E1((__int64)v16, 1u);
    if ( !(_DWORD)v7 )
    {
      v13 = sub_24136(120i64);
      if ( !v13 )
      {
        v6 = 0i64;
        v7 = -9223372036854775799i64;
        goto LABEL_9;
      }
      v6 = v13;
      *(_BYTE *)(v13 + 40) = 0;
      *(_BYTE *)(v13 + 88) = 0;
      v7 = sub_35F95((__int64 *)v13, v8, v9, v10, a5);
      if ( (_DWORD)v7 )
      {
        sub_35E9F((_QWORD *)v6);
      }
      else
      {
        *(_DWORD *)(v6 + 24) = 1;
        *(_QWORD *)(v6 + 56) = 0i64;
        *(_QWORD *)(v6 + 64) = 0i64;
        v7 = sub_35C57((__int64)v16, 1);
        if ( (_DWORD)v7 )
          goto LABEL_9;
        v7 = sub_27643(v16, (__int64)sub_35C95, (__int64)sub_35DED, 0i64, v6);
        if ( (_DWORD)v7 )
          goto LABEL_9;
        v7 = sub_35E2C((__int64)v16);
        if ( !(_DWORD)v7 )
        {
          *v11 = v16;
          v16 = 0i64;
          return v7;
        }
      }
    }
  }
  v6 = 0i64;
LABEL_9:
  if ( v16 )
    sub_27054((__int64)v16);
  if ( v6 )
    sub_35E9F((_QWORD *)v6);
  return v7;
}

//----- (0000000000035C57) ----------------------------------------------------
signed __int64 __fastcall sub_35C57(__int64 a1, char a2)
{
  char v2; // di
  __int64 v3; // rsi
  signed __int64 result; // rax
  int v5; // [rsp+2Ch] [rbp-14h]

  v2 = a2;
  v3 = a1;
  result = sub_276AC(a1, &v5);
  if ( !(_DWORD)result )
    result = sub_2768D(v3, v5 & 0xFFFFFF | (unsigned int)(1 << (v2 + 24)));
  return result;
}

//----- (0000000000035C95) ----------------------------------------------------
signed __int64 __fastcall sub_35C95(__int64 a1, int *a2, __int64 a3, __int64 a4)
{
  signed __int64 v4; // rdi
  __int64 v5; // rbx
  __int64 v6; // rsi
  __int64 v7; // r15
  __int64 v8; // r14
  int v9; // ecx
  __int64 *v10; // rax
  signed __int64 v11; // rax
  __int64 v13; // rcx
  int v14; // er8
  unsigned int v15; // eax
  int v16; // edx
  int v17[4]; // [rsp+48h] [rbp-58h]
  int v18; // [rsp+58h] [rbp-48h]
  unsigned int v19; // [rsp+5Ch] [rbp-44h]
  char v20; // [rsp+60h] [rbp-40h]
  int v21; // [rsp+6Ch] [rbp-34h]

  v4 = -9223372036854775806i64;
  if ( a1 )
  {
    v5 = a1;
    v6 = *(_QWORD *)(a1 + 160);
    if ( v6 )
    {
      v7 = a4;
      if ( a4 )
      {
        v8 = a3;
        if ( a3 )
        {
          if ( a2 && *(_DWORD *)(a1 + 88) == 1 )
          {
            v9 = *(_DWORD *)(v6 + 24);
            v10 = (__int64 *)v6;
            if ( v9 != 1 )
            {
              if ( v9 == 2 )
                v10 = (__int64 *)(v6 + 8);
              else
                v10 = (__int64 *)(v6 + 16);
            }
            if ( *v10 )
            {
              v11 = sub_244D1(a3, a4, a2, *v10, (int *)(v5 + 32), (int *)(v5 + 44), *(_BYTE *)(v5 + 168), v5 + 176);
              v4 = -9223372036854775794i64;
              if ( v11 != -9223372036854775794i64 )
              {
                if ( (_DWORD)v11 )
                  return v11;
                v13 = *(_QWORD *)(v6 + 80);
                v4 = v11;
                if ( v13 )
                {
                  v4 = sub_3EED1(v13, &v20);
                  if ( !(_DWORD)v4 )
                  {
                    v14 = *(_DWORD *)(v5 + 48);
                    v15 = *(_DWORD *)(v5 + 52);
                    v19 = v14 + v15 - v21 - 11;
                    v16 = *(_DWORD *)(v5 + 44);
                    v18 = v16 + 24;
                    sub_26B03(v17, v16, v14, *(_DWORD *)(v5 + 56) - 24, v15);
                    return sub_244D1(
                             v8,
                             v7,
                             v17,
                             *(_QWORD *)(*(_QWORD *)(v6 + 80) + 16i64),
                             (int *)(*(_QWORD *)(v6 + 80) + 32i64),
                             &v18,
                             *(_BYTE *)(*(_QWORD *)(v6 + 80) + 168i64),
                             v5 + 176);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v4;
}

//----- (0000000000035DED) ----------------------------------------------------
signed __int64 __fastcall sub_35DED(__int64 a1)
{
  __int64 v1; // rsi
  signed __int64 result; // rax

  if ( !a1 )
    return -9223372036854775806i64;
  v1 = a1;
  sub_36576(a1);
  result = sub_35E9F(*(_QWORD **)(v1 + 160));
  *(_QWORD *)(v1 + 160) = 0i64;
  return result;
}

//----- (0000000000035E2C) ----------------------------------------------------
signed __int64 __fastcall sub_35E2C(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  __int64 v3; // rcx
  signed __int64 result; // rax

  if ( !a1 )
    return -9223372036854775806i64;
  v1 = a1;
  if ( *(_DWORD *)(a1 + 88) != 1 )
    return -9223372036854775806i64;
  v2 = *(_QWORD *)(a1 + 160);
  if ( !v2 )
    return -9223372036854775806i64;
  *(_BYTE *)(v2 + 89) = 1;
  v3 = *(_QWORD *)(v1 + 80);
  if ( v3 )
    result = sub_3F3B4(v3, v1, 366, (__int64)sub_36107, 0i64);
  else
    result = sub_271F9(v1, (__int64)sub_36544);
  return result;
}

//----- (0000000000035E9F) ----------------------------------------------------
signed __int64 __fastcall sub_35E9F(_QWORD *a1)
{
  _QWORD *v1; // rsi
  __int64 v2; // rcx

  if ( !a1 )
    return -9223372036854775806i64;
  v1 = a1;
  if ( *a1 )
    (*(void (**)(void))(qword_96CD8 + 72))();
  *v1 = 0i64;
  if ( v1[1] )
    (*(void (**)(void))(qword_96CD8 + 72))();
  v1[1] = 0i64;
  if ( v1[2] )
    (*(void (**)(void))(qword_96CD8 + 72))();
  v1[2] = 0i64;
  v2 = v1[10];
  if ( v2 )
  {
    sub_27054(v2);
    v1[10] = 0i64;
  }
  (*(void (__fastcall **)(_QWORD *))(qword_96CD8 + 72))(v1);
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000035F37) ----------------------------------------------------
signed __int64 __fastcall sub_35F37(__int64 a1, __int64 a2, __int64 a3, __int64 a4, signed int *a5)
{
  signed __int64 result; // rax
  __int64 v6; // rsi
  __int64 *v7; // rcx

  result = -9223372036854775806i64;
  if ( a1 )
  {
    if ( a5 )
    {
      if ( a4 )
      {
        if ( a3 )
        {
          if ( a2 )
          {
            v6 = a1;
            if ( *(_DWORD *)(a1 + 88) == 1 )
            {
              v7 = *(__int64 **)(a1 + 160);
              if ( v7 )
              {
                result = sub_35F95(v7, a2, a3, a4, a5);
                if ( !(_DWORD)result )
                  *(_BYTE *)(v6 + 40) = 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (0000000000035F95) ----------------------------------------------------
signed __int64 __fastcall sub_35F95(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, signed int *a5)
{
  signed __int64 result; // rax
  __int64 v6; // rsi
  __int64 v7; // rbx
  __int64 v8; // r12
  __int64 *v9; // r13
  __int64 v10; // rdi
  __int64 v11; // rax
  __int64 v12; // r15
  __int64 v13; // rax
  __int64 v14; // r14
  __int64 v15; // rax
  __int64 v16; // rbx

  result = -9223372036854775806i64;
  if ( !a1 )
    return result;
  v6 = a2;
  if ( !a2 )
    return result;
  v7 = a3;
  if ( !a3 )
    return result;
  v8 = a4;
  if ( !a4 )
    return result;
  v9 = a1;
  if ( !a5 )
    return result;
  v10 = 4 * a5[1] * (signed __int64)*a5;
  v11 = sub_24103(4 * a5[1] * (signed __int64)*a5);
  if ( !v11 )
    return -9223372036854775799i64;
  v12 = v11;
  (*(void (__fastcall **)(__int64, __int64, __int64))(qword_96CD8 + 352))(v11, v6, v10);
  v13 = sub_24103(v10);
  if ( v13 )
  {
    v14 = v13;
    (*(void (__fastcall **)(__int64, __int64, __int64))(qword_96CD8 + 352))(v13, v7, v10);
    v15 = sub_24103(v10);
    if ( v15 )
    {
      v16 = v15;
      (*(void (__fastcall **)(__int64, __int64, __int64))(qword_96CD8 + 352))(v15, v8, v10);
      if ( *v9 )
        (*(void (**)(void))(qword_96CD8 + 72))();
      *v9 = v12;
      if ( v9[1] )
        (*(void (**)(void))(qword_96CD8 + 72))();
      v9[1] = v14;
      if ( v9[2] )
        (*(void (**)(void))(qword_96CD8 + 72))();
      v9[2] = v16;
      return 0i64;
    }
  }
  else
  {
    v14 = 0i64;
  }
  (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v12);
  if ( v14 )
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v14);
  return -9223372036854775799i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (0000000000036107) ----------------------------------------------------
__int64 __fastcall sub_36107(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  void (__fastcall *v3)(__int64, _QWORD); // rbx
  __int64 v4; // rsi
  __int64 v5; // r14
  char v6; // al
  int v7; // ecx
  __int64 v8; // rcx
  void (__fastcall *v9)(__int64, _QWORD); // rax
  signed __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rax
  void (__fastcall *v14)(__int64, _QWORD); // rbx
  char v15; // di
  __int64 v17; // rcx
  int *v18; // r15
  __int64 v19; // rax
  int v20; // edx
  __int64 v21; // rcx
  int v22; // edx
  __int64 v23; // rax
  void (__fastcall *v24)(__int64, _QWORD); // r8
  __int64 v25; // [rsp+28h] [rbp-38h]
  int v26; // [rsp+30h] [rbp-30h]
  int v27; // [rsp+34h] [rbp-2Ch]

  if ( !a1 )
    goto LABEL_38;
  v2 = a2;
  LODWORD(v3) = 0;
  if ( !a2 )
    return (unsigned int)v3;
  v4 = a1;
  if ( *(_DWORD *)(a1 + 88) != 1 )
    return (unsigned int)v3;
  v5 = *(_QWORD *)(a1 + 160);
  if ( !v5 || !*(_BYTE *)(v5 + 89) )
    goto LABEL_38;
  v26 = *(_DWORD *)(a2 + 28);
  v27 = *(_DWORD *)(a2 + 32);
  v6 = *(_BYTE *)(v5 + 44);
  if ( !v6 && !*(_BYTE *)(v5 + 48) )
  {
    LOBYTE(v7) = *(_BYTE *)(a2 + 8);
LABEL_17:
    if ( !(_BYTE)v7 )
      goto LABEL_38;
    v10 = *(_QWORD *)(a2 + 16) & 0x1Fi64;
    LODWORD(v3) = 0;
    if ( v10 <= 3 )
    {
      if ( v10 != 1 )
      {
        if ( v10 != 2 )
          return (unsigned int)v3;
        if ( sub_26AB0((int *)(v4 + 44), &v26) )
        {
          *(_BYTE *)(v5 + 74) = 1;
          v11 = *(_QWORD *)(v5 + 96);
          if ( v11 )
          {
            if ( (unsigned int)sub_366DA(v11, &v25) )
              goto LABEL_67;
            v12 = v25;
          }
          else
          {
            v25 = 0i64;
            v12 = 0i64;
          }
          if ( v12 == v4 )
          {
            v15 = 0;
LABEL_69:
            LOBYTE(v3) = 1;
            goto LABEL_70;
          }
          *(_DWORD *)(v5 + 28) = *(_DWORD *)(v5 + 24);
          *(_BYTE *)(v5 + 72) = 1;
          if ( *(_BYTE *)(v5 + 88) )
          {
            if ( *(_DWORD *)(v4 + 88) == 1 )
            {
              v19 = *(_QWORD *)(v4 + 160);
              if ( v19 )
              {
                v3 = *(void (__fastcall **)(__int64, _QWORD))(v19 + 56);
                if ( v3 )
                  v3(v2, *(_QWORD *)(v19 + 64));
              }
            }
          }
          if ( !*(_BYTE *)(v5 + 89) || !(unsigned int)sub_3F3B4(*(_QWORD *)(v4 + 80), v4, 511, (__int64)sub_36107, 0i64) )
          {
            if ( *(_QWORD *)(v5 + 96) )
            {
              if ( sub_359AF((__int64)sub_3667A, v4, 1750000i64, 0) )
              {
                *(_BYTE *)(v5 + 73) = 1;
LABEL_68:
                v15 = 1;
                goto LABEL_69;
              }
            }
            else
            {
              *(_DWORD *)(v5 + 24) = 3;
              if ( !(unsigned int)sub_35C57(v4, 3) )
                goto LABEL_68;
            }
          }
LABEL_67:
          LOBYTE(v3) = 1;
          return (unsigned int)v3;
        }
LABEL_38:
        LODWORD(v3) = 0;
        return (unsigned int)v3;
      }
      if ( !*(_BYTE *)(v5 + 72) )
        goto LABEL_38;
      if ( sub_26AB0((int *)(v4 + 44), &v26) )
      {
        *(_BYTE *)(v5 + 74) = 1;
        v15 = 1;
        if ( *(_DWORD *)(v5 + 24) == 3 || *(_BYTE *)(v5 + 73) )
        {
          LODWORD(v3) = 0;
        }
        else
        {
          *(_DWORD *)(v5 + 24) = 3;
          LODWORD(v3) = 0;
          if ( (unsigned int)sub_35C57(v4, 3) )
            return (unsigned int)v3;
        }
      }
      else
      {
        *(_BYTE *)(v5 + 74) = 0;
        v20 = *(_DWORD *)(v5 + 28);
        *(_DWORD *)(v5 + 24) = v20;
        LODWORD(v3) = 0;
        if ( (unsigned int)sub_35C57(v4, v20) )
          return (unsigned int)v3;
        v15 = 1;
      }
LABEL_70:
      if ( !v15 || (v21 = *(_QWORD *)(v5 + 96)) == 0 )
      {
        if ( !v15 )
          return (unsigned int)v3;
        v21 = v4;
      }
      sub_274AA(v21);
      return (unsigned int)v3;
    }
    if ( v10 != 4 )
    {
      if ( v10 != 16 )
        return (unsigned int)v3;
      if ( sub_26AB0((int *)(v4 + 44), &v26) && *(_DWORD *)(v4 + 88) == 1 )
      {
        v13 = *(_QWORD *)(v4 + 160);
        if ( v13 )
        {
          v14 = *(void (__fastcall **)(__int64, _QWORD))(v13 + 56);
          if ( v14 )
            v14(v2, *(_QWORD *)(v13 + 64));
        }
      }
      goto LABEL_38;
    }
    if ( (unsigned int)sub_3F3B4(*(_QWORD *)(v4 + 80), v4, 366, (__int64)sub_36107, 0i64) )
      goto LABEL_38;
    if ( !sub_26AB0((int *)(v4 + 44), &v26) || !*(_BYTE *)(v5 + 72) )
    {
      LODWORD(v3) = 0;
LABEL_61:
      *(_BYTE *)(v5 + 72) = 0;
      v15 = (char)v3;
      goto LABEL_70;
    }
    if ( *(_BYTE *)(v5 + 40) )
    {
      v17 = *(_QWORD *)(v5 + 96);
      if ( *(_DWORD *)(v5 + 28) == 1 )
      {
        *(_DWORD *)(v5 + 24) = 2;
        if ( v17 )
        {
          v18 = (int *)(v5 + 24);
LABEL_77:
          LOBYTE(v3) = 1;
          if ( (unsigned int)sub_3670F(v17, v4) )
            return (unsigned int)v3;
          v22 = *v18;
          goto LABEL_82;
        }
        LOBYTE(v22) = 2;
LABEL_82:
        LOBYTE(v3) = 1;
        if ( (unsigned int)sub_35C57(v4, v22) )
          return (unsigned int)v3;
        *(_DWORD *)(v5 + 28) = *(_DWORD *)(v5 + 24);
        LOBYTE(v3) = 1;
        if ( !*(_BYTE *)(v5 + 88) && *(_DWORD *)(v4 + 88) == 1 )
        {
          v23 = *(_QWORD *)(v4 + 160);
          if ( v23 )
          {
            v24 = *(void (__fastcall **)(__int64, _QWORD))(v23 + 56);
            if ( v24 )
              v24(v2, *(_QWORD *)(v23 + 64));
          }
        }
        goto LABEL_61;
      }
      v18 = (int *)(v5 + 24);
      if ( v17 )
      {
        *v18 = 2;
        goto LABEL_77;
      }
      *v18 = 1;
    }
    else
    {
      *(_DWORD *)(v5 + 24) = 1;
    }
    LOBYTE(v22) = 1;
    goto LABEL_82;
  }
  v7 = *(_DWORD *)(a2 + 8);
  if ( !(v7 & 0xFF00) )
    goto LABEL_17;
  v8 = *(_QWORD *)(a2 + 16);
  if ( !v8 )
    goto LABEL_38;
  if ( *(_WORD *)(v8 + 4) == *(_WORD *)(v5 + 46) && *(_BYTE *)(v5 + 48)
    || (LODWORD(v3) = 0, v6) && *(_WORD *)(v8 + 6) == *(_WORD *)(v5 + 42) )
  {
    v9 = *(void (__fastcall **)(__int64, _QWORD))(v5 + 56);
    LOBYTE(v3) = 1;
    if ( v9 )
      v9(a2, *(_QWORD *)(v5 + 64));
  }
  return (unsigned int)v3;
}

//----- (0000000000036544) ----------------------------------------------------
signed __int64 __fastcall sub_36544(__int64 a1, __int64 a2)
{
  return sub_3F3B4(a2, a1, 366, (__int64)sub_36107, 0i64);
}

//----- (0000000000036576) ----------------------------------------------------
signed __int64 __fastcall sub_36576(__int64 a1)
{
  signed __int64 result; // rax
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // rcx

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v2 = a1;
    if ( *(_DWORD *)(a1 + 88) == 1 )
    {
      v3 = *(_QWORD *)(a1 + 160);
      if ( v3 )
      {
        *(_BYTE *)(v3 + 89) = 0;
        v4 = *(_QWORD *)(v2 + 80);
        if ( !v4 || !*(_QWORD *)(v2 + 256) || (result = sub_3F58B(v4, v2), !(_DWORD)result) )
          result = 0i64;
      }
    }
  }
  return result;
}

//----- (00000000000365CA) ----------------------------------------------------
signed __int64 __fastcall sub_365CA(__int64 a1, int a2)
{
  signed __int64 result; // rax
  __int64 v3; // rsi
  __int64 v4; // rcx
  int v5; // eax

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a1;
    if ( *(_DWORD *)(a1 + 88) == 1 )
    {
      v4 = *(_QWORD *)(a1 + 160);
      if ( v4 )
      {
        v5 = *(_DWORD *)(v4 + 24);
        if ( v5 != a2 )
        {
          *(_DWORD *)(v4 + 28) = v5;
          *(_DWORD *)(v4 + 24) = a2;
          result = sub_35C57(v3, a2);
          if ( (_DWORD)result )
            return result;
          *(_BYTE *)(v3 + 40) = 1;
        }
        result = 0i64;
      }
    }
  }
  return result;
}

//----- (000000000003661D) ----------------------------------------------------
signed __int64 __fastcall sub_3661D(__int64 a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // rax
  __int64 v4; // rcx

  result = -9223372036854775806i64;
  if ( a1 && *(_DWORD *)(a1 + 88) == 1 )
  {
    v4 = *(_QWORD *)(a1 + 160);
    if ( v4 )
    {
      *(_QWORD *)(v4 + 56) = a2;
      *(_QWORD *)(v4 + 64) = a3;
      result = 0i64;
    }
  }
  return result;
}

//----- (000000000003664E) ----------------------------------------------------
signed __int64 __fastcall sub_3664E(__int64 a1, char a2)
{
  signed __int64 result; // rax
  __int64 v3; // rcx

  result = -9223372036854775806i64;
  if ( a1 && *(_DWORD *)(a1 + 88) == 1 )
  {
    v3 = *(_QWORD *)(a1 + 160);
    if ( v3 )
    {
      *(_BYTE *)(v3 + 88) = a2;
      result = 0i64;
    }
  }
  return result;
}

//----- (000000000003667A) ----------------------------------------------------
void __fastcall sub_3667A(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  if ( a2 )
  {
    v2 = *(_QWORD *)(a2 + 160);
    if ( v2 )
    {
      *(_BYTE *)(v2 + 73) = 0;
      if ( *(_QWORD *)(v2 + 96) )
      {
        if ( *(_BYTE *)(v2 + 72) && *(_BYTE *)(v2 + 74) )
        {
          *(_DWORD *)(v2 + 24) = 3;
          if ( !(unsigned int)sub_35C57(a2, 3) )
            sub_274AA(*(_QWORD *)(v2 + 96));
        }
      }
    }
  }
}

//----- (00000000000366DA) ----------------------------------------------------
signed __int64 __fastcall sub_366DA(__int64 a1, _QWORD *a2)
{
  signed __int64 result; // rax
  __int64 v3; // rcx

  result = -9223372036854775806i64;
  if ( a1 && a2 && *(_DWORD *)(a1 + 88) == 2 )
  {
    v3 = *(_QWORD *)(a1 + 160);
    if ( v3 )
    {
      *a2 = *(_QWORD *)(v3 + 48);
      result = 0i64;
    }
  }
  return result;
}

//----- (000000000003670F) ----------------------------------------------------
signed __int64 __fastcall sub_3670F(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax
  __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 v5; // rcx

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a2;
    if ( a2 )
    {
      if ( *(_DWORD *)(a1 + 88) == 2 && *(_DWORD *)(a2 + 88) == 1 )
      {
        v4 = *(_QWORD *)(a1 + 160);
        if ( v4 )
        {
          v5 = *(_QWORD *)(v4 + 48);
          if ( v5 == a2 )
            return 0i64;
          if ( !v5 || (result = sub_365CA(v5, 1), !(_DWORD)result) )
          {
            *(_QWORD *)(v4 + 48) = v3;
            return 0i64;
          }
        }
      }
    }
  }
  return result;
}

//----- (0000000000036774) ----------------------------------------------------
void __fastcall sub_36774(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rcx

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 544);
  if ( v2 )
  {
    sub_35A74(v2);
    *(_QWORD *)(v1 + 544) = 0i64;
  }
}

//----- (00000000000367A3) ----------------------------------------------------
void __fastcall sub_367A3(__int64 a1)
{
  __int64 v1; // rsi

  if ( *(_QWORD *)(a1 + 576) )
  {
    v1 = a1;
    sub_1A11E();
    sub_35A74(*(_QWORD *)(v1 + 576));
    *(_QWORD *)(v1 + 576) = 0i64;
  }
}

//----- (00000000000367EF) ----------------------------------------------------
__int64 __fastcall sub_367EF(__int64 a1)
{
  __int64 result; // rax
  signed __int64 v2; // rcx

  result = *(_QWORD *)(a1 + 632);
  if ( result )
  {
    v2 = 8i64;
    do
    {
      *(_QWORD *)(result + v2 - 8) = 0i64;
      *(_QWORD *)(result + v2) = 0i64;
      v2 += 16i64;
    }
    while ( v2 != 88 );
  }
  return result;
}

//----- (000000000003681B) ----------------------------------------------------
signed __int64 __fastcall sub_3681B(__int64 a1, __int64 a2, __int64 a3, int a4, _QWORD *a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, char a10, char a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15)
{
  int v15; // er13
  __int64 v16; // r15
  char v17; // al
  char v18; // bl
  int v19; // eax
  _QWORD *v20; // rax
  signed __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // rdx
  int v24; // eax
  int v25; // eax
  signed __int64 v26; // rdi
  __int64 v27; // r12
  __int64 v28; // r9
  signed __int64 v29; // r13
  __int64 v30; // rax
  signed int v31; // ecx
  __int64 v32; // r15
  char v34[1024]; // [rsp+20h] [rbp-450h]
  __int64 v35; // [rsp+420h] [rbp-50h]
  __int64 v36; // [rsp+428h] [rbp-48h]
  __int64 v37; // [rsp+430h] [rbp-40h]

  v15 = a4;
  v36 = a3;
  v35 = a2;
  v37 = a1;
  sub_1A11E();
  sub_1A11E();
  sub_1A11E();
  sub_1A11E();
  sub_1A11E();
  sub_1A11E();
  sub_1A11E();
  sub_1A11E();
  sub_1A11E();
  sub_1A11E();
  sub_1A11E();
  sub_1A11E();
  sub_1A11E();
  sub_1A11E();
  v16 = v37;
  sub_1A11E();
  sub_F180((char *)v37, 0, 0x2A8ui64);
  *(_QWORD *)(v37 + 624) = 0i64;
  *(_QWORD *)(v16 + 40) = v36;
  *(_QWORD *)(v16 + 32) = v35;
  *(_DWORD *)(v16 + 232) = 2 - ((unsigned __int8)sub_3FBF3() < 1u);
  sub_3484A((_QWORD *)(v16 + 224), *(_QWORD *)(v16 + 40));
  v17 = sub_34A08(*(unsigned __int64 ***)(v16 + 224));
  v18 = v17;
  v19 = v15 - (((unsigned __int8)v17 < 1u) - 1);
  *(_DWORD *)(v16 + 48) = v19;
  v20 = (_QWORD *)sub_24136(8i64 * v19);
  *(_QWORD *)(v16 + 56) = v20;
  if ( v15 > 0 )
  {
    *v20 = *a5;
    if ( v15 != 1 )
    {
      v21 = 1i64;
      do
      {
        *(_QWORD *)(*(_QWORD *)(v16 + 56) + 8 * v21) = a5[v21];
        ++v21;
      }
      while ( v15 != v21 );
    }
  }
  if ( v18 )
    *(_QWORD *)(*(_QWORD *)(v16 + 56) + 8i64 * v15) = a9;
  if ( a6 )
  {
    v22 = *(signed int *)(v16 + 48);
    if ( v22 <= 0 )
      goto LABEL_15;
    v23 = 0i64;
    while ( *(_QWORD *)(*(_QWORD *)(v16 + 56) + 8 * v23) != a6 )
    {
      if ( ++v23 >= v22 )
        goto LABEL_15;
    }
    if ( (signed int)v23 < 0 )
LABEL_15:
      sub_1A11E();
    else
      *(_QWORD *)(v16 + 64) = a6;
  }
  *(_QWORD *)(v16 + 72) = a7;
  *(_QWORD *)(v16 + 80) = a8;
  *(_QWORD *)(v16 + 88) = a9;
  *(_BYTE *)(v16 + 96) = a10;
  *(_BYTE *)(v16 + 97) = a11;
  *(_DWORD *)(v16 + 100) = a12;
  *(_QWORD *)(v16 + 104) = a13;
  *(_QWORD *)(v16 + 112) = a14;
  *(_QWORD *)(v16 + 120) = a15;
  v24 = sub_189FE("M'illumino d'immenso");
  sub_18A90(v16, (__int64)"M'illumino d'immenso", v24);
  v25 = sub_189FE("M'illumino d'immenso");
  sub_18A90(v16 + 641, (__int64)"M'illumino d'immenso", v25);
  sub_1A11E();
  if ( *(_DWORD *)(v16 + 48) > 0 )
  {
    v26 = 0i64;
    do
    {
      v27 = *(_QWORD *)(*(_QWORD *)(v16 + 56) + 8 * v26);
      sub_1A11E();
      *(_QWORD *)v27;
      sub_1A11E();
      v28 = *(unsigned int *)(v27 + 24);
      sub_1A11E();
      if ( *(_DWORD *)(v27 + 24) > 0 )
      {
        v29 = 0i64;
        do
        {
          v30 = *(_QWORD *)(*(_QWORD *)(v27 + 32) + 8 * v29);
          v31 = *(_DWORD *)(v30 + 8);
          if ( v31 >= 1024 )
            v31 = 1023;
          v32 = v31;
          sub_1B930(v34, *(char **)v30, v31);
          v34[v32] = 0;
          sub_1A11E();
          ++v29;
        }
        while ( v29 < *(signed int *)(v27 + 24) );
      }
      ++v26;
      v16 = v37;
    }
    while ( v26 < *(signed int *)(v37 + 48) );
  }
  sub_1A11E();
  if ( !sub_2C1A0(*(_QWORD *)(v16 + 40), L"loginui.efires", (_QWORD *)(v16 + 144)) )
    return 0i64;
  sub_1A11E();
  return 1i64;
}
// 41838: using guessed type __int16 aLoginuiEfires[15];
// 3681B: using guessed type char var_450[1024];

//----- (0000000000036CB8) ----------------------------------------------------
signed __int64 __fastcall sub_36CB8(_QWORD *a1)
{
  _QWORD *v1; // rsi
  __int64 v2; // rdi
  __int64 *v3; // rdx
  __int64 v4; // rcx
  __int64 *v5; // rcx
  signed __int64 v6; // rax
  signed __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v12; // [rsp+30h] [rbp-100h]
  __int64 v13; // [rsp+38h] [rbp-F8h]
  __int64 v14; // [rsp+40h] [rbp-F0h]
  __int64 v15; // [rsp+48h] [rbp-E8h]
  __int64 v16; // [rsp+50h] [rbp-E0h]
  __int64 v17; // [rsp+58h] [rbp-D8h]
  __int64 v18; // [rsp+60h] [rbp-D0h]
  __int64 v19; // [rsp+68h] [rbp-C8h]
  __int64 v20; // [rsp+70h] [rbp-C0h]
  __int64 v21; // [rsp+78h] [rbp-B8h]
  __int64 v22; // [rsp+80h] [rbp-B0h]
  __int64 v23; // [rsp+88h] [rbp-A8h]
  __int64 v24; // [rsp+90h] [rbp-A0h]
  __int64 v25; // [rsp+98h] [rbp-98h]
  __int64 v26; // [rsp+A0h] [rbp-90h]
  __int64 v27; // [rsp+A8h] [rbp-88h]
  __int64 v28; // [rsp+B0h] [rbp-80h]
  __int64 v29; // [rsp+B8h] [rbp-78h]
  __int64 v30; // [rsp+C0h] [rbp-70h]
  __int64 v31; // [rsp+C8h] [rbp-68h]
  __int64 v32; // [rsp+D0h] [rbp-60h]
  __int64 v33; // [rsp+D8h] [rbp-58h]
  __int64 v34; // [rsp+E0h] [rbp-50h]
  __int64 v35; // [rsp+E8h] [rbp-48h]
  __int64 v36; // [rsp+F0h] [rbp-40h]
  __int64 v37; // [rsp+F8h] [rbp-38h]

  v1 = a1;
  sub_1A11E();
  if ( sub_36F59((__int64)v1) )
  {
    v12 = v1[52];
    v13 = v1[55];
    v14 = v1[56];
    v15 = v1[50];
    v16 = v1[40];
    v17 = v1[48];
    v18 = v1[49];
    v19 = v1[53];
    v20 = v1[54];
    v21 = v1[57];
    v22 = v1[58];
    v23 = v1[63];
    v24 = v1[64];
    v25 = v1[75];
    v26 = v1[60];
    v27 = v1[61];
    v28 = v1[59];
    v29 = v1[32];
    v30 = v1[33];
    v2 = 0i64;
    v31 = 0i64;
    v32 = 0i64;
    v33 = 0i64;
    v34 = 0i64;
    v35 = 0i64;
    v36 = 0i64;
    v37 = 0i64;
    do
    {
      v3 = (__int64 *)*(&v12 + v2);
      if ( v3 )
      {
        v4 = v3[10];
        if ( v4 )
          !sub_3F1DC(v4, v3);
        else
          sub_27054(*(&v12 + v2));
        sub_1A11E();
      }
      ++v2;
    }
    while ( v2 != 26 );
    sub_1A11E();
    v5 = (__int64 *)v1[44];
    if ( v5 && (v6 = sub_2D46E(v5)) != 0 )
    {
      v7 = v6;
      sub_1A11E();
    }
    else
    {
      v7 = 0i64;
    }
    v8 = v1[46];
    if ( v8 )
    {
      v9 = sub_35006(v8);
      if ( v9 )
      {
        v10 = v9;
        sub_1A11E();
        v7 = v10;
      }
    }
  }
  else
  {
    sub_1A11E();
    v7 = 1i64;
  }
  return v7;
}

//----- (0000000000036F59) ----------------------------------------------------
bool __fastcall sub_36F59(__int64 a1)
{
  __int64 v1; // rsi
  int v2; // edi
  bool result; // al

  v1 = a1;
  v2 = sub_189FE("M'illumino d'immenso");
  if ( (unsigned int)sub_18A43(v1, (__int64)"M'illumino d'immenso", v2) )
    result = 0;
  else
    result = (unsigned int)sub_18A43(v1 + 641, (__int64)"M'illumino d'immenso", v2) == 0;
  return result;
}

//----- (0000000000036FB5) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_36FB5()
{
  byte_96A40 = 0;
  if ( !sub_359AF((__int64)sub_37005, 0i64, 15000000i64, 0) )
  {
    sub_1A11E();
    byte_96A40 = 1;
  }
}
// 36FBD: write access to const memory at 96A40 has been detected
// 36FF8: write access to const memory at 96A40 has been detected
// 96A40: using guessed type char byte_96A40;

//----- (0000000000037005) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_37005()
{
  byte_96A40 = 1;
}
// 37009: write access to const memory at 96A40 has been detected
// 96A40: using guessed type char byte_96A40;

//----- (0000000000037012) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 __fastcall sub_37012(__int64 a1, char **a2, __int64 a3)
{
  __int64 v3; // r13
  char **v4; // rbx
  __int64 v5; // rsi
  _QWORD *v6; // r8
  bool v7; // zf
  __int64 v8; // rcx
  signed __int64 v9; // rdi
  signed __int64 v10; // rax
  int v11; // eax
  int v12; // edi
  char *v13; // rdx
  char *v14; // rdx
  int v15; // er9
  char *v16; // rdx
  unsigned __int64 **v17; // rdi
  __int64 v18; // rax
  char v19; // al
  __int64 v20; // rax
  int v21; // ecx
  __int64 v22; // r14
  __int64 v23; // rbx
  __int64 v24; // rax
  int v25; // ecx
  __int64 *v26; // rcx
  signed __int64 v27; // rcx
  char *v28; // rdx
  __int64 v29; // rax
  __int64 v30; // r9
  __int64 v31; // r9
  __int64 v32; // r9
  signed int v33; // edi
  unsigned __int8 v34; // al
  unsigned __int8 v35; // dl
  unsigned int v36; // edx
  __int64 v37; // rax
  __int64 v38; // rbx
  __int64 v39; // rdx
  signed __int64 v40; // rax
  __int64 v42; // r9
  unsigned int v43; // edx
  unsigned int v44; // edx
  unsigned int v45; // eax
  bool v46; // r14
  __int64 v47; // rcx
  __int64 v48; // rcx
  __int64 v49; // rax
  __int64 v50; // rcx
  __int64 v51; // rdx
  __int64 v52; // rcx
  unsigned int v53; // edx
  __int64 v54; // rdi
  __int64 v55; // rcx
  int v56; // ecx
  _DWORD *v57; // rax
  __int64 v58; // rcx
  __int64 v59; // rax
  void (__fastcall *v60)(const char *, __int64 *, signed __int64, __int64, const char *, __int64); // rbx
  __int64 v61; // rax
  __int64 v62; // rcx
  __int64 v63; // rdi
  int v64; // ebx
  unsigned int v65; // edx
  __int64 v66; // r9
  __int64 v67; // rax
  __int64 v68; // rcx
  __int64 v69; // rcx
  __int64 v70; // rcx
  __int64 v71; // rcx
  __int64 v72; // rax
  __int64 v73; // rcx
  __int64 *v74; // rdi
  __int64 *v75; // rbx
  __int64 v76; // rdx
  __int64 v77; // rax
  __int64 v78; // rcx
  __int64 v79; // rcx
  unsigned __int64 v80; // rcx
  unsigned int v81; // edx
  __int64 v82; // [rsp+28h] [rbp-208h]
  char v83; // [rsp+30h] [rbp-200h]
  int v84; // [rsp+34h] [rbp-1FCh]
  char v85; // [rsp+38h] [rbp-1F8h]
  int v86; // [rsp+3Ch] [rbp-1F4h]
  char v87; // [rsp+40h] [rbp-1F0h]
  unsigned __int64 v88; // [rsp+48h] [rbp-1E8h]
  __int64 v89; // [rsp+50h] [rbp-1E0h]
  __int64 v90; // [rsp+58h] [rbp-1D8h]
  __int64 v91; // [rsp+60h] [rbp-1D0h]
  __int64 v92; // [rsp+68h] [rbp-1C8h]
  __int64 v93; // [rsp+70h] [rbp-1C0h]
  __int64 v94; // [rsp+78h] [rbp-1B8h]
  __int64 v95; // [rsp+80h] [rbp-1B0h]
  __int64 v96; // [rsp+88h] [rbp-1A8h]
  __int64 v97; // [rsp+90h] [rbp-1A0h]
  __int64 v98; // [rsp+98h] [rbp-198h]
  __int64 v99; // [rsp+A0h] [rbp-190h]
  __int64 v100; // [rsp+A8h] [rbp-188h]
  __int64 v101; // [rsp+B0h] [rbp-180h]
  __int64 v102; // [rsp+B8h] [rbp-178h]
  __int64 v103; // [rsp+C0h] [rbp-170h]
  __int64 v104; // [rsp+C8h] [rbp-168h]
  __int64 v105; // [rsp+D0h] [rbp-160h]
  __int64 v106; // [rsp+D8h] [rbp-158h]
  __int64 v107; // [rsp+E0h] [rbp-150h]
  __int64 v108; // [rsp+E8h] [rbp-148h]
  __int64 v109; // [rsp+F0h] [rbp-140h]
  __int64 v110; // [rsp+F8h] [rbp-138h]
  __int64 v111; // [rsp+100h] [rbp-130h]
  __int64 v112; // [rsp+110h] [rbp-120h]
  _QWORD *v113; // [rsp+118h] [rbp-118h]
  __int64 v114; // [rsp+120h] [rbp-110h]
  int v115; // [rsp+128h] [rbp-108h]
  int v116; // [rsp+12Ch] [rbp-104h]
  char v117; // [rsp+130h] [rbp-100h]
  char v118; // [rsp+138h] [rbp-F8h]
  unsigned __int64 v119; // [rsp+140h] [rbp-F0h]
  char v120; // [rsp+148h] [rbp-E8h]
  char v121; // [rsp+150h] [rbp-E0h]
  unsigned __int64 v122; // [rsp+158h] [rbp-D8h]
  signed __int64 (__fastcall *v123)(__int64, __int64); // [rsp+160h] [rbp-D0h]
  __int64 v124; // [rsp+168h] [rbp-C8h]
  __int64 (__fastcall *v125)(__int64, __int64); // [rsp+170h] [rbp-C0h]
  __int64 v126; // [rsp+178h] [rbp-B8h]
  signed __int64 (__fastcall *v127)(__int64, __int64); // [rsp+180h] [rbp-B0h]
  __int64 v128; // [rsp+188h] [rbp-A8h]
  __int64 v129; // [rsp+190h] [rbp-A0h]
  __int64 v130; // [rsp+198h] [rbp-98h]
  __int64 v131; // [rsp+1A0h] [rbp-90h]
  __int64 v132; // [rsp+1A8h] [rbp-88h]
  __int64 v133; // [rsp+1B0h] [rbp-80h]
  __int64 v134; // [rsp+1B8h] [rbp-78h]
  __int64 v135; // [rsp+1C0h] [rbp-70h]
  unsigned __int8 v136; // [rsp+1D0h] [rbp-60h]
  __int64 v137; // [rsp+1D8h] [rbp-58h]
  char **v138; // [rsp+1E0h] [rbp-50h]
  __int64 *v139; // [rsp+1E8h] [rbp-48h]
  int v140; // [rsp+1F4h] [rbp-3Ch]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  sub_1A11E();
  sub_340E9((__int64 *)(v5 + 536), v5);
  if ( v4 )
    sub_F180(*v4, 0, 0x18ui64);
  if ( !sub_36F59(v5) )
  {
    sub_1A11E();
    return 1i64;
  }
  sub_1A11E();
  v6 = (_QWORD *)(v5 + 160);
  v7 = *(_QWORD *)(v5 + 240) == 0i64;
  v8 = *(_QWORD *)(v5 + 40);
  v139 = (__int64 *)(v5 + 536);
  if ( v7 )
  {
    if ( !sub_2C1A0(v8, L"Lucida13.efires", v6) )
      goto LABEL_10;
  }
  else if ( !sub_2C1A0(v8, (__int16 *)"L", v6) )
  {
    goto LABEL_10;
  }
  sub_1A11E();
LABEL_10:
  *(_QWORD *)(v5 + 392) = sub_2BEB3(
                            *(unsigned __int64 **)(v5 + 144),
                            "loginui_shutdown_up.png",
                            "loginui_shutdown_up.png",
                            "loginui_shutdown_down.png",
                            (__int64)sub_38C5A,
                            v5);
  *(_QWORD *)(v5 + 384) = sub_2BEB3(
                            *(unsigned __int64 **)(v5 + 144),
                            "loginui_restart_up.png",
                            "loginui_restart_up.png",
                            "loginui_restart_down.png",
                            (__int64)sub_38CA4,
                            v5);
  *(_QWORD *)(v5 + 512) = sub_2BEB3(
                            *(unsigned __int64 **)(v5 + 144),
                            "loginui_password_hint_up.png",
                            "loginui_password_hint_up.png",
                            "loginui_password_hint_down.png",
                            (__int64)sub_38CEE,
                            v5);
  *(_QWORD *)(v5 + 504) = sub_2BEB3(
                            *(unsigned __int64 **)(v5 + 144),
                            "loginui_goButton.png",
                            "loginui_goButtonPressed.png",
                            "loginui_goButtonPressed.png",
                            (__int64)sub_38D3C,
                            v5);
  *(_QWORD *)(v5 + 440) = sub_2BEB3(
                            *(unsigned __int64 **)(v5 + 144),
                            "loginui_goBackButton.png",
                            "loginui_goBackButtonPressed.png",
                            "loginui_goBackButtonPressed.png",
                            (__int64)sub_38D86,
                            v5);
  *(_QWORD *)(v5 + 528) = sub_2BA6A(*(unsigned __int64 **)(v5 + 144), "loginui_internalStampView.png");
  *(_QWORD *)(v5 + 208) = 0i64;
  v10 = sub_2C719(*(unsigned __int64 **)(v5 + 144), "loginui_keyboard_layout.uchr", 1, (char **)(v5 + 208), 0i64, 1);
  v138 = v4;
  if ( v10 )
  {
    LOBYTE(v10) = 1;
    v140 = v10;
    sub_1A11E();
    if ( sub_2C719(
           *(unsigned __int64 **)(v5 + 144),
           "loginui_fallback_keyboard_layout.uchr",
           1,
           (char **)(v5 + 208),
           0i64,
           1) )
    {
      sub_1A11E();
    }
  }
  else
  {
    sub_1A11E();
    v140 = 0;
  }
  v11 = *(_DWORD *)(v5 + 232);
  v12 = 124 * v11;
  *(_QWORD *)(v5 + 448) = sub_38DD0(v5, *(_QWORD *)(v5 + 208), "loginui_name_field_placeholder.png", 145 * v11, 1);
  v13 = "loginui_name_field_focus.png";
  if ( *(_QWORD *)(v5 + 240) )
    v13 = "loginui_name_field.png";
  *(_QWORD *)(v5 + 456) = sub_2BA6A(*(unsigned __int64 **)(v5 + 144), v13);
  *(_QWORD *)(v5 + 464) = sub_2BA6A(*(unsigned __int64 **)(v5 + 144), "loginui_name_field.png");
  if ( *(_DWORD *)(v5 + 232) == 2 )
    v12 = 290;
  *(_QWORD *)(v5 + 416) = sub_38DD0(v5, *(_QWORD *)(v5 + 208), "loginui_password_field_placeholder.png", v12, 1);
  v14 = "loginui_password_field_focus.png";
  if ( *(_QWORD *)(v5 + 240) )
    v14 = "loginui_password_field.png";
  *(_QWORD *)(v5 + 424) = sub_2BA6A(*(unsigned __int64 **)(v5 + 144), v14);
  *(_QWORD *)(v5 + 432) = sub_2BA6A(*(unsigned __int64 **)(v5 + 144), "loginui_password_field.png");
  v15 = 630;
  if ( *(_DWORD *)(v5 + 232) != 2 )
    v15 = 290;
  *(_QWORD *)(v5 + 472) = sub_38DD0(v5, *(_QWORD *)(v5 + 208), "loginui_recovery_field_placeholder.png", v15, 1);
  v16 = "loginui_recovery_field_focus.png";
  if ( *(_QWORD *)(v5 + 240) )
    v16 = "loginui_recovery_field.png";
  *(_QWORD *)(v5 + 480) = sub_2BA6A(*(unsigned __int64 **)(v5 + 144), v16);
  *(_QWORD *)(v5 + 488) = sub_2BA6A(*(unsigned __int64 **)(v5 + 144), "loginui_recovery_field.png");
  sub_2B27C(*(_QWORD *)(v5 + 472), 1);
  sub_2B28F(*(_QWORD *)(v5 + 472), 1);
  sub_2B269(*(_QWORD *)(v5 + 472), 1);
  v136 = 0;
  v17 = (unsigned __int64 **)(v5 + 152);
  if ( sub_2C1B7(*(_QWORD *)(v5 + 40), L"flag_picker.efires", (_QWORD *)(v5 + 152), &v136) )
    sub_1A11E();
  if ( *v17
    && (v18 = sub_2D085(v5 + 360, *(_QWORD *)(v5 + 32), *v17, (__int64)sub_38F3A, v5),
        (*(_QWORD *)(v5 + 352) = v18) != 0i64) )
  {
    v19 = sub_2CEC9(v18, v140);
    if ( !(v136 | (unsigned __int8)v19) )
      sub_2CBDA(*(_QWORD *)(v5 + 352));
  }
  else
  {
    sub_1A11E();
  }
  v20 = *(_QWORD *)(v5 + 32);
  *(_DWORD *)(v5 + 336) = *(_DWORD *)(v20 + 12) / 2;
  v21 = *(_DWORD *)(v20 + 8);
  *(_DWORD *)(v5 + 340) = v21 / 2;
  if ( !*(_QWORD *)(v5 + 320) )
    *(_DWORD *)(v5 + 340) = v21 / 2 - (((unsigned __int64)(1717986919i64 * v21) >> 63) + (1717986919i64 * v21 >> 35));
  v22 = *(signed int *)(v5 + 48);
  if ( *(_DWORD *)(v5 + 48) )
  {
    v23 = *(_QWORD *)(v5 + 56);
    if ( (_DWORD)v22 == 1 )
    {
      v112 = *(_QWORD *)(*(_QWORD *)v23 + 64i64);
      v113 = sub_39014;
      v114 = v5;
      sub_3469F((_QWORD *)(v5 + 264), (__int64 **)&v112);
      goto LABEL_44;
    }
    sub_2BE2F(
      *(unsigned __int64 **)(v5 + 144),
      "loginui_magicPocketShadow_left.png",
      &v83,
      (unsigned __int64 *)&v85,
      0i64,
      1);
    sub_2BE2F(*(unsigned __int64 **)(v5 + 144), "loginui_magicPocketShadow_right.png", &v87, &v88, 0i64, 1);
    sub_F180((char *)&v112, 0, 0x80ui64);
    LODWORD(v112) = v22;
    v113 = (_QWORD *)sub_24103(8 * v22);
    v25 = *(_DWORD *)(v5 + 232);
    v115 = 20 * v25;
    v116 = 2 * (*(_DWORD *)(*(_QWORD *)(v5 + 32) + 12i64) / v25 > 1600) + 3;
    v123 = sub_3C3B8;
    v124 = v5;
    v125 = sub_3C432;
    v126 = v5;
    v127 = sub_3C5E0;
    v128 = v5;
    sub_2BE2F(*(unsigned __int64 **)(v5 + 144), "loginui_next.png", &v117, &v119, 0i64, 1);
    sub_2BE2F(*(unsigned __int64 **)(v5 + 144), "loginui_nextPressed.png", &v118, &v119, 0i64, 1);
    sub_2BE2F(*(unsigned __int64 **)(v5 + 144), "loginui_previous.png", &v120, &v122, 0i64, 1);
    sub_2BE2F(*(unsigned __int64 **)(v5 + 144), "loginui_previousPressed.png", &v121, &v122, 0i64, 1);
    v26 = *(__int64 **)(*(_QWORD *)v23 + 64i64);
    v114 = *v26;
    if ( (signed int)v22 > 0 )
    {
      *v113 = v26;
      v27 = 1i64;
      do
      {
        v113[v27] = *(_QWORD *)(*(_QWORD *)(v23 + 8 * v27) + 64i64);
        ++v27;
      }
      while ( (unsigned int)v22 != v27 );
    }
    v105 = 0i64;
    if ( sub_2FCF6(&v105, &v112, (__int64 *)&v83) )
      sub_1A11E();
    v24 = v105;
  }
  else
  {
    sub_1A11E();
    v24 = 0i64;
  }
  *(_QWORD *)(v5 + 256) = v24;
LABEL_44:
  *(_QWORD *)(v5 + 320) = sub_349EB(*(unsigned __int64 ***)(v5 + 224));
  if ( *(_BYTE *)(v5 + 304) )
  {
    v28 = "loginui_password_required_touchid_ribbon.png";
  }
  else
  {
    if ( !*(_BYTE *)(v5 + 305) )
    {
      v29 = 0i64;
      goto LABEL_49;
    }
    v28 = "loginui_password_required_watch_ribbon.png";
  }
  v29 = sub_2BA6A(*(unsigned __int64 **)(v5 + 144), v28);
LABEL_49:
  *(_QWORD *)(v5 + 312) = v29;
  v30 = *(unsigned __int8 *)(v5 + 304);
  sub_1A11E();
  v31 = *(unsigned __int8 *)(v5 + 305);
  sub_1A11E();
  v32 = *(_QWORD *)(v5 + 320);
  sub_1A11E();
  if ( sub_2C1A0(*(_QWORD *)(v5 + 40), (__int16 *)"b", (_QWORD *)(v5 + 168)) )
    sub_1A11E();
  else
    *(_QWORD *)(v5 + 368) = sub_34E27(
                              (_QWORD *)(v5 + 376),
                              *(_QWORD *)(v5 + 32),
                              *(_QWORD *)(v5 + 168),
                              (__int64)sub_3904B,
                              v5);
  if ( sub_3FBF3() )
    sub_2BDBE(*(unsigned __int64 **)(v5 + 144), *(_QWORD *)(*(_QWORD *)(v5 + 32) + 40i64), "loginui_cursor.png");
  sub_1A11E();
  if ( v3 )
  {
    while ( !byte_96A40 )
      ;
    sub_1A11E();
    if ( *(_BYTE *)(v3 + 225) )
    {
      v33 = 20;
      do
      {
        v34 = *(_BYTE *)(v3 + 168);
        v35 = v34 + 12;
        if ( v34 >= 0xF4u )
          v35 = -1;
        sub_27500(v3, v35);
        sub_2F99D(*(_QWORD **)(v5 + 32), 10i64);
        --v33;
      }
      while ( v33 );
      sub_3F1DC(*(_QWORD *)(v5 + 32), (__int64 *)v3);
    }
  }
  if ( *(_QWORD *)(v5 + 240) )
  {
    sub_1A11E();
    sub_35852();
    sub_3F613(*(_QWORD *)(v5 + 32), *(_QWORD *)(v5 + 240), 0);
    sub_27500(*(_QWORD *)(v5 + 240), 0);
    sub_3F6AA(*(_QWORD **)(v5 + 32));
    sub_353A0(300i64, 0x32ui64, 1);
    sub_1A11E();
  }
  sub_3F6AA(*(_QWORD **)(v5 + 32));
  LOBYTE(v36) = 1;
  sub_275C4(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 40i64), v36);
  v112 = *(_QWORD *)(v5 + 256);
  v113 = *(_QWORD **)(v5 + 264);
  v114 = *(_QWORD *)(v5 + 360);
  *(_QWORD *)&v115 = *(_QWORD *)(v5 + 376);
  *(_QWORD *)&v117 = *(_QWORD *)(v5 + 392);
  *(_QWORD *)&v118 = *(_QWORD *)(v5 + 384);
  v119 = *(_QWORD *)(v5 + 432);
  *(_QWORD *)&v120 = *(_QWORD *)(v5 + 424);
  *(_QWORD *)&v121 = *(_QWORD *)(v5 + 416);
  v122 = *(_QWORD *)(v5 + 440);
  v123 = *(signed __int64 (__fastcall **)(__int64, __int64))(v5 + 464);
  v124 = *(_QWORD *)(v5 + 456);
  v125 = *(__int64 (__fastcall **)(__int64, __int64))(v5 + 448);
  v126 = *(_QWORD *)(v5 + 488);
  v127 = *(signed __int64 (__fastcall **)(__int64, __int64))(v5 + 480);
  v128 = *(_QWORD *)(v5 + 472);
  v129 = *(_QWORD *)(v5 + 320);
  v130 = *(_QWORD *)(v5 + 504);
  v131 = *(_QWORD *)(v5 + 512);
  v132 = *(_QWORD *)(v5 + 528);
  v133 = *(_QWORD *)(v5 + 312);
  v134 = 1i64;
  v135 = 0i64;
  v37 = sub_2B927((__int64)&v112, 0);
  if ( v37 )
    goto LABEL_65;
  v38 = 0i64;
  v9 = 0i64;
  while ( 1 )
  {
    v39 = *(&v112 + v38);
    if ( !v39 )
      goto LABEL_72;
    if ( v39 == 1 )
      break;
    v40 = sub_3F340(*(_QWORD *)(v5 + 32), v39);
    if ( v40 )
    {
      v9 = v40;
      sub_1A11E();
    }
    else
    {
      v9 = 0i64;
    }
LABEL_72:
    ++v38;
  }
  if ( v9 )
    goto LABEL_74;
  sub_1A11E();
  v105 = *(_QWORD *)(v5 + 384);
  v106 = *(_QWORD *)(v5 + 392);
  v107 = *(_QWORD *)(v5 + 320);
  v108 = *(_QWORD *)(v5 + 376);
  v109 = *(_QWORD *)(v5 + 528);
  v110 = 1i64;
  v111 = 0i64;
  v42 = *(_QWORD *)(v5 + 504);
  sub_1A11E();
  LOBYTE(v43) = 1;
  sub_275C4(*(_QWORD *)(v5 + 504), v43);
  LOBYTE(v44) = 1;
  v37 = sub_2B927((__int64)&v105, v44);
  if ( v37 )
  {
LABEL_65:
    v9 = v37;
LABEL_74:
    sub_1A11E();
    return v9;
  }
  if ( *(_QWORD *)(v5 + 352) )
  {
    LOBYTE(v45) = sub_34936(*(unsigned __int64 ***)(v5 + 224));
    sub_275C4(*(_QWORD *)(v5 + 360), v45);
  }
  *(_DWORD *)(v5 + 408) = -162 * *(_DWORD *)(v5 + 232);
  sub_1A11E();
  if ( sub_349C6(*(unsigned __int64 ***)(v5 + 224)) )
  {
    sub_38464(v5);
    v46 = 0;
  }
  else
  {
    v46 = *(_DWORD *)(v5 + 48) == 1;
    if ( *(_DWORD *)(v5 + 48) == 1 )
      sub_38714(v5, 0, 1);
    else
      sub_38799(v5, 1);
    v61 = *(_QWORD *)(v5 + 432);
    if ( v61 )
    {
      v62 = *(_QWORD *)(v5 + 312);
      if ( v62 )
      {
        v63 = *(_QWORD *)(v62 + 44);
        *(_QWORD *)&v85 = *(_QWORD *)(v62 + 52);
        *(_QWORD *)&v83 = v63;
        v64 = *(_DWORD *)(*(_QWORD *)(v5 + 32) + 12i64) / 2;
        v84 = *(_DWORD *)(v61 + 48) + *(_DWORD *)(v61 + 52) + 10 * *(_DWORD *)(v5 + 232);
        *(_DWORD *)&v83 = v64 - v86 / 2;
        sub_27402((_DWORD *)v62, &v83);
        LOBYTE(v65) = 1;
        sub_275C4(*(_QWORD *)(v5 + 312), v65);
      }
    }
  }
  sub_1A11E();
  v47 = *(_QWORD *)(v5 + 544);
  if ( v47 )
  {
    sub_35A74(v47);
    *(_QWORD *)(v5 + 544) = 0i64;
  }
  *(_QWORD *)(v5 + 544) = sub_359AF((__int64)sub_3DB6E, v5, 200000000i64, 1u);
  *(_QWORD *)(v5 + 552) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 40i64) + 44i64);
  sub_1A11E();
  sub_1A11E();
  v48 = *(_QWORD *)(v5 + 32);
  sub_2C16A();
  v82 = *(_QWORD *)(v5 + 64);
  sub_1A11E();
  v49 = *(_QWORD *)(v5 + 64);
  if ( v49 )
  {
    v50 = *(signed int *)(v5 + 48);
    if ( v50 <= 0 )
      goto LABEL_95;
    v51 = 0i64;
    while ( *(_QWORD *)(*(_QWORD *)(v5 + 56) + 8 * v51) != v49 )
    {
      if ( ++v51 >= v50 )
        goto LABEL_95;
    }
    if ( (_DWORD)v51 == -1 )
    {
LABEL_95:
      sub_1A11E();
    }
    else
    {
      v52 = *(_QWORD *)(v5 + 256);
      if ( v52 )
      {
        sub_30ECA(v52, v51, 1);
        LOBYTE(v53) = 1;
        sub_275C4(*(_QWORD *)(v5 + 424), v53);
      }
    }
  }
  sub_1A11E();
  sub_3413D(*v139);
  v54 = (__int64)v138;
  if ( v46 )
  {
    if ( !(unsigned __int8)sub_38B4D(v5, *(_QWORD *)(v5 + 192)) )
      sub_2B3C8(*(_QWORD *)(v5 + 416), 1);
    sub_35A58((__int64)sub_38BF4, v5, 180i64, 0);
  }
  sub_1A11E();
  if ( *(_DWORD *)(v5 + 100) == 1 )
  {
    *(_QWORD *)(v5 + 328) = sub_35A58((__int64)sub_3DD75, v5, 600000000i64, 0);
    sub_1A11E();
  }
  sub_1A11E();
  sub_38C1B(v5);
  sub_2FA45();
  sub_341CC(*(_QWORD *)(v5 + 536));
  v55 = *(_QWORD *)(v5 + 328);
  if ( v55 )
  {
    sub_35A74(v55);
    *(_QWORD *)(v5 + 328) = 0i64;
  }
  if ( v54 )
  {
    v56 = *(_DWORD *)(v5 + 216);
    v57 = *(_DWORD **)v54;
    **(_DWORD **)v54 = v56;
    if ( v56 == 1 )
    {
      v58 = *(_QWORD *)(v5 + 192);
      if ( !v58 )
        goto LABEL_144;
      *((_QWORD *)v57 + 1) = v58;
      if ( sub_292C5() )
      {
        v59 = *(_QWORD *)(v5 + 192);
        v60 = *(void (__fastcall **)(const char *, __int64 *, signed __int64, __int64, const char *, __int64))(qword_96CE0 + 88);
        if ( *(_DWORD *)(v59 + 24) )
        {
          v60(
            "l",
            qword_93650,
            7i64,
            *(signed int *)(**(_QWORD **)(v59 + 32) + 8i64),
            ***(const char ****)(v59 + 32),
            v82);
        }
        else
        {
          v66 = (signed int)sub_189FE("<unknow>");
          v60("l", qword_93650, 7i64, v66, "<unknow>", v82);
        }
      }
      if ( (v67 = *(_QWORD *)(v5 + 192), (v68 = *(_QWORD *)(v67 + 64)) == 0)
        || (v69 = *(_QWORD *)(v68 + 104), *(_QWORD *)(*(_QWORD *)v54 + 16i64) = v69, v67 == *(_QWORD *)(v5 + 80))
        && !v69
        || v67 == *(_QWORD *)(v5 + 72) && !v69 )
      {
LABEL_144:
        sub_1A11E();
      }
    }
  }
  if ( qword_96D30 )
  {
    sub_35A74(qword_96D30);
    sub_275C4(qword_96D38, 0);
    sub_3F6AA(*(_QWORD **)(qword_96D38 + 80));
    qword_96D30 = 0i64;
    sub_1A11E();
  }
  v70 = *(_QWORD *)(v5 + 256);
  if ( v70 && sub_30C41(v70) )
    sub_1A11E();
  if ( *(_BYTE *)(v5 + 97) || *(_DWORD *)(v5 + 216) != 1 )
    return 0i64;
  v71 = *(_QWORD *)(*(_QWORD *)(v5 + 32) + 40i64);
  v72 = *(_QWORD *)(v71 + 44);
  v137 = *(_QWORD *)(v71 + 52);
  *(_QWORD *)&v136 = 0i64;
  sub_27402((_DWORD *)v71, &v136);
  sub_275C4(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 40i64), 0);
  sub_38C1B(v5);
  v73 = *(_QWORD *)(v5 + 288);
  if ( v73 )
    goto LABEL_138;
  v74 = (__int64 *)(v5 + 288);
  v75 = (__int64 *)&v85;
  *(_QWORD *)&v83 = *(_QWORD *)(v5 + 360);
  *(_QWORD *)&v85 = *(_QWORD *)(v5 + 376);
  *(_QWORD *)&v87 = *(_QWORD *)(v5 + 384);
  v88 = *(_QWORD *)(v5 + 392);
  v89 = *(_QWORD *)(v5 + 424);
  v90 = *(_QWORD *)(v5 + 432);
  v91 = *(_QWORD *)(v5 + 416);
  v92 = *(_QWORD *)(v5 + 448);
  v93 = *(_QWORD *)(v5 + 440);
  v94 = *(_QWORD *)(v5 + 456);
  v95 = *(_QWORD *)(v5 + 464);
  v96 = *(_QWORD *)(v5 + 472);
  v97 = *(_QWORD *)(v5 + 480);
  v98 = *(_QWORD *)(v5 + 488);
  v99 = *(_QWORD *)(v5 + 504);
  v100 = *(_QWORD *)(v5 + 400);
  v101 = *(_QWORD *)(v5 + 512);
  v102 = *(_QWORD *)(v5 + 320);
  v103 = 1i64;
  v104 = 0i64;
  sub_2780F((_QWORD *)(v5 + 288), *(_QWORD *)(v5 + 32));
  v76 = *(_QWORD *)&v83;
  while ( 2 )
  {
    if ( !v76 )
    {
LABEL_136:
      v76 = *v75;
      ++v75;
      continue;
    }
    break;
  }
  if ( v76 != 1 )
  {
    sub_278C3(*v74, v76);
    goto LABEL_136;
  }
  v73 = *v74;
LABEL_138:
  sub_3340E(v73, 0xFFu, 2, 200);
  sub_2F99D(*(_QWORD **)(v5 + 32), 210i64);
  if ( !*(_QWORD *)(v5 + 520) )
  {
    v77 = sub_2BA6A(*(unsigned __int64 **)(v5 + 144), "loginui_bootprogressbar.png");
    *(_QWORD *)(v5 + 520) = v77;
    if ( v77 )
    {
      v78 = *(_QWORD *)(v77 + 44);
      *(_QWORD *)&v85 = *(_QWORD *)(v77 + 52);
      *(_QWORD *)&v83 = v78;
      v79 = *(_QWORD *)(v5 + 32);
      *(_DWORD *)&v83 = (*(_DWORD *)(v79 + 12) - *(_DWORD *)(v77 + 56)) / 2;
      v80 = 2863311532i64 * *(_DWORD *)(v79 + 8);
      v84 = (v80 >> 63) + HIDWORD(v80);
      sub_27402((_DWORD *)v77, &v83);
      sub_27500(*(_QWORD *)(v5 + 520), 0xFFu);
      LOBYTE(v81) = 1;
      sub_275C4(*(_QWORD *)(v5 + 520), v81);
      sub_3F340(*(_QWORD *)(v5 + 32), *(_QWORD *)(v5 + 520));
      sub_3340E(*(_QWORD *)(v5 + 520), 0, 2, 200);
    }
  }
  return 0i64;
}
// 3819F: write access to const memory at 96D30 has been detected
// 41900: using guessed type __int16 aLucida13Efires[16];
// 41920: using guessed type __int16 aFlagPickerEfir[19];
// 93650: using guessed type __int64 qword_93650[2];
// 96A40: using guessed type char byte_96A40;
// 96CE0: using guessed type __int64 qword_96CE0;
// 96D30: using guessed type __int64 qword_96D30;
// 96D38: using guessed type __int64 qword_96D38;

//----- (0000000000038464) ----------------------------------------------------
void __fastcall sub_38464(__int64 a1)
{
  __int64 v1; // rsi
  unsigned int v2; // er8
  _QWORD *v3; // rax
  unsigned int v4; // edx
  __int64 v5; // rcx
  __int64 v6; // [rsp+20h] [rbp-B0h]
  __int64 v7; // [rsp+28h] [rbp-A8h]
  __int64 v8; // [rsp+30h] [rbp-A0h]
  __int64 v9; // [rsp+38h] [rbp-98h]
  __int64 v10; // [rsp+40h] [rbp-90h]
  __int64 v11; // [rsp+48h] [rbp-88h]
  __int64 v12; // [rsp+50h] [rbp-80h]
  __int64 v13; // [rsp+58h] [rbp-78h]
  __int64 v14; // [rsp+60h] [rbp-70h]
  __int64 v15; // [rsp+68h] [rbp-68h]
  __int64 v16; // [rsp+70h] [rbp-60h]
  __int64 v17; // [rsp+78h] [rbp-58h]
  __int64 v18; // [rsp+80h] [rbp-50h]
  __int64 v19; // [rsp+88h] [rbp-48h]
  __int64 v20; // [rsp+90h] [rbp-40h]
  __int64 v21; // [rsp+98h] [rbp-38h]
  __int64 v22; // [rsp+A0h] [rbp-30h]

  v1 = a1;
  sub_1A11E();
  if ( *(_DWORD *)(v1 + 184) != 2 )
  {
    LOBYTE(v2) = 1;
    sub_3BBC7(v1, "sound_SCREFIAudio.VoiceOverOn", v2);
  }
  *(_DWORD *)(v1 + 184) = 2;
  sub_34253(*(char **)(v1 + 536));
  v3 = (_QWORD *)sub_342D0(*(_QWORD *)(v1 + 536));
  if ( v3 )
  {
    v3[5] = sub_3D325;
    v3[4] = sub_3CD52;
    v3[6] = sub_3D402;
    v3[7] = sub_3CE33;
    v3[17] = sub_3CED1;
    v3[8] = sub_3CF59;
    v3[9] = sub_3CF9A;
    v3[10] = sub_3D007;
    v3[11] = sub_3D038;
    v3[12] = sub_3D069;
    v3[13] = sub_3D09A;
    v3[14] = sub_3D0D2;
    v3[15] = sub_3D10A;
    v3[16] = sub_3D133;
  }
  sub_3AFB2(v1, 0);
  *(_QWORD *)(v1 + 192) = 0i64;
  v16 = *(_QWORD *)(v1 + 456);
  v17 = *(_QWORD *)(v1 + 448);
  v18 = *(_QWORD *)(v1 + 432);
  v19 = *(_QWORD *)(v1 + 416);
  v20 = *(_QWORD *)(v1 + 440);
  v21 = 1i64;
  v22 = 0i64;
  LOBYTE(v4) = 1;
  sub_2B927((__int64)&v16, v4);
  sub_2B9C3(5u, (__int64)&v16, 0);
  v6 = *(_QWORD *)(v1 + 512);
  v7 = *(_QWORD *)(v1 + 464);
  v8 = *(_QWORD *)(v1 + 424);
  v9 = *(_QWORD *)(v1 + 480);
  v10 = *(_QWORD *)(v1 + 488);
  v11 = *(_QWORD *)(v1 + 400);
  v12 = *(_QWORD *)(v1 + 256);
  v13 = *(_QWORD *)(v1 + 264);
  v14 = 1i64;
  v15 = 0i64;
  sub_2B927((__int64)&v6, 0);
  sub_2AE83(*(_QWORD *)(v1 + 448));
  sub_2AE83(*(_QWORD *)(v1 + 416));
  sub_2B3F3(*(_QWORD **)(v1 + 448), 1);
  sub_2B3F3(*(_QWORD **)(v1 + 416), 1);
  sub_2B2A2(*(_QWORD *)(v1 + 448), 1, 0);
  sub_2B2A2(*(_QWORD *)(v1 + 416), 0, 0);
  sub_2B2A2(*(_QWORD *)(v1 + 472), 0, 0);
  v5 = *(_QWORD *)(v1 + 256);
  if ( v5 )
    sub_30C41(v5);
  sub_3D482((_QWORD *)v1, *(_QWORD **)(v1 + 448), 1);
  sub_3A4BF(v1, 0i64, 0xFFFF);
}

//----- (0000000000038714) ----------------------------------------------------
void __fastcall sub_38714(__int64 a1, char a2, char a3)
{
  char v3; // si
  char v4; // bl
  __int64 v5; // rdi
  __int64 v6; // rax
  signed __int64 v7; // rcx
  __int64 v8; // rcx

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( *(_DWORD *)(a1 + 184) == 2 )
  {
    v6 = *(_QWORD *)(a1 + 632);
    if ( v6 )
    {
      v7 = 8i64;
      do
      {
        *(_QWORD *)(v6 + v7 - 8) = 0i64;
        *(_QWORD *)(v6 + v7) = 0i64;
        v7 += 16i64;
      }
      while ( v7 != 88 );
    }
    sub_3BBC7(v5, "sound_SCREFIAudio.VoiceOverOff", 2u);
  }
  v8 = *(_QWORD *)(v5 + 264);
  *(_QWORD *)(v5 + 192) = **(_QWORD **)(v5 + 56);
  sub_3453F(v8, 0);
  sub_3C7E5(v5, v4, v3);
}

//----- (0000000000038799) ----------------------------------------------------
void __fastcall sub_38799(__int64 a1, char a2)
{
  char v2; // bl
  __int64 v3; // rsi
  unsigned int v4; // er8
  __int64 v5; // rax
  signed __int64 v6; // rcx
  _QWORD *v7; // rax
  unsigned int v8; // edx
  __int64 v9; // rcx
  __int64 v10; // [rsp+30h] [rbp-B0h]
  __int64 v11; // [rsp+38h] [rbp-A8h]
  __int64 v12; // [rsp+40h] [rbp-A0h]
  __int64 v13; // [rsp+48h] [rbp-98h]
  __int64 v14; // [rsp+50h] [rbp-90h]
  __int64 v15; // [rsp+58h] [rbp-88h]
  __int64 v16; // [rsp+60h] [rbp-80h]
  __int64 v17; // [rsp+68h] [rbp-78h]
  __int64 v18; // [rsp+70h] [rbp-70h]
  __int64 v19; // [rsp+78h] [rbp-68h]
  __int64 v20; // [rsp+80h] [rbp-60h]
  __int64 v21; // [rsp+88h] [rbp-58h]
  __int64 v22; // [rsp+90h] [rbp-50h]
  __int64 v23; // [rsp+98h] [rbp-48h]
  __int64 v24; // [rsp+A0h] [rbp-40h]
  __int64 v25; // [rsp+A8h] [rbp-38h]
  __int64 v26; // [rsp+B0h] [rbp-30h]
  __int64 v27; // [rsp+B8h] [rbp-28h]
  __int64 v28; // [rsp+C0h] [rbp-20h]

  v2 = a2;
  v3 = a1;
  sub_1A11E();
  if ( *(_DWORD *)(v3 + 184) == 2 )
  {
    v5 = *(_QWORD *)(v3 + 632);
    if ( v5 )
    {
      v6 = 8i64;
      do
      {
        *(_QWORD *)(v5 + v6 - 8) = 0i64;
        *(_QWORD *)(v5 + v6) = 0i64;
        v6 += 16i64;
      }
      while ( v6 != 88 );
    }
    LOBYTE(v4) = 2;
    sub_3BBC7(v3, "sound_SCREFIAudio.VoiceOverOff", v4);
  }
  *(_DWORD *)(v3 + 184) = 0;
  sub_3A4BF(v3, 0i64, 0xFFFF);
  sub_34253(*(char **)(v3 + 536));
  v7 = (_QWORD *)sub_342D0(*(_QWORD *)(v3 + 536));
  if ( v7 )
  {
    v7[5] = sub_3D871;
    *v7 = sub_3D892;
    v7[2] = sub_3D892;
    v7[1] = sub_3D8B3;
    v7[3] = sub_3D8B3;
    v7[18] = sub_3D8D4;
    v7[7] = sub_3CE33;
    v7[17] = sub_3CED1;
    v7[8] = sub_3CF59;
    v7[9] = sub_3CF9A;
    v7[10] = sub_3D007;
    v7[11] = sub_3D038;
    v7[12] = sub_3D069;
    v7[13] = sub_3D09A;
    v7[14] = sub_3D0D2;
    v7[15] = sub_3D10A;
    v7[16] = sub_3D133;
  }
  sub_1A11E();
  if ( v2 )
    sub_27500(*(_QWORD *)(v3 + 256), 0xFFu);
  v24 = *(_QWORD *)(v3 + 256);
  v25 = *(_QWORD *)(v3 + 392);
  v26 = *(_QWORD *)(v3 + 384);
  v27 = 1i64;
  v28 = 0i64;
  LOBYTE(v8) = 1;
  sub_2B927((__int64)&v24, v8);
  if ( v2 )
    sub_3340E(*(_QWORD *)(v3 + 256), 0, 1, 200);
  sub_1A11E();
  v10 = *(_QWORD *)(v3 + 504);
  v11 = *(_QWORD *)(v3 + 512);
  v12 = *(_QWORD *)(v3 + 416);
  v13 = *(_QWORD *)(v3 + 448);
  v14 = *(_QWORD *)(v3 + 472);
  v15 = *(_QWORD *)(v3 + 424);
  v16 = *(_QWORD *)(v3 + 456);
  v17 = *(_QWORD *)(v3 + 480);
  v18 = *(_QWORD *)(v3 + 432);
  v19 = *(_QWORD *)(v3 + 464);
  v20 = *(_QWORD *)(v3 + 488);
  v21 = *(_QWORD *)(v3 + 440);
  v22 = 1i64;
  v23 = 0i64;
  sub_2B927((__int64)&v10, 0);
  sub_1A11E();
  sub_2AE83(*(_QWORD *)(v3 + 416));
  sub_2AE83(*(_QWORD *)(v3 + 448));
  sub_2AE83(*(_QWORD *)(v3 + 472));
  sub_1A11E();
  sub_2B3C8(*(_QWORD *)(v3 + 416), 0);
  sub_2B3C8(*(_QWORD *)(v3 + 448), 0);
  sub_2B3C8(*(_QWORD *)(v3 + 472), 0);
  sub_1A11E();
  v9 = *(_QWORD *)(v3 + 256);
  if ( v9 )
    sub_306FE(v9);
  sub_1A11E();
  sub_1A11E();
}

//----- (0000000000038B4D) ----------------------------------------------------
__int64 __fastcall sub_38B4D(__int64 a1, __int64 a2)
{
  unsigned int v2; // edi
  __int64 v3; // rsi
  unsigned int (__fastcall *v4)(__int64, __int64, int *); // rax
  int v5; // eax
  _QWORD *v6; // rcx
  int v8; // [rsp+2Ch] [rbp-14h]

  v8 = 0;
  v2 = 0;
  if ( a2 )
  {
    v3 = a1;
    v4 = *(unsigned int (__fastcall **)(__int64, __int64, int *))(a1 + 112);
    if ( v4 )
    {
      if ( v4(a1, a2, &v8) )
      {
        *(_DWORD *)(v3 + 584) = v8;
        sub_3BB78(v3);
        sub_392BD((_QWORD *)v3, 2);
        v5 = *(_DWORD *)(v3 + 184);
        LOBYTE(v2) = 1;
        if ( v5 == 4 )
        {
          sub_2B3C8(*(_QWORD *)(v3 + 472), 0);
          v6 = *(_QWORD **)(v3 + 472);
          goto LABEL_9;
        }
        if ( v5 == 1 )
        {
          sub_2B3C8(*(_QWORD *)(v3 + 416), 0);
          v6 = *(_QWORD **)(v3 + 416);
LABEL_9:
          sub_2B3F3(v6, 0);
          return v2;
        }
      }
      else
      {
        v2 = 0;
      }
    }
  }
  return v2;
}

//----- (0000000000038BF4) ----------------------------------------------------
signed __int64 __fastcall sub_38BF4(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = a2;
  sub_274AA(*(_QWORD *)(a2 + 424));
  return sub_3F6AA(*(_QWORD **)(v2 + 32));
}

//----- (0000000000038C1B) ----------------------------------------------------
signed __int64 __fastcall sub_38C1B(__int64 a1)
{
  signed __int64 v1; // rsi

  v1 = sub_3F6AA(*(_QWORD **)(a1 + 32));
  if ( v1 )
    sub_1A11E();
  return v1;
}

//----- (0000000000038C5A) ----------------------------------------------------
__int64 __fastcall sub_38C5A(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = a2;
  sub_1A11E();
  sub_2FACD((__int64)sub_390CA, v2, (__int64)sub_39090, (__int64)"_LW_Shutdown");
  return 0i64;
}

//----- (0000000000038CA4) ----------------------------------------------------
__int64 __fastcall sub_38CA4(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = a2;
  sub_1A11E();
  sub_2FACD((__int64)sub_390CA, v2, (__int64)sub_390D5, (__int64)"_LW_Restart");
  return 0i64;
}

//----- (0000000000038CEE) ----------------------------------------------------
__int64 __fastcall sub_38CEE(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // r9

  v2 = a2;
  v3 = *(_QWORD *)(a1 + 16);
  sub_1A11E();
  sub_2FACD((__int64)sub_390CA, v2, (__int64)sub_3910F, (__int64)"_LW_LoginPane_ForgotPassword");
  return 0i64;
}

//----- (0000000000038D3C) ----------------------------------------------------
__int64 __fastcall sub_38D3C(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = a2;
  sub_1A11E();
  sub_2FACD((__int64)sub_390CA, v2, (__int64)sub_3C0C2, (__int64)"_LW_LoginPane_LoginButtonCallback_deferred");
  return 0i64;
}

//----- (0000000000038D86) ----------------------------------------------------
__int64 __fastcall sub_38D86(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = a2;
  sub_1A11E();
  sub_2FACD((__int64)sub_390CA, v2, (__int64)sub_3C11E, (__int64)"_LW_LoginPane_BackButtonCallback_deferred");
  return 0i64;
}

//----- (0000000000038DD0) ----------------------------------------------------
__int64 __fastcall sub_38DD0(__int64 a1, __int64 a2, char *a3, int a4, char a5)
{
  char *v5; // r12
  __int64 v6; // r14
  __int64 v7; // rsi
  __int64 v9[2]; // [rsp+30h] [rbp-90h]
  char v10; // [rsp+40h] [rbp-80h]
  char v11; // [rsp+48h] [rbp-78h]
  char v12; // [rsp+50h] [rbp-70h]
  char v13; // [rsp+58h] [rbp-68h]
  char v14; // [rsp+60h] [rbp-60h]
  char v15; // [rsp+68h] [rbp-58h]
  char v16; // [rsp+70h] [rbp-50h]
  char v17; // [rsp+78h] [rbp-48h]
  __int64 v18; // [rsp+80h] [rbp-40h]
  __int64 v19; // [rsp+88h] [rbp-38h]

  v5 = a3;
  v6 = a2;
  v7 = a1;
  sub_26B03(v9, 0, 0, a4, 17 * *(_DWORD *)(a1 + 232));
  memset(&v10, 0, 0x48ui64);
  sub_2BE2F(*(unsigned __int64 **)(v7 + 144), "loginui_passdot.png", &v10, (unsigned __int64 *)&v11, 0i64, 1);
  sub_2BE2F(*(unsigned __int64 **)(v7 + 144), "loginui_password_capslock.png", &v14, (unsigned __int64 *)&v15, 0i64, 1);
  if ( v5 )
    sub_2BE2F(*(unsigned __int64 **)(v7 + 144), v5, &v16, (unsigned __int64 *)&v17, 0i64, 1);
  sub_2BE2F(
    *(unsigned __int64 **)(v7 + 144),
    "loginui_text_selection_color.png",
    &v12,
    (unsigned __int64 *)&v13,
    0i64,
    1);
  v18 = *(_QWORD *)(v7 + 160);
  if ( sub_2A281(&v19, v9, &v10, v6, *(_QWORD *)(v7 + 240) != 0i64) )
    sub_1A11E();
  if ( a5 )
    sub_2AB71(v19, (__int64)sub_3C17A, v7);
  return v19;
}

//----- (0000000000038F3A) ----------------------------------------------------
__int64 __fastcall sub_38F3A(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v6; // [rsp+30h] [rbp-60h]
  __int64 v7; // [rsp+38h] [rbp-58h]
  __int64 v8; // [rsp+40h] [rbp-50h]
  __int64 v9; // [rsp+48h] [rbp-48h]
  __int64 v10; // [rsp+50h] [rbp-40h]
  __int64 v11; // [rsp+58h] [rbp-38h]
  __int64 v12; // [rsp+60h] [rbp-30h]

  v2 = a2;
  v3 = a1;
  sub_1A11E();
  v2[26] = *(_QWORD *)(v3 + 32);
  v6 = v2[52];
  v7 = v2[56];
  v8 = v2[75];
  v9 = v2[59];
  v4 = 0i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  do
  {
    if ( *(&v6 + v4) && sub_2B4AA(*(&v6 + v4), v2[26]) )
      sub_1A11E();
    ++v4;
  }
  while ( v4 != 4 );
  sub_3A4BF((__int64)v2, 0i64, 0xFFFF);
  return 0i64;
}

//----- (0000000000039014) ----------------------------------------------------
signed __int64 __fastcall sub_39014(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rsi

  v2 = (_QWORD *)a2;
  sub_367A3(a2);
  sub_3A409(v2);
  sub_38714((__int64)v2, 1, 1);
  return sub_38C1B((__int64)v2);
}

//----- (000000000003904B) ----------------------------------------------------
__int64 __fastcall sub_3904B(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = a2;
  sub_1A11E();
  sub_3A4BF(v2, 0i64, 0xFFFF);
  sub_38C1B(v2);
  return 0i64;
}

//----- (0000000000039090) ----------------------------------------------------
signed __int64 __fastcall sub_39090(__int64 a1)
{
  *(_DWORD *)(a1 + 216) = 5;
  sub_1A11E();
  return sub_2FA77();
}

//----- (00000000000390CA) ----------------------------------------------------
__int64 __fastcall sub_390CA(__int64 a1, __int64 a2, __int64 (__fastcall *a3)(__int64))
{
  return a3(a2);
}

//----- (00000000000390D5) ----------------------------------------------------
signed __int64 __fastcall sub_390D5(__int64 a1)
{
  *(_DWORD *)(a1 + 216) = 4;
  sub_1A11E();
  return sub_2FA77();
}

//----- (000000000003910F) ----------------------------------------------------
__int64 __fastcall sub_3910F(_QWORD *a1)
{
  _QWORD *v1; // rsi
  __int64 v2; // rcx

  v1 = a1;
  sub_1A11E();
  if ( v1[24] )
  {
    if ( v1[40] )
      sub_39194((__int64)v1, 1);
    v2 = v1[39];
    if ( v2 )
      sub_275C4(v2, 0);
    sub_392BD(v1, -1);
  }
  else
  {
    sub_1A11E();
  }
  return 0i64;
}

//----- (0000000000039194) ----------------------------------------------------
void __fastcall sub_39194(__int64 a1, char a2)
{
  char v2; // bl
  __int64 v3; // r14
  __int64 v4; // rcx
  bool v5; // al
  unsigned int v6; // edx
  __int64 v7; // rcx
  __int64 v8; // rbx
  signed int v9; // esi
  bool v10; // sf

  if ( *(_QWORD *)(a1 + 320) )
  {
    v2 = a2;
    v3 = a1;
    sub_39381(a1);
    v4 = *(_QWORD *)(v3 + 320);
    if ( *(_BYTE *)(v4 + 225) && !*(_BYTE *)(v4 + 168) )
      v5 = *(_QWORD *)(v4 + 80) != 0i64;
    else
      v5 = 0;
    if ( v5 == v2 )
    {
      sub_1A11E();
    }
    else
    {
      sub_27500(v4, 0xFFu);
      v7 = *(_QWORD *)(v3 + 320);
      if ( v2 )
      {
        LOBYTE(v6) = 1;
        sub_275C4(v7, v6);
        v8 = *(_QWORD *)(v3 + 320);
        if ( !*(_QWORD *)(v8 + 80) )
        {
          sub_3F340(*(_QWORD *)(v3 + 32), *(_QWORD *)(v3 + 320));
          v8 = *(_QWORD *)(v3 + 320);
        }
        v9 = 255;
        do
        {
          sub_27500(v8, v9);
          sub_2FB5E(
            *(_QWORD **)(v3 + 32),
            (unsigned __int64)(0x3E8 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 4);
          v10 = v9 - 52 < 0;
          v9 -= 52;
          v8 = *(_QWORD *)(v3 + 320);
        }
        while ( !v10 );
        sub_27500(*(_QWORD *)(v3 + 320), 0);
      }
      else
      {
        sub_275C4(v7, 0);
      }
      sub_38C1B(v3);
    }
  }
  else
  {
    sub_1A11E();
  }
}

//----- (00000000000392BD) ----------------------------------------------------
void __fastcall sub_392BD(_QWORD *a1, int a2)
{
  int v2; // edi
  _QWORD *v3; // rsi
  __int64 v4; // rdx
  __int64 v5; // rax

  v2 = a2;
  v3 = a1;
  sub_1A11E();
  if ( v2 == -1 && !sub_3941B(v3) )
    goto LABEL_8;
  v4 = v3[50];
  if ( v4 )
  {
    if ( *(_BYTE *)(v4 + 225) )
      goto LABEL_8;
    sub_3F1DC(v3[4], (__int64 *)v4);
    v3[50] = 0i64;
  }
  v5 = sub_3947A((__int64)v3, v2);
  v3[50] = v5;
  if ( v5 )
  {
    sub_39C9F((__int64)v3);
    return;
  }
LABEL_8:
  sub_1A11E();
}

//----- (0000000000039381) ----------------------------------------------------
signed __int64 __fastcall sub_39381(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  int v3; // er8
  __int64 v4; // r9
  __int64 v5; // r9
  signed __int64 result; // rax
  __int64 v7; // [rsp+20h] [rbp-10h]
  __int64 v8; // [rsp+28h] [rbp-8h]

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 320);
  if ( v2 )
  {
    v3 = *(_DWORD *)(v1 + 232);
    v4 = *(_QWORD *)(v2 + 44);
    v8 = *(_QWORD *)(v2 + 52);
    v7 = v4;
    v5 = *(_QWORD *)(v1 + 32);
    LODWORD(v7) = *(_DWORD *)(v5 + 12) / 2 - *(_DWORD *)(v2 + 56) / 2;
    HIDWORD(v7) = *(_DWORD *)(v5 + 8) - 129 * v3 - *(_DWORD *)(v2 + 52);
    result = sub_27402((_DWORD *)v2, &v7);
  }
  else
  {
    sub_1A11E();
    result = 0i64;
  }
  return result;
}

//----- (000000000003941B) ----------------------------------------------------
bool __fastcall sub_3941B(_QWORD *a1)
{
  __int64 v1; // rdx
  bool result; // al
  __int64 v3; // rcx

  v1 = a1[24];
  if ( v1 )
  {
    result = 1;
    if ( !a1[9] && !a1[10] )
    {
      v3 = *(_QWORD *)(v1 + 64);
      if ( !*(_QWORD *)(v3 + 56) && !*(_QWORD *)(v3 + 72) )
        result = *(_BYTE *)(v1 + 58) != 0;
    }
  }
  else
  {
    sub_1A11E();
    result = 0;
  }
  return result;
}

//----- (000000000003947A) ----------------------------------------------------
__int64 __fastcall sub_3947A(__int64 a1, int a2)
{
  int v2; // ebx
  __int64 v3; // r12
  __int64 v4; // rax
  __int64 v5; // r15
  int v6; // edx
  signed __int64 v7; // r13
  signed __int64 v8; // r8
  unsigned __int64 *v9; // rcx
  unsigned __int64 *v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rbx
  __int64 v13; // rsi
  int v14; // er14
  int v15; // er14
  __int64 v16; // rdi
  __int64 (__fastcall *v17)(__int64, __int64); // r15
  __int64 (__fastcall *v18)(__int64, __int64); // r14
  __int64 v20; // [rsp+20h] [rbp-2B0h]
  __int64 v21; // [rsp+A0h] [rbp-230h]
  __int64 v22; // [rsp+A8h] [rbp-228h]
  __int64 v23; // [rsp+B0h] [rbp-220h]
  __int64 v24; // [rsp+B8h] [rbp-218h]
  __int64 v25; // [rsp+C0h] [rbp-210h]
  __int64 v26; // [rsp+C8h] [rbp-208h]
  __int64 v27; // [rsp+D0h] [rbp-200h]
  __int64 v28; // [rsp+D8h] [rbp-1F8h]
  __int64 v29; // [rsp+E0h] [rbp-1F0h]
  __int64 v30[15]; // [rsp+E8h] [rbp-1E8h]
  __int64 v31; // [rsp+160h] [rbp-170h]
  __int64 v32[16]; // [rsp+168h] [rbp-168h]
  __int64 v33; // [rsp+1E8h] [rbp-E8h]
  unsigned int v34[4]; // [rsp+1F0h] [rbp-E0h]
  __int64 v35; // [rsp+200h] [rbp-D0h]
  __int64 v36; // [rsp+208h] [rbp-C8h]
  int *v37; // [rsp+210h] [rbp-C0h]
  __int64 v38; // [rsp+218h] [rbp-B8h]
  __int64 v39; // [rsp+220h] [rbp-B0h]
  __int64 v40; // [rsp+228h] [rbp-A8h]
  __int64 *v41; // [rsp+230h] [rbp-A0h]
  __int64 v42; // [rsp+238h] [rbp-98h]
  __int64 v43; // [rsp+240h] [rbp-90h]
  __int64 *v44; // [rsp+248h] [rbp-88h]
  __int64 v45; // [rsp+250h] [rbp-80h]
  __int64 v46; // [rsp+258h] [rbp-78h]
  __int64 *v47; // [rsp+260h] [rbp-70h]
  __int64 v48; // [rsp+268h] [rbp-68h]
  signed int v49; // [rsp+270h] [rbp-60h]
  int v50; // [rsp+274h] [rbp-5Ch]
  int v51; // [rsp+278h] [rbp-58h]
  int v52; // [rsp+27Ch] [rbp-54h]
  __int64 v53; // [rsp+280h] [rbp-50h]
  __int64 v54; // [rsp+288h] [rbp-48h]
  __int64 savedregs; // [rsp+2D0h] [rbp+0h]

  v2 = a2;
  v3 = a1;
  sub_1A11E();
  memset(&v29, 0, 0x80ui64);
  memset(&v31, 0, 0x80ui64);
  v54 = 0i64;
  v53 = 0i64;
  v38 = 0i64;
  v39 = 0i64;
  v40 = 0i64;
  v41 = 0i64;
  v42 = 0i64;
  v43 = 0i64;
  v44 = 0i64;
  v45 = 0i64;
  v46 = 0i64;
  v47 = 0i64;
  v48 = 0i64;
  v4 = *(_QWORD *)(v3 + 192);
  v5 = *(_QWORD *)(v4 + 64);
  if ( v4 == *(_QWORD *)(v3 + 72) )
  {
    sub_1A11E();
    v9 = *(unsigned __int64 **)(v3 + 144);
    if ( *(_QWORD *)(v5 + 56) )
    {
      sub_2BE2F(v9, "loginui_master_popmsg_with_hint_title.png", &v29, (unsigned __int64 *)&v31, 0i64, 1);
      LOWORD(v53) = 257;
      v30[0] = *(_QWORD *)(v5 + 56);
      v32[0] = *(_QWORD *)(v5 + 64);
      LODWORD(v7) = 2;
    }
    else
    {
      sub_2BE2F(v9, "loginui_master_popmsg_title.png", &v29, (unsigned __int64 *)&v31, 0i64, 1);
      LOBYTE(v53) = 1;
      LODWORD(v7) = 1;
    }
    goto LABEL_35;
  }
  if ( v4 != *(_QWORD *)(v3 + 80) )
  {
    sub_1A11E();
    if ( v2 == 3 )
    {
      sub_2BE2F(
        *(unsigned __int64 **)(v3 + 144),
        "loginui_popmsg_lockedout.png",
        &v29,
        (unsigned __int64 *)&v31,
        0i64,
        1);
      LOBYTE(v53) = 1;
      LODWORD(v7) = 1;
    }
    else if ( v2 == 2 )
    {
      v6 = *(_DWORD *)(v3 + 584) / 60 + (*(_DWORD *)(v3 + 584) % 60 > 0);
      LODWORD(v7) = 1;
      if ( v6 <= 0 )
        v6 = 1;
      v8 = 60i64;
      if ( v6 < 61 )
        v8 = (unsigned int)v6;
      v28 = 0i64;
      v27 = 0i64;
      v26 = 0i64;
      v25 = 0i64;
      v24 = 0i64;
      v23 = 0i64;
      v22 = 0i64;
      v21 = 0i64;
      sub_18905((unsigned __int64)&v21, (__int64)"loginui_popmsg_backoff_%d.png", v8);
      sub_2BE2F(*(unsigned __int64 **)(v3 + 144), (char *)&v21, &v29, (unsigned __int64 *)&v31, 0i64, 1);
      LOBYTE(v53) = 1;
    }
    else if ( *(_QWORD *)(v5 + 56) )
    {
      sub_2BE2F(
        *(unsigned __int64 **)(v3 + 144),
        "loginui_popmsg_passhint_title.png",
        &v29,
        (unsigned __int64 *)&v31,
        0i64,
        1);
      LOWORD(v53) = 257;
      v30[0] = *(_QWORD *)(v5 + 56);
      v32[0] = *(_QWORD *)(v5 + 64);
      LODWORD(v7) = 2;
    }
    else
    {
      LODWORD(v7) = 0;
    }
    if ( *(_QWORD *)(v3 + 72) || *(_QWORD *)(v3 + 80) || *(_BYTE *)(*(_QWORD *)(v3 + 192) + 58i64) )
    {
      v18 = 0i64;
      sub_2BE2F(
        *(unsigned __int64 **)(v3 + 144),
        "loginui_popmsg_if_you_forgot_title.png",
        &v38,
        (unsigned __int64 *)&v39,
        0i64,
        1);
      if ( *(_QWORD *)(v3 + 72) )
      {
        sub_2BE2F(
          *(unsigned __int64 **)(v3 + 144),
          "loginui_popmsg_reset_with_master_up.png",
          &v40,
          (unsigned __int64 *)&v42,
          0i64,
          1);
        sub_2BE2F(
          *(unsigned __int64 **)(v3 + 144),
          "loginui_popmsg_reset_with_master_down.png",
          &v41,
          (unsigned __int64 *)&v42,
          0i64,
          1);
        v18 = sub_39D2F;
      }
      if ( *(_QWORD *)(v3 + 80) )
      {
        sub_2BE2F(
          *(unsigned __int64 **)(v3 + 144),
          "loginui_popmsg_reset_with_recovery_up.png",
          &v43,
          (unsigned __int64 *)&v45,
          0i64,
          1);
        sub_2BE2F(
          *(unsigned __int64 **)(v3 + 144),
          "loginui_popmsg_reset_with_recovery_down.png",
          &v44,
          (unsigned __int64 *)&v45,
          0i64,
          1);
        v17 = sub_39D59;
      }
      else
      {
        v17 = 0i64;
      }
      if ( *(_BYTE *)(*(_QWORD *)(v3 + 192) + 58i64) )
      {
        sub_1A11E();
        sub_2BE2F(
          *(unsigned __int64 **)(v3 + 144),
          "loginui_reset_with_icloud_up.png",
          &v46,
          (unsigned __int64 *)&v48,
          0i64,
          1);
        sub_2BE2F(
          *(unsigned __int64 **)(v3 + 144),
          "loginui_reset_with_icloud_down.png",
          &v47,
          (unsigned __int64 *)&v48,
          0i64,
          1);
      }
      goto LABEL_39;
    }
LABEL_35:
    v17 = 0i64;
    v18 = 0i64;
    goto LABEL_39;
  }
  sub_1A11E();
  v10 = *(unsigned __int64 **)(v3 + 144);
  if ( *(_QWORD *)(v5 + 56) )
  {
    sub_2BE2F(v10, "loginui_recovery_popmsg_with_hint_title.png", &v29, (unsigned __int64 *)&v31, 0i64, 1);
    LOWORD(v53) = 257;
    v30[0] = *(_QWORD *)(v5 + 56);
    v32[0] = *(_QWORD *)(v5 + 64);
    v7 = 2i64;
  }
  else
  {
    sub_2BE2F(v10, "loginui_recovery_popmsg_title.png", &v29, (unsigned __int64 *)&v31, 0i64, 1);
    LOBYTE(v53) = 1;
    v7 = 1i64;
  }
  if ( !*(_QWORD *)(v5 + 72) )
    goto LABEL_35;
  v11 = *(_QWORD *)(v5 + 88);
  v12 = (unsigned int)v7;
  if ( v11 )
  {
    *(&v29 + (unsigned int)v7) = v11;
    *(&v31 + (unsigned int)v7) = *(_QWORD *)(v5 + 96);
  }
  else
  {
    sub_2BE2F(
      *(unsigned __int64 **)(v3 + 144),
      "loginui_recovery_popmsg_call_apple.png",
      &savedregs + (unsigned int)v7 - 62,
      (unsigned __int64 *)&v31 + (unsigned int)v7,
      0i64,
      1);
  }
  *((_BYTE *)&v53 + (unsigned int)v7) = 1;
  v13 = v7;
  LODWORD(v7) = v7 + 1;
  v14 = *(_DWORD *)(v3 + 232);
  if ( !sub_2BE2F(
          *(unsigned __int64 **)(v3 + 144),
          "loginui_recovery_popmsg_service_records.png",
          &v35,
          (unsigned __int64 *)&v51,
          0i64,
          1) )
  {
    v36 = v13;
    if ( *(_QWORD *)(v5 + 72) )
    {
      v15 = 16 * v14;
      v37 = (int *)(v5 + 80);
      sub_26AF2(&v49, *(_DWORD *)(v5 + 84) + v15 + v52, v51);
      v16 = sub_24103(4 * v50 * (signed __int64)v49);
      sub_26B03(v34, 0, 0, v50, v49);
      sub_2445C(-1, v16, (unsigned int *)&v49, v34);
      sub_F180((char *)&v21, 0, 0x28ui64);
      v33 = 0i64;
      sub_244D1(v16, (__int64)&v49, (int *)v34, v35, &v51, (int *)&v33, 0, (__int64)&v21);
      LODWORD(v33) = v52 + v15 + v33;
      sub_244D1(v16, (__int64)&v49, (int *)v34, *(_QWORD *)(v5 + 72), v37, (int *)&v33, 0, (__int64)&v21);
      v30[v12] = v16;
      v32[v12] = *(_QWORD *)&v49;
      *((_BYTE *)&v53 + v12 + 1) = 1;
      LODWORD(v7) = v36 + 2;
    }
  }
  v17 = 0i64;
  v18 = 0i64;
LABEL_39:
  LODWORD(v20) = v7;
  return sub_39DEA(
           v3,
           (__int64)&v29,
           (__int64)&v31,
           (__int64)&v53,
           v20,
           v38,
           (__int128 *)&v39,
           v40,
           v41,
           (__int64)&v42,
           (__int64)v18,
           v43,
           v44,
           (__int64)&v45,
           (__int64)v17,
           v46,
           v47,
           (__int64)&v48);
}
// 3947A: using guessed type __int64 var_1E8[15];
// 3947A: using guessed type __int64 var_168[16];

//----- (0000000000039C9F) ----------------------------------------------------
signed __int64 __fastcall sub_39C9F(__int64 a1)
{
  __int64 v1; // rsi

  v1 = a1;
  sub_1A11E();
  if ( sub_3F340(*(_QWORD *)(v1 + 32), *(_QWORD *)(v1 + 400)) )
    sub_1A11E();
  sub_3A4BF(v1, 0i64, 1);
  sub_3340E(*(_QWORD *)(v1 + 400), 0, 2, 100);
  return sub_3264C(*(_QWORD *)(v1 + 400));
}

//----- (0000000000039D2F) ----------------------------------------------------
__int64 __fastcall sub_39D2F(__int64 a1, __int64 a2)
{
  sub_2FACD((__int64)sub_390CA, a2, (__int64)sub_3A2B4, (__int64)"_LW_LoginPane_GoTo_MasterPasswordPane");
  return 0i64;
}

//----- (0000000000039D59) ----------------------------------------------------
__int64 __fastcall sub_39D59(__int64 a1, __int64 a2)
{
  sub_2FACD((__int64)sub_390CA, a2, (__int64)sub_3B312, (__int64)"_LW_LoginPane_GoTo_RecoveryPasswordPane");
  return 0i64;
}

//----- (0000000000039D83) ----------------------------------------------------
signed __int64 __fastcall sub_39D83(__int64 a1, _QWORD *a2)
{
  __int64 v2; // rsi

  v2 = (__int64)a2;
  sub_3A409(a2);
  sub_38C1B(v2);
  sub_1A11E();
  *(_DWORD *)(v2 + 216) = 6;
  sub_1A11E();
  return sub_2FA77();
}

//----- (0000000000039DEA) ----------------------------------------------------
__int64 __fastcall sub_39DEA(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int128 a7, __int64 a8, __int64 *a9, __int64 a10, __int64 a11, __int64 a12, __int64 *a13, __int64 a14, __int64 a15, __int64 a16, __int64 *a17, __int64 a18)
{
  __int64 v18; // r12
  __int64 v19; // r13
  __int64 v20; // rsi
  __int64 v21; // r14
  __int64 v22; // r15
  int v23; // eax
  __int64 v24; // rdx
  __int64 v25; // rbx
  __int64 *v26; // rdx
  int v27; // eax
  __int64 v28; // r15
  int v29; // eax
  __int64 v30; // rsi
  __int64 v31; // rax
  int v33; // [rsp+38h] [rbp-5D8h]
  int v34; // [rsp+3Ch] [rbp-5D4h]
  char v35; // [rsp+40h] [rbp-5D0h]
  char v36; // [rsp+48h] [rbp-5C8h]
  char v37; // [rsp+50h] [rbp-5C0h]
  char v38; // [rsp+58h] [rbp-5B8h]
  char v39; // [rsp+60h] [rbp-5B0h]
  char v40; // [rsp+68h] [rbp-5A8h]
  char v41; // [rsp+70h] [rbp-5A0h]
  char v42; // [rsp+78h] [rbp-598h]
  char v43; // [rsp+80h] [rbp-590h]
  int v44; // [rsp+88h] [rbp-588h]
  __int64 v45[16]; // [rsp+90h] [rbp-580h]
  __int64 v46[16]; // [rsp+110h] [rbp-500h]
  __int64 v47[16]; // [rsp+190h] [rbp-480h]
  char v48[16]; // [rsp+210h] [rbp-400h]
  int v49[16]; // [rsp+220h] [rbp-3F0h]
  __int64 v50[16]; // [rsp+260h] [rbp-3B0h]
  __int64 v51[16]; // [rsp+2E0h] [rbp-330h]
  __int64 v52[16]; // [rsp+360h] [rbp-2B0h]
  __int64 v53[16]; // [rsp+3E0h] [rbp-230h]
  __int64 v54[16]; // [rsp+460h] [rbp-1B0h]
  __int64 v55[16]; // [rsp+4E0h] [rbp-130h]
  __int128 v56; // [rsp+560h] [rbp-B0h]
  int v57[18]; // [rsp+570h] [rbp-A0h]
  __int64 v58; // [rsp+5B8h] [rbp-58h]
  char v59[80]; // [rsp+5C0h] [rbp-50h]

  v18 = a4;
  v19 = a3;
  v20 = a2;
  v21 = a1;
  LODWORD(v22) = a5;
  sub_1A11E();
  sub_F180((char *)v54, 0, 0x80ui64);
  sub_F180((char *)v52, 0, 0x80ui64);
  sub_F180((char *)v55, 0, 0x80ui64);
  sub_F180((char *)v53, 0, 0x80ui64);
  sub_F180((char *)v57, 0, 0x40ui64);
  v58 = 0i64;
  sub_F180((char *)&v33, 0, 0x328ui64);
  if ( (signed int)a5 > 0 )
  {
    v23 = 10 * *(_DWORD *)(v21 + 232);
    v24 = 0i64;
    do
    {
      v54[v24] = *(_QWORD *)(v20 + 8 * v24);
      v55[v24] = *(_QWORD *)(v19 + 8 * v24);
      v59[v24] = *(_BYTE *)(v18 + v24);
      v57[v24++] = v23;
    }
    while ( (unsigned int)a5 != v24 );
  }
  v25 = *((_QWORD *)&a7 + 1);
  if ( a6 )
  {
    v26 = (__int64 *)a7;
    v27 = *(_DWORD *)(v21 + 232);
    if ( (_DWORD)a5 )
    {
      *((_DWORD *)&v56 + (signed int)a5 + 3) = 15 * v27;
      v56 = 0ui64;
      sub_2BE2F(
        *(unsigned __int64 **)(v21 + 144),
        "loginui_hint_divider_line.png",
        &v56,
        (unsigned __int64 *)&v56 + 1,
        0i64,
        1);
      v25 = *((_QWORD *)&a7 + 1);
      v26 = (__int64 *)a7;
      v54[(signed int)a5] = v56;
      v55[(signed int)a5] = *((_QWORD *)&v56 + 1);
      v59[(signed int)a5] = 1;
      v27 = *(_DWORD *)(v21 + 232);
      v57[(signed int)a5] = 12 * v27;
      LODWORD(v28) = a5 + 1;
    }
    else
    {
      LODWORD(v28) = 0;
    }
    v22 = (signed int)v28;
    v54[v22] = a6;
    v55[v22] = *v26;
    v59[v22] = 0;
    v57[v22] = 6 * v27;
    LODWORD(v22) = v22 + 1;
  }
  if ( v25 )
  {
    v22 = (signed int)v22;
    v54[v22] = v25;
    v52[v22] = a8;
    v55[v22] = *a9;
    v59[v22] = 0;
    v53[v22] = a10;
    v57[v22] = 3 * *(_DWORD *)(v21 + 232);
    LODWORD(v22) = v22 + 1;
  }
  if ( a11 )
  {
    v22 = (signed int)v22;
    v54[v22] = a11;
    v52[v22] = a12;
    v55[v22] = *a13;
    v59[v22] = 0;
    v53[v22] = a14;
    v57[v22] = 3 * *(_DWORD *)(v21 + 232);
    LODWORD(v22) = v22 + 1;
  }
  if ( a15 )
  {
    v22 = (signed int)v22;
    v54[v22] = a15;
    v52[v22] = a16;
    v55[v22] = *a17;
    v59[v22] = 0;
    v53[v22] = a18;
    v57[v22] = 3 * *(_DWORD *)(v21 + 232);
    LODWORD(v22) = v22 + 1;
  }
  if ( *(_QWORD *)(v21 + 192) == *(_QWORD *)(v21 + 88) )
    v29 = 0;
  else
    v29 = *(_DWORD *)(*(_QWORD *)(v21 + 512) + 44i64)
        + *(_DWORD *)(*(_QWORD *)(v21 + 512) + 56i64) / 2
        - *(_DWORD *)(*(_QWORD *)(v21 + 424) + 44i64)
        - *(_DWORD *)(*(_QWORD *)(v21 + 424) + 56i64) / 2;
  v34 = v29;
  sub_2BE2F(*(unsigned __int64 **)(v21 + 144), "loginui_popover_top.png", &v36, (unsigned __int64 *)&v37, 0i64, 1);
  sub_2BE2F(*(unsigned __int64 **)(v21 + 144), "loginui_popover_tile.png", &v38, (unsigned __int64 *)&v39, 0i64, 1);
  sub_2BE2F(*(unsigned __int64 **)(v21 + 144), "loginui_popover_bottom.png", &v40, (unsigned __int64 *)&v41, 0i64, 1);
  sub_2BE2F(*(unsigned __int64 **)(v21 + 144), "loginui_popover_uparrow.png", &v42, (unsigned __int64 *)&v43, 0i64, 1);
  v33 = 380 * *(_DWORD *)(v21 + 232);
  v44 = v22;
  v35 = 0;
  if ( (signed int)v22 > 0 )
  {
    v30 = 0i64;
    do
    {
      sub_1A11E();
      v45[v30] = v54[v30];
      v46[v30] = v52[v30];
      v47[v30] = v55[v30];
      v48[v30] = v59[v30];
      v49[v30] = v57[v30];
      v31 = v53[v30];
      if ( v31 )
      {
        v50[v30] = v31;
        v51[v30] = v21;
      }
      ++v30;
    }
    while ( (unsigned int)v22 != v30 );
  }
  sub_32250(&v58, &v33);
  return v58;
}
// 39DEA: using guessed type __int64 var_1B0[16];
// 39DEA: using guessed type __int64 var_2B0[16];
// 39DEA: using guessed type __int64 var_130[16];
// 39DEA: using guessed type __int64 var_230[16];
// 39DEA: using guessed type int var_A0[18];
// 39DEA: using guessed type char var_50[80];
// 39DEA: using guessed type __int64 var_580[16];
// 39DEA: using guessed type __int64 var_500[16];
// 39DEA: using guessed type __int64 var_480[16];
// 39DEA: using guessed type char var_400[16];
// 39DEA: using guessed type int var_3F0[16];
// 39DEA: using guessed type __int64 var_3B0[16];
// 39DEA: using guessed type __int64 var_330[16];

//----- (000000000003A2B4) ----------------------------------------------------
signed __int64 __fastcall sub_3A2B4(__int64 a1)
{
  _QWORD *v1; // rsi
  __int64 v2; // rax
  __int64 v3; // rcx
  signed __int64 v4; // rdi
  __int64 v5; // rcx
  unsigned int v6; // edx
  __int64 v8; // [rsp+20h] [rbp-40h]
  __int64 v9; // [rsp+28h] [rbp-38h]
  __int64 v10; // [rsp+30h] [rbp-30h]
  __int64 v11; // [rsp+38h] [rbp-28h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  __int64 v13; // [rsp+48h] [rbp-18h]

  v1 = (_QWORD *)a1;
  *(_DWORD *)(a1 + 184) = 3;
  if ( *(_QWORD *)(a1 + 320) )
    sub_39194(a1, 1);
  if ( v1[9] && (sub_2AE83(v1[52]), (v2 = v1[9]) != 0) )
  {
    v3 = *(_QWORD *)(v2 + 64);
    if ( v3 )
    {
      *(_QWORD *)(v3 + 104) = v1[24];
    }
    else
    {
      sub_1A11E();
      v2 = v1[9];
    }
    v1[24] = v2;
    sub_3A409(v1);
    v5 = v1[33];
    if ( v5 )
      sub_3453F(v5, 1);
    v4 = 0i64;
    sub_3A4BF((__int64)v1, 0i64, 0xFFFF);
    v8 = v1[52];
    v9 = v1[53];
    v10 = v1[64];
    v11 = v1[55];
    v12 = 1i64;
    v13 = 0i64;
    LOBYTE(v6) = 1;
    sub_2B927((__int64)&v8, v6);
    sub_3AFB2((__int64)v1, 1);
    sub_3B080(v1, 0xFFFFFFFF);
    sub_38C1B((__int64)v1);
  }
  else
  {
    sub_1A11E();
    v4 = 1i64;
  }
  return v4;
}

//----- (000000000003A409) ----------------------------------------------------
__int64 __fastcall sub_3A409(_QWORD *a1)
{
  _QWORD *v1; // rsi
  __int64 v3; // [rsp+20h] [rbp-70h]
  __int64 v4; // [rsp+28h] [rbp-68h]
  __int64 v5; // [rsp+30h] [rbp-60h]
  __int64 v6; // [rsp+38h] [rbp-58h]
  __int64 v7; // [rsp+40h] [rbp-50h]
  __int64 v8; // [rsp+48h] [rbp-48h]
  __int64 v9; // [rsp+50h] [rbp-40h]
  __int64 v10; // [rsp+58h] [rbp-38h]
  __int64 v11; // [rsp+60h] [rbp-30h]
  __int64 v12; // [rsp+68h] [rbp-28h]
  __int64 v13; // [rsp+70h] [rbp-20h]

  v1 = a1;
  sub_1A11E();
  v3 = v1[52];
  v4 = v1[53];
  v5 = v1[54];
  v6 = v1[55];
  v7 = v1[59];
  v8 = v1[60];
  v9 = v1[61];
  v10 = v1[50];
  v11 = v1[64];
  v12 = 1i64;
  v13 = 0i64;
  return sub_2B927((__int64)&v3, 0);
}

//----- (000000000003A4BF) ----------------------------------------------------
void __fastcall sub_3A4BF(__int64 a1, _DWORD *a2, int a3)
{
  int v3; // er15
  _DWORD *v4; // rsi
  __int64 v5; // r13
  __int64 v6; // rcx
  __int64 v7; // rax
  int v8; // esi
  int v9; // edi
  int v10; // er14
  int v11; // er12
  int v12; // er8
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rdx
  int v15; // eax
  int v16; // er12
  int v17; // er15
  int v18; // edi
  int v19; // ebx
  signed __int64 v20; // rdi
  __int64 v21; // rcx
  unsigned __int64 v22; // rax
  signed __int64 v23; // rdi
  __int64 v24; // rcx
  __int64 v25; // rdx
  __int64 v26; // rax
  int v27; // eax
  signed __int64 v28; // rdi
  __int64 v29; // rax
  int v30; // er14
  __int64 v31; // rdx
  __int64 v32; // r10
  int v33; // er11
  int v34; // edi
  int v35; // ecx
  int v36; // er12
  __int64 v37; // rbx
  int v38; // er8
  int v39; // edi
  __int64 v40; // rax
  signed int v41; // er15
  int v42; // er14
  int v43; // ecx
  int v44; // esi
  __int64 v45; // r9
  _DWORD *v46; // r8
  __int64 v47; // r9
  _DWORD *v48; // rdx
  _DWORD *v49; // r8
  __int64 v50; // rdi
  _DWORD *v51; // rcx
  _DWORD *v52; // rbx
  signed __int64 v53; // rax
  signed __int64 v54; // r12
  __int64 v55; // rcx
  unsigned __int64 v56; // rax
  signed __int64 v57; // rcx
  _DWORD *v58; // rbx
  __int64 v59; // rcx
  unsigned __int64 v60; // rax
  signed int v61; // er8
  int v62; // esi
  signed __int64 v63; // rdi
  __int64 v64; // rcx
  unsigned __int64 v65; // rax
  signed __int64 v66; // rax
  signed __int64 v67; // rbx
  __int64 v68; // r8
  __int64 v69; // rcx
  unsigned __int64 v70; // rbx
  int v71; // eax
  unsigned __int64 v72; // rax
  signed __int64 v73; // rax
  signed __int64 v74; // rbx
  __int64 v75; // rcx
  int v76; // eax
  unsigned __int64 v77; // rbx
  __int64 v78; // rcx
  signed __int64 v79; // rax
  signed __int64 v80; // rdi
  __int64 v81; // rcx
  unsigned __int64 v82; // rax
  __int64 v83; // rdx
  int v84; // eax
  int v85; // edx
  bool v86; // zf
  bool v87; // sf
  unsigned __int8 v88; // of
  int v89; // eax
  int v90; // edx
  __int64 v91; // rdx
  __int64 v92; // rax
  int v93; // eax
  int v94; // eax
  int v95; // edx
  int v96; // eax
  int v97; // edx
  int v98; // er14
  int v99; // edx
  int v100; // eax
  int v101; // edx
  unsigned int v102; // [rsp+34h] [rbp-7Ch]
  _DWORD *v103; // [rsp+38h] [rbp-78h]
  signed __int64 v104; // [rsp+38h] [rbp-78h]
  __int64 v105; // [rsp+40h] [rbp-70h]
  signed __int64 v106; // [rsp+40h] [rbp-70h]
  int v107; // [rsp+48h] [rbp-68h]
  unsigned __int64 v108; // [rsp+50h] [rbp-60h]
  unsigned __int64 v109; // [rsp+58h] [rbp-58h]
  int v110; // [rsp+64h] [rbp-4Ch]
  unsigned __int64 v111; // [rsp+68h] [rbp-48h]
  __int64 v112; // [rsp+70h] [rbp-40h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  if ( (_WORD)a3 )
  {
    v6 = *(_QWORD *)(a1 + 384);
    if ( v6 )
    {
      v7 = *(_QWORD *)(v5 + 392);
      if ( v7 )
      {
        v103 = a2;
        v8 = a3;
        v9 = *(_DWORD *)(v5 + 232);
        v10 = *(_DWORD *)(*(_QWORD *)(v5 + 32) + 8i64) - 94 * v9;
        v11 = *(_DWORD *)(v5 + 336);
        v12 = 12 * v9;
        v13 = *(_QWORD *)(v6 + 44);
        v112 = *(_QWORD *)(v6 + 52);
        v111 = v13;
        v14 = *(_QWORD *)(v7 + 44);
        v109 = *(_QWORD *)(v7 + 52);
        v108 = v14;
        v15 = v11 - 10 * v9;
        v16 = 10 * v9 + v11;
        v17 = HIDWORD(v109);
        v18 = (HIDWORD(v109) + HIDWORD(v112)) / 2 - 20 * v9;
        if ( v18 > v12 )
        {
          v19 = (v12 + v18) / 2;
          v15 -= v19;
          v16 += v19;
        }
        LODWORD(v111) = v15 - SHIDWORD(v112) / 2;
        HIDWORD(v111) = v10;
        v20 = sub_27402((_DWORD *)v6, &v111);
        if ( v20 )
        {
          sub_1A11E();
          v17 = HIDWORD(v109);
        }
        LODWORD(v108) = v16 - v17 / 2;
        HIDWORD(v108) = v10;
        if ( sub_27402(*(_DWORD **)(v5 + 392), &v108) )
        {
          sub_1A11E();
          v3 = v8;
          v4 = v103;
        }
        else
        {
          v3 = v8;
          v4 = v103;
          if ( !v20 )
          {
LABEL_14:
            v21 = *(_QWORD *)(v5 + 360);
            if ( v21 )
            {
              v22 = *(_QWORD *)(v21 + 44);
              v112 = *(_QWORD *)(v21 + 52);
              v111 = v22;
              LODWORD(v111) = *(_DWORD *)(*(_QWORD *)(v5 + 32) + 12i64)
                            - *(_DWORD *)(v21 + 56)
                            - 4 * *(_DWORD *)(v5 + 232);
              HIDWORD(v111) = 2;
              v23 = sub_27402((_DWORD *)v21, &v111);
            }
            else
            {
              v23 = 0i64;
            }
            v24 = *(_QWORD *)(v5 + 376);
            if ( v24 )
            {
              v25 = *(_QWORD *)(v24 + 52);
              v111 = *(_QWORD *)(v24 + 44);
              v112 = v25;
              HIDWORD(v111) = 2;
              v26 = *(_QWORD *)(v5 + 360);
              if ( v26 && *(_BYTE *)(v26 + 225) )
                v27 = *(_DWORD *)(v26 + 44) - HIDWORD(v112);
              else
                v27 = *(_DWORD *)(*(_QWORD *)(v5 + 32) + 12i64) - HIDWORD(v112) - 4 * *(_DWORD *)(v5 + 232);
              LODWORD(v111) = v27;
              v23 += sub_27402((_DWORD *)v24, &v111);
            }
            if ( v23 )
              sub_1A11E();
            goto LABEL_25;
          }
        }
      }
    }
    sub_1A11E();
    goto LABEL_14;
  }
  if ( !(a3 & 1) )
    return;
LABEL_25:
  if ( *(_QWORD *)(v5 + 424) )
  {
    v28 = 0i64;
  }
  else
  {
    sub_1A11E();
    v28 = 1i64;
  }
  if ( !*(_QWORD *)(v5 + 456) )
  {
    sub_1A11E();
    ++v28;
  }
  if ( !*(_QWORD *)(v5 + 480) )
  {
    sub_1A11E();
    ++v28;
  }
  if ( !*(_QWORD *)(v5 + 432) )
  {
    sub_1A11E();
    ++v28;
  }
  if ( !*(_QWORD *)(v5 + 464) )
  {
    sub_1A11E();
    ++v28;
  }
  if ( !*(_QWORD *)(v5 + 488) )
  {
    sub_1A11E();
    ++v28;
  }
  if ( !*(_QWORD *)(v5 + 416) )
  {
    sub_1A11E();
    ++v28;
  }
  if ( !*(_QWORD *)(v5 + 448) )
  {
    sub_1A11E();
    ++v28;
  }
  if ( !*(_QWORD *)(v5 + 472) )
  {
    sub_1A11E();
    goto LABEL_50;
  }
  if ( v28 )
  {
LABEL_50:
    sub_1A11E();
LABEL_51:
    sub_1A11E();
    goto LABEL_52;
  }
  v110 = v3;
  v29 = *(_QWORD *)(v5 + 32);
  v30 = *(_DWORD *)(v29 + 12) / 2;
  v31 = *(_QWORD *)(v5 + 424);
  v32 = *(_QWORD *)(v31 + 52);
  v33 = v30 - *(_DWORD *)(v31 + 56) / 2;
  v34 = *(_DWORD *)(v29 + 8) / 2 - (signed int)v32 / 2;
  v35 = *(_DWORD *)(v5 + 232);
  v36 = v34 + 8 * v35;
  v37 = *(_QWORD *)(v5 + 456);
  v38 = v30 - *(_DWORD *)(v37 + 56) / 2;
  v39 = v34 - 12 * v35 - *(_DWORD *)(*(_QWORD *)(v5 + 448) + 52i64);
  v40 = *(_QWORD *)(v5 + 480);
  v41 = *(_DWORD *)(v40 + 56);
  v42 = v30 - v41 / 2;
  v105 = *(_QWORD *)(v37 + 52);
  v102 = *(_DWORD *)(v40 + 52);
  if ( v4 )
  {
    v43 = v4[1];
    v33 += *v4;
    v36 += v43;
    v38 += *v4;
    v39 += v43;
    v42 += *v4;
  }
  v44 = v38;
  v45 = *(_QWORD *)(v5 + 416);
  v46 = *(_DWORD **)(v5 + 432);
  v107 = v33;
  v111 = __PAIR__(v36, v33);
  v112 = v32;
  v104 = sub_3B15D(v5, (_DWORD *)v31, v46, v45, &v111);
  v47 = *(_QWORD *)(v5 + 448);
  v48 = *(_DWORD **)(v5 + 456);
  v49 = *(_DWORD **)(v5 + 464);
  v111 = __PAIR__(v39, v44);
  v112 = v105;
  v106 = sub_3B15D(v5, v48, v49, v47, &v111);
  v50 = *(_QWORD *)(v5 + 472);
  v51 = *(_DWORD **)(v5 + 480);
  v52 = *(_DWORD **)(v5 + 488);
  v108 = __PAIR__(v36, v42);
  v109 = __PAIR__(v41, v102);
  if ( v51 )
  {
    v53 = sub_27402(v51, &v108);
    if ( v53 )
    {
      v54 = v53;
      sub_1A11E();
      goto LABEL_77;
    }
  }
  else
  {
    sub_1A11E();
  }
  v54 = 0i64;
LABEL_77:
  LOWORD(v3) = v110;
  if ( v52 )
  {
    v73 = sub_27402(v52, &v108);
    if ( v73 )
    {
      v74 = v73;
      sub_1A11E();
      v54 = v74;
    }
  }
  else
  {
    sub_1A11E();
  }
  if ( v50 )
  {
    v78 = *(_QWORD *)(v50 + 52);
    v111 = *(_QWORD *)(v50 + 44);
    v112 = v78;
    LODWORD(v111) = v108 + 22;
    HIDWORD(v111) = 15 * *(_DWORD *)(v5 + 232) + HIDWORD(v108);
    v79 = sub_27402((_DWORD *)v50, &v111);
    if ( v79 )
    {
      v80 = v79;
      sub_1A11E();
      v54 = v80;
    }
  }
  else
  {
    sub_1A11E();
  }
  v81 = *(_QWORD *)(v5 + 440);
  if ( v81 )
  {
    v82 = *(_QWORD *)(v81 + 44);
    v112 = *(_QWORD *)(v81 + 52);
    v111 = v82;
    v83 = *(_QWORD *)(v5 + 192);
    if ( v83 == *(_QWORD *)(v5 + 88) )
    {
      v92 = *(_QWORD *)(v81 + 80);
      LODWORD(v111) = (*(_DWORD *)(v92 + 12) - HIDWORD(v112)) / 2;
      v93 = (*(_DWORD *)(v92 + 8) - (signed int)v112) / 2;
    }
    else
    {
      if ( *(_DWORD *)(v5 + 184) == 2 )
      {
        v84 = *(_DWORD *)(v5 + 232);
        v85 = 2 * v84;
        v88 = __OFSUB__(v84, 1);
        v86 = v84 == 1;
        v87 = v84 - 1 < 0;
        v89 = 18 * v84;
        v90 = 9 * v85 + 8;
        if ( !((unsigned __int8)(v87 ^ v88) | v86) )
          v90 = v89;
        LODWORD(v111) = v44 - HIDWORD(v112) + v90;
        v91 = *(_QWORD *)(v5 + 448);
      }
      else
      {
        v94 = *(_DWORD *)(v5 + 232);
        if ( v83 == *(_QWORD *)(v5 + 80) )
        {
          v98 = v42 - HIDWORD(v112);
          v99 = 2 * v94;
          v88 = __OFSUB__(v94, 1);
          v86 = v94 == 1;
          v87 = v94 - 1 < 0;
          v100 = 18 * v94;
          v101 = 9 * v99 + 8;
          if ( !((unsigned __int8)(v87 ^ v88) | v86) )
            v101 = v100;
          LODWORD(v111) = v98 + v101;
          v91 = *(_QWORD *)(v5 + 480);
        }
        else
        {
          v95 = 2 * v94;
          v88 = __OFSUB__(v94, 1);
          v86 = v94 == 1;
          v87 = v94 - 1 < 0;
          v96 = 18 * v94;
          v97 = 9 * v95 + 8;
          if ( !((unsigned __int8)(v87 ^ v88) | v86) )
            v97 = v96;
          LODWORD(v111) = v107 - HIDWORD(v112) + v97;
          v91 = *(_QWORD *)(v5 + 416);
        }
      }
      v93 = *(_DWORD *)(v91 + 48) + (*(_DWORD *)(v91 + 52) - (signed int)v112) / 2;
    }
    HIDWORD(v111) = v93;
    sub_27402((_DWORD *)v81, &v111);
  }
  if ( v54 | v104 | v106 )
    goto LABEL_51;
LABEL_52:
  v55 = *(_QWORD *)(v5 + 400);
  if ( v55 )
  {
    v56 = *(_QWORD *)(v55 + 44);
    v112 = *(_QWORD *)(v55 + 52);
    v111 = v56;
    LODWORD(v111) = *(_DWORD *)(v5 + 336) - SHIDWORD(v112) / 2;
    HIDWORD(v111) = *(_DWORD *)(*(_QWORD *)(v5 + 32) + 8i64) / 2
                  - *(_DWORD *)(*(_QWORD *)(v5 + 424) + 52i64) / 2
                  + 32 * *(_DWORD *)(v5 + 232);
    if ( sub_27402((_DWORD *)v55, &v111) )
      sub_1A11E();
  }
  v57 = 424i64;
  if ( *(_DWORD *)(v5 + 184) == 4 )
    v57 = 480i64;
  v58 = *(_DWORD **)(v5 + v57);
  v59 = *(_QWORD *)(v5 + 504);
  if ( v59 )
  {
    v60 = *(_QWORD *)(v59 + 44);
    v112 = *(_QWORD *)(v59 + 52);
    v111 = v60;
    v61 = *(_DWORD *)(v5 + 232);
    v62 = -18 * v61;
    if ( v61 <= 1 )
      v62 = -8 - 18 * v61;
    LODWORD(v111) = v58[11] + v58[14] + v62;
    HIDWORD(v111) = v58[12] + (v58[13] - *(_DWORD *)(v59 + 52)) / 2;
    v63 = sub_27402((_DWORD *)v59, &v111);
    if ( v63 )
      sub_1A11E();
  }
  else
  {
    v63 = 0i64;
  }
  v64 = *(_QWORD *)(v5 + 512);
  if ( v64 )
  {
    v65 = *(_QWORD *)(v64 + 44);
    v112 = *(_QWORD *)(v64 + 52);
    v111 = v65;
    LODWORD(v111) = v58[14] + v58[11] - *(_DWORD *)(v64 + 56) - 24;
    HIDWORD(v111) = v58[12] + (v58[13] - *(_DWORD *)(v64 + 52)) / 2;
    v66 = sub_27402((_DWORD *)v64, &v111);
    if ( v66 )
    {
      v67 = v66;
      sub_1A11E();
      v63 = v67;
    }
  }
  if ( v63 )
    sub_1A11E();
  if ( (_WORD)v3 )
  {
    v68 = *(_QWORD *)(v5 + 32);
    v69 = *(_QWORD *)(v5 + 256);
    if ( v69 )
    {
      v70 = *(_QWORD *)(v69 + 44);
      v112 = *(_QWORD *)(v69 + 52);
      v111 = v70;
      LODWORD(v111) = *(_DWORD *)(v68 + 12) / 2 - SHIDWORD(v112) / 2;
      v71 = *(_DWORD *)(v68 + 8) / 2 - v112 + 8 * *(_DWORD *)(v5 + 232);
    }
    else
    {
      v69 = *(_QWORD *)(v5 + 264);
      if ( !v69 )
      {
        sub_1A11E();
LABEL_81:
        if ( sub_39381(v5) )
          sub_1A11E();
        v75 = *(_QWORD *)(v5 + 528);
        if ( v75 )
        {
          v76 = 129 * *(_DWORD *)(v5 + 232);
          v77 = *(_QWORD *)(v75 + 44);
          v112 = *(_QWORD *)(v75 + 52);
          v111 = v77;
          LODWORD(v111) = *(_DWORD *)(*(_QWORD *)(v5 + 32) + 12i64) / 2 - *(_DWORD *)(v75 + 56) / 2;
          HIDWORD(v111) = v76;
          sub_27402((_DWORD *)v75, &v111);
        }
        return;
      }
      v72 = *(_QWORD *)(v69 + 44);
      v112 = *(_QWORD *)(v69 + 52);
      v111 = v72;
      LODWORD(v111) = *(_DWORD *)(v68 + 12) / 2 - SHIDWORD(v112) / 2;
      v71 = *(_DWORD *)(v68 + 8) / 2 - v112 + 8 * *(_DWORD *)(v5 + 232);
    }
    HIDWORD(v111) = v71;
    if ( sub_27402((_DWORD *)v69, &v111) )
      sub_1A11E();
    goto LABEL_81;
  }
}

//----- (000000000003AFB2) ----------------------------------------------------
void __fastcall sub_3AFB2(__int64 a1, int a2)
{
  _QWORD *v2; // rsi
  unsigned __int64 *v3; // rcx
  __int64 v4; // rdx
  char *v5; // r8

  v2 = (_QWORD *)a1;
  if ( !a2 )
  {
    sub_2BDBE(*(unsigned __int64 **)(a1 + 144), *(_QWORD *)(a1 + 432), "loginui_password_field.png");
    v3 = (unsigned __int64 *)v2[18];
    v4 = v2[53];
    if ( v2[30] )
      v5 = "loginui_password_field.png";
    else
      v5 = "loginui_password_field_focus.png";
    goto LABEL_12;
  }
  if ( a2 != 2 )
  {
    if ( a2 == 1 )
    {
      sub_2BDBE(*(unsigned __int64 **)(a1 + 144), *(_QWORD *)(a1 + 432), "loginui_masterpassword_field.png");
      v3 = (unsigned __int64 *)v2[18];
      v4 = v2[53];
      if ( v2[30] )
        v5 = "loginui_masterpassword_field.png";
      else
        v5 = "loginui_masterpassword_field_focus.png";
LABEL_12:
      sub_2BDBE(v3, v4, v5);
      return;
    }
    sub_1A11E();
  }
}

//----- (000000000003B080) ----------------------------------------------------
void __fastcall sub_3B080(_QWORD *a1, unsigned int a2)
{
  int v2; // edi
  _QWORD *v3; // rsi
  __int64 v4; // rdx
  __int64 v5; // rax

  v2 = a2;
  v3 = a1;
  sub_1A11E();
  v4 = v3[50];
  if ( v4 && *(_BYTE *)(v4 + 225) )
  {
    sub_3F1DC(v3[4], (__int64 *)v4);
    if ( sub_3941B(v3) )
    {
      sub_3B2A4((__int64)v3, 0);
      v5 = sub_3947A((__int64)v3, v2);
      v3[50] = v5;
      if ( v5 )
        sub_39C9F((__int64)v3);
      else
        sub_1A11E();
    }
    else
    {
      sub_1A11E();
      sub_3B2A4((__int64)v3, 1);
    }
  }
  else
  {
    sub_392BD(v3, -1);
  }
}

//----- (000000000003B15D) ----------------------------------------------------
signed __int64 __fastcall sub_3B15D(__int64 a1, _DWORD *a2, _DWORD *a3, __int64 a4, _DWORD *a5)
{
  __int64 v5; // rsi
  _DWORD *v6; // rdi
  __int64 v7; // r14
  signed __int64 v8; // rax
  signed __int64 v9; // rbx
  signed __int64 v10; // rax
  signed __int64 v11; // rdi
  __int64 v12; // rax
  signed __int64 v13; // rax
  signed __int64 v14; // rsi
  __int64 v16; // [rsp+28h] [rbp-38h]
  __int64 v17; // [rsp+30h] [rbp-30h]

  v5 = a4;
  v6 = a3;
  v7 = a1;
  if ( a2 )
  {
    v8 = sub_27402(a2, a5);
    if ( v8 )
    {
      v9 = v8;
      sub_1A11E();
      goto LABEL_6;
    }
  }
  else
  {
    sub_1A11E();
  }
  v9 = 0i64;
LABEL_6:
  if ( v6 )
  {
    v10 = sub_27402(v6, a5);
    if ( v10 )
    {
      v11 = v10;
      sub_1A11E();
      v9 = v11;
    }
  }
  else
  {
    sub_1A11E();
  }
  if ( v5 )
  {
    v12 = *(_QWORD *)(v5 + 44);
    v17 = *(_QWORD *)(v5 + 52);
    v16 = v12;
    LODWORD(v16) = *a5 + 22;
    HIDWORD(v16) = a5[1] + 15 * *(_DWORD *)(v7 + 232);
    v13 = sub_27402((_DWORD *)v5, &v16);
    if ( v13 )
    {
      v14 = v13;
      sub_1A11E();
      v9 = v14;
    }
  }
  else
  {
    sub_1A11E();
  }
  return v9;
}

//----- (000000000003B2A4) ----------------------------------------------------
signed __int64 __fastcall sub_3B2A4(__int64 a1, char a2)
{
  char v2; // bl
  __int64 v3; // rsi
  signed __int64 result; // rax

  if ( *(_QWORD *)(a1 + 400) )
  {
    v2 = a2;
    v3 = a1;
    sub_1A11E();
    sub_27500(*(_QWORD *)(v3 + 400), 0xFFu);
    if ( v2 )
      sub_38C1B(v3);
    result = sub_3F1DC(*(_QWORD *)(v3 + 32), *(__int64 **)(v3 + 400));
    *(_QWORD *)(v3 + 400) = 0i64;
  }
  return result;
}

//----- (000000000003B312) ----------------------------------------------------
signed __int64 __fastcall sub_3B312(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rcx
  signed __int64 v5; // rdi
  unsigned int v6; // edx
  __int64 v8; // [rsp+20h] [rbp-90h]
  __int64 v9; // [rsp+28h] [rbp-88h]
  __int64 v10; // [rsp+30h] [rbp-80h]
  __int64 v11; // [rsp+38h] [rbp-78h]
  __int64 v12; // [rsp+40h] [rbp-70h]
  __int64 v13; // [rsp+48h] [rbp-68h]
  __int64 v14; // [rsp+50h] [rbp-60h]
  __int64 v15; // [rsp+60h] [rbp-50h]
  __int64 v16; // [rsp+68h] [rbp-48h]
  __int64 v17; // [rsp+70h] [rbp-40h]
  __int64 v18; // [rsp+78h] [rbp-38h]
  __int64 v19; // [rsp+80h] [rbp-30h]

  v1 = a1;
  sub_1A11E();
  v2 = sub_342D0(*(_QWORD *)(v1 + 536));
  if ( v2 )
    *(_QWORD *)(v2 + 40) = sub_3B51B;
  *(_DWORD *)(v1 + 184) = 4;
  v3 = *(_QWORD *)(v1 + 80);
  if ( v3 )
  {
    v4 = *(_QWORD *)(v3 + 64);
    if ( v4 )
    {
      *(_QWORD *)(v4 + 104) = *(_QWORD *)(v1 + 192);
    }
    else
    {
      sub_1A11E();
      v3 = *(_QWORD *)(v1 + 80);
    }
    *(_QWORD *)(v1 + 192) = v3;
    sub_2AE83(*(_QWORD *)(v1 + 416));
    sub_2AE83(*(_QWORD *)(v1 + 472));
    sub_3A409((_QWORD *)v1);
    if ( *(_QWORD *)(v1 + 264) )
    {
      sub_1A11E();
      sub_3453F(*(_QWORD *)(v1 + 264), 1);
    }
    v5 = 0i64;
    sub_3A4BF(v1, 0i64, 0xFFFF);
    v8 = *(_QWORD *)(v1 + 472);
    v9 = *(_QWORD *)(v1 + 480);
    v10 = *(_QWORD *)(v1 + 488);
    v11 = *(_QWORD *)(v1 + 512);
    v12 = *(_QWORD *)(v1 + 440);
    v13 = 1i64;
    v14 = 0i64;
    LOBYTE(v6) = 1;
    sub_2B927((__int64)&v8, v6);
    sub_27500(*(_QWORD *)(v1 + 488), 0);
    sub_27500(*(_QWORD *)(v1 + 480), 0);
    sub_27500(*(_QWORD *)(v1 + 472), 0);
    v15 = *(_QWORD *)(v1 + 432);
    v16 = *(_QWORD *)(v1 + 424);
    v17 = *(_QWORD *)(v1 + 416);
    v18 = 1i64;
    v19 = 0i64;
    sub_2B927((__int64)&v15, 0);
    sub_2B3C8(*(_QWORD *)(v1 + 472), 1);
    sub_3B2A4(v1, 0);
    sub_38C1B(v1);
  }
  else
  {
    sub_1A11E();
    v5 = 1i64;
  }
  return v5;
}

//----- (000000000003B51B) ----------------------------------------------------
__int64 __fastcall sub_3B51B(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rsi

  v1 = a1;
  sub_1A11E();
  v2 = *(_QWORD *)(v1 + 168);
  if ( *(_QWORD *)(v2 + 320) )
    sub_39194(v2, 1);
  sub_3B583(v2, *(_QWORD **)(v2 + 472), *(_QWORD *)(v2 + 480), *(_QWORD *)(v2 + 488));
  return 0i64;
}

//----- (000000000003B583) ----------------------------------------------------
__int64 __fastcall sub_3B583(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r15
  __int64 v5; // rdi
  _QWORD *v6; // r14
  __int64 v7; // rsi
  unsigned int v8; // edx
  __int64 v9; // rbx
  __int64 v10; // r13
  __int64 v11; // rax
  __int64 v12; // rdx
  __int64 (__fastcall *v13)(__int64, __int64, __int64, int *); // rdi
  __int64 v14; // r12
  unsigned int v15; // ebx
  unsigned int v16; // er8
  unsigned int v17; // er8
  __int64 v18; // rcx
  char v19; // bl
  signed __int64 v20; // rbx
  int v21; // eax
  unsigned int v22; // edx
  __int64 v24; // [rsp+20h] [rbp-50h]
  __int64 v25; // [rsp+28h] [rbp-48h]
  int v26; // [rsp+34h] [rbp-3Ch]

  if ( a1 )
  {
    v4 = a4;
    v5 = a3;
    v6 = a2;
    v7 = a1;
    sub_365CA(*(_QWORD *)(a1 + 504), 3);
    sub_3B2A4(v7, 1);
    sub_367A3(v7);
    sub_27500(v5, 0);
    sub_27500(v4, 0);
    sub_275C4(v5, 0);
    LOBYTE(v8) = 1;
    sub_275C4(v4, v8);
    sub_2B3C8((__int64)v6, 0);
    sub_2B3F3(v6, 0);
    sub_275C4(*(_QWORD *)(v7 + 504), 0);
    sub_38C1B(v7);
    v9 = sub_2B417((__int64)v6);
    v10 = sub_2B42C((__int64)v6);
    v11 = sub_2B441((__int64)v6);
    ++*(_DWORD *)(v7 + 496);
    v26 = 0;
    v12 = *(_QWORD *)(v7 + 192);
    if ( v12 )
    {
      v25 = v5;
      v13 = *(__int64 (__fastcall **)(__int64, __int64, __int64, int *))(v7 + 104);
      if ( v13 )
      {
        v14 = v11;
        v15 = v13(v7, v12, v9, &v26);
        if ( v15 == 1 )
        {
          v15 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, int *))(v7 + 104))(
                  v7,
                  *(_QWORD *)(v7 + 192),
                  v10,
                  &v26);
          if ( v15 == 1 )
            v15 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, int *))(v7 + 104))(
                    v7,
                    *(_QWORD *)(v7 + 192),
                    v14,
                    &v26);
        }
        if ( !v15 )
        {
          if ( *(_DWORD *)(v7 + 184) == 2 )
            sub_3B93D(v7, 3);
          *(_DWORD *)(v7 + 216) = 1;
          sub_1A11E();
          sub_2FA77();
          LOBYTE(v15) = 1;
          goto LABEL_28;
        }
        v5 = v25;
        if ( (v15 | 1) == 3 )
        {
          sub_3BADA(v7);
          sub_2AE83((__int64)v6);
          if ( v15 == 2 )
          {
            *(_DWORD *)(v7 + 584) = v26;
            sub_3BB78(v7);
            if ( *(_DWORD *)(v7 + 184) == 2 )
            {
              v18 = v7;
              LOBYTE(v17) = 6;
LABEL_35:
              sub_3BBC7(v18, 0i64, v17);
              goto LABEL_36;
            }
          }
          else if ( *(_DWORD *)(v7 + 184) == 2 )
          {
            v18 = v7;
            LOBYTE(v17) = 7;
            goto LABEL_35;
          }
LABEL_36:
          sub_392BD((_QWORD *)v7, v15);
          sub_365CA(*(_QWORD *)(v7 + 504), 1);
          v15 = 0;
LABEL_28:
          sub_38C1B(v7);
          return v15;
        }
LABEL_16:
        if ( *(_DWORD *)(v7 + 184) == 2 )
        {
          LOBYTE(v16) = 5;
          sub_3BBC7(v7, "sound_SCREFIAudio.UsernameOrPasswordIncorrect", v16);
        }
        v24 = 0i64;
        if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD))(qword_96CD8 + 320))(qword_92C50, 0i64) < 0 )
        {
          sub_1A11E();
        }
        else
        {
          v19 = (*(__int64 (**)(void))(v24 + 8))();
          sub_1A11E();
          if ( v19 )
          {
LABEL_24:
            sub_3BADA(v7);
            sub_2AB36(v6);
            v21 = *(_DWORD *)(v7 + 184);
            if ( v21 == 1 && *(_DWORD *)(v7 + 496) > 2 || (unsigned int)(v21 - 3) <= 1 )
              sub_3910F((_QWORD *)v7);
            sub_365CA(*(_QWORD *)(v7 + 504), 1);
            LOBYTE(v22) = 1;
            sub_275C4(v5, v22);
            v15 = 0;
            sub_275C4(v4, 0);
            sub_2B3C8((__int64)v6, 1);
            sub_2B3F3(v6, 1);
            goto LABEL_28;
          }
        }
        v20 = *(signed int *)(v7 + 496);
        if ( v20 >= 6 )
        {
          sub_1A11E();
          sub_2FB24(500 * (v20 - 5));
        }
        goto LABEL_24;
      }
      v5 = v25;
    }
    sub_1A11E();
    goto LABEL_16;
  }
  sub_1A11E();
  return 0;
}
// 92C50: using guessed type __int64 qword_92C50[2];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003B93D) ----------------------------------------------------
void __fastcall sub_3B93D(__int64 a1, int a2)
{
  int v2; // er14
  __int64 v3; // rdi
  char v4; // al
  signed __int64 v5; // rbx
  signed __int64 v6; // rsi
  __int64 v7; // rcx
  void (__fastcall *v8)(__int64, _QWORD, signed __int64, signed __int64, _QWORD); // rax
  void (__fastcall **v9)(signed __int64, _QWORD, signed __int64); // [rsp+28h] [rbp-28h]

  v2 = a2;
  v3 = a1;
  v9 = 0i64;
  if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD))(qword_96CD8 + 320))(qword_92B80, 0i64) )
  {
    if ( !*(_QWORD *)(v3 + 624) )
    {
      sub_1A11E();
      if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64))(qword_96CD8 + 320))(qword_93640, 0i64, v3 + 624) )
      {
LABEL_13:
        sub_1A11E();
        return;
      }
    }
  }
  else
  {
    sub_1A11E();
  }
  v4 = sub_35204();
  v5 = 200000i64;
  if ( !v4 )
    v5 = 200i64;
  v6 = 150000i64;
  if ( !v4 )
    v6 = 150i64;
  if ( v9 && *v9 )
  {
    sub_1A11E();
    (*v9)(1i64, 0i64, 400i64);
    if ( !((__int64 (__fastcall *)(_QWORD, signed __int64, signed __int64))*v9)(v2, v5, v6) )
      return;
    goto LABEL_13;
  }
  if ( *(_QWORD *)(v3 + 624) )
  {
    sub_1A11E();
    v7 = *(_QWORD *)(v3 + 624);
    v8 = *(void (__fastcall **)(__int64, _QWORD, signed __int64, signed __int64, _QWORD))(v7 + 24);
    if ( v8 )
      v8(v7, v2, v5, v6, 0i64);
    else
      sub_1A11E();
  }
}
// 92B80: using guessed type __int64 qword_92B80[2];
// 93640: using guessed type __int64 qword_93640[2];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003BADA) ----------------------------------------------------
signed __int64 __fastcall sub_3BADA(__int64 a1)
{
  __int64 v1; // rsi
  unsigned __int64 v2; // rbx
  signed __int64 result; // rax
  __int64 v4; // [rsp+20h] [rbp-60h]
  __int64 v5; // [rsp+28h] [rbp-58h]
  __int64 v6; // [rsp+30h] [rbp-50h]
  __int64 v7; // [rsp+38h] [rbp-48h]
  __int64 v8; // [rsp+40h] [rbp-40h]
  __int64 v9; // [rsp+48h] [rbp-38h]
  __int64 v10; // [rsp+50h] [rbp-30h]
  __int64 v11; // [rsp+58h] [rbp-28h]

  v1 = a1;
  v10 = 4293967296i64;
  v8 = 4294967283i64;
  v7 = 13i64;
  v6 = 4294967283i64;
  v5 = 13i64;
  v4 = 4294967283i64;
  v9 = 0i64;
  v2 = 0i64;
  do
  {
    result = *(&v4 + v2);
    v11 = result;
    if ( (signed int)result < -999999 )
      break;
    ++v2;
    sub_3A4BF(v1, &v11, 0xFFFF);
    result = sub_2FB5E(
               *(_QWORD **)(v1 + 32),
               (unsigned __int64)(0x3E8 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 4);
  }
  while ( v2 < 0x64 );
  return result;
}

//----- (000000000003BB78) ----------------------------------------------------
void __fastcall sub_3BB78(__int64 a1)
{
  __int64 v1; // rsi

  v1 = a1;
  sub_367A3(a1);
  *(_QWORD *)(v1 + 576) = sub_359AF((__int64)sub_3BF44, v1, 30000000i64, 1u);
  sub_1A11E();
}

//----- (000000000003BBC7) ----------------------------------------------------
char __fastcall sub_3BBC7(__int64 a1, char *a2, unsigned int a3)
{
  unsigned int v3; // ebx
  char *v4; // r15
  __int64 v5; // rdi
  char v6; // si
  __int64 v7; // rcx
  __int64 v8; // rsi
  char result; // al
  _QWORD *v10; // r14
  unsigned __int64 *v11; // rax
  unsigned __int64 *v12; // r12
  bool v13; // cl
  unsigned __int64 **v14; // rbx
  unsigned __int64 *v15; // rcx
  __int64 v16; // rax
  unsigned __int64 v17; // rdx
  _QWORD *v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rbx
  __int64 v21; // [rsp+30h] [rbp-40h]
  __int64 v22; // [rsp+38h] [rbp-38h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = a3;
  sub_1A11E();
  if ( !v6 )
  {
    if ( !v4 )
      goto LABEL_6;
    goto LABEL_17;
  }
  v7 = *(_QWORD *)(v5 + 616);
  if ( v7 )
  {
LABEL_3:
    v8 = (*(__int64 (__fastcall **)(__int64, _QWORD))(v7 + 8))(v7, v3);
    if ( v8 < 0 )
      sub_1A11E();
LABEL_14:
    v13 = v8 == 0;
    goto LABEL_15;
  }
  v10 = (_QWORD *)(v5 + 616);
  sub_1A11E();
  v8 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64))(qword_96CD8 + 320))(qword_93630, 0i64, v5 + 616);
  if ( v8 >= 0 )
  {
    v11 = sub_348ED(*(unsigned __int64 ***)(v5 + 224));
    if ( v11 )
    {
      v12 = v11;
      sub_1A11E();
      v8 = (*(__int64 (__fastcall **)(_QWORD, unsigned __int64 *))(*v10 + 24i64))(*v10, v12);
      if ( v8 < 0 )
        sub_1A11E();
    }
    else
    {
      sub_1A11E();
    }
    v7 = *v10;
    if ( !*v10 )
      goto LABEL_14;
    goto LABEL_3;
  }
  sub_1A11E();
  v13 = 0;
LABEL_15:
  result = 1;
  if ( !v13 && v4 )
  {
LABEL_17:
    if ( !*(_QWORD *)(v5 + 632) )
      *(_QWORD *)(v5 + 632) = sub_24136(80i64);
    if ( !*(_QWORD *)(v5 + 624) )
    {
      sub_1A11E();
      if ( (*(__int64 (__fastcall **)(__int64 *, _QWORD, __int64))(qword_96CD8 + 320))(qword_93640, 0i64, v5 + 624) < 0 )
        goto LABEL_41;
    }
    v14 = (unsigned __int64 **)(v5 + 176);
    if ( !*(_QWORD *)(v5 + 176) )
    {
      sub_1A11E();
      if ( sub_2C1A0(*(_QWORD *)(v5 + 40), L"sound.efires", (_QWORD *)(v5 + 176)) )
      {
        sub_1A11E();
        *v14 = 0i64;
        return 0;
      }
    }
    if ( !*(_QWORD *)(v5 + 624) )
      return 0;
    v15 = *v14;
    if ( !*v14 )
      return 0;
    v21 = 0i64;
    v22 = 0i64;
    if ( sub_2C719(v15, v4, 0, (char **)&v21, (unsigned __int64 *)&v22, 0) < 0 )
    {
LABEL_41:
      sub_1A11E();
      return 0;
    }
    if ( *(_BYTE *)(v5 + 640) )
    {
      v16 = *(_QWORD *)(v5 + 632);
      v17 = 0i64;
      v18 = *(_QWORD **)(v5 + 632);
      do
      {
        if ( !*v18 )
        {
          *v18 = v21;
          v18[1] = v22;
          goto LABEL_6;
        }
        ++v17;
        v18 += 2;
      }
      while ( v17 < 5 );
      v19 = 0i64;
      do
      {
        v20 = *(_QWORD *)(v16 + v19 + 24);
        *(_QWORD *)(v16 + v19) = *(_QWORD *)(v16 + v19 + 16);
        *(_QWORD *)(v16 + v19 + 8) = v20;
        v19 += 16i64;
      }
      while ( v19 != 64 );
      *(_QWORD *)(v16 + 64) = v21;
      *(_QWORD *)(v16 + 72) = v22;
    }
    else
    {
      sub_3BFBC(v5, v21, v22);
    }
LABEL_6:
    result = 1;
  }
  return result;
}
// 41964: using guessed type __int16 aSoundEfires[13];
// 93630: using guessed type __int64 qword_93630[2];
// 93640: using guessed type __int64 qword_93640[2];
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003BF44) ----------------------------------------------------
void __fastcall sub_3BF44(__int64 a1, __int64 a2)
{
  __int64 *v2; // rsi
  bool v3; // zf
  bool v4; // sf
  unsigned __int8 v5; // of
  unsigned int v6; // edx

  v2 = (__int64 *)a2;
  v5 = __OFADD__(-3, *(_DWORD *)(a2 + 584));
  v3 = *(_DWORD *)(a2 + 584) == 3;
  v4 = *(_DWORD *)(a2 + 584) - 3 < 0;
  *(_DWORD *)(a2 + 584) -= 3;
  if ( (unsigned __int8)(v4 ^ v5) | v3 )
  {
    sub_367A3(a2);
    sub_3B2A4((__int64)v2, 1);
    LOBYTE(v6) = 1;
    sub_275C4(v2[53], v6);
    sub_275C4(v2[54], 0);
    sub_2B3C8(v2[52], 1);
    sub_2B3F3((_QWORD *)v2[52], 1);
  }
  else
  {
    sub_3B080((_QWORD *)a2, 2u);
  }
}

//----- (000000000003BFBC) ----------------------------------------------------
__int64 __fastcall sub_3BFBC(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rsi
  __int64 result; // rax
  __int64 v7; // [rsp+28h] [rbp-28h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v7 = 0i64;
  (*(void (__fastcall **)(signed __int64, signed __int64, __int64 *(__fastcall *)(__int64, __int64), __int64, __int64 *, _QWORD))(qword_96CD8 + 80))(
    512i64,
    8i64,
    sub_3C045,
    a1,
    &v7,
    0i64);
  sub_1A11E();
  result = (*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64 *))(*(_QWORD *)(v5 + 624) + 32i64))(
             *(_QWORD *)(v5 + 624),
             v4,
             v3,
             &v7);
  if ( !result )
    *(_BYTE *)(v5 + 640) = 1;
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003C045) ----------------------------------------------------
__int64 *__fastcall sub_3C045(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 *result; // rax
  __int64 v4; // rcx
  __int64 v5; // rsi

  v2 = a2;
  sub_1A11E();
  *(_BYTE *)(v2 + 640) = 0;
  result = *(__int64 **)(v2 + 632);
  if ( *result )
  {
    sub_3BFBC(v2, *result, result[1]);
    result = *(__int64 **)(v2 + 632);
    v4 = 0i64;
    do
    {
      v5 = result[v4 + 3];
      result[v4] = result[v4 + 2];
      result[v4 + 1] = v5;
      v4 += 2i64;
    }
    while ( v4 != 8 );
    result[8] = 0i64;
    result[9] = 0i64;
  }
  return result;
}

//----- (000000000003C0C2) ----------------------------------------------------
__int64 __fastcall sub_3C0C2(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rax
  __int64 (__fastcall *v3)(_QWORD, _QWORD); // rax

  v1 = a1;
  v2 = sub_342D0(*(_QWORD *)(a1 + 536));
  if ( v2 )
  {
    v3 = *(__int64 (__fastcall **)(_QWORD, _QWORD))(v2 + 40);
    if ( v3 )
      return v3(*(_QWORD *)(v1 + 536), 0i64);
  }
  sub_1A11E();
  return 1i64;
}

//----- (000000000003C11E) ----------------------------------------------------
__int64 __fastcall sub_3C11E(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rax
  __int64 (__fastcall *v3)(_QWORD, _QWORD); // rax

  v1 = a1;
  v2 = sub_342D0(*(_QWORD *)(a1 + 536));
  if ( v2 )
  {
    v3 = *(__int64 (__fastcall **)(_QWORD, _QWORD))(v2 + 32);
    if ( v3 )
      return v3(*(_QWORD *)(v1 + 536), 0i64);
  }
  sub_1A11E();
  return 1i64;
}

//----- (000000000003C17A) ----------------------------------------------------
__int64 __fastcall sub_3C17A(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  bool v4; // bl
  unsigned int v5; // er14
  unsigned int v6; // edx
  __int64 v7; // rdx
  unsigned int v8; // er8
  __int64 v9; // rcx
  unsigned int v11; // er8

  v2 = a2;
  v3 = a1;
  if ( (*(_QWORD *)(a2 + 416) == a1 && (unsigned int)(*(_DWORD *)(a2 + 184) - 1) < 3
     || *(_QWORD *)(a2 + 472) == a1 && *(_DWORD *)(a2 + 184) == 4)
    && a1 )
  {
    v4 = sub_2B456(a1);
    v5 = 0;
    sub_27500(*(_QWORD *)(v2 + 504), 0);
    LOBYTE(v6) = v4 == 0;
    sub_275C4(*(_QWORD *)(v2 + 504), v6);
    if ( v4 )
      v5 = sub_3C279(v2, v7, v8);
    sub_275C4(*(_QWORD *)(v2 + 512), v5);
    v9 = *(_QWORD *)(v2 + 312);
    if ( v9 )
      sub_275C4(v9, 0);
    if ( !v4 )
      sub_3B2A4(v2, 1);
    if ( *(_QWORD *)(v2 + 416) == v3 )
    {
      if ( sub_2B497(v3) )
      {
        if ( *(_DWORD *)(v2 + 184) == 2 )
        {
          LOBYTE(v11) = 62;
          if ( !sub_3BBC7(v2, "sound_SCREFIAudio.Beep", v11) )
            sub_3B93D(v2, 1);
        }
      }
    }
  }
  return 0i64;
}

//----- (000000000003C279) ----------------------------------------------------
__int64 __fastcall sub_3C279(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rsi
  __int64 v4; // rcx
  __int64 v5; // rax
  bool v6; // al
  bool v7; // di
  char v8; // cl
  unsigned int v9; // ebx

  v3 = a1;
  v4 = *(_QWORD *)(a1 + 192);
  if ( v4 )
  {
    v5 = *(_QWORD *)(v4 + 64);
    if ( v5 )
    {
      LOBYTE(a3) = *(_QWORD *)(v5 + 56) != 0i64;
    }
    else
    {
      sub_1A11E();
      v4 = *(_QWORD *)(v3 + 192);
      a3 = 0;
    }
    v6 = *(_DWORD *)(v4 + 20) == 3;
    v7 = v4 == *(_QWORD *)(v3 + 88);
    v8 = *(_BYTE *)(v4 + 58);
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    a3 = 0;
  }
  v9 = 0;
  if ( v6 || v7 )
  {
LABEL_15:
    sub_1A11E();
  }
  else
  {
    v9 = 0;
    switch ( (unsigned __int64)*(unsigned int *)(v3 + 184) )
    {
      case 0ui64:
        goto LABEL_15;
      case 1ui64:
        LOBYTE(v9) = 1;
        if ( !*(_QWORD *)(v3 + 80) && !*(_QWORD *)(v3 + 72) && !v8 )
          v9 = a3;
        goto LABEL_15;
      case 2ui64:
        v9 = 0;
        goto LABEL_15;
      case 3ui64:
        LOBYTE(v9) = 1;
        goto LABEL_15;
      case 4ui64:
        LOBYTE(v9) = 1;
        goto LABEL_15;
      default:
        return v9;
    }
  }
  return v9;
}

//----- (000000000003C3B8) ----------------------------------------------------
signed __int64 __fastcall sub_3C3B8(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  signed __int64 result; // rax

  v2 = a2;
  sub_1A11E();
  if ( v2 )
  {
    sub_34253(*(char **)(v2 + 536));
    sub_2FACD(
      (__int64)sub_390CA,
      v2,
      (__int64)sub_3C6DF,
      (__int64)"_LW_UsersPane_UsersCarouselViewClickCallback_deferred");
    result = 0i64;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}

//----- (000000000003C432) ----------------------------------------------------
__int64 __fastcall sub_3C432(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rcx

  v2 = a2;
  sub_1A11E();
  sub_1A11E();
  *(_DWORD *)(v2 + 184) = 0;
  sub_2B3C8(*(_QWORD *)(v2 + 416), 0);
  if ( !*(_QWORD *)(v2 + 280) )
  {
    sub_2780F((_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 32));
    sub_278C3(*(_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 504));
    sub_278C3(*(_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 512));
    sub_278C3(*(_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 432));
    sub_278C3(*(_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 424));
    sub_278C3(*(_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 416));
    sub_278C3(*(_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 440));
    sub_278C3(*(_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 464));
    sub_278C3(*(_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 456));
    sub_278C3(*(_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 488));
    sub_278C3(*(_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 480));
    sub_278C3(*(_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 472));
    sub_278C3(*(_QWORD *)(v2 + 280), *(_QWORD *)(v2 + 448));
  }
  v3 = *(_QWORD *)(v2 + 400);
  if ( v3 )
    sub_27500(v3, 0xFFu);
  sub_3340E(*(_QWORD *)(v2 + 280), 0xFFu, 2, 200);
  sub_32E34(*(_QWORD *)(v2 + 280), (__int64)sub_3D1FC, v2);
  *(_QWORD *)(v2 + 192) = 0i64;
  return 0i64;
}

//----- (000000000003C5E0) ----------------------------------------------------
signed __int64 __fastcall sub_3C5E0(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  int v3; // eax
  __int64 v4; // rsi
  unsigned int v5; // edx
  __int64 *i; // rdi
  signed __int64 v7; // rdi

  v2 = a2;
  sub_1A11E();
  if ( v2 )
  {
    sub_3A4BF(v2, 0i64, 1);
    v3 = sub_30F3C(*(_QWORD *)(v2 + 256));
    if ( v3 < 0 || v3 >= *(_DWORD *)(v2 + 48) )
    {
      sub_1A11E();
      v7 = -1i64;
    }
    else if ( *(_QWORD *)(*(_QWORD *)(v2 + 56) + 8i64 * v3) == *(_QWORD *)(v2 + 88) )
    {
      v7 = 0i64;
    }
    else
    {
      v4 = sub_3CDB1((__int64 *)v2);
      sub_27500(v4, 0xFFu);
      for ( i = *(__int64 **)(v4 + 216); i; i = (__int64 *)i[3] )
      {
        LOBYTE(v5) = 1;
        sub_275C4(*i, v5);
      }
      v7 = 0i64;
      sub_3340E(v4, 0, 2, 200);
    }
  }
  else
  {
    sub_1A11E();
    v7 = 1i64;
  }
  return v7;
}

//----- (000000000003C6DF) ----------------------------------------------------
signed __int64 __fastcall sub_3C6DF(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rcx
  int v3; // eax
  __int64 *v4; // rax
  __int64 v5; // r9
  __int64 v6; // rcx
  signed __int64 v7; // rdi

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 256);
  if ( v2 )
  {
    *(_DWORD *)(v1 + 184) = 1;
    v3 = sub_30F3C(v2);
    if ( v3 < 0 || v3 >= *(_DWORD *)(v1 + 48) )
    {
      sub_1A11E();
      v7 = -1i64;
    }
    else
    {
      v4 = *(__int64 **)(*(_QWORD *)(v1 + 56) + 8i64 * v3);
      *(_QWORD *)(v1 + 192) = v4;
      v5 = *v4;
      sub_1A11E();
      v6 = *(_QWORD *)(v1 + 312);
      if ( v6 )
      {
        sub_27500(v6, 0xFFu);
        sub_275C4(*(_QWORD *)(v1 + 312), 0);
        sub_38C1B(v1);
      }
      sub_3C7E5(v1, 1, 1);
      *(_DWORD *)(v1 + 496) = 0;
      v7 = sub_38C1B(v1);
    }
  }
  else
  {
    sub_1A11E();
    v7 = 1i64;
  }
  sub_38B4D(v1, *(_QWORD *)(v1 + 192));
  return v7;
}

//----- (000000000003C7E5) ----------------------------------------------------
void __fastcall sub_3C7E5(__int64 a1, char a2, char a3)
{
  char v3; // r15
  char v4; // r14
  __int64 v5; // rsi
  _QWORD *v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rdi
  __int64 (__fastcall *v9)(__int64); // rcx
  unsigned int v10; // edx
  __int64 v11; // rcx
  unsigned int v12; // edx
  __int64 v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rax
  unsigned int v16; // edx
  __int64 v17; // rdx
  unsigned int v18; // er8
  unsigned int v19; // eax
  __int64 v20; // rax
  __int64 v21; // rcx
  char *v22; // rdx
  char *v23; // rdx
  char *v24; // rdx
  __int64 v25; // ST20_8
  __int64 v26; // rax
  __int64 v27; // [rsp+A0h] [rbp-D0h]
  __int64 v28; // [rsp+A8h] [rbp-C8h]
  __int64 v29; // [rsp+B0h] [rbp-C0h]
  __int64 v30; // [rsp+B8h] [rbp-B8h]
  __int64 v31; // [rsp+C0h] [rbp-B0h]
  __int64 v32; // [rsp+C8h] [rbp-A8h]
  __int64 v33; // [rsp+D0h] [rbp-A0h]
  __int64 v34; // [rsp+D8h] [rbp-98h]
  __int64 v35; // [rsp+E0h] [rbp-90h]
  __int64 v36; // [rsp+E8h] [rbp-88h]
  __int64 v37; // [rsp+F0h] [rbp-80h]
  unsigned __int64 v38; // [rsp+F8h] [rbp-78h]
  __int64 v39; // [rsp+100h] [rbp-70h]
  char v40; // [rsp+108h] [rbp-68h]
  __int64 *v41; // [rsp+110h] [rbp-60h]
  char v42; // [rsp+118h] [rbp-58h]
  __int64 v43; // [rsp+120h] [rbp-50h]
  unsigned __int64 v44; // [rsp+128h] [rbp-48h]
  char v45; // [rsp+137h] [rbp-39h]

  v3 = a3;
  v4 = a2;
  v5 = a1;
  sub_1A11E();
  *(_DWORD *)(v5 + 184) = 1;
  sub_3A4BF(v5, 0i64, 0xFFFF);
  sub_34253(*(char **)(v5 + 536));
  v6 = (_QWORD *)sub_342D0(*(_QWORD *)(v5 + 536));
  v7 = *(_QWORD *)(v5 + 88);
  v8 = *(_QWORD *)(v5 + 192);
  if ( v6 )
  {
    v9 = 0i64;
    if ( v8 != v7 )
      v9 = sub_3CCE2;
    v6[5] = v9;
    v6[4] = sub_3CD52;
    v6[7] = sub_3CE33;
    v6[17] = sub_3CED1;
    v6[8] = sub_3CF59;
    v6[9] = sub_3CF9A;
    v6[10] = sub_3D007;
    v6[11] = sub_3D038;
    v6[12] = sub_3D069;
    v6[13] = sub_3D09A;
    v6[14] = sub_3D0D2;
    v6[15] = sub_3D10A;
    v6[16] = sub_3D133;
  }
  sub_3AFB2(v5, 0);
  sub_27500(*(_QWORD *)(v5 + 264), 0xFFu);
  LOBYTE(v10) = 1;
  sub_275C4(*(_QWORD *)(v5 + 264), v10);
  v11 = *(_QWORD *)(v5 + 264);
  if ( v3 )
    sub_3340E(v11, 0, 2, 200);
  else
    sub_27500(v11, 0);
  if ( v8 == v7 )
  {
    LOBYTE(v12) = 1;
    sub_275C4(*(_QWORD *)(v5 + 440), v12);
    v14 = *(_QWORD *)(v5 + 440);
    if ( v3 )
    {
      sub_27500(v14, 0xFFu);
      sub_3340E(*(_QWORD *)(v5 + 440), 0, 2, 200);
    }
    else
    {
      v3 = 0;
      sub_27500(v14, 0);
    }
  }
  else
  {
    v13 = *(_QWORD *)(v5 + 424);
    v27 = *(_QWORD *)(v5 + 424);
    v28 = *(_QWORD *)(v5 + 416);
    v29 = *(_QWORD *)(v5 + 256);
    v30 = 1i64;
    v31 = 0i64;
    if ( v3 && !*(_BYTE *)(v13 + 225) )
    {
      v15 = sub_3CDB1((__int64 *)v5);
      sub_27500(v15, 0xFFu);
    }
    else
    {
      v3 = 0;
    }
    LOBYTE(v12) = 1;
    sub_2B927((__int64)&v27, v12);
    LOBYTE(v16) = *(_DWORD *)(v5 + 48) > 1;
    sub_275C4(*(_QWORD *)(v5 + 440), v16);
  }
  v27 = *(_QWORD *)(v5 + 504);
  v28 = *(_QWORD *)(v5 + 432);
  v29 = *(_QWORD *)(v5 + 480);
  v30 = *(_QWORD *)(v5 + 488);
  v31 = *(_QWORD *)(v5 + 472);
  v32 = *(_QWORD *)(v5 + 456);
  v33 = *(_QWORD *)(v5 + 464);
  v34 = *(_QWORD *)(v5 + 448);
  v35 = 1i64;
  v36 = 0i64;
  sub_2B927((__int64)&v27, 0);
  sub_2B3C8(*(_QWORD *)(v5 + 448), 0);
  sub_2B3C8(*(_QWORD *)(v5 + 472), 0);
  sub_2B3C8(*(_QWORD *)(v5 + 416), 0);
  if ( v4 && v8 != v7 )
    sub_2B2A2(*(_QWORD *)(v5 + 416), 1, 0);
  v19 = sub_3C279(v5, v17, v18);
  sub_275C4(*(_QWORD *)(v5 + 512), v19);
  if ( v8 != v7 && v3 )
  {
    v20 = sub_3CDB1((__int64 *)v5);
    sub_3340E(v20, 0, 2, 200);
  }
  v21 = *(_QWORD *)(v5 + 256);
  if ( v21 )
    sub_306FE(v21);
  if ( v8 == v7 )
  {
    v22 = "loginui_popmsg_guest_warning_msg.png";
    if ( !*(_BYTE *)(v5 + 97) )
      v22 = "loginui_popmsg_guest_info_msg.png";
    v37 = 0i64;
    sub_2BE2F(*(unsigned __int64 **)(v5 + 144), v22, &v37, &v38, 0i64, 1);
    v43 = v37;
    v44 = v38;
    v45 = 1;
    v23 = "loginui_popmsg_guest_warning_button_up.png";
    if ( !*(_BYTE *)(v5 + 97) )
      v23 = "loginui_popmsg_guest_info_button_up.png";
    v39 = 0i64;
    sub_2BE2F(*(unsigned __int64 **)(v5 + 144), v23, &v39, (unsigned __int64 *)&v40, 0i64, 1);
    v24 = "loginui_popmsg_guest_warning_button_down.png";
    if ( !*(_BYTE *)(v5 + 97) )
      v24 = "loginui_popmsg_guest_info_button_down.png";
    v41 = 0i64;
    sub_2BE2F(*(unsigned __int64 **)(v5 + 144), v24, &v41, (unsigned __int64 *)&v42, 0i64, 1);
    LODWORD(v25) = 1;
    v26 = sub_39DEA(
            v5,
            (__int64)&v43,
            (__int64)&v44,
            (__int64)&v45,
            v25,
            0i64,
            0i64,
            v39,
            v41,
            (__int64)&v40,
            (__int64)sub_3D1A5,
            0i64,
            0i64,
            0i64,
            0i64,
            0i64,
            0i64,
            0i64);
    *(_QWORD *)(v5 + 400) = v26;
    if ( v26 )
      sub_39C9F(v5);
    else
      sub_1A11E();
  }
}

//----- (000000000003CCE2) ----------------------------------------------------
__int64 __fastcall sub_3CCE2(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rcx

  v1 = a1;
  sub_1A11E();
  v2 = *(_QWORD *)(v1 + 168);
  if ( v2 )
    sub_3B583(v2, *(_QWORD **)(v2 + 416), *(_QWORD *)(v2 + 424), *(_QWORD *)(v2 + 432));
  else
    sub_1A11E();
  return 0i64;
}

//----- (000000000003CD52) ----------------------------------------------------
__int64 __fastcall sub_3CD52(__int64 a1)
{
  __int64 v1; // rsi

  v1 = *(_QWORD *)(a1 + 168);
  if ( *(_QWORD *)(v1 + 256) )
  {
    sub_367A3(*(_QWORD *)(a1 + 168));
    sub_311B0(*(_QWORD *)(v1 + 256));
    if ( *(_DWORD *)(v1 + 184) == 2 )
      sub_38799(v1, 0);
  }
  else if ( *(_DWORD *)(v1 + 48) == 1 )
  {
    sub_38714(*(_QWORD *)(a1 + 168), 1, 0);
  }
  return 0i64;
}

//----- (000000000003CDB1) ----------------------------------------------------
__int64 __fastcall sub_3CDB1(__int64 *a1)
{
  __int64 result; // rax
  __int64 *v2; // rsi

  result = a1[34];
  if ( !result )
  {
    v2 = a1;
    sub_2780F(a1 + 34, a1[4]);
    sub_278C3(v2[34], v2[53]);
    sub_278C3(v2[34], v2[52]);
    sub_278C3(v2[34], v2[55]);
    sub_278C3(v2[34], v2[64]);
    result = v2[34];
  }
  return result;
}

//----- (000000000003CE33) ----------------------------------------------------
__int64 __fastcall sub_3CE33(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rsi

  v1 = a1;
  sub_1A11E();
  v2 = *(_QWORD *)(v1 + 168);
  sub_367A3(v2);
  if ( *(_DWORD *)(v2 + 184) == 2 )
  {
    if ( *(_QWORD *)(v2 + 256) )
    {
      sub_367A3(v2);
      sub_311B0(*(_QWORD *)(v2 + 256));
      sub_38799(v2, 0);
    }
    else if ( *(_DWORD *)(v2 + 48) == 1 )
    {
      sub_38714(v2, 1, 0);
    }
  }
  else
  {
    sub_38464(v2);
    *(_DWORD *)(v2 + 496) = 0;
    sub_38C1B(v2);
  }
  return 0i64;
}

//----- (000000000003CED1) ----------------------------------------------------
signed __int64 __fastcall sub_3CED1(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  int v3; // eax
  signed __int64 result; // rax
  __int64 v5; // rcx

  if ( a1 && a2 && (v2 = *(_QWORD *)(a1 + 168)) != 0 )
  {
    if ( *(_WORD *)a2 == 32 || *(_WORD *)a2 == 2 )
    {
      if ( *(_BYTE *)(a2 + 4) )
      {
        v3 = sub_2C122();
        sub_2C12E(4 * v3);
      }
      else
      {
        v5 = *(_QWORD *)(v2 + 32);
        sub_2C16A();
      }
    }
    result = 0i64;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}

//----- (000000000003CF59) ----------------------------------------------------
__int64 __fastcall sub_3CF59(__int64 a1)
{
  __int64 v1; // rsi

  v1 = *(_QWORD *)(a1 + 168);
  if ( (unsigned int)sub_BCFC() == 2 )
  {
    sub_BA8B(1u);
    sub_38C1B(v1);
  }
  else
  {
    sub_BA8B(2u);
  }
  return 0i64;
}

//----- (000000000003CF9A) ----------------------------------------------------
__int64 __fastcall sub_3CF9A(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rcx
  __int64 v4; // [rsp+28h] [rbp-18h]

  v1 = *(_QWORD *)(a1 + 168);
  v2 = *(_QWORD *)(v1 + 296);
  if ( v2 )
  {
    sub_275C4(v2, *(_BYTE *)(v2 + 225) == 0);
  }
  else
  {
    v4 = 0i64;
    sub_337EF(&v4, *(_QWORD *)(v1 + 32));
    sub_3F340(*(_QWORD *)(v1 + 32), v4);
    *(_QWORD *)(v1 + 296) = v4;
  }
  sub_38C1B(v1);
  return 0i64;
}

//----- (000000000003D007) ----------------------------------------------------
__int64 __fastcall sub_3D007(__int64 a1)
{
  sub_2FACD((__int64)sub_390CA, *(_QWORD *)(a1 + 168), (__int64)sub_3910F, (__int64)"_LW_LoginPane_ForgotPassword");
  return 0i64;
}

//----- (000000000003D038) ----------------------------------------------------
__int64 __fastcall sub_3D038(__int64 a1)
{
  sub_2FACD((__int64)sub_390CA, *(_QWORD *)(a1 + 168), (__int64)sub_39090, (__int64)"_LW_Shutdown");
  return 0i64;
}

//----- (000000000003D069) ----------------------------------------------------
__int64 __fastcall sub_3D069(__int64 a1)
{
  sub_2FACD((__int64)sub_390CA, *(_QWORD *)(a1 + 168), (__int64)sub_390D5, (__int64)"_LW_Restart");
  return 0i64;
}

//----- (000000000003D09A) ----------------------------------------------------
__int64 __fastcall sub_3D09A(__int64 a1)
{
  __int64 v1; // rdx

  v1 = *(_QWORD *)(a1 + 168);
  if ( *(_QWORD *)(v1 + 72) )
    sub_2FACD((__int64)sub_390CA, v1, (__int64)sub_3A2B4, (__int64)"_LW_LoginPane_GoTo_MasterPasswordPane");
  return 0i64;
}

//----- (000000000003D0D2) ----------------------------------------------------
__int64 __fastcall sub_3D0D2(__int64 a1)
{
  __int64 v1; // rdx

  v1 = *(_QWORD *)(a1 + 168);
  if ( *(_QWORD *)(v1 + 80) )
    sub_2FACD((__int64)sub_390CA, v1, (__int64)sub_3B312, (__int64)"_LW_LoginPane_GoTo_RecoveryPasswordPane");
  return 0i64;
}

//----- (000000000003D10A) ----------------------------------------------------
signed __int64 __fastcall sub_3D10A(__int64 a1)
{
  _QWORD *v1; // rdx
  __int64 v2; // rax
  signed __int64 result; // rax

  v1 = *(_QWORD **)(a1 + 168);
  v2 = v1[24];
  if ( v2 && *(_BYTE *)(v2 + 58) )
    result = sub_39D83(0i64, v1);
  else
    result = 0i64;
  return result;
}

//----- (000000000003D133) ----------------------------------------------------
__int64 __fastcall sub_3D133(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rsi
  signed int v3; // ebx
  unsigned int v4; // edx

  v1 = *(_QWORD *)(a1 + 168);
  v2 = (unsigned __int64)(0x3E8 * (unsigned __int128)0xCCCCCCCCCCCCCCCDui64 >> 64) >> 3;
  v3 = 3;
  do
  {
    sub_275C4(*(_QWORD *)(v1 + 360), 0);
    sub_2FB5E(*(_QWORD **)(v1 + 32), v2);
    LOBYTE(v4) = 1;
    sub_275C4(*(_QWORD *)(v1 + 360), v4);
    sub_2FB5E(*(_QWORD **)(v1 + 32), v2);
    --v3;
  }
  while ( v3 );
  return 0i64;
}

//----- (000000000003D1A5) ----------------------------------------------------
signed __int64 __fastcall sub_3D1A5(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = a2;
  sub_1A11E();
  *(_DWORD *)(v2 + 216) = 3;
  sub_1A11E();
  return sub_2FA77();
}

//----- (000000000003D1FC) ----------------------------------------------------
signed __int64 __fastcall sub_3D1FC(__int64 a1, __int64 *a2)
{
  __int64 *v2; // rsi
  __int64 v3; // rbx
  __int64 *v4; // rdx
  __int64 v6; // [rsp+20h] [rbp-90h]
  __int64 v7; // [rsp+28h] [rbp-88h]
  __int64 v8; // [rsp+30h] [rbp-80h]
  __int64 v9; // [rsp+38h] [rbp-78h]
  __int64 v10; // [rsp+40h] [rbp-70h]
  __int64 v11; // [rsp+48h] [rbp-68h]
  __int64 v12; // [rsp+50h] [rbp-60h]
  __int64 v13; // [rsp+58h] [rbp-58h]
  __int64 v14; // [rsp+60h] [rbp-50h]
  __int64 v15; // [rsp+68h] [rbp-48h]
  __int64 v16; // [rsp+70h] [rbp-40h]
  __int64 v17; // [rsp+78h] [rbp-38h]
  __int64 v18; // [rsp+80h] [rbp-30h]
  __int64 v19; // [rsp+88h] [rbp-28h]
  __int64 v20; // [rsp+90h] [rbp-20h]

  v2 = a2;
  v3 = a1;
  sub_1A11E();
  sub_32E34(v3, 0i64, 0i64);
  v6 = v2[63];
  v7 = v2[64];
  v8 = v2[54];
  v9 = v2[53];
  v10 = v2[52];
  v11 = v2[55];
  v12 = v2[58];
  v13 = v2[57];
  v14 = v2[61];
  v15 = v2[60];
  v16 = v2[59];
  v17 = v2[56];
  v18 = v2[50];
  v19 = 1i64;
  v20 = 0i64;
  sub_2B927((__int64)&v6, 0);
  v4 = (__int64 *)v2[50];
  if ( v4 )
  {
    sub_3F1DC(v2[4], v4);
    v2[50] = 0i64;
  }
  sub_38799((__int64)v2, 0);
  return sub_38C1B((__int64)v2);
}

//----- (000000000003D325) ----------------------------------------------------
signed __int64 __fastcall sub_3D325(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rdi
  __int64 *v3; // rbx
  __int64 v4; // r9
  signed __int64 result; // rax
  __int64 v6; // [rsp+20h] [rbp-30h]
  __int64 v7; // [rsp+28h] [rbp-28h]

  v1 = *(_QWORD *)(a1 + 168);
  v2 = *(_QWORD *)(v1 + 448);
  v3 = (__int64 *)sub_3D64E(
                    *(_DWORD *)(v1 + 48),
                    *(_QWORD *)(v1 + 56),
                    *(_QWORD *)(v1 + 448),
                    (unsigned __int8 (__fastcall *)(_BYTE *, char *, signed __int64))sub_2C02D);
  if ( v3
    || (v6 = *(_QWORD *)(v1 + 72),
        v7 = *(_QWORD *)(v1 + 80),
        (v3 = (__int64 *)sub_3D64E(
                           2,
                           (__int64)&v6,
                           v2,
                           (unsigned __int8 (__fastcall *)(_BYTE *, char *, signed __int64))sub_2C02D)) != 0i64) )
  {
    v4 = *v3;
    sub_1A11E();
    *(_QWORD *)(v1 + 192) = v3;
    result = sub_3D482((_QWORD *)v1, *(_QWORD **)(v1 + 416), 1);
  }
  else
  {
    sub_1A11E();
    *(_QWORD *)(v1 + 192) = 0i64;
    sub_38464(v1);
    result = sub_38C1B(v1);
  }
  return result;
}

//----- (000000000003D402) ----------------------------------------------------
signed __int64 __fastcall sub_3D402(__int64 a1)
{
  _QWORD *v1; // rsi

  v1 = *(_QWORD **)(a1 + 168);
  if ( sub_2B3E0(v1[56]) )
    return sub_3D325(v1[67]);
  if ( sub_2B3E0(v1[52]) )
    return sub_3D482(v1, (_QWORD *)v1[56], 1);
  sub_1A11E();
  return 1i64;
}

//----- (000000000003D482) ----------------------------------------------------
signed __int64 __fastcall sub_3D482(_QWORD *a1, _QWORD *a2, char a3)
{
  char v3; // r14
  _QWORD *v4; // rbx
  _QWORD *v5; // rsi
  __int64 v6; // rdi
  __int64 v7; // rcx
  signed __int64 v8; // rdi
  unsigned int v9; // edx
  unsigned int v10; // edx
  unsigned int v11; // er8
  __int64 v12; // rcx
  int v13; // edx
  unsigned int v14; // edx
  unsigned int v15; // edx
  unsigned int v16; // er8

  v3 = a3;
  v4 = a2;
  v5 = a1;
  sub_2B3F3(a2, 1);
  sub_2B3C8((__int64)v4, 1);
  v6 = sub_342D0(v5[67]);
  v7 = v5[52];
  if ( (_QWORD *)v7 == v4 )
  {
    sub_2B3C8(v5[56], 0);
    sub_27500(v5[58], 0);
    sub_27500(v5[53], 0);
    LOBYTE(v9) = 1;
    sub_275C4(v5[58], v9);
    sub_275C4(v5[57], 0);
    LOBYTE(v10) = 1;
    sub_275C4(v5[53], v10);
    sub_275C4(v5[54], 0);
    if ( v6 )
      *(_QWORD *)(v6 + 40) = sub_3D7CB;
    v8 = sub_38C1B((__int64)v5);
    if ( v3 )
    {
      LOBYTE(v11) = 4;
      if ( !sub_3BBC7((__int64)v5, "sound_SCREFIAudio.Password", v11) )
      {
        v12 = (__int64)v5;
        v13 = 2;
LABEL_14:
        sub_3B93D(v12, v13);
        return v8;
      }
    }
  }
  else
  {
    if ( (_QWORD *)v5[56] != v4 )
    {
      sub_1A11E();
      return 1i64;
    }
    sub_2B3C8(v7, 0);
    sub_27500(v5[57], 0);
    sub_27500(v5[54], 0);
    sub_275C4(v5[58], 0);
    LOBYTE(v14) = 1;
    sub_275C4(v5[57], v14);
    sub_275C4(v5[53], 0);
    LOBYTE(v15) = 1;
    sub_275C4(v5[54], v15);
    if ( v6 )
      *(_QWORD *)(v6 + 40) = sub_3D325;
    v8 = sub_38C1B((__int64)v5);
    if ( v3 )
    {
      LOBYTE(v16) = 3;
      if ( !sub_3BBC7((__int64)v5, "sound_SCREFIAudio.Username", v16) )
      {
        v12 = (__int64)v5;
        v13 = 1;
        goto LABEL_14;
      }
    }
  }
  return v8;
}

//----- (000000000003D64E) ----------------------------------------------------
__int64 __fastcall sub_3D64E(int a1, __int64 a2, __int64 a3, unsigned __int8 (__fastcall *a4)(_BYTE *, char *, signed __int64))
{
  unsigned __int8 (__fastcall *v4)(_BYTE *, char *, signed __int64); // rsi
  __int64 v5; // rbx
  int v6; // er14
  _WORD *v7; // rdi
  _WORD *v8; // r15
  _WORD *v9; // r12
  _BYTE *v10; // rbx
  __int64 v11; // r15
  __int64 v12; // r13
  __int64 v13; // r12
  __int64 v14; // rax
  signed int v15; // ecx
  __int64 v16; // r14
  char v18[1032]; // [rsp+30h] [rbp-460h]
  _BYTE *v19; // [rsp+438h] [rbp-58h]
  _BYTE *v20; // [rsp+440h] [rbp-50h]
  __int64 v21; // [rsp+448h] [rbp-48h]
  __int64 v22; // [rsp+450h] [rbp-40h]

  v4 = a4;
  v5 = a3;
  v21 = a2;
  v6 = a1;
  v7 = (_WORD *)sub_2B417(a3);
  v8 = (_WORD *)sub_2B42C(v5);
  v9 = (_WORD *)sub_2B441(v5);
  v10 = sub_71CF(v7);
  v19 = sub_71CF(v8);
  v20 = sub_71CF(v9);
  sub_1A11E();
  if ( v6 <= 0 )
    return 0i64;
  v22 = v6;
  v11 = 0i64;
  while ( 1 )
  {
    v12 = *(_QWORD *)(v21 + 8 * v11);
    if ( v12 )
    {
      if ( *(_DWORD *)(v12 + 24) > 0 )
        break;
    }
LABEL_12:
    if ( ++v11 >= v22 )
      return 0i64;
  }
  v13 = 0i64;
  while ( 1 )
  {
    v14 = *(_QWORD *)(*(_QWORD *)(v12 + 32) + 8 * v13);
    v15 = *(_DWORD *)(v14 + 8);
    if ( v15 >= 1024 )
      v15 = 1023;
    v16 = v15;
    sub_1B930(v18, *(char **)v14, v15);
    v18[v16] = 0;
    sub_1A11E();
    if ( v4(v10, v18, 1024i64) || v4(v19, v18, 1024i64) || v4(v20, v18, 1024i64) )
      return v12;
    if ( ++v13 >= *(signed int *)(v12 + 24) )
      goto LABEL_12;
  }
}
// 3D64E: using guessed type char var_460[1032];

//----- (000000000003D7CB) ----------------------------------------------------
__int64 __fastcall sub_3D7CB(__int64 a1)
{
  __int64 v1; // rsi

  v1 = *(_QWORD *)(a1 + 168);
  if ( !*(_QWORD *)(v1 + 192) )
    sub_1A11E();
  sub_2B3F3(*(_QWORD **)(v1 + 448), 0);
  sub_2B3F3(*(_QWORD **)(v1 + 416), 0);
  if ( !(unsigned __int8)sub_3B583(v1, *(_QWORD **)(v1 + 416), *(_QWORD *)(v1 + 424), *(_QWORD *)(v1 + 432)) )
  {
    sub_2B3F3(*(_QWORD **)(v1 + 448), 1);
    sub_2B3F3(*(_QWORD **)(v1 + 416), 1);
    sub_3D482((_QWORD *)v1, *(_QWORD **)(v1 + 416), 0);
  }
  return 0i64;
}

//----- (000000000003D871) ----------------------------------------------------
__int64 __fastcall sub_3D871(__int64 a1)
{
  __int64 v1; // rcx
  __int64 result; // rax

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 168) + 256i64);
  if ( v1 )
    result = sub_31187(v1);
  else
    result = 0i64;
  return result;
}

//----- (000000000003D892) ----------------------------------------------------
signed __int64 __fastcall sub_3D892(__int64 a1)
{
  __int64 v1; // rcx
  signed __int64 result; // rax

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 168) + 256i64);
  if ( v1 )
    result = sub_310A2(v1);
  else
    result = 0i64;
  return result;
}

//----- (000000000003D8B3) ----------------------------------------------------
signed __int64 __fastcall sub_3D8B3(__int64 a1)
{
  __int64 v1; // rcx
  signed __int64 result; // rax

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 168) + 256i64);
  if ( v1 )
    result = sub_3110D(v1);
  else
    result = 0i64;
  return result;
}

//----- (000000000003D8D4) ----------------------------------------------------
__int64 __fastcall sub_3D8D4(__int64 a1, __int16 *a2)
{
  __int64 v2; // rsi
  __int16 v3; // r14
  __int16 v4; // bx
  __int64 v5; // rcx
  _DWORD *v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rdi
  __int64 v9; // rbx
  __int64 v10; // rax
  signed int v11; // edi
  __int64 v12; // rcx
  __int64 v14; // [rsp+40h] [rbp-40h]
  __int64 v15; // [rsp+48h] [rbp-38h]
  __int64 v16; // [rsp+50h] [rbp-30h]

  v2 = *(_QWORD *)(a1 + 168);
  v3 = a2[1];
  v4 = *a2;
  v5 = *(_QWORD *)(v2 + 592);
  if ( v5 )
  {
    sub_35A74(v5);
    *(_QWORD *)(v2 + 592) = sub_359AF((__int64)sub_3DAD5, v2, 15000000i64, 0);
  }
  else
  {
    *(_QWORD *)(v2 + 592) = sub_359AF((__int64)sub_3DAD5, v2, 15000000i64, 0);
    v6 = (_DWORD *)sub_38DD0(v2, *(_QWORD *)(v2 + 208), 0i64, 100, 0);
    *(_QWORD *)(v2 + 600) = v6;
    v7 = *(_QWORD *)(v2 + 32);
    v6[12] = *(_DWORD *)(v7 + 8) - 64;
    v6[11] = *(_DWORD *)(v7 + 12) / 2 - v6[14] / 2;
    sub_1A11E();
    sub_275C4(*(_QWORD *)(v2 + 600), 0);
    sub_3F340(*(_QWORD *)(v2 + 32), *(_QWORD *)(v2 + 600));
  }
  *(_BYTE *)(v2 + 608) = 1;
  sub_2AB8E(*(_QWORD *)(v2 + 600), v3, v4);
  v8 = *(_QWORD *)(v2 + 600);
  v9 = sub_3D64E(
         *(_DWORD *)(v2 + 48),
         *(_QWORD *)(v2 + 56),
         *(_QWORD *)(v2 + 600),
         (unsigned __int8 (__fastcall *)(_BYTE *, char *, signed __int64))sub_2C0AB);
  if ( !v9 )
  {
    v14 = *(_QWORD *)(v2 + 72);
    v15 = *(_QWORD *)(v2 + 80);
    v16 = *(_QWORD *)(v2 + 88);
    v9 = sub_3D64E(3, (__int64)&v14, v8, (unsigned __int8 (__fastcall *)(_BYTE *, char *, signed __int64))sub_2C0AB);
  }
  v10 = *(signed int *)(v2 + 48);
  v11 = -1;
  if ( v10 > 0 )
  {
    v12 = 0i64;
    while ( *(_QWORD *)(*(_QWORD *)(v2 + 56) + 8 * v12) != v9 )
    {
      if ( ++v12 >= v10 )
        goto LABEL_12;
    }
    v11 = v12;
  }
LABEL_12:
  sub_2B417(*(_QWORD *)(v2 + 600));
  sub_1A11E();
  *(_BYTE *)(v2 + 608) = 0;
  if ( sub_30F4F(*(_QWORD *)(v2 + 256), v11) )
    sub_1A11E();
  return 0i64;
}

//----- (000000000003DAD5) ----------------------------------------------------
__int64 __fastcall sub_3DAD5(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 result; // rax

  v2 = a2;
  if ( *(_BYTE *)(a2 + 608) )
  {
    sub_1A11E();
    result = sub_359AF((__int64)sub_3DAD5, v2, 2500000i64, 0);
    *(_QWORD *)(v2 + 592) = result;
  }
  else
  {
    sub_1A11E();
    sub_3F1DC(*(_QWORD *)(v2 + 32), *(__int64 **)(v2 + 600));
    *(_QWORD *)(v2 + 592) = 0i64;
    *(_QWORD *)(v2 + 600) = 0i64;
    result = sub_38C1B(v2);
  }
  return result;
}

//----- (000000000003DB6E) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_3DB6E(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rax
  int v4; // edi
  char v5; // bl
  char v6; // al
  char v7; // [rsp+37h] [rbp-19h]

  v2 = a2;
  v3 = *(_QWORD *)(*(_QWORD *)(a2 + 32) + 40i64);
  if ( *(_DWORD *)(a2 + 552) != *(_DWORD *)(v3 + 44) || *(_DWORD *)(a2 + 556) != *(_DWORD *)(v3 + 48) )
  {
    sub_1A11E();
    *(_QWORD *)(v2 + 552) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 40i64) + 44i64);
LABEL_8:
    dword_96A44 = 0;
    return;
  }
  v4 = *(_DWORD *)(a2 + 560);
  if ( v4 != (unsigned int)sub_34247(*(_QWORD *)(a2 + 536)) )
  {
    sub_1A11E();
    *(_DWORD *)(v2 + 560) = sub_34247(*(_QWORD *)(v2 + 536));
    goto LABEL_8;
  }
  if ( ++dword_96A44 <= 14 && byte_96A48 != 1 )
  {
    sub_1A11E();
  }
  else
  {
    sub_1A11E();
    *(_DWORD *)(v2 + 216) = 2;
    sub_1A11E();
    sub_2FA77();
  }
  v7 = 0;
  if ( sub_35036(0x4D534C44u, &v7) )
    sub_1A11E();
  v5 = v7;
  v6 = sub_3518C();
  if ( v5 && v6 )
  {
    if ( byte_96A48 == 1 )
    {
      sub_1A11E();
      *(_DWORD *)(v2 + 216) = 2;
      sub_1A11E();
      sub_2FA77();
    }
    else
    {
      byte_96A48 = 1;
      sub_1A11E();
    }
  }
  else
  {
    byte_96A48 = 0;
  }
}
// 3DBC6: write access to const memory at 96A44 has been detected
// 3DC54: write access to const memory at 96A44 has been detected
// 3DD45: write access to const memory at 96A48 has been detected
// 3DD51: write access to const memory at 96A48 has been detected
// 96A44: using guessed type int dword_96A44;
// 96A48: using guessed type char byte_96A48;

//----- (000000000003DD75) ----------------------------------------------------
void __fastcall sub_3DD75(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  void (__fastcall *v3)(__int64); // rax

  v2 = a2;
  sub_1A11E();
  *(_QWORD *)(v2 + 328) = 0i64;
  if ( *(_QWORD *)(v2 + 320) )
  {
    sub_39194(v2, 0);
    *(_QWORD *)(v2 + 320) = 0i64;
  }
  *(_QWORD *)(v2 + 320) = sub_2BA6A(*(unsigned __int64 **)(v2 + 144), "loginui_recovery_ribbon.png");
  sub_39194(v2, 1);
  sub_1A11E();
  if ( *(_BYTE *)(v2 + 128) )
  {
    sub_1A11E();
  }
  else
  {
    v3 = *(void (__fastcall **)(__int64))(v2 + 120);
    if ( v3 )
    {
      v3(v2);
      *(_BYTE *)(v2 + 128) = 1;
    }
  }
}

//----- (000000000003DE3B) ----------------------------------------------------
signed __int64 __fastcall sub_3DE3B(_QWORD *a1, __int64 a2, _DWORD *a3)
{
  signed __int64 v3; // rsi
  _DWORD *v4; // rdi
  _QWORD *v5; // r13
  signed __int64 v6; // rbx
  __int64 v7; // r14
  unsigned __int64 v8; // rax
  signed int v9; // ebx
  signed int v10; // ecx
  unsigned __int64 v11; // r9
  _QWORD *v12; // rcx
  __int64 v14; // [rsp+30h] [rbp-80h]
  unsigned __int64 v15; // [rsp+40h] [rbp-70h]
  __int64 v16; // [rsp+48h] [rbp-68h]
  int v17; // [rsp+50h] [rbp-60h]
  int v18; // [rsp+54h] [rbp-5Ch]
  __int64 v19; // [rsp+58h] [rbp-58h]
  __int64 v20; // [rsp+60h] [rbp-50h]
  __int64 v21; // [rsp+68h] [rbp-48h]
  _QWORD *v22; // [rsp+70h] [rbp-40h]

  v3 = -9223372036854775806i64;
  v22 = 0i64;
  v21 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  if ( !a1 )
    goto LABEL_17;
  if ( !a2 )
    goto LABEL_17;
  v4 = a3;
  if ( !a3 )
    goto LABEL_17;
  v5 = a1;
  v6 = sub_263BE(&v21, (__int64)&v16, (__int64)&v17, a2);
  if ( (_DWORD)v6 )
    goto LABEL_18;
  v7 = sub_24103(16i64);
  if ( sub_3FBF3() )
  {
    v14 = 0i64;
    v15 = 0i64;
    sub_3FC0B(v21, &v17, &v14, (__int64)&v15);
    v16 *= 4i64;
    v21 = v14;
    v8 = v15;
    *(_QWORD *)&v17 = v15;
    *(_QWORD *)v7 = 47244640267i64;
    v9 = *(_DWORD *)v7;
    v10 = *(_DWORD *)(v7 + 4);
    v11 = v8 >> 32;
  }
  else
  {
    *(_QWORD *)v7 = 17179869188i64;
    LODWORD(v8) = v17;
    LODWORD(v11) = v18;
    v10 = 4;
    v9 = 4;
  }
  sub_26B03(&v14, *v4 - v9, v4[1] - v10, v11, v8);
  v6 = sub_26E4B((__int64 *)&v22, (__int64)&v14);
  if ( (_DWORD)v6 )
    goto LABEL_18;
  if ( !v22 )
  {
    v3 = -9223372036854775799i64;
LABEL_17:
    v6 = v3;
    goto LABEL_18;
  }
  v6 = sub_274E1((__int64)v22, 3u);
  if ( !(_DWORD)v6 )
  {
    v12 = v22;
    v22[2] = v21;
    v21 = 0i64;
    v12[3] = v16;
    v6 = sub_27CFB((__int64 **)&v19);
    if ( !(_DWORD)v6 )
    {
      v6 = (*(__int64 (__fastcall **)(signed __int64, void (__fastcall *)(__int64, __int64), __int64 *, _QWORD *))(v19 + 8))(
             1i64,
             sub_3E084,
             &v20,
             v22);
      if ( !(_DWORD)v6 )
      {
        v15 = *(_QWORD *)v4;
        v6 = (*(__int64 (**)(void))(v19 + 24))();
        if ( !(_DWORD)v6 )
        {
          *(_QWORD *)(v7 + 8) = v20;
          v6 = sub_27643(v22, 0i64, (__int64)sub_3E0E5, 0i64, v7);
          if ( !(_DWORD)v6 )
          {
            v20 = 0i64;
            *v5 = v22;
            v22 = 0i64;
          }
        }
      }
    }
  }
LABEL_18:
  if ( v20 && v19 )
    (*(void (**)(void))(v19 + 16))();
  if ( v22 )
    sub_27054((__int64)v22);
  if ( v21 )
    (*(void (**)(void))(qword_96CD8 + 72))();
  return v6;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003E084) ----------------------------------------------------
void __fastcall sub_3E084(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  _DWORD *v3; // rax
  __int64 v4; // rcx
  int v5; // [rsp+20h] [rbp-10h]
  int v6; // [rsp+24h] [rbp-Ch]

  if ( a2 )
  {
    v2 = a2;
    v3 = *(_DWORD **)(a2 + 160);
    v5 = *(_DWORD *)(a1 + 28) - *v3;
    v6 = *(_DWORD *)(a1 + 32) - v3[1];
    if ( *(_BYTE *)(a1 + 8) )
    {
      if ( (*(_QWORD *)(a1 + 16) & 0x1Fi64) == 1 && !(unsigned int)sub_27219(a2, &v5) )
      {
        v4 = *(_QWORD *)(v2 + 80);
        if ( v4 )
          sub_2FB9B(v4);
      }
    }
  }
}

//----- (000000000003E0E5) ----------------------------------------------------
signed __int64 __fastcall sub_3E0E5(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rsi

  if ( !a1 )
    return -9223372036854775806i64;
  v1 = a1;
  v2 = sub_3E12C(a1);
  if ( *(_QWORD *)(v1 + 160) )
    (*(void (**)(void))(qword_96CD8 + 72))();
  return v2;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003E12C) ----------------------------------------------------
__int64 __fastcall sub_3E12C(__int64 a1)
{
  __int64 result; // rax
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // [rsp+28h] [rbp-18h]

  result = -9223372036854775806i64;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 88) == 3 )
    {
      v2 = *(_QWORD *)(a1 + 160);
      v3 = *(_QWORD *)(v2 + 8);
      if ( v3 )
      {
        result = sub_27CFB((__int64 **)&v4);
        if ( !(_DWORD)result )
        {
          result = (*(__int64 (__fastcall **)(__int64))(v4 + 16))(v3);
          if ( !(_DWORD)result )
          {
            *(_QWORD *)(v2 + 8) = 0i64;
            result = 0i64;
          }
        }
      }
    }
  }
  return result;
}

//----- (000000000003E188) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_3E188(unsigned int a1)
{
  if ( a1 >= 8 )
    a1 = 0;
  dword_96A4C = a1;
  return 0i64;
}
// 3E194: write access to const memory at 96A4C has been detected
// 96A4C: using guessed type int dword_96A4C;

//----- (000000000003E19E) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_3E19E(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 (*v4)(void); // rax

  if ( (unsigned int)dword_96A4C < 8 )
  {
    if ( dword_96A4C )
    {
      v4 = (__int64 (*)(void))off_91ED0[dword_96A4C - 1];
      return v4();
    }
  }
  else
  {
    dword_96A4C = 0;
  }
  v4 = (__int64 (*)(void))sub_3E230;
  if ( SHIDWORD(a4) > SHIDWORD(a3) )
    v4 = (__int64 (*)(void))sub_3E1FE;
  if ( (signed int)a4 > (signed int)a3 )
    v4 = (__int64 (*)(void))sub_3E1FE;
  return v4();
}
// 3E1AF: write access to const memory at 96A4C has been detected
// 91ED0: using guessed type __int64 (__fastcall *off_91ED0[7])();
// 96A4C: using guessed type int dword_96A4C;

//----- (000000000003E1FE) ----------------------------------------------------
signed __int64 __fastcall sub_3E1FE(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  return sub_3E367(a2, a1, a3, a4, (__int64)sub_3E972, 0x20000u);
}

//----- (000000000003E230) ----------------------------------------------------
signed __int64 __fastcall sub_3E230(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  return sub_3E367(a2, a1, a3, a4, (__int64)sub_3E777, 0x8000u);
}

//----- (000000000003E262) ----------------------------------------------------
signed __int64 __fastcall sub_3E262(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  int v4; // er12
  unsigned __int64 v5; // r13
  int v6; // er14
  __int64 v7; // rsi
  __int64 v8; // rbx
  unsigned __int64 v9; // r15
  unsigned int v10; // edi
  unsigned int v11; // ecx
  int v12; // er14
  int v13; // er12
  unsigned int v14; // eax
  unsigned __int64 v15; // r15
  int v16; // er13
  unsigned int v17; // eax
  int v18; // eax
  int v20; // [rsp+28h] [rbp-58h]
  int v21; // [rsp+30h] [rbp-50h]
  signed __int64 v22; // [rsp+38h] [rbp-48h]
  unsigned int v23; // [rsp+40h] [rbp-40h]

  v4 = a4;
  v22 = -9223372036854775806i64;
  if ( (_DWORD)a4 )
  {
    v5 = a4 >> 32;
    if ( HIDWORD(a4) )
    {
      v6 = a3;
      v7 = a2;
      v8 = a1;
      v9 = a3 >> 32;
      v10 = sub_2C972(SHIDWORD(a3), SHIDWORD(a4));
      v11 = sub_2C972(v6, v4);
      v22 = 0i64;
      if ( v4 > 0 )
      {
        v23 = v11;
        v12 = 0;
        v21 = v4;
        v20 = v9;
        do
        {
          if ( (signed int)v5 > 0 )
          {
            v13 = 0;
            do
            {
              v14 = sub_2C88C(v10, v13);
              v15 = v5;
              v16 = sub_2C86B(v14);
              v17 = sub_2C88C(v23, v12);
              v18 = v16 + v20 * (unsigned __int64)sub_2C86B(v17);
              v5 = v15;
              (*(void (__fastcall **)(__int64, __int64, signed __int64))(qword_96CD8 + 352))(v8, v7 + 4i64 * v18, 4i64);
              v8 += 4i64;
              ++v13;
            }
            while ( (_DWORD)v15 != v13 );
          }
          ++v12;
        }
        while ( v12 != v21 );
      }
    }
  }
  return v22;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003E367) ----------------------------------------------------
signed __int64 __fastcall sub_3E367(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, __int64 a5, unsigned int a6)
{
  __int64 v6; // r15
  int v7; // er13
  __int64 v8; // rsi
  __int64 v9; // rbx
  signed int v10; // edi
  signed int v11; // edi
  signed __int64 v12; // rsi
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // rdx
  __int64 v16; // r13
  __int64 v17; // rax
  __int64 v18; // r13
  __int64 v19; // rdi
  int v20; // eax
  __int64 v21; // rcx
  signed __int64 v22; // rbx
  __int64 v23; // rax
  __int64 v24; // r15
  __int64 v25; // rdi
  unsigned int v26; // ebx
  __int64 v27; // r13
  unsigned int v28; // er14
  unsigned int v29; // ecx
  unsigned int v30; // eax
  __int64 v31; // rbx
  unsigned int v32; // edi
  int v33; // ecx
  int v34; // eax
  int v36; // [rsp+28h] [rbp-F8h]
  int v37; // [rsp+2Ch] [rbp-F4h]
  __int64 v38; // [rsp+30h] [rbp-F0h]
  int v39; // [rsp+38h] [rbp-E8h]
  int v40; // [rsp+3Ch] [rbp-E4h]
  __int64 v41; // [rsp+40h] [rbp-E0h]
  __int64 v42; // [rsp+48h] [rbp-D8h]
  signed int *v43; // [rsp+50h] [rbp-D0h]
  _QWORD *v44; // [rsp+58h] [rbp-C8h]
  __int64 v45; // [rsp+60h] [rbp-C0h]
  __int64 v46; // [rsp+68h] [rbp-B8h]
  __int64 *v47; // [rsp+70h] [rbp-B0h]
  __int64 v48; // [rsp+78h] [rbp-A8h]
  signed int *v49; // [rsp+80h] [rbp-A0h]
  __int64 v50; // [rsp+88h] [rbp-98h]
  __int64 v51; // [rsp+90h] [rbp-90h]
  __int64 v52; // [rsp+98h] [rbp-88h]
  int *v53; // [rsp+A0h] [rbp-80h]
  __int64 v54; // [rsp+A8h] [rbp-78h]
  __int64 v55; // [rsp+B0h] [rbp-70h]
  unsigned int v56; // [rsp+BCh] [rbp-64h]
  signed int *v57; // [rsp+C0h] [rbp-60h]
  __int64 v58; // [rsp+C8h] [rbp-58h]
  __int64 v59; // [rsp+D0h] [rbp-50h]
  __int64 v60; // [rsp+D8h] [rbp-48h]
  __int64 v61; // [rsp+E0h] [rbp-40h]

  v6 = a4;
  v7 = a3;
  v60 = a2;
  v54 = a1;
  v57 = 0i64;
  v58 = 0i64;
  v8 = a3 >> 32;
  v9 = a4 >> 32;
  v10 = sub_2C972(SHIDWORD(a4), SHIDWORD(a3));
  if ( v10 > 0x10000 )
    v10 = 0x10000;
  v36 = sub_2C905(a6, v10);
  v37 = v10;
  v38 = a5;
  v11 = sub_2C972(v6, v7);
  if ( v11 > 0x10000 )
    v11 = 0x10000;
  v39 = sub_2C905(a6, v11);
  v40 = v11;
  v41 = a5;
  v48 = v8;
  v55 = v9;
  v12 = sub_3EBD5(v8, v9, (__int64)&v36, &v57);
  if ( !(_DWORD)v12 )
    v12 = sub_3EBD5(v7, v6, (__int64)&v39, &v58);
  if ( !(_DWORD)v12 )
  {
    v61 = v12;
    v13 = sub_24136(16i64);
    if ( v13 )
    {
      v14 = v13;
      if ( (signed int)v6 > 0 )
      {
        v52 = (signed int)v6;
        v51 = 4 * (v6 >> 32);
        v61 = 0i64;
        v15 = 0i64;
        v16 = v60;
        while ( 1 )
        {
          v17 = *(_QWORD *)(v58 + 8);
          v53 = (int *)(16 * v15 + *(_QWORD *)(v58 + 8));
          if ( !v53 )
            break;
          if ( !v54 )
            break;
          if ( !v16 )
            break;
          v49 = v57;
          if ( !v57 )
            break;
          v50 = v15;
          v60 = v16;
          if ( (signed int)v55 > 0 )
          {
            v47 = (__int64 *)(16 * v15 + v17 + 8);
            v18 = v60;
            v59 = 0i64;
            do
            {
              v19 = *((_QWORD *)v49 + 1);
              (*(void (__fastcall **)(__int64, signed __int64, _QWORD))(qword_96CD8 + 360))(v14, 16i64, 0i64);
              v20 = *v53;
              if ( *v53 > 0 )
              {
                v43 = (signed int *)(v19 + 16 * v59);
                v44 = (_QWORD *)(v19 + 16 * v59 + 8);
                LODWORD(v21) = *(_DWORD *)(v19 + 16 * v59);
                v22 = 0i64;
                v46 = v18;
                do
                {
                  if ( (signed int)v21 > 0 )
                  {
                    v23 = *v47;
                    v56 = *(_DWORD *)(*v47 + 8 * v22 + 4);
                    v45 = v22;
                    v42 = v54 + 4 * *(signed int *)(v23 + 8 * v22) * (signed __int64)(signed int)v48;
                    v24 = 0i64;
                    do
                    {
                      v25 = v42 + 4i64 * *(signed int *)(*v44 + 8 * v24);
                      v26 = sub_2C899(*(_DWORD *)(*v44 + 8 * v24 + 4), v56);
                      v27 = 0i64;
                      do
                      {
                        v28 = sub_2C972(*(unsigned __int8 *)(v25 + v27), 255);
                        v29 = 0x10000;
                        if ( v27 != 3 )
                          v29 = sub_2C972(*(unsigned __int8 *)(v25 + 3) ^ 0xFFu, 255);
                        v30 = sub_2C899(v29, v28);
                        *(_DWORD *)(v14 + 4 * v27++) += sub_2C899(v30, v26);
                      }
                      while ( v27 != 4 );
                      ++v24;
                      v21 = *v43;
                    }
                    while ( v24 < v21 );
                    v20 = *v53;
                    v18 = v46;
                    v22 = v45;
                  }
                  ++v22;
                }
                while ( v22 < v20 );
              }
              v31 = 0i64;
              do
              {
                v32 = *(_DWORD *)(v14 + 4 * v31);
                if ( (signed int)sub_2C88C(*(_DWORD *)(v14 + 4 * v31), 255) < 0 )
                  v33 = 0;
                else
                  v33 = sub_2C88C(v32, 255);
                v34 = sub_2C86B(v33 + 0x8000);
                if ( (unsigned __int64)v34 >= 0xFF )
                  LOBYTE(v34) = -1;
                *(_BYTE *)(v18 + v31++) = v34;
              }
              while ( v31 != 4 );
              v18 += 4i64;
              ++v59;
            }
            while ( v59 != v55 );
          }
          v16 = v51 + v60;
          v15 = v50 + 1;
          if ( v50 + 1 >= v52 )
            goto LABEL_40;
        }
        v61 = -9223372036854775806i64;
      }
LABEL_40:
      (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v14);
      v12 = v61;
    }
    else
    {
      v12 = -9223372036854775799i64;
    }
  }
  if ( v57 )
    sub_3EB5D(v57);
  if ( v58 )
    sub_3EB5D((signed int *)v58);
  return v12;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003E777) ----------------------------------------------------
signed __int64 __fastcall sub_3E777(int a1)
{
  int v1; // edx
  signed __int64 result; // rax

  v1 = -a1;
  if ( -a1 < 1 )
    v1 = a1;
  result = 0i64;
  if ( v1 <= 0x8000 )
    result = 0x10000i64;
  return result;
}

//----- (000000000003E794) ----------------------------------------------------
signed __int64 __fastcall sub_3E794(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  return sub_3E367(a2, a1, a3, a4, (__int64)sub_3E7C6, 0x10000u);
}

//----- (000000000003E7C6) ----------------------------------------------------
__int64 __fastcall sub_3E7C6(int a1)
{
  int v1; // edx
  __int64 result; // rax

  v1 = -a1;
  if ( -a1 < 1 )
    v1 = a1;
  result = (unsigned int)(0x10000 - v1);
  if ( v1 >= 0x10000 )
    result = 0i64;
  return result;
}

//----- (000000000003E7E0) ----------------------------------------------------
signed __int64 __fastcall sub_3E7E0(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r14
  unsigned __int64 v5; // rdi
  __int64 v6; // rbx
  __int64 v7; // rsi
  unsigned int v8; // eax

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = sub_2C972(3, 2);
  return sub_3E367(v6, v7, v5, v4, (__int64)sub_3E834, v8);
}

//----- (000000000003E834) ----------------------------------------------------
__int64 __fastcall sub_3E834(signed int a1)
{
  signed int v1; // esi
  int v2; // ebx
  unsigned int v3; // ebx
  int v4; // eax
  unsigned int v5; // eax

  v1 = -a1;
  if ( -a1 < 1 )
    v1 = a1;
  if ( v1 >= 0x8000 )
  {
    v3 = 0;
    if ( v1 < (signed int)sub_2C972(3, 2) )
    {
      v4 = sub_2C972(3, 2);
      v5 = sub_32B42(v1 - v4, 2);
      return sub_2C899(v5, 0x8000u);
    }
  }
  else
  {
    v2 = sub_2C972(3, 4);
    v3 = v2 - (unsigned __int64)sub_32B42(v1, 2);
  }
  return v3;
}

//----- (000000000003E8BA) ----------------------------------------------------
signed __int64 __fastcall sub_3E8BA(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  return sub_3E367(a2, a1, a3, a4, (__int64)sub_3E8EC, 0x20000u);
}

//----- (000000000003E8EC) ----------------------------------------------------
__int64 __fastcall sub_3E8EC(signed int a1)
{
  signed int v1; // esi
  unsigned int v2; // eax
  int v3; // edi
  int v4; // edi
  __int64 result; // rax
  unsigned int v6; // eax

  v1 = -a1;
  if ( -a1 < 1 )
    v1 = a1;
  if ( v1 >= 0x10000 )
  {
    result = 0i64;
    if ( v1 < 0x20000 )
    {
      v6 = sub_32B42(0x20000 - v1, 3);
      result = sub_2C8F8(v6, 6);
    }
  }
  else
  {
    v2 = sub_32B42(v1, 3);
    v3 = sub_2C899(v2, 0x8000u);
    v4 = v3 - (unsigned __int64)sub_32B42(v1, 2);
    result = v4 + (unsigned int)sub_2C972(2, 3);
  }
  return result;
}

//----- (000000000003E972) ----------------------------------------------------
__int64 __fastcall sub_3E972(signed int a1)
{
  signed int v1; // esi
  unsigned int v2; // eax
  int v3; // edi
  unsigned int v4; // eax
  int v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // eax
  int v8; // edi
  int v9; // eax
  int v10; // edi

  v1 = -a1;
  if ( -a1 < 1 )
    v1 = a1;
  if ( v1 >= 0x10000 )
  {
    v6 = 0;
    if ( v1 < 0x20000 )
    {
      v7 = sub_32B42(v1, 2);
      v8 = sub_2C88C(v7, 5);
      v9 = sub_32B42(v1, 3);
      v10 = sub_2C899(v8 - v9, 0x8000u);
      v6 = v10 + 0x20000 - (unsigned __int64)sub_2C88C(v1, 4);
    }
  }
  else
  {
    v2 = sub_32B42(v1, 3);
    v3 = sub_2C88C(v2, 3);
    v4 = sub_32B42(v1, 2);
    v5 = sub_2C88C(v4, 5);
    v6 = (unsigned __int64)sub_2C899(v3 - v5, 0x8000u) + 0x10000;
  }
  return v6;
}

//----- (000000000003EA33) ----------------------------------------------------
signed __int64 __fastcall sub_3EA33(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  return sub_3E367(a2, a1, a3, a4, (__int64)sub_3EA65, 0x20000u);
}

//----- (000000000003EA65) ----------------------------------------------------
__int64 __fastcall sub_3EA65(signed int a1)
{
  signed int v1; // esi
  unsigned int v2; // edi
  int *v3; // r14
  unsigned int v4; // edi
  unsigned int v5; // eax
  int v6; // edi
  unsigned int v7; // ebx
  unsigned int v8; // eax
  int v9; // ebx
  int v11; // [rsp+20h] [rbp-40h]
  int v12; // [rsp+24h] [rbp-3Ch]
  int v13; // [rsp+28h] [rbp-38h]
  int v14; // [rsp+2Ch] [rbp-34h]
  int v15; // [rsp+30h] [rbp-30h]
  int v16; // [rsp+34h] [rbp-2Ch]
  int v17; // [rsp+38h] [rbp-28h]
  int v18; // [rsp+3Ch] [rbp-24h]

  v1 = -a1;
  if ( -a1 < 1 )
    v1 = a1;
  v11 = sub_2C972(8, 9);
  v2 = 0;
  v12 = 0;
  v13 = sub_2C88C(0x20000u, -1);
  v14 = sub_2C972(7, 6);
  v15 = sub_2C972(16, 9);
  v16 = sub_2C972(-10, 3);
  v17 = 0x20000;
  v18 = sub_2C972(-7, 18);
  if ( v1 < 0x20000 )
  {
    v3 = &v15;
    if ( v1 < 0x10000 )
      v3 = &v11;
    v4 = v3[3];
    v5 = sub_32B42(v1, 3);
    v6 = sub_2C899(v4, v5);
    v7 = v3[2];
    v8 = sub_32B42(v1, 2);
    v9 = v6 + (unsigned __int64)sub_2C899(v7, v8);
    v2 = *v3 + v9 + (unsigned __int64)sub_2C899(v3[1], v1);
  }
  return v2;
}

//----- (000000000003EB5D) ----------------------------------------------------
__int64 __fastcall sub_3EB5D(signed int *a1)
{
  signed int *v1; // rsi
  __int64 v2; // rcx
  void (__fastcall *v3)(__int64); // rdx
  signed __int64 v4; // rdi
  signed __int64 v5; // rbx
  __int64 result; // rax

  if ( a1 )
  {
    v1 = a1;
    v2 = *((_QWORD *)a1 + 1);
    if ( v2 )
    {
      v3 = *(void (__fastcall **)(__int64))(qword_96CD8 + 72);
      if ( *v1 > 0 )
      {
        v4 = 8i64;
        v5 = 0i64;
        do
        {
          v3(*(_QWORD *)(v2 + v4));
          ++v5;
          v3 = *(void (__fastcall **)(__int64))(qword_96CD8 + 72);
          v2 = *((_QWORD *)v1 + 1);
          v4 += 16i64;
        }
        while ( v5 < *v1 );
      }
      v3(v2);
    }
    result = (*(__int64 (__fastcall **)(signed int *))(qword_96CD8 + 72))(v1);
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003EBD5) ----------------------------------------------------
signed __int64 __fastcall sub_3EBD5(int a1, int a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v4; // r12
  int v5; // esi
  int v6; // er13
  signed __int64 v7; // r15
  unsigned int v8; // er14
  _DWORD *v9; // rax
  _DWORD *v10; // rbx
  __int64 v11; // rax
  signed __int64 v12; // rcx
  __int64 v13; // rbx
  int v14; // eax
  int v15; // eax
  int v16; // edi
  int v17; // eax
  int v18; // eax
  signed int v19; // edi
  unsigned int v20; // eax
  int v21; // er12
  unsigned int v22; // eax
  int v23; // eax
  int v24; // eax
  signed __int64 v25; // rsi
  __int64 v26; // rax
  bool v27; // zf
  signed __int64 v28; // rax
  signed int *v29; // rbx
  unsigned int v30; // er13
  int v31; // er15
  signed int *v32; // r14
  int v33; // edi
  signed int v34; // eax
  int v35; // ecx
  unsigned int v36; // esi
  int v37; // eax
  __int64 (__fastcall *v38)(_QWORD); // rbx
  unsigned int v39; // eax
  unsigned int v40; // eax
  int v41; // eax
  __int64 v42; // rcx
  __int64 v43; // rdx
  __int64 v44; // rcx
  signed __int64 v45; // rsi
  int v46; // eax
  int v48; // [rsp+28h] [rbp-98h]
  _QWORD *v49; // [rsp+38h] [rbp-88h]
  signed __int64 v50; // [rsp+40h] [rbp-80h]
  __int64 v51; // [rsp+50h] [rbp-70h]
  signed __int64 v52; // [rsp+58h] [rbp-68h]
  signed __int64 v53; // [rsp+60h] [rbp-60h]
  signed int v54; // [rsp+6Ch] [rbp-54h]
  int v55; // [rsp+70h] [rbp-50h]
  unsigned int v56; // [rsp+74h] [rbp-4Ch]
  _DWORD *v57; // [rsp+78h] [rbp-48h]
  signed int v58; // [rsp+80h] [rbp-40h]
  int v59; // [rsp+84h] [rbp-3Ch]

  v4 = a4;
  v51 = a3;
  v5 = a2;
  v6 = a1;
  v7 = -9223372036854775799i64;
  v8 = sub_2C972(a2, a1);
  v9 = (_DWORD *)sub_24136(16i64);
  if ( v9 )
  {
    v10 = v9;
    *v9 = v5;
    v11 = sub_24136(16i64 * v5);
    *((_QWORD *)v10 + 1) = v11;
    if ( v11 )
    {
      v49 = v4;
      if ( v5 <= 0 )
      {
LABEL_33:
        *v49 = v10;
        return 0i64;
      }
      v50 = v5;
      v57 = v10;
      v12 = 0i64;
      v13 = v11;
      v55 = v6;
      v56 = v8;
      while ( 2 )
      {
        v53 = v12;
        v14 = sub_2C860(v12);
        v15 = sub_2C905(v14 + 0x8000, v8);
        v16 = v15;
        v17 = v15 - *(_DWORD *)v51;
        if ( v17 <= 7 )
          v17 = 8;
        v58 = v17 - 8;
        v18 = sub_2C860(v6);
        v48 = v16;
        v19 = v16 + *(_DWORD *)v51 + 8;
        if ( v18 - 8 < v19 )
          v19 = (unsigned __int64)sub_2C860(v6) - 8;
        v20 = sub_32BA9(v58);
        v21 = sub_2C86B(v20);
        v22 = sub_32BA9(v19);
        v23 = sub_2C86B(v22);
        v59 = v23;
        v24 = v23 - v21 + 1;
        if ( v24 )
        {
          v25 = 16 * v53;
          *(_DWORD *)(v13 + 16 * v53 + 4) = v24;
          v26 = sub_24136(8i64 * v24);
          *(_QWORD *)(v13 + 16 * v53 + 8) = v26;
          v27 = v26 == 0;
          v28 = 0i64;
          if ( v27 )
            v28 = -9223372036854775799i64;
          if ( !(_DWORD)v28 )
          {
            v28 = -9223372036854775787i64;
            if ( v59 >= v21 )
            {
              v54 = v19;
              v52 = v13 + v25 + 4;
              v29 = (signed int *)(v25 + v13);
              v30 = 0;
              do
              {
                v31 = v58;
                if ( v58 <= (signed int)sub_2C860(v21) )
                  v31 = sub_2C860(v21);
                v32 = v29;
                v33 = v21 + 1;
                v34 = sub_2C860(v21 + 1);
                v35 = v54;
                if ( v54 >= v34 )
                  v35 = sub_2C860(v33);
                v36 = v35 - v31;
                v37 = sub_2C8F8(v31 + v35, 2);
                v38 = *(__int64 (__fastcall **)(_QWORD))(v51 + 8);
                v39 = sub_2C899(*(_DWORD *)(v51 + 4), v37 - v48);
                v40 = v38(v39);
                v41 = sub_2C899(v40, v36);
                v29 = v32;
                if ( v41 )
                {
                  v42 = *v32;
                  if ( (signed int)v42 >= *(_DWORD *)v52 )
                  {
                    v28 = -9223372036854775799i64;
                    goto LABEL_32;
                  }
                  v43 = *(_QWORD *)(v52 + 4);
                  *(_DWORD *)(v43 + 8 * v42) = v21;
                  *(_DWORD *)(v43 + 8 * v42 + 4) = v41;
                  *v32 = v42 + 1;
                }
                v30 += v41;
                ++v21;
              }
              while ( v33 - 1 < v59 );
              v28 = -9223372036854775787i64;
              if ( !v30 )
                break;
              if ( v30 != 0x10000 && *v32 > 0 )
              {
                v44 = *(_QWORD *)(v52 + 4);
                v45 = 0i64;
                do
                {
                  v46 = sub_2C905(*(_DWORD *)(v44 + 8 * v45 + 4), v30);
                  v44 = *(_QWORD *)(v52 + 4);
                  *(_DWORD *)(v44 + 8 * v45++ + 4) = v46;
                }
                while ( v45 < *v32 );
              }
              v12 = v53 + 1;
              v10 = v57;
              v6 = v55;
              v8 = v56;
              if ( v53 + 1 < v50 )
              {
                v13 = *((_QWORD *)v57 + 1);
                continue;
              }
              goto LABEL_33;
            }
          }
        }
        else
        {
          v28 = -9223372036854775806i64;
        }
        break;
      }
    }
    else
    {
      v57 = v10;
      v28 = -9223372036854775799i64;
    }
LABEL_32:
    v7 = v28;
    sub_3EB5D(v57);
  }
  return v7;
}

//----- (000000000003EED1) ----------------------------------------------------
signed __int64 __fastcall sub_3EED1(__int64 a1, _QWORD *a2)
{
  signed __int64 result; // rax
  __int64 v3; // rcx
  __int64 v4; // rax

  result = -9223372036854775806i64;
  if ( a1 && a2 && *(_DWORD *)(a1 + 88) == 9 )
  {
    v3 = *(_QWORD *)(a1 + 160);
    if ( v3 )
    {
      v4 = *(_QWORD *)(v3 + 8);
      a2[1] = *(_QWORD *)(v3 + 16);
      *a2 = v4;
      result = 0i64;
    }
  }
  return result;
}

//----- (000000000003EF0E) ----------------------------------------------------
signed __int64 __fastcall sub_3EF0E(__int64 *a1, int a2)
{
  signed __int64 v2; // rbx
  int v3; // esi
  __int64 *v4; // r15
  __int64 v5; // rax
  __int64 v6; // r13
  signed __int64 v7; // rdi
  __int64 v8; // rax
  int *v9; // rcx
  char *v10; // rax
  int v11; // er12
  int v12; // er14
  int v13; // edi
  __int64 v14; // rax
  __int64 v15; // rsi
  int v16; // er13
  __int64 v18; // [rsp+28h] [rbp-48h]
  int v19; // [rsp+34h] [rbp-3Ch]

  v2 = -9223372036854775802i64;
  v19 = a2;
  if ( !a1 )
    return -9223372036854775806i64;
  if ( byte_96CF0 )
  {
    v3 = a2;
    v4 = a1;
    v5 = sub_24136(96i64);
    if ( !v5 )
      return -9223372036854775799i64;
    v6 = v5;
    v7 = sub_3FAAF((_QWORD *)(v5 + 88), 16i64);
    if ( !(_DWORD)v7 )
    {
      if ( qword_96CF8 )
      {
        v8 = *(_QWORD *)(*(_QWORD *)(qword_96CF8 + 24) + 8i64);
        v9 = (int *)(v8 + 4);
        v10 = (char *)(v8 + 8);
      }
      else
      {
        v10 = byte_96D00;
        v9 = &dword_96D04;
      }
      v11 = *(_DWORD *)v10;
      v12 = *v9;
      *(_DWORD *)(v6 + 12) = *v9;
      *(_DWORD *)(v6 + 8) = v11;
      sub_23BC8((_QWORD *)(v6 + 16));
      if ( v11 && v12 )
      {
        *(_DWORD *)(v6 + 48) = v3;
        *(_BYTE *)(v6 + 52) = 0;
        v13 = 0;
        *(_QWORD *)(v6 + 32) = 0i64;
        *(_QWORD *)(v6 + 40) = 0i64;
        *(_QWORD *)(v6 + 56) = 0i64;
        v14 = sub_24103((unsigned int)(4 * v12 * v11));
        *(_QWORD *)v6 = v14;
        if ( v14 )
        {
          v15 = v14;
          v18 = v6;
          do
          {
            v16 = v12;
            do
            {
              (*(void (__fastcall **)(__int64, int *, signed __int64))(qword_96CD8 + 352))(v15, &v19, 4i64);
              v15 += 4i64;
              --v16;
            }
            while ( v16 );
            ++v13;
          }
          while ( v13 != v11 );
          *v4 = v18;
          return 0i64;
        }
        v2 = -9223372036854775799i64;
      }
      v7 = v2;
    }
    sub_3F069((_QWORD *)v6);
    v2 = v7;
  }
  return v2;
}
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CF0: using guessed type char byte_96CF0;
// 96CF8: using guessed type __int64 qword_96CF8;
// 96D04: using guessed type int dword_96D04;

//----- (000000000003F069) ----------------------------------------------------
signed __int64 __fastcall sub_3F069(_QWORD *a1)
{
  _QWORD *v1; // rsi
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 v4; // rcx
  __int64 *v5; // rax
  signed __int64 v6; // rdi
  __int64 v7; // rbx

  if ( !a1 )
    return -9223372036854775806i64;
  v1 = a1;
  if ( *a1 )
  {
    (*(void (**)(void))(qword_96CD8 + 72))();
    *v1 = 0i64;
  }
  v2 = v1[7];
  if ( v2 )
  {
    sub_35A74(v2);
    v1[7] = 0i64;
  }
  v3 = v1[4];
  if ( !v3 || !(unsigned int)sub_27054(v3) )
    v1[4] = 0i64;
  v4 = v1[5];
  if ( !v4 || !(unsigned int)sub_27054(v4) )
    v1[5] = 0i64;
  while ( !sub_23BD5(v1 + 2) )
  {
    v5 = (__int64 *)sub_23C0D((__int64)(v1 + 2));
    sub_3F1DC((__int64)v1, v5);
  }
  if ( v1[8] )
    sub_3F278((__int64)v1);
  v6 = sub_3FB3E(v1[11]);
  while ( 1 )
  {
    v7 = v1[9];
    if ( !v7 )
      break;
    sub_3F2DA((__int64)v1, v1[9]);
    (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v7);
  }
  if ( !v6 )
    sub_3FBB3(v1[11]);
  sub_3FB13(v1[11]);
  (*(void (__fastcall **)(_QWORD *))(qword_96CD8 + 72))(v1);
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003F181) ----------------------------------------------------
signed __int64 __fastcall sub_3F181(__int64 a1, __int64 a2)
{
  return sub_3F613(a1, a2, 0);
}

//----- (000000000003F18E) ----------------------------------------------------
signed __int64 __fastcall sub_3F18E(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // rcx
  signed __int64 result; // rax

  if ( !a1 )
    return -9223372036854775806i64;
  v2 = a2;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 40);
  if ( !v4 || (result = sub_27054(v4), !(_DWORD)result) )
  {
    if ( v2 )
    {
      *(_QWORD *)(v2 + 80) = v3;
      *(_BYTE *)(v2 + 40) = 1;
    }
    *(_QWORD *)(v3 + 40) = v2;
    result = 0i64;
  }
  return result;
}

//----- (000000000003F1DC) ----------------------------------------------------
signed __int64 __fastcall sub_3F1DC(__int64 a1, __int64 *a2)
{
  signed __int64 v2; // rbx
  __int64 *v3; // rsi
  __int64 v4; // rdi
  void (__fastcall *v5)(__int64 *, __int64); // rax
  __int64 v6; // rdx
  signed __int64 v7; // rax

  v2 = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = a1;
      if ( sub_23BD5(a2) )
      {
        v2 = -9223372036854775794i64;
      }
      else
      {
        sub_23BE1(v3);
        v5 = (void (__fastcall *)(__int64 *, __int64))v3[14];
        if ( v5 )
          v5(v3, v4);
        v6 = v3[32];
        if ( v6 )
        {
          sub_3F2DA(v4, v6);
          (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v3[32]);
          v3[32] = 0i64;
        }
        v7 = sub_27054((__int64)v3);
        v2 = 0i64;
        if ( (_DWORD)v7 )
          v2 = v7;
      }
    }
  }
  return v2;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003F278) ----------------------------------------------------
__int64 __fastcall sub_3F278(__int64 a1)
{
  signed __int64 v1; // rdi
  __int64 v2; // rsi
  __int64 result; // rax
  __int64 v4; // [rsp+28h] [rbp-18h]

  v1 = -9223372036854775806i64;
  v4 = 0i64;
  if ( !a1 )
    return v1;
  v2 = a1;
  if ( !*(_QWORD *)(a1 + 64) )
    return v1;
  result = sub_27CFB((__int64 **)&v4);
  if ( (_DWORD)result )
    return result;
  if ( !v4 )
    return -9223372036854775805i64;
  result = (*(__int64 (__fastcall **)(_QWORD))(v4 + 16))(*(_QWORD *)(v2 + 64));
  if ( !(_DWORD)result )
    *(_QWORD *)(v2 + 64) = 0i64;
  return result;
}

//----- (000000000003F2DA) ----------------------------------------------------
void __fastcall sub_3F2DA(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  _QWORD *v4; // rcx
  __int64 v5; // rdx
  _QWORD *v6; // rax

  if ( a1 )
  {
    v2 = a2;
    if ( a2 )
    {
      v3 = a1;
      if ( !(unsigned int)sub_3FB3E(*(_QWORD *)(a1 + 88)) )
      {
        v4 = (_QWORD *)(v3 + 72);
        while ( 1 )
        {
          v5 = *v4;
          if ( !*v4 )
            break;
          v6 = v4;
          v4 = (_QWORD *)(v5 + 40);
          if ( v5 == v2 )
          {
            *v6 = *v4;
            if ( !*(_BYTE *)(v2 + 32) )
              --*(_DWORD *)(v3 + 80);
            break;
          }
        }
        sub_3FBB3(*(_QWORD *)(v3 + 88));
      }
    }
  }
}

//----- (000000000003F340) ----------------------------------------------------
signed __int64 __fastcall sub_3F340(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax
  __int64 v3; // rdi
  __int64 v4; // rbx
  signed __int64 v5; // rdx
  __int64 v6; // rcx
  void (__fastcall *v7)(__int64, __int64); // rax

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = a1;
      *(_QWORD *)(a2 + 80) = a1;
      v5 = a1 + 16;
      v6 = a1 + 16;
      while ( 1 )
      {
        v6 = *(_QWORD *)v6;
        if ( v6 == v5 )
          break;
        if ( !v6 )
          return result;
        if ( *(_DWORD *)(v6 + 248) > *(_DWORD *)(v3 + 248) )
          goto LABEL_9;
      }
      v6 = v5;
LABEL_9:
      sub_23BF5(v6, (_QWORD *)v3);
      v7 = *(void (__fastcall **)(__int64, __int64))(v3 + 104);
      if ( v7 )
        v7(v3, v4);
      result = 0i64;
    }
  }
  return result;
}

//----- (000000000003F3B4) ----------------------------------------------------
signed __int64 __fastcall sub_3F3B4(__int64 a1, __int64 a2, int a3, __int64 a4, __int64 a5)
{
  signed __int64 v5; // rbx
  __int64 v6; // rdi
  __int64 v7; // rsi
  signed __int64 result; // rax
  int v9; // er13
  __int64 v10; // r14
  __int64 v11; // rax
  __int64 v12; // r15
  __int64 v13; // rax
  __int64 v14; // r15
  signed __int64 v15; // rdi
  __int64 *v16; // rdx
  __int64 *v17; // rax
  __int64 v18; // rcx
  __int64 v19; // rdi
  __int64 v20; // [rsp+28h] [rbp-48h]
  __int64 v21; // [rsp+30h] [rbp-40h]

  v5 = -9223372036854775806i64;
  if ( !a1 )
    return v5;
  v6 = a2;
  if ( !a2 )
    return v5;
  v7 = a1;
  if ( *(_QWORD *)(a2 + 80) != a1 )
    return v5;
  v9 = a3;
  if ( !a3 )
    return -9223372036854775805i64;
  v10 = a4;
  if ( !a4 )
    return v5;
  result = sub_3FB3E(*(_QWORD *)(a1 + 88));
  if ( !(_DWORD)result )
  {
    if ( *(_QWORD *)(v7 + 64) )
    {
LABEL_10:
      v11 = *(_QWORD *)(v6 + 256);
      v12 = v11;
      if ( !v11 )
      {
        v13 = sub_24136(48i64);
        if ( !v13 )
        {
          v5 = -9223372036854775799i64;
          goto LABEL_36;
        }
        v12 = v13;
        v11 = *(_QWORD *)(v6 + 256);
      }
      *(_QWORD *)(v12 + 24) = v6;
      *(_DWORD *)v12 = v9;
      *(_QWORD *)(v12 + 8) = v10;
      *(_QWORD *)(v12 + 16) = a5;
      if ( !v11 )
      {
        *(_QWORD *)(v6 + 256) = v12;
        if ( !v12 )
          goto LABEL_36;
        v15 = sub_3FB3E(*(_QWORD *)(v7 + 88));
        if ( (_DWORD)v15 )
          goto LABEL_39;
        v16 = (__int64 *)(v7 + 72);
        do
        {
          v17 = v16;
          v18 = *v16;
          if ( !*v16 )
            break;
          v19 = *(_QWORD *)(v18 + 24);
          if ( !v19 )
            goto LABEL_25;
          v16 = (__int64 *)(v18 + 40);
        }
        while ( *(_DWORD *)(*(_QWORD *)(v12 + 24) + 248i64) <= *(_DWORD *)(v19 + 248) );
        *(_QWORD *)(v12 + 40) = v18;
        *v17 = v12;
        ++*(_DWORD *)(v7 + 80);
        v5 = 0i64;
LABEL_25:
        sub_3FBB3(*(_QWORD *)(v7 + 88));
        v15 = v5;
        if ( (_DWORD)v5 )
        {
LABEL_39:
          (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v12);
          v5 = v15;
          goto LABEL_36;
        }
      }
      v5 = 0i64;
LABEL_36:
      sub_3FBB3(*(_QWORD *)(v7 + 88));
      return v5;
    }
    v21 = 0i64;
    v20 = 0i64;
    v14 = sub_27CFB((__int64 **)&v21);
    if ( (_DWORD)v14 )
    {
LABEL_17:
      v5 = v14;
      goto LABEL_36;
    }
    if ( v21 )
    {
      v14 = (*(__int64 (__fastcall **)(signed __int64, void (__fastcall *)(__int64, __int64), __int64 *, __int64))(v21 + 8))(
              0xFFFFFFFFi64,
              sub_3F9D3,
              &v20,
              v7);
      if ( (_DWORD)v14 )
      {
        if ( v20 )
        {
          if ( v21 )
            (*(void (**)(void))(v21 + 16))();
        }
        goto LABEL_17;
      }
      if ( v20 )
      {
        *(_QWORD *)(v7 + 64) = v20;
        goto LABEL_10;
      }
    }
    v5 = -9223372036854775805i64;
    goto LABEL_36;
  }
  return result;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003F58B) ----------------------------------------------------
signed __int64 __fastcall sub_3F58B(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rdi
  __int64 v3; // rbx
  __int64 v4; // rsi
  bool v6; // zf

  v2 = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = a1;
      if ( *(_QWORD *)(a2 + 80) == a1 )
      {
        if ( *(_QWORD *)(a2 + 256) )
        {
          v2 = sub_3FB3E(*(_QWORD *)(a1 + 88));
          if ( !(_DWORD)v2 )
          {
            *(_BYTE *)(*(_QWORD *)(v3 + 256) + 32i64) = 1;
            v6 = (*(_DWORD *)(v4 + 80))-- == 1;
            *(_QWORD *)(v3 + 256) = 0i64;
            if ( !v6 || (v2 = sub_3F278(v4), !(_DWORD)v2) )
              v2 = 0i64;
            sub_3FBB3(*(_QWORD *)(v4 + 88));
          }
        }
      }
    }
  }
  return v2;
}

//----- (000000000003F613) ----------------------------------------------------
signed __int64 __fastcall sub_3F613(__int64 a1, __int64 a2, char a3)
{
  signed __int64 result; // rax
  char v4; // bl
  __int64 v5; // rsi
  __int64 v6; // rdi
  __int64 v7; // rcx
  char v8; // [rsp+28h] [rbp-28h]

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v4 = a3;
    v5 = a2;
    v6 = a1;
    if ( !a3 || *(_DWORD *)(a2 + 56) <= *(_DWORD *)(a1 + 12) && *(_DWORD *)(a2 + 52) <= *(_DWORD *)(a1 + 8) )
    {
      v7 = *(_QWORD *)(a1 + 32);
      if ( !v7 || (result = sub_27054(v7), !(_DWORD)result) )
      {
        if ( v5 )
        {
          *(_BYTE *)(v6 + 52) = 0;
          *(_QWORD *)(v5 + 80) = v6;
          if ( v4 )
          {
            sub_26B03(&v8, 0, 0, *(_DWORD *)(v6 + 12), *(_DWORD *)(v6 + 8));
            sub_26B1E(v5 + 44, (_DWORD *)(v5 + 52), &v8);
          }
        }
        *(_QWORD *)(v6 + 32) = v5;
        result = 0i64;
      }
    }
  }
  return result;
}

//----- (000000000003F6AA) ----------------------------------------------------
signed __int64 __fastcall sub_3F6AA(_QWORD *a1)
{
  _QWORD *v1; // rsi
  int **v2; // r15
  int *v3; // rbx
  char i; // r12
  signed __int64 v6; // rdi
  __int64 v8; // rcx
  signed __int64 v9; // rax
  __int64 *j; // rbx
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rdi
  char v14; // al
  int v15[4]; // [rsp+30h] [rbp-60h]
  __int64 v16; // [rsp+40h] [rbp-50h]
  int v17; // [rsp+48h] [rbp-48h]
  int v18; // [rsp+4Ch] [rbp-44h]
  int v19; // [rsp+50h] [rbp-40h]
  int v20; // [rsp+54h] [rbp-3Ch]
  _QWORD *savedregs; // [rsp+90h] [rbp+0h]

  savedregs = &savedregs;
  if ( !a1 )
    return -9223372036854775806i64;
  if ( !byte_96CF0 )
    return -9223372036854775802i64;
  v1 = a1;
  if ( !*a1 )
    return -9223372036854775804i64;
  v16 = a1[5];
  sub_26B03(&v17, 0, 0, 0, 0);
  v2 = (int **)(v1 + 2);
  if ( *((_BYTE *)v1 + 52) )
  {
    v3 = *v2;
    for ( i = 0; v3 != (int *)v2; v3 = *(int **)v3 )
    {
      if ( *((_BYTE *)v3 + 40) )
      {
        if ( i )
        {
          sub_26C52((__int64)&v17, &v17, v3 + 15);
          sub_26C52((__int64)&v17, &v17, v3 + 11);
        }
        else
        {
          sub_26C52((__int64)&v17, v3 + 11, v3 + 15);
          i = 1;
        }
      }
    }
  }
  else
  {
    sub_26B03(&v17, 0, 0, *((_DWORD *)v1 + 3), *((_DWORD *)v1 + 2));
    i = 1;
  }
  if ( v16 && *(_BYTE *)(v16 + 40) )
  {
    if ( i )
    {
      sub_26C52((__int64)&v17, &v17, (int *)(v16 + 60));
      sub_26C52((__int64)&v17, &v17, (int *)(v16 + 44));
    }
    else
    {
      sub_26C52((__int64)&v17, (int *)(v16 + 44), (int *)(v16 + 60));
      i = 1;
    }
  }
  if ( !v20 || !v19 )
    return 0i64;
  v6 = 0i64;
  sub_26B03(v15, 0, 0, *((_DWORD *)v1 + 3), *((_DWORD *)v1 + 2));
  if ( sub_26BB1(&v17, &v17, v15) )
    return v6;
  if ( i )
  {
    v6 = sub_2445C(*((_DWORD *)v1 + 12), *v1, (unsigned int *)v1 + 2, (unsigned int *)&v17);
    if ( (_DWORD)v6 )
      return v6;
  }
  v8 = v1[4];
  if ( v8 )
  {
    v9 = sub_26F86(v8, &v17, *v1, (__int64)(v1 + 1));
    if ( v9 )
    {
      v6 = v9;
      if ( v9 != -9223372036854775794i64 )
        return v6;
    }
  }
  for ( j = (__int64 *)*v2; j != (__int64 *)v2; j = (__int64 *)*j )
  {
    if ( *((_BYTE *)j + 225) && *((_BYTE *)j + 168) != -1 && *((_DWORD *)j + 22) != 10 )
    {
      v11 = ((__int64 (__fastcall *)(__int64 *, int *, _QWORD, _QWORD *))j[12])(j, &v17, *v1, v1 + 1);
      if ( v11 == -9223372036854775794i64 )
        continue;
      v6 = v11;
      if ( (_DWORD)v11 )
        return v6;
    }
    (*(void (__fastcall **)(__int64, __int64, signed __int64))(qword_96CD8 + 352))(
      (__int64)j + 60,
      (__int64)j + 44,
      16i64);
    *((_BYTE *)j + 40) = 0;
  }
  if ( !v16 )
    goto LABEL_45;
  if ( !*(_BYTE *)(v16 + 225) )
    goto LABEL_44;
  v12 = (*(__int64 (__fastcall **)(__int64, int *, _QWORD, _QWORD *))(v16 + 96))(v16, &v17, *v1, v1 + 1);
  if ( v12 == -9223372036854775794i64 )
  {
LABEL_45:
    v14 = *((_BYTE *)v1 + 52);
    if ( i )
    {
      if ( v14 )
        goto LABEL_50;
    }
    else if ( v14 )
    {
      return 0i64;
    }
    *((_BYTE *)v1 + 52) = 1;
LABEL_50:
    v6 = sub_243E3(*v1, 2u, v17, v18, v17, v18, v20, v19, 4i64 * *((signed int *)v1 + 3));
    if ( (_DWORD)v6 )
      return v6;
    return 0i64;
  }
  v6 = v12;
  if ( !(_DWORD)v12 )
  {
LABEL_44:
    v13 = v16;
    (*(void (__fastcall **)(__int64, __int64, signed __int64))(qword_96CD8 + 352))(v16 + 60, v16 + 44, 16i64);
    *(_BYTE *)(v13 + 40) = 0;
    goto LABEL_45;
  }
  return v6;
}
// 96CD8: using guessed type __int64 qword_96CD8;
// 96CF0: using guessed type char byte_96CF0;

//----- (000000000003F9D3) ----------------------------------------------------
void __fastcall sub_3F9D3(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rdi
  __int64 i; // rbx
  __int64 v5; // rcx
  unsigned __int8 (__fastcall *v6)(__int64, __int64, _QWORD); // rax
  __int64 *v7; // rdi
  __int64 v8; // rcx

  if ( a1 )
  {
    v2 = a2;
    if ( a2 )
    {
      v3 = a1;
      if ( !(unsigned int)sub_3FB3E(*(_QWORD *)(a2 + 88)) )
      {
        for ( i = *(_QWORD *)(v2 + 72); i; i = *(_QWORD *)(i + 40) )
        {
          v5 = *(_QWORD *)(i + 24);
          if ( !v5 )
            goto LABEL_24;
          if ( *(_BYTE *)(v5 + 225) )
          {
            if ( *(_BYTE *)(v5 + 168) != -1 && !*(_BYTE *)(i + 32) )
            {
              if ( *(_DWORD *)i & *(_DWORD *)(v3 + 8) )
              {
                v6 = *(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD))(i + 8);
                if ( v6 )
                {
                  if ( v6(v5, v3, *(_QWORD *)(i + 16)) )
                    break;
                }
              }
            }
          }
        }
        if ( !(unsigned int)sub_3FB3E(*(_QWORD *)(v2 + 88)) )
        {
          v7 = (__int64 *)(v2 + 72);
          while ( 1 )
          {
            v8 = *v7;
            if ( !*v7 )
              break;
            if ( *(_BYTE *)(v8 + 32) )
            {
              *v7 = *(_QWORD *)(v8 + 40);
              (*(void (**)(void))(qword_96CD8 + 72))();
              v8 = *v7;
            }
            if ( v8 )
              v7 = (__int64 *)(v8 + 40);
          }
          sub_3FBB3(*(_QWORD *)(v2 + 88));
        }
LABEL_24:
        sub_3FBB3(*(_QWORD *)(v2 + 88));
      }
    }
  }
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003FAAF) ----------------------------------------------------
signed __int64 __fastcall sub_3FAAF(_QWORD *a1, __int64 a2)
{
  signed __int64 v2; // rsi
  __int64 v3; // r14
  _QWORD *v4; // rdi
  _QWORD *v5; // rax
  _QWORD *v6; // rbx

  v2 = -9223372036854775806i64;
  if ( a1 )
  {
    v3 = a2;
    v4 = a1;
    v5 = (_QWORD *)sub_24136(40i64);
    if ( v5 )
    {
      v6 = v5;
      sub_24098(v5, v3);
      v6[3] = 0i64;
      *((_BYTE *)v6 + 32) = 0;
      *v4 = v6;
      v2 = 0i64;
    }
    else
    {
      v2 = -9223372036854775799i64;
    }
  }
  return v2;
}

//----- (000000000003FB13) ----------------------------------------------------
signed __int64 __fastcall sub_3FB13(__int64 a1)
{
  if ( !a1 )
    return -9223372036854775806i64;
  (*(void (**)(void))(qword_96CD8 + 72))();
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003FB3E) ----------------------------------------------------
signed __int64 __fastcall sub_3FB3E(__int64 a1)
{
  __int64 v1; // rsi
  unsigned __int64 v2; // rdi
  __int64 v3; // rax

  if ( !a1 )
    return -9223372036854775806i64;
  v1 = a1;
  v2 = (*(__int64 (__fastcall **)(signed __int64))(qword_96CD8 + 24))(31i64);
  (*(void (__fastcall **)(unsigned __int64))(qword_96CD8 + 32))(v2);
  v3 = *(_QWORD *)(v1 + 24);
  if ( !v3 )
  {
    if ( v2 >= *(_QWORD *)v1 )
    {
      v3 = 0i64;
    }
    else
    {
      while ( sub_240AB((_QWORD *)v1) )
        ;
      *(_BYTE *)(v1 + 32) = 1;
      v3 = *(_QWORD *)(v1 + 24);
    }
  }
  *(_QWORD *)(v1 + 24) = v3 + 1;
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003FBB3) ----------------------------------------------------
signed __int64 __fastcall sub_3FBB3(__int64 a1)
{
  signed __int64 result; // rax
  __int64 v2; // rdx
  signed __int64 v3; // rdx

  result = -9223372036854775806i64;
  if ( a1 )
  {
    v2 = *(_QWORD *)(a1 + 24);
    if ( v2 )
    {
      v3 = v2 - 1;
      *(_QWORD *)(a1 + 24) = v3;
      if ( !v3 )
      {
        if ( *(_BYTE *)(a1 + 32) )
        {
          *(_BYTE *)(a1 + 32) = 0;
          sub_240E8(a1);
        }
      }
      result = 0i64;
    }
  }
  return result;
}

//----- (000000000003FBF3) ----------------------------------------------------
char sub_3FBF3()
{
  return byte_96A50;
}
// 96A50: using guessed type char byte_96A50;

//----- (000000000003FBFF) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_3FBFF(char a1)
{
  byte_96A50 = a1;
}
// 3FC03: write access to const memory at 96A50 has been detected
// 96A50: using guessed type char byte_96A50;

//----- (000000000003FC0B) ----------------------------------------------------
signed __int64 __fastcall sub_3FC0B(__int64 a1, signed int *a2, __int64 *a3, __int64 a4)
{
  signed int *v4; // r13
  __int64 v5; // rdi
  __int64 v6; // r14
  signed __int64 v7; // rbx
  __int64 v8; // rsi
  signed int v9; // ecx
  int v10; // er9
  __int64 v11; // r12
  int v12; // er10
  int v13; // er11
  int v14; // eax
  signed int v15; // er8
  __int64 v16; // rdx
  __int64 v17; // r14
  __int64 v18; // rax
  __int16 v19; // cx
  __int64 v20; // rbx
  __int64 v21; // rbx
  __int64 v22; // rbx
  _DWORD *v23; // rax
  signed __int64 result; // rax
  char v25; // [rsp+30h] [rbp-70h]
  __int64 *v26; // [rsp+40h] [rbp-60h]
  _DWORD *v27; // [rsp+48h] [rbp-58h]
  __int64 v28; // [rsp+50h] [rbp-50h]
  __int64 v29; // [rsp+58h] [rbp-48h]
  int v30; // [rsp+64h] [rbp-3Ch]

  if ( a1 && a3 )
  {
    v4 = a2;
    v5 = a1;
    v27 = (_DWORD *)a4;
    v26 = a3;
    v6 = a2[1];
    v7 = 2i64 * *a2;
    v8 = sub_24103(4 * 2 * v6 * 2i64 * *a2);
    v29 = v7;
    v28 = 2 * v6;
    sub_26B03(&v25, 0, 0, 2 * v6, v7);
    v9 = v4[1];
    if ( v9 > 0 )
    {
      v10 = 4 * v6;
      LODWORD(v11) = *v4;
      v12 = 2 * v6;
      v13 = 2 * v6 + 1;
      v14 = 0;
      v15 = 0;
      do
      {
        if ( (signed int)v11 > 0 )
        {
          v30 = v14;
          LODWORD(v16) = v14;
          v17 = 0i64;
          do
          {
            v18 = v15 + v9 * (signed int)v17;
            v19 = *(_WORD *)(v5 + 4 * v18);
            LOBYTE(v18) = *(_BYTE *)(v5 + 4 * v18 + 2) >> 1;
            v16 = (signed int)v16;
            *(_WORD *)(v8 + 4 * v16) = v19;
            *(_BYTE *)(v8 + 4 * v16 + 2) = v18;
            *(_BYTE *)(v8 + 4 * v16 + 3) = 0;
            v20 = (signed int)v16 + 1;
            *(_WORD *)(v8 + 4 * v20) = v19;
            *(_BYTE *)(v8 + 4 * v20 + 2) = v18;
            *(_BYTE *)(v8 + 4 * v20 + 3) = 0;
            v21 = v12 + (signed int)v16;
            *(_WORD *)(v8 + 4 * v21) = v19;
            *(_BYTE *)(v8 + 4 * v21 + 2) = v18;
            *(_BYTE *)(v8 + 4 * v21 + 3) = 0;
            v22 = v13 + (signed int)v16;
            *(_WORD *)(v8 + 4 * v22) = v19;
            *(_BYTE *)(v8 + 4 * v22 + 2) = v18;
            *(_BYTE *)(v8 + 4 * v22 + 3) = 0;
            ++v17;
            v11 = *v4;
            v9 = v4[1];
            LODWORD(v16) = v10 + v16;
          }
          while ( v17 < v11 );
          v14 = v30;
        }
        ++v15;
        v14 += 2;
      }
      while ( v15 < v9 );
    }
    v23 = v27;
    v27[1] = v28;
    *v23 = v29;
    *v26 = v8;
    result = 0i64;
  }
  else
  {
    sub_1A11E();
    result = 1i64;
  }
  return result;
}

//----- (000000000003FD8F) ----------------------------------------------------
signed __int64 __fastcall sub_3FD8F(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 v4; // rdi
  __int64 v5; // r14
  unsigned __int64 v6; // r12
  int v7; // er13
  __int64 v8; // rbx
  __int16 v9; // ax
  char v10; // si
  __int16 v13[260]; // [rsp+30h] [rbp-250h]
  __int64 *v14; // [rsp+238h] [rbp-48h]
  __int64 v15; // [rsp+240h] [rbp-40h]

  v14 = a4;
  v4 = a3;
  v5 = a2;
  v6 = 0i64;
  sub_F180((char *)v13, 0, 0x200ui64);
  v15 = 0i64;
  v7 = 0;
  v8 = v5;
  do
  {
    v9 = *(_WORD *)(v4 + 2 * v6);
    if ( v9 != 47 && v9 )
    {
      v13[v7++] = v9;
    }
    else
    {
      if ( v7 )
      {
        if ( (*(__int64 (__fastcall **)(__int64, __int64 *, __int16 *, signed __int64, _QWORD))(v8 + 8))(
               v8,
               &v15,
               v13,
               1i64,
               0i64) )
        {
          sub_1A11E();
          v10 = 0;
        }
        else
        {
          v10 = 1;
        }
        if ( v8 != v5 && (*(__int64 (__fastcall **)(__int64))(v8 + 16))(v8) )
        {
          sub_1A11E();
          return 1i64;
        }
        if ( !v10 )
          return 1i64;
        v8 = v15;
        v15 = 0i64;
      }
      v7 = 0;
      sub_F180((char *)v13, 0, 0x200ui64);
    }
    if ( v6 > 0xFF )
      break;
  }
  while ( *(_WORD *)(v4 + 2 * v6++) != 0 );
  if ( v14 )
    *v14 = v8;
  return 0i64;
}
// 3FD8F: using guessed type __int16 var_250[260];

//----- (000000000003FED1) ----------------------------------------------------
signed __int64 __fastcall sub_3FED1(__int64 a1, __int64 *a2, _QWORD *a3)
{
  _QWORD *v3; // r14
  __int64 *v4; // rbx
  __int64 v5; // rdi
  signed __int64 v6; // rsi
  __int64 v8; // r15
  __int64 v9; // rax
  __int64 v10; // [rsp+28h] [rbp-38h]
  __int64 v11; // [rsp+30h] [rbp-30h]

  if ( !a1 )
  {
    sub_1A11E();
    return -1i64;
  }
  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = -1i64;
  if ( (*(unsigned int (__fastcall **)(__int64, signed __int64))(a1 + 56))(a1, -1i64)
    || (*(unsigned int (__fastcall **)(__int64, __int64 *))(v5 + 48))(v5, &v10) )
  {
    goto LABEL_4;
  }
  v8 = 0i64;
  (*(void (__fastcall **)(__int64, _QWORD))(v5 + 56))(v5, 0i64);
  v11 = v10;
  if ( v10 )
  {
    v9 = sub_24136(v10);
    if ( !v9 )
    {
LABEL_4:
      sub_1A11E();
      return v6;
    }
    v8 = v9;
    if ( (*(unsigned int (__fastcall **)(__int64, __int64 *, __int64))(v5 + 32))(v5, &v11, v9) )
    {
      sub_1A11E();
      (*(void (__fastcall **)(__int64))(qword_96CD8 + 72))(v8);
      return v6;
    }
  }
  if ( v4 )
    *v4 = v8;
  if ( v3 )
    *v3 = v11;
  return 0i64;
}
// 96CD8: using guessed type __int64 qword_96CD8;

//----- (000000000003FFD2) ----------------------------------------------------
__int64 __fastcall sub_3FFD2(int a1)
{
  int v1; // esi
  __int64 v2; // rax
  __int64 v3; // rdi

  v1 = a1;
  v2 = sub_24136(16i64);
  v3 = v2;
  *(_DWORD *)v2 = v1;
  *(_QWORD *)(v2 + 8) = sub_24136(8i64 * v1);
  return v3;
}

//----- (0000000000040008) ----------------------------------------------------
void __fastcall sub_40008(_DWORD *a1, __int64 a2, char *a3)
{
  char *v3; // r15
  __int64 v4; // r14
  _DWORD *v5; // rdi
  __int64 v6; // rsi
  signed int *v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rdi
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rdi
  __int64 v13; // rsi
  signed __int64 v14; // rcx

  if ( a3 )
  {
    v3 = a3;
    v4 = a2;
    v5 = a1;
    v6 = (unsigned int)sub_400E3(a3) % *a1;
    v7 = *(signed int **)(*((_QWORD *)v5 + 1) + 8 * v6);
    if ( !v7 )
    {
      v7 = (signed int *)sub_24103(16i64);
      *v7 = 0;
      *((_QWORD *)v7 + 1) = 0i64;
      *(_QWORD *)(*((_QWORD *)v5 + 1) + 8 * v6) = v7;
    }
    v8 = sub_24136(16i64 * *v7 + 16);
    LODWORD(v9) = *v7;
    if ( *v7 > 0 )
    {
      v10 = 0i64;
      v11 = 0i64;
      do
      {
        v12 = *((_QWORD *)v7 + 1);
        v13 = *(_QWORD *)(v12 + v10);
        *(_QWORD *)(v8 + v10 + 8) = *(_QWORD *)(v12 + v10 + 8);
        *(_QWORD *)(v8 + v10) = v13;
        ++v11;
        v9 = *v7;
        v10 += 16i64;
      }
      while ( v11 < v9 );
    }
    v14 = 16i64 * (signed int)v9;
    *(_QWORD *)(v8 + v14) = v4;
    *(_QWORD *)(v8 + v14 + 8) = v3;
    ++*v7;
    *((_QWORD *)v7 + 1) = v8;
  }
  else
  {
    sub_1A11E();
  }
}

//----- (00000000000400E3) ----------------------------------------------------
__int64 __fastcall sub_400E3(char *a1)
{
  char *v1; // rbx
  unsigned int v2; // eax
  unsigned int v3; // ecx
  int v4; // er9
  signed int v5; // edx
  signed __int64 v6; // r8
  signed __int64 v7; // rcx
  unsigned int v8; // esi
  unsigned __int8 v9; // of
  unsigned int v10; // ecx
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax

  v1 = a1;
  v2 = sub_189FE(a1);
  v3 = 0;
  if ( v1 && (signed int)v2 > 0 )
  {
    v4 = v2 & 3;
    v5 = v2 >> 2;
    if ( v2 >> 2 )
    {
      v6 = 4i64 * (unsigned int)(v5 - 1);
      v7 = (signed __int64)(v1 + 3);
      do
      {
        v8 = ((v2 + *(unsigned __int16 *)(v7 - 3)) << 16) ^ (v2 + *(unsigned __int16 *)(v7 - 3)) ^ (*(unsigned __int16 *)(v7 - 1) << 11);
        v2 = v8 + (v8 >> 11);
        v7 += 4i64;
        v9 = __OFSUB__(v5--, 1);
      }
      while ( !((unsigned __int8)((v5 < 0) ^ v9) | (v5 == 0)) );
      v1 += v6 + 4;
    }
    if ( v4 == 1 )
    {
      v10 = (*v1 + v2) ^ ((*v1 + v2) << 10);
      v11 = v10 >> 1;
    }
    else
    {
      if ( v4 != 2 )
      {
        if ( v4 == 3 )
          v2 = ((v2 + *(unsigned __int16 *)v1) ^ (v1[2] << 18) ^ ((v2 + *(unsigned __int16 *)v1) << 16))
             + (((v2 + *(unsigned __int16 *)v1) ^ (v1[2] << 18) ^ ((v2 + *(unsigned __int16 *)v1) << 16)) >> 11);
        goto LABEL_14;
      }
      v10 = (v2 + *(unsigned __int16 *)v1) ^ ((v2 + *(unsigned __int16 *)v1) << 11);
      v11 = v10 >> 17;
    }
    v2 = v10 + v11;
LABEL_14:
    v12 = (v2 ^ 8 * v2) + ((v2 ^ 8 * v2) >> 5);
    v13 = (v12 ^ 16 * v12) + ((v12 ^ 16 * v12) >> 17);
    v3 = (v13 ^ (v13 << 25)) + ((v13 ^ (v13 << 25)) >> 6);
  }
  return v3;
}

//----- (00000000000401FA) ----------------------------------------------------
__int64 __fastcall sub_401FA(__int64 a1, char *a2)
{
  __int64 v2; // rdi
  char *v3; // r15
  unsigned int v4; // eax
  __int64 v5; // rcx
  signed int *v6; // r12
  signed __int64 v7; // rdi
  __int64 v8; // r14
  signed __int64 v9; // rsi
  __int64 v10; // rbx

  if ( !a2 || (v2 = a1) == 0 || (v3 = a2, v4 = sub_400E3(a2), (v5 = *(_QWORD *)(v2 + 8)) == 0) )
  {
    sub_1A11E();
    return 0i64;
  }
  v6 = *(signed int **)(v5 + 8i64 * (v4 % *(_DWORD *)v2));
  if ( !v6 || *v6 <= 0 )
    return 0i64;
  v7 = 8i64;
  v8 = 0i64;
  v9 = 0i64;
  while ( 1 )
  {
    v10 = *((_QWORD *)v6 + 1);
    if ( !(unsigned int)sub_18A1A(*(char **)(v10 + v7), v3) )
      break;
    ++v9;
    v7 += 16i64;
    if ( v9 >= *v6 )
      return v8;
  }
  return *(_QWORD *)(v10 + v7 - 8);
}

//----- (00000000000402B7) ----------------------------------------------------
void __noreturn sub_402B7()
{
  sub_1A11E();
  BUG();
}

// ALL OK, 924 function(s) have been successfully decompiled
